// import baseUrl from '../../src/config/env.js'
var baseUrl = 'https://gw.alipayobjects.com/os/alisis/geo-data-v0.1.2'
// var baseUrl = 'http://192.168.0.156:1666';
// var baseUrl = 'http://192.168.0.201:8901/api';
// var baseUrl = 'http://syy333.dynv6.net:18901/api';
// var baseUrl = 'http://140.0.190.116:1666';
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).L7Plot = {}) }(this, (function (t) {
    "use strict"; var e = new Map; var n = new Map; var r = new Map; var i = function (t) { return null !== t && "function" != typeof t && isFinite(t.length) }, o = {}.toString, a = function (t, e) { return o.call(t) === "[object " + e + "]" }, s = function (t) { return a(t, "Function") }, l = function (t) { return Array.isArray ? Array.isArray(t) : a(t, "Array") }, u = function (t) { var e = typeof t; return null !== t && "object" === e || "function" === e }; function c(t, e) { if (t) if (l(t)) for (var n = 0, r = t.length; n < r && !1 !== e(t[n], n); n++); else if (u(t)) for (var i in t) if (t.hasOwnProperty(i) && !1 === e(t[i], i)) break } var p = function (t) { return "object" == typeof t && null !== t }, h = function (t) { if (!p(t) || !a(t, "Object")) return !1; if (null === Object.getPrototypeOf(t)) return !0; for (var e = t; null !== Object.getPrototypeOf(e);)e = Object.getPrototypeOf(e); return Object.getPrototypeOf(t) === e }, f = function (t) { return a(t, "String") }, d = Object.values ? function (t) { return Object.values(t) } : function (t) { var e = []; return c(t, (function (n, r) { s(t) && "prototype" === r || e.push(n) })), e }, m = function (t) { return (e = t, function (t) { return null == t }(e) ? "" : e.toString()).toLowerCase(); var e }; function v(t, e) { return t && e ? t.replace(/\\?\{([^{}]+)\}/g, (function (t, n) { return "\\" === t.charAt(0) ? t.slice(1) : void 0 === e[n] ? "" : e[n] })) : t } var y = function (t) { return a(t, "Boolean") }, g = function (t) { return void 0 === t }, _ = function (t) { if ("object" != typeof t || null === t) return t; var e; if (l(t)) { e = []; for (var n = 0, r = t.length; n < r; n++)"object" == typeof t[n] && null != t[n] ? e[n] = _(t[n]) : e[n] = t[n] } else for (var i in e = {}, t) "object" == typeof t[i] && null != t[i] ? e[i] = _(t[i]) : e[i] = t[i]; return e }; function x(t, e, n, r) { for (var i in n = n || 0, r = r || 5, e) if (e.hasOwnProperty(i)) { var o = e[i]; null !== o && h(o) ? (h(t[i]) || (t[i] = {}), n < r ? x(t[i], o, n + 1, r) : t[i] = e[i]) : l(o) ? (t[i] = [], t[i] = t[i].concat(o)) : void 0 !== o && (t[i] = o) } } var b = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; for (var r = 0; r < e.length; r += 1)x(t, e[r]); return t }, w = function (t, e) { if (t === e) return !0; if (!t || !e) return !1; if (f(t) || f(e)) return !1; if (i(t) || i(e)) { if (t.length !== e.length) return !1; for (var n = !0, r = 0; r < t.length && (n = w(t[r], e[r])); r++); return n } if (p(t) || p(e)) { var o = Object.keys(t), a = Object.keys(e); if (o.length !== a.length) return !1; for (n = !0, r = 0; r < o.length && (n = w(t[o[r]], e[o[r]])); r++); return n } return !1 }, S = Object.prototype.hasOwnProperty, E = function (t, e) { if (null === t || !h(t)) return {}; var n = {}; return c(e, (function (e) { S.call(t, e) && (n[e] = t[e]) })), n }, C = {}, T = function (t) { return C[t = t || "g"] ? C[t] += 1 : C[t] = 1, t + C[t] }, A = function (t, e) { return A = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) }, A(t, e) }; function M(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null"); function n() { this.constructor = t } A(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) } var O, k = function () { return k = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }, k.apply(this, arguments) }; function I(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]) } return n } function P(t, e, n, r) { return new (n || (n = Promise))((function (i, o) { function a(t) { try { l(r.next(t)) } catch (t) { o(t) } } function s(t) { try { l(r.throw(t)) } catch (t) { o(t) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(a, s) } l((r = r.apply(t, e || [])).next()) })) } function L(t, e) { var n, r, i, o, a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function s(o) { return function (s) { return function (o) { if (n) throw new TypeError("Generator is already executing."); for (; a;)try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return a.label++, { value: o[1], done: !1 }; case 5: a.label++, r = o[1], o = [0]; continue; case 7: o = a.ops.pop(), a.trys.pop(); continue; default: if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) { a = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (6 === o[0] && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break } i[2] && a.ops.pop(), a.trys.pop(); continue }o = e.call(t, a) } catch (t) { o = [6, t], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s]) } } } function R(t, e) { var n = "function" == typeof Symbol && t[Symbol.iterator]; if (!n) return t; var r, i, o = n.call(t), a = []; try { for (; (void 0 === e || e-- > 0) && !(r = o.next()).done;)a.push(r.value) } catch (t) { i = { error: t } } finally { try { r && !r.done && (n = o.return) && n.call(o) } finally { if (i) throw i.error } } return a } !function (t, e) { if (!s(t)) throw new TypeError("Expected a function"); var n = function () { for (var r = [], i = 0; i < arguments.length; i++)r[i] = arguments[i]; var o = e ? e.apply(this, r) : r[0], a = n.cache; if (a.has(o)) return a.get(o); var s = t.apply(this, r); return a.set(o, s), s }; n.cache = new Map }((function (t, e) { void 0 === e && (e = {}); var n = e.fontSize, r = e.fontFamily, i = e.fontWeight, o = e.fontStyle, a = e.fontVariant; return O || (O = document.createElement("canvas").getContext("2d")), O.font = [o, a, i, n + "px", r].join(" "), O.measureText(f(t) ? t : "").width }), (function (t, e) { return void 0 === e && (e = {}), function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; var r = Array(t), i = 0; for (e = 0; e < n; e++)for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }([t], d(e)).join("") })); var D = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function N(t) { if (t.__esModule) return t; var e = Object.defineProperty({}, "__esModule", { value: !0 }); return Object.keys(t).forEach((function (n) { var r = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, r.get ? r : { enumerable: !0, get: function () { return t[n] } }) })), e } var z = {}; !function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.ITEM_TPL = t.CONTAINER_TPL = t.VALUE_CLASS = t.NAME_CLASS = t.LIST_ITEM_CLASS = t.LIST_CLASS = t.TITLE_CLASS = t.CONTAINER_CLASS = void 0, t.CONTAINER_CLASS = "l7plot-tooltip", t.TITLE_CLASS = "l7plot-tooltip__title", t.LIST_CLASS = "l7plot-tooltip__list", t.LIST_ITEM_CLASS = "l7plot-tooltip__list-item", t.NAME_CLASS = "l7plot-tooltip__name", t.VALUE_CLASS = "l7plot-tooltip__value", t.CONTAINER_TPL = '<div class="'.concat(t.CONTAINER_CLASS, '">\n  <div class="').concat(t.TITLE_CLASS, '"></div>\n  <ul class="').concat(t.LIST_CLASS, '"></ul>\n</div>'), t.ITEM_TPL = '<li class="'.concat(t.LIST_ITEM_CLASS, '" data-index={index}>\n  <span class="').concat(t.NAME_CLASS, '">{name}</span>\n  <span class="').concat(t.VALUE_CLASS, '">{value}</span>\n</li>') }(z); var F = {}; !function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.ITEM_TPL = t.CONTAINER_TPL = t.VALUE_CLASS = t.MARKER_CLASS = t.LIST_ITEM_CLASS = t.LIST_CLASS = t.TITLE_CLASS = t.CONTAINER_CLASS = void 0, t.CONTAINER_CLASS = "l7plot-legend l7plot-legend__category", t.TITLE_CLASS = "l7plot-legend__title", t.LIST_CLASS = "l7plot-legend__category-list", t.LIST_ITEM_CLASS = "l7plot-legend__list-item", t.MARKER_CLASS = "l7plot-legend__category-marker", t.VALUE_CLASS = "l7plot-legend__category-value", t.CONTAINER_TPL = '<div class="'.concat(t.CONTAINER_CLASS, '">\n  <div class="').concat(t.TITLE_CLASS, '"></div>\n  <ul class="').concat(t.LIST_CLASS, '"></ul>\n</div>'), t.ITEM_TPL = '<li class="'.concat(t.LIST_ITEM_CLASS, '" data-index={index}>\n  <span class="').concat(t.MARKER_CLASS, '" style="background:{color}"></span>\n  <span class="').concat(t.VALUE_CLASS, '">{value}</span>\n</li>') }(F); var B = {}; function j(t) { var e, n, r, i = { point: { default: { fill: t.pointFillColor, size: t.pointSize, stroke: t.pointBorderColor, lineWidth: t.pointBorder, fillOpacity: t.pointFillOpacity }, active: { fill: t.pointActiveFillColor }, selected: { fill: t.pointSelectedFillColor } } }; return { mapStyle: t.mapStyle, defaultColor: t.brandColor, subColor: t.subColor, semanticRed: t.paletteSemanticRed, semanticGreen: t.paletteSemanticGreen, fontFamily: t.fontFamily, colors10: t.paletteQualitative10, colors20: t.paletteQualitative20, sequenceColors: t.paletteSequence, shapes: { point: ["circle", "square"], line: ["line"] }, sizes: [1, 10], geometries: { point: { circle: { default: { style: i.point.default }, active: { style: i.point.active }, selected: { style: i.point.selected } } }, line: {}, polygon: {} }, components: { legend: { category: { domStyles: (e = {}, e[F.CONTAINER_CLASS] = { visibility: "visible", zIndex: 1, backgroundColor: t.legendContainerFillColor, boxShadow: t.legendContainerShadow, borderRadius: "".concat(t.legendContainerBorderRadius, "px"), color: t.legendTextFillColor, fontFamily: t.fontFamily, padding: "10px", lineHeight: "1", fontSize: "".concat(t.legendTextFontSize, "px") }, e[F.TITLE_CLASS] = { fontSize: "13px", lineHeight: "19px", marginBottom: "8px" }, e[F.LIST_CLASS] = { margin: "0px", padding: "0px" }, e[F.LIST_ITEM_CLASS] = { marginBottom: "2px" }, e[F.MARKER_CLASS] = { width: "10px", height: "10px" }, e[F.VALUE_CLASS] = { paddingLeft: "8px" }, e) }, continue: { domStyles: (n = {}, n[B.CONTAINER_CLASS] = { visibility: "visible", zIndex: 1, backgroundColor: t.legendContainerFillColor, boxShadow: t.legendContainerShadow, borderRadius: "".concat(t.legendContainerBorderRadius, "px"), color: t.legendTextFillColor, fontFamily: t.fontFamily, padding: "10px", lineHeight: 1, fontSize: "".concat(t.legendTextFontSize, "px") }, n[B.TITLE_CLASS] = { fontSize: "13px", lineHeight: "19px", marginBottom: "8px" }, n[B.RIBBON_CLASS] = { display: "flex", alignItems: "center" }, n[B.GRADIENT_BAR_CLASS] = { width: "140px", height: "14px", margin: "0px 5px" }, n[B.VALUE_RANGE_CLASS] = { padding: "0px" }, n) } }, tooltip: { domStyles: (r = {}, r[z.CONTAINER_CLASS] = { visibility: "visible", zIndex: 999, transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)", backgroundColor: t.tooltipContainerFillColor, boxShadow: t.tooltipContainerShadow, borderRadius: "".concat(t.tooltipContainerBorderRadius, "px"), color: t.tooltipTextFillColor, fontSize: "".concat(t.tooltipTextFontSize, "px"), fontFamily: t.fontFamily, lineHeight: t.tooltipTextLineHeight }, r[z.TITLE_CLASS] = { marginBottom: "4px" }, r[z.LIST_CLASS] = { margin: "0px", padding: "0px" }, r[z.LIST_ITEM_CLASS] = { marginBottom: "4px" }, r[z.NAME_CLASS] = { color: t.tooltipItemNameFillColor }, r[z.VALUE_CLASS] = { color: t.tooltipItemValueFillColor, marginLeft: "30px" }, r) }, label: { style: { textAnchor: "center", textOffset: [0, 0], fill: t.labelFillColor, fontSize: t.labelFontSize, fontFamily: t.fontFamily, fillColorDark: t.labelFillColorDark, fillColorLight: t.labelFillColorLight } } } } } !function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.RIBBON_TPL = t.CONTAINER_TPL = t.VALUE_RANGE_CLASS = t.GRADIENT_BAR_CLASS = t.RIBBON_CLASS = t.RIBBON_CONTAINER_CLASS = t.TITLE_CLASS = t.CONTAINER_CLASS = void 0, t.CONTAINER_CLASS = "l7plot-legend l7plot-legend__continue", t.TITLE_CLASS = "l7plot-legend__title", t.RIBBON_CONTAINER_CLASS = "l7plot-legend__ribbon-container", t.RIBBON_CLASS = "l7plot-legend__ribbon", t.GRADIENT_BAR_CLASS = "l7plot-legend__gradient-bar", t.VALUE_RANGE_CLASS = "l7plot-legend__value-range", t.CONTAINER_TPL = '<div class="'.concat(t.CONTAINER_CLASS, '">\n  <div class="').concat(t.TITLE_CLASS, '"></div>\n  <div class="').concat(t.RIBBON_CONTAINER_CLASS, '"></div>\n</div>'), t.RIBBON_TPL = '<div class="'.concat(t.RIBBON_CLASS, '">\n  <span class="').concat(t.VALUE_RANGE_CLASS, '">{min}</span>\n  <div class="').concat(t.GRADIENT_BAR_CLASS, '" style="background-image: {backgroundImage}"></div>\n  <span class="').concat(t.VALUE_RANGE_CLASS, '">{max}</span>\n</div>') }(B); var U = "#000", V = "#595959", G = "#FFFFFF", H = ["#5B8FF9", "#5AD8A6", "#5D7092", "#F6BD16", "#6F5EF9", "#6DC8EC", "#945FB9", "#FF9845", "#1E9493", "#FF99C3"], W = ["#5B8FF9", "#CDDDFD", "#5AD8A6", "#CDF3E4", "#5D7092", "#CED4DE", "#F6BD16", "#FCEBB9", "#6F5EF9", "#D3CEFD", "#6DC8EC", "#D3EEF9", "#945FB9", "#DECFEA", "#FF9845", "#FFE0C7", "#1E9493", "#BBDEDE", "#FF99C3", "#FFE0ED"], X = ["#B8E1FF", "#9AC5FF", "#7DAAFF", "#5B8FF9", "#3D76DD", "#085EC0", "#0047A5", "#00318A", "#001D70"], q = function (t) { void 0 === t && (t = {}); var e = t.mapStyle, n = void 0 === e ? "light" : e, r = t.subColor, i = void 0 === r ? "rgba(0,0,0,0.05)" : r, o = t.paletteQualitative10, a = void 0 === o ? H : o, s = t.paletteQualitative20, l = void 0 === s ? W : s, u = t.paletteSemanticRed, c = void 0 === u ? "#F4664A" : u, p = t.paletteSemanticGreen, h = void 0 === p ? "#30BF78" : p, f = t.paletteSemanticYellow, d = void 0 === f ? "#FAAD14" : f, m = t.paletteSequence, v = void 0 === m ? X : m, y = t.fontFamily, g = void 0 === y ? '"-apple-system", "Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : y, _ = t.brandColor, x = void 0 === _ ? a[0] : _; return { mapStyle: n, brandColor: x, subColor: i, paletteQualitative10: a, paletteQualitative20: l, paletteSemanticRed: c, paletteSemanticGreen: h, paletteSemanticYellow: d, paletteSequence: v, fontFamily: g, legendContainerFillColor: "rgba(255, 255, 255, 0.85)", legendContainerShadow: "0 2px 8px 0 rgba(166, 166, 166, 0.20)", legendContainerBorderRadius: 2, legendTextFillColor: V, legendTextFontSize: 12, tooltipContainerFillColor: "rgba(255, 255, 255, 0.9)", tooltipContainerShadow: "rgb(0 0 0 / 16%) 0px 6px 12px 0px", tooltipContainerBorderRadius: 2, tooltipTextFillColor: V, tooltipItemNameFillColor: V, tooltipItemValueFillColor: V, tooltipTextFontSize: 12, tooltipTextLineHeight: "20px", labelFillColor: V, labelFillColorDark: "#2c3542", labelFillColorLight: "#ffffff", labelFontSize: 12, pointFillColor: x, pointFillOpacity: .95, pointSize: 4, pointBorder: 1, pointBorderColor: G, pointActiveBorderColor: U, pointSelectedBorderColor: U } }; q(); var Z = "#000", Y = "#FFFFFF", K = "#A6A6A6", Q = ["#5B8FF9", "#5AD8A6", "#5D7092", "#F6BD16", "#E86452", "#6DC8EC", "#945FB9", "#FF9845", "#1E9493", "#FF99C3"], J = ["#5B8FF9", "#CDDDFD", "#5AD8A6", "#CDF3E4", "#5D7092", "#CED4DE", "#F6BD16", "#FCEBB9", "#E86452", "#F8D0CB", "#6DC8EC", "#D3EEF9", "#945FB9", "#DECFEA", "#FF9845", "#FFE0C7", "#1E9493", "#BBDEDE", "#FF99C3", "#FFE0ED"], $ = ["#B8E1FF", "#9AC5FF", "#7DAAFF", "#5B8FF9", "#3D76DD", "#085EC0", "#0047A5", "#00318A", "#001D70"], tt = function (t) { void 0 === t && (t = {}); var e = t.mapStyle, n = void 0 === e ? "dark" : e, r = t.subColor, i = void 0 === r ? "rgba(255,255,255,0.05)" : r, o = t.paletteQualitative10, a = void 0 === o ? Q : o, s = t.paletteQualitative20, l = void 0 === s ? J : s, u = t.paletteSemanticRed, c = void 0 === u ? "#F4664A" : u, p = t.paletteSemanticGreen, h = void 0 === p ? "#30BF78" : p, f = t.paletteSemanticYellow, d = void 0 === f ? "#FAAD14" : f, m = t.paletteSequence, v = void 0 === m ? $ : m, y = t.fontFamily, g = void 0 === y ? '"-apple-system", "Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : y, _ = t.brandColor; return { mapStyle: n, brandColor: void 0 === _ ? a[0] : _, subColor: i, paletteQualitative10: a, paletteQualitative20: l, paletteSemanticRed: c, paletteSemanticGreen: h, paletteSemanticYellow: d, paletteSequence: v, fontFamily: g, legendContainerFillColor: "rgba(31, 31, 31, 0.85)", legendContainerShadow: "0 2px 8px 0 rgba(166, 166, 166, 0.20)", legendContainerBorderRadius: 2, legendTextFillColor: K, legendTextFontSize: 12, tooltipContainerFillColor: "rgba(31, 31, 31, 0.9)", tooltipContainerShadow: "0px 2px 4px rgba(0, 0, 0, 0.5)", tooltipContainerBorderRadius: 2, tooltipTextFillColor: K, tooltipItemNameFillColor: K, tooltipItemValueFillColor: K, tooltipTextFontSize: 12, tooltipTextLineHeight: "20px", labelFillColor: K, labelFillColorDark: "#2c3542", labelFillColorLight: "#ffffff", labelFontSize: 12, pointFillColor: Q[0], pointFillOpacity: .95, pointSize: 4, pointBorder: 1, pointBorderColor: Z, pointActiveBorderColor: Y, pointSelectedBorderColor: Y } }; function et(t) { var e = t.styleSheet, n = void 0 === e ? {} : e, r = I(t, ["styleSheet"]), i = q(n); return b({}, j(i), r) } function nt(t) { var e = t.styleSheet, n = void 0 === e ? {} : e, r = I(t, ["styleSheet"]), i = tt(n); return b({}, j(i), r) } tt(); var rt, it = et({}), ot = { default: it, light: it, dark: nt({}) }; function at(t) { return void 0 === t && (t = "default"), function (t, e, n) { for (var r = 0, i = f(e) ? e.split(".") : e; t && r < i.length;)t = t[i[r++]]; return void 0 === t || r < i.length ? n : t }(ot, m(t), ot.default) } !function (t) { !function (e) { var n = "object" == typeof D ? D : "object" == typeof self ? self : "object" == typeof this ? this : Function("return this;")(), r = i(t); function i(t, e) { return function (n, r) { "function" != typeof t[n] && Object.defineProperty(t, n, { configurable: !0, writable: !0, value: r }), e && e(n, r) } } void 0 === n.Reflect ? n.Reflect = t : r = i(n.Reflect, r), function (t) { var e = Object.prototype.hasOwnProperty, n = "function" == typeof Symbol, r = n && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", i = n && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", o = "function" == typeof Object.create, a = { __proto__: [] } instanceof Array, s = !o && !a, l = { create: o ? function () { return rt(Object.create(null)) } : a ? function () { return rt({ __proto__: null }) } : function () { return rt({}) }, has: s ? function (t, n) { return e.call(t, n) } : function (t, e) { return e in t }, get: s ? function (t, n) { return e.call(t, n) ? t[n] : void 0 } : function (t, e) { return t[e] } }, u = Object.getPrototypeOf(Function), c = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, p = c || "function" != typeof Map || "function" != typeof Map.prototype.entries ? tt() : Map, h = c || "function" != typeof Set || "function" != typeof Set.prototype.entries ? et() : Set, f = new (c || "function" != typeof WeakMap ? nt() : WeakMap); function d(t, e, n, r) { if (D(n)) { if (!H(t)) throw new TypeError; if (!X(e)) throw new TypeError; return E(t, e) } if (!H(t)) throw new TypeError; if (!F(e)) throw new TypeError; if (!F(r) && !D(r) && !N(r)) throw new TypeError; return N(r) && (r = void 0), C(t, e, n = G(n), r) } function m(t, e) { function n(n, r) { if (!F(n)) throw new TypeError; if (!D(r) && !q(r)) throw new TypeError; I(t, e, n, r) } return n } function v(t, e, n, r) { if (!F(n)) throw new TypeError; return D(r) || (r = G(r)), I(t, e, n, r) } function y(t, e, n) { if (!F(e)) throw new TypeError; return D(n) || (n = G(n)), A(t, e, n) } function g(t, e, n) { if (!F(e)) throw new TypeError; return D(n) || (n = G(n)), M(t, e, n) } function _(t, e, n) { if (!F(e)) throw new TypeError; return D(n) || (n = G(n)), O(t, e, n) } function x(t, e, n) { if (!F(e)) throw new TypeError; return D(n) || (n = G(n)), k(t, e, n) } function b(t, e) { if (!F(t)) throw new TypeError; return D(e) || (e = G(e)), P(t, e) } function w(t, e) { if (!F(t)) throw new TypeError; return D(e) || (e = G(e)), L(t, e) } function S(t, e, n) { if (!F(e)) throw new TypeError; D(n) || (n = G(n)); var r = T(e, n, !1); if (D(r)) return !1; if (!r.delete(t)) return !1; if (r.size > 0) return !0; var i = f.get(e); return i.delete(n), i.size > 0 || f.delete(e), !0 } function E(t, e) { for (var n = t.length - 1; n >= 0; --n) { var r = (0, t[n])(e); if (!D(r) && !N(r)) { if (!X(r)) throw new TypeError; e = r } } return e } function C(t, e, n, r) { for (var i = t.length - 1; i >= 0; --i) { var o = (0, t[i])(e, n, r); if (!D(o) && !N(o)) { if (!F(o)) throw new TypeError; r = o } } return r } function T(t, e, n) { var r = f.get(t); if (D(r)) { if (!n) return; r = new p, f.set(t, r) } var i = r.get(e); if (D(i)) { if (!n) return; i = new p, r.set(e, i) } return i } function A(t, e, n) { if (M(t, e, n)) return !0; var r = $(e); return !N(r) && A(t, r, n) } function M(t, e, n) { var r = T(e, n, !1); return !D(r) && U(r.has(t)) } function O(t, e, n) { if (M(t, e, n)) return k(t, e, n); var r = $(e); return N(r) ? void 0 : O(t, r, n) } function k(t, e, n) { var r = T(e, n, !1); if (!D(r)) return r.get(t) } function I(t, e, n, r) { T(n, r, !0).set(t, e) } function P(t, e) { var n = L(t, e), r = $(t); if (null === r) return n; var i = P(r, e); if (i.length <= 0) return n; if (n.length <= 0) return i; for (var o = new h, a = [], s = 0, l = n; s < l.length; s++) { var u = l[s]; o.has(u) || (o.add(u), a.push(u)) } for (var c = 0, p = i; c < p.length; c++) { u = p[c]; o.has(u) || (o.add(u), a.push(u)) } return a } function L(t, e) { var n = [], r = T(t, e, !1); if (D(r)) return n; for (var i = Y(r.keys()), o = 0; ;) { var a = Q(i); if (!a) return n.length = o, n; var s = K(a); try { n[o] = s } catch (t) { try { J(i) } finally { throw t } } o++ } } function R(t) { if (null === t) return 1; switch (typeof t) { case "undefined": return 0; case "boolean": return 2; case "string": return 3; case "symbol": return 4; case "number": return 5; case "object": return null === t ? 1 : 6; default: return 6 } } function D(t) { return void 0 === t } function N(t) { return null === t } function z(t) { return "symbol" == typeof t } function F(t) { return "object" == typeof t ? null !== t : "function" == typeof t } function B(t, e) { switch (R(t)) { case 0: case 1: case 2: case 3: case 4: case 5: return t }var n = 3 === e ? "string" : 5 === e ? "number" : "default", i = Z(t, r); if (void 0 !== i) { var o = i.call(t, n); if (F(o)) throw new TypeError; return o } return j(t, "default" === n ? "number" : n) } function j(t, e) { if ("string" === e) { var n = t.toString; if (W(n)) if (!F(i = n.call(t))) return i; if (W(r = t.valueOf)) if (!F(i = r.call(t))) return i } else { var r; if (W(r = t.valueOf)) if (!F(i = r.call(t))) return i; var i, o = t.toString; if (W(o)) if (!F(i = o.call(t))) return i } throw new TypeError } function U(t) { return !!t } function V(t) { return "" + t } function G(t) { var e = B(t, 3); return z(e) ? e : V(e) } function H(t) { return Array.isArray ? Array.isArray(t) : t instanceof Object ? t instanceof Array : "[object Array]" === Object.prototype.toString.call(t) } function W(t) { return "function" == typeof t } function X(t) { return "function" == typeof t } function q(t) { switch (R(t)) { case 3: case 4: return !0; default: return !1 } } function Z(t, e) { var n = t[e]; if (null != n) { if (!W(n)) throw new TypeError; return n } } function Y(t) { var e = Z(t, i); if (!W(e)) throw new TypeError; var n = e.call(t); if (!F(n)) throw new TypeError; return n } function K(t) { return t.value } function Q(t) { var e = t.next(); return !e.done && e } function J(t) { var e = t.return; e && e.call(t) } function $(t) { var e = Object.getPrototypeOf(t); if ("function" != typeof t || t === u) return e; if (e !== u) return e; var n = t.prototype, r = n && Object.getPrototypeOf(n); if (null == r || r === Object.prototype) return e; var i = r.constructor; return "function" != typeof i || i === t ? e : i } function tt() { var t = {}, e = [], n = function () { function t(t, e, n) { this._index = 0, this._keys = t, this._values = e, this._selector = n } return t.prototype["@@iterator"] = function () { return this }, t.prototype[i] = function () { return this }, t.prototype.next = function () { var t = this._index; if (t >= 0 && t < this._keys.length) { var n = this._selector(this._keys[t], this._values[t]); return t + 1 >= this._keys.length ? (this._index = -1, this._keys = e, this._values = e) : this._index++, { value: n, done: !1 } } return { value: void 0, done: !0 } }, t.prototype.throw = function (t) { throw this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), t }, t.prototype.return = function (t) { return this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), { value: t, done: !0 } }, t }(); return function () { function e() { this._keys = [], this._values = [], this._cacheKey = t, this._cacheIndex = -2 } return Object.defineProperty(e.prototype, "size", { get: function () { return this._keys.length }, enumerable: !0, configurable: !0 }), e.prototype.has = function (t) { return this._find(t, !1) >= 0 }, e.prototype.get = function (t) { var e = this._find(t, !1); return e >= 0 ? this._values[e] : void 0 }, e.prototype.set = function (t, e) { var n = this._find(t, !0); return this._values[n] = e, this }, e.prototype.delete = function (e) { var n = this._find(e, !1); if (n >= 0) { for (var r = this._keys.length, i = n + 1; i < r; i++)this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i]; return this._keys.length--, this._values.length--, e === this._cacheKey && (this._cacheKey = t, this._cacheIndex = -2), !0 } return !1 }, e.prototype.clear = function () { this._keys.length = 0, this._values.length = 0, this._cacheKey = t, this._cacheIndex = -2 }, e.prototype.keys = function () { return new n(this._keys, this._values, r) }, e.prototype.values = function () { return new n(this._keys, this._values, o) }, e.prototype.entries = function () { return new n(this._keys, this._values, a) }, e.prototype["@@iterator"] = function () { return this.entries() }, e.prototype[i] = function () { return this.entries() }, e.prototype._find = function (t, e) { return this._cacheKey !== t && (this._cacheIndex = this._keys.indexOf(this._cacheKey = t)), this._cacheIndex < 0 && e && (this._cacheIndex = this._keys.length, this._keys.push(t), this._values.push(void 0)), this._cacheIndex }, e }(); function r(t, e) { return t } function o(t, e) { return e } function a(t, e) { return [t, e] } } function et() { return function () { function t() { this._map = new p } return Object.defineProperty(t.prototype, "size", { get: function () { return this._map.size }, enumerable: !0, configurable: !0 }), t.prototype.has = function (t) { return this._map.has(t) }, t.prototype.add = function (t) { return this._map.set(t, t), this }, t.prototype.delete = function (t) { return this._map.delete(t) }, t.prototype.clear = function () { this._map.clear() }, t.prototype.keys = function () { return this._map.keys() }, t.prototype.values = function () { return this._map.values() }, t.prototype.entries = function () { return this._map.entries() }, t.prototype["@@iterator"] = function () { return this.keys() }, t.prototype[i] = function () { return this.keys() }, t }() } function nt() { var t = 16, n = l.create(), r = i(); return function () { function t() { this._key = i() } return t.prototype.has = function (t) { var e = o(t, !1); return void 0 !== e && l.has(e, this._key) }, t.prototype.get = function (t) { var e = o(t, !1); return void 0 !== e ? l.get(e, this._key) : void 0 }, t.prototype.set = function (t, e) { return o(t, !0)[this._key] = e, this }, t.prototype.delete = function (t) { var e = o(t, !1); return void 0 !== e && delete e[this._key] }, t.prototype.clear = function () { this._key = i() }, t }(); function i() { var t; do { t = "@@WeakMap@@" + u() } while (l.has(n, t)); return n[t] = !0, t } function o(t, n) { if (!e.call(t, r)) { if (!n) return; Object.defineProperty(t, r, { value: l.create() }) } return t[r] } function a(t, e) { for (var n = 0; n < e; ++n)t[n] = 255 * Math.random() | 0; return t } function s(t) { return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(t)) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(new Uint8Array(t)) : a(new Uint8Array(t), t) : a(new Array(t), t) } function u() { var e = s(t); e[6] = 79 & e[6] | 64, e[8] = 191 & e[8] | 128; for (var n = "", r = 0; r < t; ++r) { var i = e[r]; 4 !== r && 6 !== r && 8 !== r || (n += "-"), i < 16 && (n += "0"), n += i.toString(16).toLowerCase() } return n } } function rt(t) { return t.__ = void 0, delete t.__, t } t("decorate", d), t("metadata", m), t("defineMetadata", v), t("hasMetadata", y), t("hasOwnMetadata", g), t("getMetadata", _), t("getOwnMetadata", x), t("getMetadataKeys", b), t("getOwnMetadataKeys", w), t("deleteMetadata", S) }(r) }() }(rt || (rt = {})); var st = { exports: {} }; !function (t) { var e = Object.prototype.hasOwnProperty, n = "~"; function r() { } function i(t, e, n) { this.fn = t, this.context = e, this.once = n || !1 } function o(t, e, r, o, a) { if ("function" != typeof r) throw new TypeError("The listener must be a function"); var s = new i(r, o || t, a), l = n ? n + e : e; return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], s] : t._events[l].push(s) : (t._events[l] = s, t._eventsCount++), t } function a(t, e) { 0 == --t._eventsCount ? t._events = new r : delete t._events[e] } function s() { this._events = new r, this._eventsCount = 0 } Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), s.prototype.eventNames = function () { var t, r, i = []; if (0 === this._eventsCount) return i; for (r in t = this._events) e.call(t, r) && i.push(n ? r.slice(1) : r); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i }, s.prototype.listeners = function (t) { var e = n ? n + t : t, r = this._events[e]; if (!r) return []; if (r.fn) return [r.fn]; for (var i = 0, o = r.length, a = new Array(o); i < o; i++)a[i] = r[i].fn; return a }, s.prototype.listenerCount = function (t) { var e = n ? n + t : t, r = this._events[e]; return r ? r.fn ? 1 : r.length : 0 }, s.prototype.emit = function (t, e, r, i, o, a) { var s = n ? n + t : t; if (!this._events[s]) return !1; var l, u, c = this._events[s], p = arguments.length; if (c.fn) { switch (c.once && this.removeListener(t, c.fn, void 0, !0), p) { case 1: return c.fn.call(c.context), !0; case 2: return c.fn.call(c.context, e), !0; case 3: return c.fn.call(c.context, e, r), !0; case 4: return c.fn.call(c.context, e, r, i), !0; case 5: return c.fn.call(c.context, e, r, i, o), !0; case 6: return c.fn.call(c.context, e, r, i, o, a), !0 }for (u = 1, l = new Array(p - 1); u < p; u++)l[u - 1] = arguments[u]; c.fn.apply(c.context, l) } else { var h, f = c.length; for (u = 0; u < f; u++)switch (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), p) { case 1: c[u].fn.call(c[u].context); break; case 2: c[u].fn.call(c[u].context, e); break; case 3: c[u].fn.call(c[u].context, e, r); break; case 4: c[u].fn.call(c[u].context, e, r, i); break; default: if (!l) for (h = 1, l = new Array(p - 1); h < p; h++)l[h - 1] = arguments[h]; c[u].fn.apply(c[u].context, l) } } return !0 }, s.prototype.on = function (t, e, n) { return o(this, t, e, n, !1) }, s.prototype.once = function (t, e, n) { return o(this, t, e, n, !0) }, s.prototype.removeListener = function (t, e, r, i) { var o = n ? n + t : t; if (!this._events[o]) return this; if (!e) return a(this, o), this; var s = this._events[o]; if (s.fn) s.fn !== e || i && !s.once || r && s.context !== r || a(this, o); else { for (var l = 0, u = [], c = s.length; l < c; l++)(s[l].fn !== e || i && !s[l].once || r && s[l].context !== r) && u.push(s[l]); u.length ? this._events[o] = 1 === u.length ? u[0] : u : a(this, o) } return this }, s.prototype.removeAllListeners = function (t) { var e; return t ? (e = n ? n + t : t, this._events[e] && a(this, e)) : (this._events = new r, this._eventsCount = 0), this }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, t.exports = s }(st); var lt = st.exports, ut = {}, ct = {}; !function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.NON_CUSTOM_TAG_KEYS = t.POST_CONSTRUCT = t.DESIGN_PARAM_TYPES = t.PARAM_TYPES = t.TAGGED_PROP = t.TAGGED = t.MULTI_INJECT_TAG = t.INJECT_TAG = t.OPTIONAL_TAG = t.UNMANAGED_TAG = t.NAME_TAG = t.NAMED_TAG = void 0, t.NAMED_TAG = "named", t.NAME_TAG = "name", t.UNMANAGED_TAG = "unmanaged", t.OPTIONAL_TAG = "optional", t.INJECT_TAG = "inject", t.MULTI_INJECT_TAG = "multi_inject", t.TAGGED = "inversify:tagged", t.TAGGED_PROP = "inversify:tagged_props", t.PARAM_TYPES = "inversify:paramtypes", t.DESIGN_PARAM_TYPES = "design:paramtypes", t.POST_CONSTRUCT = "post_construct", t.NON_CUSTOM_TAG_KEYS = [t.INJECT_TAG, t.MULTI_INJECT_TAG, t.NAME_TAG, t.UNMANAGED_TAG, t.NAMED_TAG, t.OPTIONAL_TAG] }(ct); var pt = {}, ht = {}, ft = {}; Object.defineProperty(ft, "__esModule", { value: !0 }), ft.TargetTypeEnum = ft.BindingTypeEnum = ft.BindingScopeEnum = void 0; ft.BindingScopeEnum = { Request: "Request", Singleton: "Singleton", Transient: "Transient" }; ft.BindingTypeEnum = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" }; ft.TargetTypeEnum = { ClassProperty: "ClassProperty", ConstructorArgument: "ConstructorArgument", Variable: "Variable" }; var dt = {}; Object.defineProperty(dt, "__esModule", { value: !0 }), dt.id = void 0; var mt = 0; dt.id = function () { return mt++ }, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.Binding = void 0; var vt = ft, yt = dt, gt = function () { function t(t, e) { this.id = yt.id(), this.activated = !1, this.serviceIdentifier = t, this.scope = e, this.type = vt.BindingTypeEnum.Invalid, this.constraint = function (t) { return !0 }, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.dynamicValue = null } return t.prototype.clone = function () { var e = new t(this.serviceIdentifier, this.scope); return e.activated = e.scope === vt.BindingScopeEnum.Singleton && this.activated, e.implementationType = this.implementationType, e.dynamicValue = this.dynamicValue, e.scope = this.scope, e.type = this.type, e.factory = this.factory, e.provider = this.provider, e.constraint = this.constraint, e.onActivation = this.onActivation, e.cache = this.cache, e }, t }(); ht.Binding = gt; var _t = {}; Object.defineProperty(_t, "__esModule", { value: !0 }), _t.STACK_OVERFLOW = _t.CIRCULAR_DEPENDENCY_IN_FACTORY = _t.POST_CONSTRUCT_ERROR = _t.MULTIPLE_POST_CONSTRUCT_METHODS = _t.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = _t.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = _t.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = _t.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = _t.ARGUMENTS_LENGTH_MISMATCH = _t.INVALID_DECORATOR_OPERATION = _t.INVALID_TO_SELF_VALUE = _t.INVALID_FUNCTION_BINDING = _t.INVALID_MIDDLEWARE_RETURN = _t.NO_MORE_SNAPSHOTS_AVAILABLE = _t.INVALID_BINDING_TYPE = _t.NOT_IMPLEMENTED = _t.CIRCULAR_DEPENDENCY = _t.UNDEFINED_INJECT_ANNOTATION = _t.MISSING_INJECT_ANNOTATION = _t.MISSING_INJECTABLE_ANNOTATION = _t.NOT_REGISTERED = _t.CANNOT_UNBIND = _t.AMBIGUOUS_MATCH = _t.KEY_NOT_FOUND = _t.NULL_ARGUMENT = _t.DUPLICATED_METADATA = _t.DUPLICATED_INJECTABLE_DECORATOR = void 0, _t.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.", _t.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:", _t.NULL_ARGUMENT = "NULL argument", _t.KEY_NOT_FOUND = "Key Not Found", _t.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:", _t.CANNOT_UNBIND = "Could not unbind serviceIdentifier:", _t.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:", _t.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:", _t.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:"; _t.UNDEFINED_INJECT_ANNOTATION = function (t) { return "@inject called with undefined this could mean that the class " + t + " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation." }, _t.CIRCULAR_DEPENDENCY = "Circular dependency found:", _t.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.", _t.INVALID_BINDING_TYPE = "Invalid binding type:", _t.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.", _t.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!", _t.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!", _t.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier", _t.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property."; _t.ARGUMENTS_LENGTH_MISMATCH = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return "The number of constructor arguments in the derived class " + t[0] + " must be >= than the number of constructor arguments of its base class." }, _t.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.", _t.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must be a string ('singleton' or 'transient').", _t.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean", _t.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean", _t.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class"; _t.POST_CONSTRUCT_ERROR = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return "@postConstruct error in class " + t[0] + ": " + t[1] }; _t.CIRCULAR_DEPENDENCY_IN_FACTORY = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return "It looks like there is a circular dependency in one of the '" + t[0] + "' bindings. Please investigate bindings withservice identifier '" + t[1] + "'." }, _t.STACK_OVERFLOW = "Maximum call stack size exceeded"; var xt = {}; Object.defineProperty(xt, "__esModule", { value: !0 }), xt.MetadataReader = void 0; var bt = ct, wt = function () { function t() { } return t.prototype.getConstructorMetadata = function (t) { return { compilerGeneratedMetadata: Reflect.getMetadata(bt.PARAM_TYPES, t), userGeneratedMetadata: Reflect.getMetadata(bt.TAGGED, t) || {} } }, t.prototype.getPropertiesMetadata = function (t) { return Reflect.getMetadata(bt.TAGGED_PROP, t) || [] }, t }(); xt.MetadataReader = wt; var St = {}, Et = {}; Object.defineProperty(Et, "__esModule", { value: !0 }), Et.BindingCount = void 0; Et.BindingCount = { MultipleBindingsAvailable: 2, NoBindingsAvailable: 0, OnlyOneBindingAvailable: 1 }; var Ct = {}; Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.isStackOverflowExeption = void 0; var Tt = _t; Ct.isStackOverflowExeption = function (t) { return t instanceof RangeError || t.message === Tt.STACK_OVERFLOW }; var At = {}; Object.defineProperty(At, "__esModule", { value: !0 }), At.circularDependencyToException = At.listMetadataForTarget = At.listRegisteredBindingsForServiceIdentifier = At.getServiceIdentifierAsString = At.getFunctionName = void 0; var Mt = _t; function Ot(t) { return "function" == typeof t ? t.name : "symbol" == typeof t ? t.toString() : t } function kt(t, e) { return null !== t.parentRequest && (t.parentRequest.serviceIdentifier === e || kt(t.parentRequest, e)) } function It(t) { if (t.name) return t.name; var e = t.toString(), n = e.match(/^function\s*([^\s(]+)/); return n ? n[1] : "Anonymous function: " + e } At.getServiceIdentifierAsString = Ot, At.listRegisteredBindingsForServiceIdentifier = function (t, e, n) { var r = "", i = n(t, e); return 0 !== i.length && (r = "\nRegistered bindings:", i.forEach((function (t) { var e = "Object"; null !== t.implementationType && (e = It(t.implementationType)), r = r + "\n " + e, t.constraint.metaData && (r = r + " - " + t.constraint.metaData) }))), r }, At.circularDependencyToException = function t(e) { e.childRequests.forEach((function (e) { if (kt(e, e.serviceIdentifier)) { var n = function (t) { return function t(e, n) { void 0 === n && (n = []); var r = Ot(e.serviceIdentifier); return n.push(r), null !== e.parentRequest ? t(e.parentRequest, n) : n }(t).reverse().join(" --\x3e ") }(e); throw new Error(Mt.CIRCULAR_DEPENDENCY + " " + n) } t(e) })) }, At.listMetadataForTarget = function (t, e) { if (e.isTagged() || e.isNamed()) { var n = "", r = e.getNamedTag(), i = e.getCustomTags(); return null !== r && (n += r.toString() + "\n"), null !== i && i.forEach((function (t) { n += t.toString() + "\n" })), " " + t + "\n " + t + " - " + n } return " " + t }, At.getFunctionName = It; var Pt = {}; Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.Context = void 0; var Lt = dt, Rt = function () { function t(t) { this.id = Lt.id(), this.container = t } return t.prototype.addPlan = function (t) { this.plan = t }, t.prototype.setCurrentRequest = function (t) { this.currentRequest = t }, t }(); Pt.Context = Rt; var Dt = {}; Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.Metadata = void 0; var Nt = ct, zt = function () { function t(t, e) { this.key = t, this.value = e } return t.prototype.toString = function () { return this.key === Nt.NAMED_TAG ? "named: " + this.value.toString() + " " : "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }" }, t }(); Dt.Metadata = zt; var Ft = {}; Object.defineProperty(Ft, "__esModule", { value: !0 }), Ft.Plan = void 0; var Bt = function (t, e) { this.parentContext = t, this.rootRequest = e }; Ft.Plan = Bt; var jt = {}, Ut = {}, Vt = {}; Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.tagProperty = Vt.tagParameter = Vt.decorate = void 0; var Gt = _t, Ht = ct; function Wt(t, e, n, r, i) { var o = {}, a = "number" == typeof i, s = void 0 !== i && a ? i.toString() : n; if (a && void 0 !== n) throw new Error(Gt.INVALID_DECORATOR_OPERATION); Reflect.hasOwnMetadata(t, e) && (o = Reflect.getMetadata(t, e)); var l = o[s]; if (Array.isArray(l)) for (var u = 0, c = l; u < c.length; u++) { var p = c[u]; if (p.key === r.key) throw new Error(Gt.DUPLICATED_METADATA + " " + p.key.toString()) } else l = []; l.push(r), o[s] = l, Reflect.defineMetadata(t, o, e) } function Xt(t, e) { Reflect.decorate(t, e) } function qt(t, e) { return function (n, r) { e(n, r, t) } } Vt.tagParameter = function (t, e, n, r) { Wt(Ht.TAGGED, t, e, r, n) }, Vt.tagProperty = function (t, e, n) { Wt(Ht.TAGGED_PROP, t.constructor, e, n) }, Vt.decorate = function (t, e, n) { "number" == typeof n ? Xt([qt(n, t)], e) : "string" == typeof n ? Reflect.decorate([t], e, n) : Xt([t], e) }, Object.defineProperty(Ut, "__esModule", { value: !0 }), Ut.inject = Ut.LazyServiceIdentifer = void 0; var Zt = _t, Yt = ct, Kt = Dt, Qt = Vt, Jt = function () { function t(t) { this._cb = t } return t.prototype.unwrap = function () { return this._cb() }, t }(); Ut.LazyServiceIdentifer = Jt, Ut.inject = function (t) { return function (e, n, r) { if (void 0 === t) throw new Error(Zt.UNDEFINED_INJECT_ANNOTATION(e.name)); var i = new Kt.Metadata(Yt.INJECT_TAG, t); "number" == typeof r ? Qt.tagParameter(e, n, r, i) : Qt.tagProperty(e, n, i) } }; var $t = {}, te = {}; Object.defineProperty(te, "__esModule", { value: !0 }), te.QueryableString = void 0; var ee = function () { function t(t) { this.str = t } return t.prototype.startsWith = function (t) { return 0 === this.str.indexOf(t) }, t.prototype.endsWith = function (t) { var e, n = t.split("").reverse().join(""); return e = this.str.split("").reverse().join(""), this.startsWith.call({ str: e }, n) }, t.prototype.contains = function (t) { return -1 !== this.str.indexOf(t) }, t.prototype.equals = function (t) { return this.str === t }, t.prototype.value = function () { return this.str }, t }(); te.QueryableString = ee, Object.defineProperty($t, "__esModule", { value: !0 }), $t.Target = void 0; var ne = ct, re = dt, ie = Dt, oe = te, ae = function () { function t(t, e, n, r) { this.id = re.id(), this.type = t, this.serviceIdentifier = n, this.name = new oe.QueryableString(e || ""), this.metadata = new Array; var i = null; "string" == typeof r ? i = new ie.Metadata(ne.NAMED_TAG, r) : r instanceof ie.Metadata && (i = r), null !== i && this.metadata.push(i) } return t.prototype.hasTag = function (t) { for (var e = 0, n = this.metadata; e < n.length; e++) { if (n[e].key === t) return !0 } return !1 }, t.prototype.isArray = function () { return this.hasTag(ne.MULTI_INJECT_TAG) }, t.prototype.matchesArray = function (t) { return this.matchesTag(ne.MULTI_INJECT_TAG)(t) }, t.prototype.isNamed = function () { return this.hasTag(ne.NAMED_TAG) }, t.prototype.isTagged = function () { return this.metadata.some((function (t) { return ne.NON_CUSTOM_TAG_KEYS.every((function (e) { return t.key !== e })) })) }, t.prototype.isOptional = function () { return this.matchesTag(ne.OPTIONAL_TAG)(!0) }, t.prototype.getNamedTag = function () { return this.isNamed() ? this.metadata.filter((function (t) { return t.key === ne.NAMED_TAG }))[0] : null }, t.prototype.getCustomTags = function () { return this.isTagged() ? this.metadata.filter((function (t) { return ne.NON_CUSTOM_TAG_KEYS.every((function (e) { return t.key !== e })) })) : null }, t.prototype.matchesNamedTag = function (t) { return this.matchesTag(ne.NAMED_TAG)(t) }, t.prototype.matchesTag = function (t) { var e = this; return function (n) { for (var r = 0, i = e.metadata; r < i.length; r++) { var o = i[r]; if (o.key === t && o.value === n) return !0 } return !1 } }, t }(); $t.Target = ae, function (t) { var e = D && D.__spreadArray || function (t, e) { for (var n = 0, r = e.length, i = t.length; n < r; n++, i++)t[i] = e[n]; return t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.getFunctionName = t.getBaseClassDependencyCount = t.getDependencies = void 0; var n = Ut, r = _t, i = ft, o = ct, a = At; Object.defineProperty(t, "getFunctionName", { enumerable: !0, get: function () { return a.getFunctionName } }); var s = $t; function l(t, n, i, o) { var a = t.getConstructorMetadata(i), s = a.compilerGeneratedMetadata; if (void 0 === s) { var l = r.MISSING_INJECTABLE_ANNOTATION + " " + n + "."; throw new Error(l) } var p = a.userGeneratedMetadata, h = Object.keys(p), f = 0 === i.length && h.length > 0, d = h.length > i.length, m = function (t, e, n, r, i) { for (var o = [], a = 0; a < i; a++) { var s = u(a, t, e, n, r); null !== s && o.push(s) } return o }(o, n, s, p, f || d ? h.length : i.length), v = c(t, i); return e(e([], m), v) } function u(t, e, o, a, l) { var u = l[t.toString()] || [], c = p(u), h = !0 !== c.unmanaged, f = a[t], d = c.inject || c.multiInject; if ((f = d || f) instanceof n.LazyServiceIdentifer && (f = f.unwrap()), h) { if (!e && (f === Object || f === Function || void 0 === f)) { var m = r.MISSING_INJECT_ANNOTATION + " argument " + t + " in class " + o + "."; throw new Error(m) } var v = new s.Target(i.TargetTypeEnum.ConstructorArgument, c.targetName, f); return v.metadata = u, v } return null } function c(t, n) { for (var r = t.getPropertiesMetadata(n), o = [], a = 0, l = Object.keys(r); a < l.length; a++) { var u = l[a], h = r[u], f = p(r[u]), d = f.targetName || u, m = f.inject || f.multiInject, v = new s.Target(i.TargetTypeEnum.ClassProperty, d, m); v.metadata = h, o.push(v) } var y = Object.getPrototypeOf(n.prototype).constructor; if (y !== Object) { var g = c(t, y); o = e(e([], o), g) } return o } function p(t) { var e = {}; return t.forEach((function (t) { e[t.key.toString()] = t.value })), { inject: e[o.INJECT_TAG], multiInject: e[o.MULTI_INJECT_TAG], targetName: e[o.NAME_TAG], unmanaged: e[o.UNMANAGED_TAG] } } t.getDependencies = function (t, e) { return l(t, a.getFunctionName(e), e, !1) }, t.getBaseClassDependencyCount = function t(e, n) { var r = Object.getPrototypeOf(n.prototype).constructor; if (r !== Object) { var i = l(e, a.getFunctionName(r), r, !0), s = i.map((function (t) { return t.metadata.filter((function (t) { return t.key === o.UNMANAGED_TAG })) })), u = [].concat.apply([], s).length, c = i.length - u; return c > 0 ? c : t(e, r) } return 0 } }(jt); var se = {}; Object.defineProperty(se, "__esModule", { value: !0 }), se.Request = void 0; var le = dt, ue = function () { function t(t, e, n, r, i) { this.id = le.id(), this.serviceIdentifier = t, this.parentContext = e, this.parentRequest = n, this.target = i, this.childRequests = [], this.bindings = Array.isArray(r) ? r : [r], this.requestScope = null === n ? new Map : null } return t.prototype.addChildRequest = function (e, n, r) { var i = new t(e, this.parentContext, this, n, r); return this.childRequests.push(i), i }, t }(); se.Request = ue, Object.defineProperty(St, "__esModule", { value: !0 }), St.getBindingDictionary = St.createMockRequest = St.plan = void 0; var ce = Et, pe = _t, he = ft, fe = ct, de = Ct, me = At, ve = Pt, ye = Dt, ge = Ft, _e = jt, xe = se, be = $t; function we(t) { return t._bindingDictionary } function Se(t, e, n, r, i) { var o = Ce(n.container, i.serviceIdentifier), a = []; return o.length === ce.BindingCount.NoBindingsAvailable && n.container.options.autoBindInjectable && "function" == typeof i.serviceIdentifier && t.getConstructorMetadata(i.serviceIdentifier).compilerGeneratedMetadata && (n.container.bind(i.serviceIdentifier).toSelf(), o = Ce(n.container, i.serviceIdentifier)), a = e ? o : o.filter((function (t) { var e = new xe.Request(t.serviceIdentifier, n, r, t, i); return t.constraint(e) })), function (t, e, n, r) { switch (e.length) { case ce.BindingCount.NoBindingsAvailable: if (n.isOptional()) return e; var i = me.getServiceIdentifierAsString(t), o = pe.NOT_REGISTERED; throw o += me.listMetadataForTarget(i, n), o += me.listRegisteredBindingsForServiceIdentifier(r, i, Ce), new Error(o); case ce.BindingCount.OnlyOneBindingAvailable: if (!n.isArray()) return e; case ce.BindingCount.MultipleBindingsAvailable: default: if (n.isArray()) return e; i = me.getServiceIdentifierAsString(t), o = pe.AMBIGUOUS_MATCH + " " + i; throw o += me.listRegisteredBindingsForServiceIdentifier(r, i, Ce), new Error(o) } }(i.serviceIdentifier, a, i, n.container), a } function Ee(t, e, n, r, i, o) { var a, s; if (null === i) { a = Se(t, e, r, null, o), s = new xe.Request(n, r, null, a, o); var l = new ge.Plan(r, s); r.addPlan(l) } else a = Se(t, e, r, i, o), s = i.addChildRequest(o.serviceIdentifier, a, o); a.forEach((function (e) { var n = null; if (o.isArray()) n = s.addChildRequest(e.serviceIdentifier, e, o); else { if (e.cache) return; n = s } if (e.type === he.BindingTypeEnum.Instance && null !== e.implementationType) { var i = _e.getDependencies(t, e.implementationType); if (!r.container.options.skipBaseClassChecks) { var a = _e.getBaseClassDependencyCount(t, e.implementationType); if (i.length < a) { var l = pe.ARGUMENTS_LENGTH_MISMATCH(_e.getFunctionName(e.implementationType)); throw new Error(l) } } i.forEach((function (e) { Ee(t, !1, e.serviceIdentifier, r, n, e) })) } })) } function Ce(t, e) { var n = [], r = we(t); return r.hasKey(e) ? n = r.get(e) : null !== t.parent && (n = Ce(t.parent, e)), n } St.getBindingDictionary = we, St.plan = function (t, e, n, r, i, o, a, s) { void 0 === s && (s = !1); var l = new ve.Context(e), u = function (t, e, n, r, i, o) { var a = t ? fe.MULTI_INJECT_TAG : fe.INJECT_TAG, s = new ye.Metadata(a, n), l = new be.Target(e, r, n, s); if (void 0 !== i) { var u = new ye.Metadata(i, o); l.metadata.push(u) } return l }(n, r, i, "", o, a); try { return Ee(t, s, i, l, null, u), l } catch (t) { throw de.isStackOverflowExeption(t) && l.plan && me.circularDependencyToException(l.plan.rootRequest), t } }, St.createMockRequest = function (t, e, n, r) { var i = new be.Target(he.TargetTypeEnum.Variable, "", e, new ye.Metadata(n, r)), o = new ve.Context(t); return new xe.Request(e, o, null, [], i) }; var Te = {}, Ae = {}, Me = D && D.__spreadArray || function (t, e) { for (var n = 0, r = e.length, i = t.length; n < r; n++, i++)t[i] = e[n]; return t }; Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.resolveInstance = void 0; var Oe = _t, ke = ft, Ie = ct; Ae.resolveInstance = function (t, e, n) { var r, i, o = null; if (e.length > 0) { var a = e.filter((function (t) { return null !== t.target && t.target.type === ke.TargetTypeEnum.ConstructorArgument })).map(n); i = a, o = function (t, e, n) { var r = e.filter((function (t) { return null !== t.target && t.target.type === ke.TargetTypeEnum.ClassProperty })), i = r.map(n); return r.forEach((function (e, n) { var r; r = e.target.name.value(); var o = i[n]; t[r] = o })), t }(o = new ((r = t).bind.apply(r, Me([void 0], i))), e, n) } else o = new t; return function (t, e) { if (Reflect.hasMetadata(Ie.POST_CONSTRUCT, t)) { var n = Reflect.getMetadata(Ie.POST_CONSTRUCT, t); try { e[n.value]() } catch (e) { throw new Error(Oe.POST_CONSTRUCT_ERROR(t.name, e.message)) } } }(t, o), o }, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.resolve = void 0; var Pe = _t, Le = ft, Re = Ct, De = At, Ne = Ae, ze = function (t, e, n) { try { return n() } catch (n) { throw Re.isStackOverflowExeption(n) ? new Error(Pe.CIRCULAR_DEPENDENCY_IN_FACTORY(t, e.toString())) : n } }, Fe = function (t) { return function (e) { e.parentContext.setCurrentRequest(e); var n = e.bindings, r = e.childRequests, i = e.target && e.target.isArray(), o = !(e.parentRequest && e.parentRequest.target && e.target && e.parentRequest.target.matchesArray(e.target.serviceIdentifier)); if (i && o) return r.map((function (e) { return Fe(t)(e) })); var a = null; if (!e.target.isOptional() || 0 !== n.length) { var s = n[0], l = s.scope === Le.BindingScopeEnum.Singleton, u = s.scope === Le.BindingScopeEnum.Request; if (l && s.activated) return s.cache; if (u && null !== t && t.has(s.id)) return t.get(s.id); if (s.type === Le.BindingTypeEnum.ConstantValue) a = s.cache, s.activated = !0; else if (s.type === Le.BindingTypeEnum.Function) a = s.cache, s.activated = !0; else if (s.type === Le.BindingTypeEnum.Constructor) a = s.implementationType; else if (s.type === Le.BindingTypeEnum.DynamicValue && null !== s.dynamicValue) a = ze("toDynamicValue", s.serviceIdentifier, (function () { return s.dynamicValue(e.parentContext) })); else if (s.type === Le.BindingTypeEnum.Factory && null !== s.factory) a = ze("toFactory", s.serviceIdentifier, (function () { return s.factory(e.parentContext) })); else if (s.type === Le.BindingTypeEnum.Provider && null !== s.provider) a = ze("toProvider", s.serviceIdentifier, (function () { return s.provider(e.parentContext) })); else { if (s.type !== Le.BindingTypeEnum.Instance || null === s.implementationType) { var c = De.getServiceIdentifierAsString(e.serviceIdentifier); throw new Error(Pe.INVALID_BINDING_TYPE + " " + c) } a = Ne.resolveInstance(s.implementationType, r, Fe(t)) } return "function" == typeof s.onActivation && (a = s.onActivation(e.parentContext, a)), l && (s.cache = a, s.activated = !0), u && null !== t && !t.has(s.id) && t.set(s.id, a), a } } }; Te.resolve = function (t) { return Fe(t.plan.rootRequest.requestScope)(t.plan.rootRequest) }; var Be = {}, je = {}, Ue = {}, Ve = {}, Ge = {}, He = {}, We = {}; Object.defineProperty(We, "__esModule", { value: !0 }), We.typeConstraint = We.namedConstraint = We.taggedConstraint = We.traverseAncerstors = void 0; var Xe = ct, qe = Dt, Ze = function (t, e) { var n = t.parentRequest; return null !== n && (!!e(n) || Ze(n, e)) }; We.traverseAncerstors = Ze; var Ye = function (t) { return function (e) { var n = function (n) { return null !== n && null !== n.target && n.target.matchesTag(t)(e) }; return n.metaData = new qe.Metadata(t, e), n } }; We.taggedConstraint = Ye; var Ke = Ye(Xe.NAMED_TAG); We.namedConstraint = Ke; We.typeConstraint = function (t) { return function (e) { var n = null; if (null !== e) { if (n = e.bindings[0], "string" == typeof t) return n.serviceIdentifier === t; var r = e.bindings[0].implementationType; return t === r } return !1 } }, Object.defineProperty(He, "__esModule", { value: !0 }), He.BindingWhenSyntax = void 0; var Qe = Ge, Je = We, $e = function () { function t(t) { this._binding = t } return t.prototype.when = function (t) { return this._binding.constraint = t, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenTargetNamed = function (t) { return this._binding.constraint = Je.namedConstraint(t), new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenTargetIsDefault = function () { return this._binding.constraint = function (t) { return null !== t.target && !t.target.isNamed() && !t.target.isTagged() }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenTargetTagged = function (t, e) { return this._binding.constraint = Je.taggedConstraint(t)(e), new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenInjectedInto = function (t) { return this._binding.constraint = function (e) { return Je.typeConstraint(t)(e.parentRequest) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenParentNamed = function (t) { return this._binding.constraint = function (e) { return Je.namedConstraint(t)(e.parentRequest) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenParentTagged = function (t, e) { return this._binding.constraint = function (n) { return Je.taggedConstraint(t)(e)(n.parentRequest) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenAnyAncestorIs = function (t) { return this._binding.constraint = function (e) { return Je.traverseAncerstors(e, Je.typeConstraint(t)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenNoAncestorIs = function (t) { return this._binding.constraint = function (e) { return !Je.traverseAncerstors(e, Je.typeConstraint(t)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenAnyAncestorNamed = function (t) { return this._binding.constraint = function (e) { return Je.traverseAncerstors(e, Je.namedConstraint(t)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenNoAncestorNamed = function (t) { return this._binding.constraint = function (e) { return !Je.traverseAncerstors(e, Je.namedConstraint(t)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenAnyAncestorTagged = function (t, e) { return this._binding.constraint = function (n) { return Je.traverseAncerstors(n, Je.taggedConstraint(t)(e)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenNoAncestorTagged = function (t, e) { return this._binding.constraint = function (n) { return !Je.traverseAncerstors(n, Je.taggedConstraint(t)(e)) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenAnyAncestorMatches = function (t) { return this._binding.constraint = function (e) { return Je.traverseAncerstors(e, t) }, new Qe.BindingOnSyntax(this._binding) }, t.prototype.whenNoAncestorMatches = function (t) { return this._binding.constraint = function (e) { return !Je.traverseAncerstors(e, t) }, new Qe.BindingOnSyntax(this._binding) }, t }(); He.BindingWhenSyntax = $e, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.BindingOnSyntax = void 0; var tn = He, en = function () { function t(t) { this._binding = t } return t.prototype.onActivation = function (t) { return this._binding.onActivation = t, new tn.BindingWhenSyntax(this._binding) }, t }(); Ge.BindingOnSyntax = en, Object.defineProperty(Ve, "__esModule", { value: !0 }), Ve.BindingWhenOnSyntax = void 0; var nn = Ge, rn = He, on = function () { function t(t) { this._binding = t, this._bindingWhenSyntax = new rn.BindingWhenSyntax(this._binding), this._bindingOnSyntax = new nn.BindingOnSyntax(this._binding) } return t.prototype.when = function (t) { return this._bindingWhenSyntax.when(t) }, t.prototype.whenTargetNamed = function (t) { return this._bindingWhenSyntax.whenTargetNamed(t) }, t.prototype.whenTargetIsDefault = function () { return this._bindingWhenSyntax.whenTargetIsDefault() }, t.prototype.whenTargetTagged = function (t, e) { return this._bindingWhenSyntax.whenTargetTagged(t, e) }, t.prototype.whenInjectedInto = function (t) { return this._bindingWhenSyntax.whenInjectedInto(t) }, t.prototype.whenParentNamed = function (t) { return this._bindingWhenSyntax.whenParentNamed(t) }, t.prototype.whenParentTagged = function (t, e) { return this._bindingWhenSyntax.whenParentTagged(t, e) }, t.prototype.whenAnyAncestorIs = function (t) { return this._bindingWhenSyntax.whenAnyAncestorIs(t) }, t.prototype.whenNoAncestorIs = function (t) { return this._bindingWhenSyntax.whenNoAncestorIs(t) }, t.prototype.whenAnyAncestorNamed = function (t) { return this._bindingWhenSyntax.whenAnyAncestorNamed(t) }, t.prototype.whenAnyAncestorTagged = function (t, e) { return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e) }, t.prototype.whenNoAncestorNamed = function (t) { return this._bindingWhenSyntax.whenNoAncestorNamed(t) }, t.prototype.whenNoAncestorTagged = function (t, e) { return this._bindingWhenSyntax.whenNoAncestorTagged(t, e) }, t.prototype.whenAnyAncestorMatches = function (t) { return this._bindingWhenSyntax.whenAnyAncestorMatches(t) }, t.prototype.whenNoAncestorMatches = function (t) { return this._bindingWhenSyntax.whenNoAncestorMatches(t) }, t.prototype.onActivation = function (t) { return this._bindingOnSyntax.onActivation(t) }, t }(); Ve.BindingWhenOnSyntax = on, Object.defineProperty(Ue, "__esModule", { value: !0 }), Ue.BindingInSyntax = void 0; var an = ft, sn = Ve, ln = function () { function t(t) { this._binding = t } return t.prototype.inRequestScope = function () { return this._binding.scope = an.BindingScopeEnum.Request, new sn.BindingWhenOnSyntax(this._binding) }, t.prototype.inSingletonScope = function () { return this._binding.scope = an.BindingScopeEnum.Singleton, new sn.BindingWhenOnSyntax(this._binding) }, t.prototype.inTransientScope = function () { return this._binding.scope = an.BindingScopeEnum.Transient, new sn.BindingWhenOnSyntax(this._binding) }, t }(); Ue.BindingInSyntax = ln, Object.defineProperty(je, "__esModule", { value: !0 }), je.BindingInWhenOnSyntax = void 0; var un = Ue, cn = Ge, pn = He, hn = function () { function t(t) { this._binding = t, this._bindingWhenSyntax = new pn.BindingWhenSyntax(this._binding), this._bindingOnSyntax = new cn.BindingOnSyntax(this._binding), this._bindingInSyntax = new un.BindingInSyntax(t) } return t.prototype.inRequestScope = function () { return this._bindingInSyntax.inRequestScope() }, t.prototype.inSingletonScope = function () { return this._bindingInSyntax.inSingletonScope() }, t.prototype.inTransientScope = function () { return this._bindingInSyntax.inTransientScope() }, t.prototype.when = function (t) { return this._bindingWhenSyntax.when(t) }, t.prototype.whenTargetNamed = function (t) { return this._bindingWhenSyntax.whenTargetNamed(t) }, t.prototype.whenTargetIsDefault = function () { return this._bindingWhenSyntax.whenTargetIsDefault() }, t.prototype.whenTargetTagged = function (t, e) { return this._bindingWhenSyntax.whenTargetTagged(t, e) }, t.prototype.whenInjectedInto = function (t) { return this._bindingWhenSyntax.whenInjectedInto(t) }, t.prototype.whenParentNamed = function (t) { return this._bindingWhenSyntax.whenParentNamed(t) }, t.prototype.whenParentTagged = function (t, e) { return this._bindingWhenSyntax.whenParentTagged(t, e) }, t.prototype.whenAnyAncestorIs = function (t) { return this._bindingWhenSyntax.whenAnyAncestorIs(t) }, t.prototype.whenNoAncestorIs = function (t) { return this._bindingWhenSyntax.whenNoAncestorIs(t) }, t.prototype.whenAnyAncestorNamed = function (t) { return this._bindingWhenSyntax.whenAnyAncestorNamed(t) }, t.prototype.whenAnyAncestorTagged = function (t, e) { return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e) }, t.prototype.whenNoAncestorNamed = function (t) { return this._bindingWhenSyntax.whenNoAncestorNamed(t) }, t.prototype.whenNoAncestorTagged = function (t, e) { return this._bindingWhenSyntax.whenNoAncestorTagged(t, e) }, t.prototype.whenAnyAncestorMatches = function (t) { return this._bindingWhenSyntax.whenAnyAncestorMatches(t) }, t.prototype.whenNoAncestorMatches = function (t) { return this._bindingWhenSyntax.whenNoAncestorMatches(t) }, t.prototype.onActivation = function (t) { return this._bindingOnSyntax.onActivation(t) }, t }(); je.BindingInWhenOnSyntax = hn, Object.defineProperty(Be, "__esModule", { value: !0 }), Be.BindingToSyntax = void 0; var fn = _t, dn = ft, mn = je, vn = Ve, yn = function () { function t(t) { this._binding = t } return t.prototype.to = function (t) { return this._binding.type = dn.BindingTypeEnum.Instance, this._binding.implementationType = t, new mn.BindingInWhenOnSyntax(this._binding) }, t.prototype.toSelf = function () { if ("function" != typeof this._binding.serviceIdentifier) throw new Error("" + fn.INVALID_TO_SELF_VALUE); var t = this._binding.serviceIdentifier; return this.to(t) }, t.prototype.toConstantValue = function (t) { return this._binding.type = dn.BindingTypeEnum.ConstantValue, this._binding.cache = t, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = dn.BindingScopeEnum.Singleton, new vn.BindingWhenOnSyntax(this._binding) }, t.prototype.toDynamicValue = function (t) { return this._binding.type = dn.BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t, this._binding.implementationType = null, new mn.BindingInWhenOnSyntax(this._binding) }, t.prototype.toConstructor = function (t) { return this._binding.type = dn.BindingTypeEnum.Constructor, this._binding.implementationType = t, this._binding.scope = dn.BindingScopeEnum.Singleton, new vn.BindingWhenOnSyntax(this._binding) }, t.prototype.toFactory = function (t) { return this._binding.type = dn.BindingTypeEnum.Factory, this._binding.factory = t, this._binding.scope = dn.BindingScopeEnum.Singleton, new vn.BindingWhenOnSyntax(this._binding) }, t.prototype.toFunction = function (t) { if ("function" != typeof t) throw new Error(fn.INVALID_FUNCTION_BINDING); var e = this.toConstantValue(t); return this._binding.type = dn.BindingTypeEnum.Function, this._binding.scope = dn.BindingScopeEnum.Singleton, e }, t.prototype.toAutoFactory = function (t) { return this._binding.type = dn.BindingTypeEnum.Factory, this._binding.factory = function (e) { return function () { return e.container.get(t) } }, this._binding.scope = dn.BindingScopeEnum.Singleton, new vn.BindingWhenOnSyntax(this._binding) }, t.prototype.toProvider = function (t) { return this._binding.type = dn.BindingTypeEnum.Provider, this._binding.provider = t, this._binding.scope = dn.BindingScopeEnum.Singleton, new vn.BindingWhenOnSyntax(this._binding) }, t.prototype.toService = function (t) { this.toDynamicValue((function (e) { return e.container.get(t) })) }, t }(); Be.BindingToSyntax = yn; var gn = {}; Object.defineProperty(gn, "__esModule", { value: !0 }), gn.ContainerSnapshot = void 0; var _n = function () { function t() { } return t.of = function (e, n) { var r = new t; return r.bindings = e, r.middleware = n, r }, t }(); gn.ContainerSnapshot = _n; var xn = {}; Object.defineProperty(xn, "__esModule", { value: !0 }), xn.Lookup = void 0; var bn = _t, wn = function () { function t() { this._map = new Map } return t.prototype.getMap = function () { return this._map }, t.prototype.add = function (t, e) { if (null == t) throw new Error(bn.NULL_ARGUMENT); if (null == e) throw new Error(bn.NULL_ARGUMENT); var n = this._map.get(t); void 0 !== n ? (n.push(e), this._map.set(t, n)) : this._map.set(t, [e]) }, t.prototype.get = function (t) { if (null == t) throw new Error(bn.NULL_ARGUMENT); var e = this._map.get(t); if (void 0 !== e) return e; throw new Error(bn.KEY_NOT_FOUND) }, t.prototype.remove = function (t) { if (null == t) throw new Error(bn.NULL_ARGUMENT); if (!this._map.delete(t)) throw new Error(bn.KEY_NOT_FOUND) }, t.prototype.removeByCondition = function (t) { var e = this; this._map.forEach((function (n, r) { var i = n.filter((function (e) { return !t(e) })); i.length > 0 ? e._map.set(r, i) : e._map.delete(r) })) }, t.prototype.hasKey = function (t) { if (null == t) throw new Error(bn.NULL_ARGUMENT); return this._map.has(t) }, t.prototype.clone = function () { var e = new t; return this._map.forEach((function (t, n) { t.forEach((function (t) { return e.add(n, t.clone()) })) })), e }, t.prototype.traverse = function (t) { this._map.forEach((function (e, n) { t(n, e) })) }, t }(); xn.Lookup = wn; var Sn = D && D.__awaiter || function (t, e, n, r) { return new (n || (n = Promise))((function (i, o) { function a(t) { try { l(r.next(t)) } catch (t) { o(t) } } function s(t) { try { l(r.throw(t)) } catch (t) { o(t) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(a, s) } l((r = r.apply(t, e || [])).next()) })) }, En = D && D.__generator || function (t, e) { var n, r, i, o, a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function s(o) { return function (s) { return function (o) { if (n) throw new TypeError("Generator is already executing."); for (; a;)try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return a.label++, { value: o[1], done: !1 }; case 5: a.label++, r = o[1], o = [0]; continue; case 7: o = a.ops.pop(), a.trys.pop(); continue; default: if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) { a = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (6 === o[0] && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break } i[2] && a.ops.pop(), a.trys.pop(); continue }o = e.call(t, a) } catch (t) { o = [6, t], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s]) } } }, Cn = D && D.__spreadArray || function (t, e) { for (var n = 0, r = e.length, i = t.length; n < r; n++, i++)t[i] = e[n]; return t }; Object.defineProperty(pt, "__esModule", { value: !0 }), pt.Container = void 0; var Tn = ht, An = _t, Mn = ft, On = ct, kn = xt, In = St, Pn = Te, Ln = Be, Rn = dt, Dn = At, Nn = gn, zn = xn, Fn = function () { function t(t) { this._appliedMiddleware = []; var e = t || {}; if ("object" != typeof e) throw new Error("" + An.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT); if (void 0 === e.defaultScope) e.defaultScope = Mn.BindingScopeEnum.Transient; else if (e.defaultScope !== Mn.BindingScopeEnum.Singleton && e.defaultScope !== Mn.BindingScopeEnum.Transient && e.defaultScope !== Mn.BindingScopeEnum.Request) throw new Error("" + An.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE); if (void 0 === e.autoBindInjectable) e.autoBindInjectable = !1; else if ("boolean" != typeof e.autoBindInjectable) throw new Error("" + An.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE); if (void 0 === e.skipBaseClassChecks) e.skipBaseClassChecks = !1; else if ("boolean" != typeof e.skipBaseClassChecks) throw new Error("" + An.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK); this.options = { autoBindInjectable: e.autoBindInjectable, defaultScope: e.defaultScope, skipBaseClassChecks: e.skipBaseClassChecks }, this.id = Rn.id(), this._bindingDictionary = new zn.Lookup, this._snapshots = [], this._middleware = null, this.parent = null, this._metadataReader = new kn.MetadataReader } return t.merge = function (e, n) { for (var r = [], i = 2; i < arguments.length; i++)r[i - 2] = arguments[i]; var o = new t, a = Cn([e, n], r).map((function (t) { return In.getBindingDictionary(t) })), s = In.getBindingDictionary(o); function l(t, e) { t.traverse((function (t, n) { n.forEach((function (t) { e.add(t.serviceIdentifier, t.clone()) })) })) } return a.forEach((function (t) { l(t, s) })), o }, t.prototype.load = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; for (var n = this._getContainerModuleHelpersFactory(), r = 0, i = t; r < i.length; r++) { var o = i[r], a = n(o.id); o.registry(a.bindFunction, a.unbindFunction, a.isboundFunction, a.rebindFunction) } }, t.prototype.loadAsync = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return Sn(this, void 0, void 0, (function () { var e, n, r, i, o; return En(this, (function (a) { switch (a.label) { case 0: e = this._getContainerModuleHelpersFactory(), n = 0, r = t, a.label = 1; case 1: return n < r.length ? (i = r[n], o = e(i.id), [4, i.registry(o.bindFunction, o.unbindFunction, o.isboundFunction, o.rebindFunction)]) : [3, 4]; case 2: a.sent(), a.label = 3; case 3: return n++, [3, 1]; case 4: return [2] } })) })) }, t.prototype.unload = function () { for (var t = this, e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; var r = function (t) { return function (e) { return e.moduleId === t } }; e.forEach((function (e) { var n = r(e.id); t._bindingDictionary.removeByCondition(n) })) }, t.prototype.bind = function (t) { var e = this.options.defaultScope || Mn.BindingScopeEnum.Transient, n = new Tn.Binding(t, e); return this._bindingDictionary.add(t, n), new Ln.BindingToSyntax(n) }, t.prototype.rebind = function (t) { return this.unbind(t), this.bind(t) }, t.prototype.unbind = function (t) { try { this._bindingDictionary.remove(t) } catch (e) { throw new Error(An.CANNOT_UNBIND + " " + Dn.getServiceIdentifierAsString(t)) } }, t.prototype.unbindAll = function () { this._bindingDictionary = new zn.Lookup }, t.prototype.isBound = function (t) { var e = this._bindingDictionary.hasKey(t); return !e && this.parent && (e = this.parent.isBound(t)), e }, t.prototype.isBoundNamed = function (t, e) { return this.isBoundTagged(t, On.NAMED_TAG, e) }, t.prototype.isBoundTagged = function (t, e, n) { var r = !1; if (this._bindingDictionary.hasKey(t)) { var i = this._bindingDictionary.get(t), o = In.createMockRequest(this, t, e, n); r = i.some((function (t) { return t.constraint(o) })) } return !r && this.parent && (r = this.parent.isBoundTagged(t, e, n)), r }, t.prototype.snapshot = function () { this._snapshots.push(Nn.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware)) }, t.prototype.restore = function () { var t = this._snapshots.pop(); if (void 0 === t) throw new Error(An.NO_MORE_SNAPSHOTS_AVAILABLE); this._bindingDictionary = t.bindings, this._middleware = t.middleware }, t.prototype.createChild = function (e) { var n = new t(e || this.options); return n.parent = this, n }, t.prototype.applyMiddleware = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; this._appliedMiddleware = this._appliedMiddleware.concat(t); var n = this._middleware ? this._middleware : this._planAndResolve(); this._middleware = t.reduce((function (t, e) { return e(t) }), n) }, t.prototype.applyCustomMetadataReader = function (t) { this._metadataReader = t }, t.prototype.get = function (t) { return this._get(!1, !1, Mn.TargetTypeEnum.Variable, t) }, t.prototype.getTagged = function (t, e, n) { return this._get(!1, !1, Mn.TargetTypeEnum.Variable, t, e, n) }, t.prototype.getNamed = function (t, e) { return this.getTagged(t, On.NAMED_TAG, e) }, t.prototype.getAll = function (t) { return this._get(!0, !0, Mn.TargetTypeEnum.Variable, t) }, t.prototype.getAllTagged = function (t, e, n) { return this._get(!1, !0, Mn.TargetTypeEnum.Variable, t, e, n) }, t.prototype.getAllNamed = function (t, e) { return this.getAllTagged(t, On.NAMED_TAG, e) }, t.prototype.resolve = function (t) { var e = this.createChild(); return e.bind(t).toSelf(), this._appliedMiddleware.forEach((function (t) { e.applyMiddleware(t) })), e.get(t) }, t.prototype._getContainerModuleHelpersFactory = function () { var t = this, e = function (t, e) { t._binding.moduleId = e }, n = function (n) { return function (r) { var i = t.rebind.bind(t)(r); return e(i, n), i } }; return function (r) { return { bindFunction: (i = r, function (n) { var r = t.bind.bind(t)(n); return e(r, i), r }), isboundFunction: function (e) { return t.isBound.bind(t)(e) }, rebindFunction: n(r), unbindFunction: function (e) { t.unbind.bind(t)(e) } }; var i } }, t.prototype._get = function (t, e, n, r, i, o) { var a = null, s = { avoidConstraints: t, contextInterceptor: function (t) { return t }, isMultiInject: e, key: i, serviceIdentifier: r, targetType: n, value: o }; if (this._middleware) { if (null == (a = this._middleware(s))) throw new Error(An.INVALID_MIDDLEWARE_RETURN) } else a = this._planAndResolve()(s); return a }, t.prototype._planAndResolve = function () { var t = this; return function (e) { var n = In.plan(t._metadataReader, t, e.isMultiInject, e.targetType, e.serviceIdentifier, e.key, e.value, e.avoidConstraints); return n = e.contextInterceptor(n), Pn.resolve(n) } }, t }(); pt.Container = Fn; var Bn = {}; Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.AsyncContainerModule = Bn.ContainerModule = void 0; var jn = dt, Un = function (t) { this.id = jn.id(), this.registry = t }; Bn.ContainerModule = Un; var Vn = function (t) { this.id = jn.id(), this.registry = t }; Bn.AsyncContainerModule = Vn; var Gn = {}; Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.injectable = void 0; var Hn = _t, Wn = ct; Gn.injectable = function () { return function (t) { if (Reflect.hasOwnMetadata(Wn.PARAM_TYPES, t)) throw new Error(Hn.DUPLICATED_INJECTABLE_DECORATOR); var e = Reflect.getMetadata(Wn.DESIGN_PARAM_TYPES, t) || []; return Reflect.defineMetadata(Wn.PARAM_TYPES, e, t), t } }; var Xn = {}; Object.defineProperty(Xn, "__esModule", { value: !0 }), Xn.tagged = void 0; var qn = Dt, Zn = Vt; Xn.tagged = function (t, e) { return function (n, r, i) { var o = new qn.Metadata(t, e); "number" == typeof i ? Zn.tagParameter(n, r, i, o) : Zn.tagProperty(n, r, o) } }; var Yn = {}; Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.named = void 0; var Kn = ct, Qn = Dt, Jn = Vt; Yn.named = function (t) { return function (e, n, r) { var i = new Qn.Metadata(Kn.NAMED_TAG, t); "number" == typeof r ? Jn.tagParameter(e, n, r, i) : Jn.tagProperty(e, n, i) } }; var $n = {}; Object.defineProperty($n, "__esModule", { value: !0 }), $n.optional = void 0; var tr = ct, er = Dt, nr = Vt; $n.optional = function () { return function (t, e, n) { var r = new er.Metadata(tr.OPTIONAL_TAG, !0); "number" == typeof n ? nr.tagParameter(t, e, n, r) : nr.tagProperty(t, e, r) } }; var rr = {}; Object.defineProperty(rr, "__esModule", { value: !0 }), rr.unmanaged = void 0; var ir = ct, or = Dt, ar = Vt; rr.unmanaged = function () { return function (t, e, n) { var r = new or.Metadata(ir.UNMANAGED_TAG, !0); ar.tagParameter(t, e, n, r) } }; var sr = {}; Object.defineProperty(sr, "__esModule", { value: !0 }), sr.multiInject = void 0; var lr = ct, ur = Dt, cr = Vt; sr.multiInject = function (t) { return function (e, n, r) { var i = new ur.Metadata(lr.MULTI_INJECT_TAG, t); "number" == typeof r ? cr.tagParameter(e, n, r, i) : cr.tagProperty(e, n, i) } }; var pr = {}; Object.defineProperty(pr, "__esModule", { value: !0 }), pr.targetName = void 0; var hr = ct, fr = Dt, dr = Vt; pr.targetName = function (t) { return function (e, n, r) { var i = new fr.Metadata(hr.NAME_TAG, t); dr.tagParameter(e, n, r, i) } }; var mr = {}; Object.defineProperty(mr, "__esModule", { value: !0 }), mr.postConstruct = void 0; var vr = _t, yr = ct, gr = Dt; mr.postConstruct = function () { return function (t, e, n) { var r = new gr.Metadata(yr.POST_CONSTRUCT, e); if (Reflect.hasOwnMetadata(yr.POST_CONSTRUCT, t.constructor)) throw new Error(vr.MULTIPLE_POST_CONSTRUCT_METHODS); Reflect.defineMetadata(yr.POST_CONSTRUCT, r, t.constructor) } }; var _r = {}; Object.defineProperty(_r, "__esModule", { value: !0 }), _r.multiBindToService = void 0; _r.multiBindToService = function (t) { return function (e) { return function () { for (var n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r]; return n.forEach((function (n) { return t.bind(n).toService(e) })) } } }, function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.multiBindToService = t.getServiceIdentifierAsString = t.typeConstraint = t.namedConstraint = t.taggedConstraint = t.traverseAncerstors = t.decorate = t.id = t.MetadataReader = t.postConstruct = t.targetName = t.multiInject = t.unmanaged = t.optional = t.LazyServiceIdentifer = t.inject = t.named = t.tagged = t.injectable = t.ContainerModule = t.AsyncContainerModule = t.TargetTypeEnum = t.BindingTypeEnum = t.BindingScopeEnum = t.Container = t.METADATA_KEY = void 0; var e = ct; t.METADATA_KEY = e; var n = pt; Object.defineProperty(t, "Container", { enumerable: !0, get: function () { return n.Container } }); var r = ft; Object.defineProperty(t, "BindingScopeEnum", { enumerable: !0, get: function () { return r.BindingScopeEnum } }), Object.defineProperty(t, "BindingTypeEnum", { enumerable: !0, get: function () { return r.BindingTypeEnum } }), Object.defineProperty(t, "TargetTypeEnum", { enumerable: !0, get: function () { return r.TargetTypeEnum } }); var i = Bn; Object.defineProperty(t, "AsyncContainerModule", { enumerable: !0, get: function () { return i.AsyncContainerModule } }), Object.defineProperty(t, "ContainerModule", { enumerable: !0, get: function () { return i.ContainerModule } }); var o = Gn; Object.defineProperty(t, "injectable", { enumerable: !0, get: function () { return o.injectable } }); var a = Xn; Object.defineProperty(t, "tagged", { enumerable: !0, get: function () { return a.tagged } }); var s = Yn; Object.defineProperty(t, "named", { enumerable: !0, get: function () { return s.named } }); var l = Ut; Object.defineProperty(t, "inject", { enumerable: !0, get: function () { return l.inject } }), Object.defineProperty(t, "LazyServiceIdentifer", { enumerable: !0, get: function () { return l.LazyServiceIdentifer } }); var u = $n; Object.defineProperty(t, "optional", { enumerable: !0, get: function () { return u.optional } }); var c = rr; Object.defineProperty(t, "unmanaged", { enumerable: !0, get: function () { return c.unmanaged } }); var p = sr; Object.defineProperty(t, "multiInject", { enumerable: !0, get: function () { return p.multiInject } }); var h = pr; Object.defineProperty(t, "targetName", { enumerable: !0, get: function () { return h.targetName } }); var f = mr; Object.defineProperty(t, "postConstruct", { enumerable: !0, get: function () { return f.postConstruct } }); var d = xt; Object.defineProperty(t, "MetadataReader", { enumerable: !0, get: function () { return d.MetadataReader } }); var m = dt; Object.defineProperty(t, "id", { enumerable: !0, get: function () { return m.id } }); var v = Vt; Object.defineProperty(t, "decorate", { enumerable: !0, get: function () { return v.decorate } }); var y = We; Object.defineProperty(t, "traverseAncerstors", { enumerable: !0, get: function () { return y.traverseAncerstors } }), Object.defineProperty(t, "taggedConstraint", { enumerable: !0, get: function () { return y.taggedConstraint } }), Object.defineProperty(t, "namedConstraint", { enumerable: !0, get: function () { return y.namedConstraint } }), Object.defineProperty(t, "typeConstraint", { enumerable: !0, get: function () { return y.typeConstraint } }); var g = At; Object.defineProperty(t, "getServiceIdentifierAsString", { enumerable: !0, get: function () { return g.getServiceIdentifierAsString } }); var _ = _r; Object.defineProperty(t, "multiBindToService", { enumerable: !0, get: function () { return _.multiBindToService } }) }(ut); var xr = {}, br = {}; Object.defineProperty(br, "__esModule", { value: !0 }); var wr = Symbol.for("INJECTION"); function Sr(t, e, n, r) { Object.defineProperty(t, e, { configurable: !0, enumerable: !0, get: function () { return r && !Reflect.hasMetadata(wr, this, e) && Reflect.defineMetadata(wr, n(), this, e), Reflect.hasMetadata(wr, this, e) ? Reflect.getMetadata(wr, this, e) : n() }, set: function (t) { Reflect.defineMetadata(wr, t, this, e) } }) } br.makePropertyInjectDecorator = function (t, e) { return function (n) { return function (r, i) { Sr(r, i, (function () { return t.get(n) }), e) } } }, br.makePropertyInjectNamedDecorator = function (t, e) { return function (n, r) { return function (i, o) { Sr(i, o, (function () { return t.getNamed(n, r) }), e) } } }, br.makePropertyInjectTaggedDecorator = function (t, e) { return function (n, r, i) { return function (o, a) { Sr(o, a, (function () { return t.getTagged(n, r, i) }), e) } } }, br.makePropertyMultiInjectDecorator = function (t, e) { return function (n) { return function (r, i) { Sr(r, i, (function () { return t.getAll(n) }), e) } } }, Object.defineProperty(xr, "__esModule", { value: !0 }); var Er = br; var Cr = xr.default = function (t, e) { return void 0 === e && (e = !0), { lazyInject: Er.makePropertyInjectDecorator(t, e), lazyInjectNamed: Er.makePropertyInjectNamedDecorator(t, e), lazyInjectTagged: Er.makePropertyInjectTaggedDecorator(t, e), lazyMultiInject: Er.makePropertyMultiInjectDecorator(t, e) } }, Tr = { IEventEmitter: Symbol.for("IEventEmitter"), ISceneService: Symbol.for("ISceneService"), IGlobalConfigService: Symbol.for("IGlobalConfigService"), ICameraService: Symbol.for("ICameraService"), ICoordinateSystemService: Symbol.for("ICoordinateSystemService"), ILayerService: Symbol.for("ILayerService"), ILayerMappingService: Symbol.for("ILayerMappingService"), ILayerStyleService: Symbol.for("ILayerStyleService"), IMapService: Symbol.for("IMapService"), IMarkerService: Symbol.for("IMarkerService"), IPopupService: Symbol.for("PopupService"), IFactoryMapService: Symbol.for("Factory<IMapService>"), IRendererService: Symbol.for("IRendererService"), IShaderModuleService: Symbol.for("IShaderModuleService"), IIconService: Symbol.for("IIconService"), IFontService: Symbol.for("IFontService"), IInteractionService: Symbol.for("IInteractionService"), IPickingService: Symbol.for("IPickingService"), IControlService: Symbol.for("IControlService"), IStyleAttributeService: Symbol.for("IStyleAttributeService"), ILayer: Symbol.for("ILayer"), ILayerPlugin: Symbol.for("ILayerPlugin"), INormalPass: Symbol.for("INormalPass"), IPostProcessor: Symbol.for("IPostProcessor"), IPostProcessingPass: Symbol.for("IPostProcessingPass"), IFactoryPostProcessingPass: Symbol.for("Factory<IPostProcessingPass>"), IFactoryNormalPass: Symbol.for("Factory<IFactoryNormalPass>"), IMultiPassRenderer: Symbol.for("IMultiPassRenderer"), SceneID: Symbol.for("SceneID"), MapConfig: Symbol.for("MapConfig") }; function Ar(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Mr(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function Or(t, e, n) { return e && Mr(t.prototype, e), n && Mr(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function kr(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ir(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function Pr(t, e) { if (t) { if ("string" == typeof t) return Ir(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ir(t, e) : void 0 } } function Lr(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) { var r, i, o = [], a = !0, s = !1; try { for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0); } catch (t) { s = !0, i = t } finally { try { a || null == n.return || n.return() } finally { if (s) throw i } } return o } }(t, e) || Pr(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } var Rr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; function Dr(t) { this.message = t } function Nr(t) { for (var e, n, r, i, o = "", a = 0, s = (t = String(t)).length % 3; a < t.length;) { if ((n = t.charCodeAt(a++)) > 255 || (r = t.charCodeAt(a++)) > 255 || (i = t.charCodeAt(a++)) > 255) throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range."); o += Rr.charAt((e = n << 16 | r << 8 | i) >> 18 & 63) + Rr.charAt(e >> 12 & 63) + Rr.charAt(e >> 6 & 63) + Rr.charAt(63 & e) } return s ? o.slice(0, s - 3) + "===".substring(s) : o } Dr.prototype = new Error, Dr.prototype.name = "InvalidCharacterError"; var zr, Fr = function () { function t(e, n) { Ar(this, t), this.buffers = e, this.type = n } return Or(t, [{ key: "arraybuffer", value: function () { return Promise.resolve(this.buffers[0]) } }, { key: "stream", value: function () { throw new Error("not implemented") } }, { key: "text", value: function () { throw new Error("not implemented") } }, { key: "slice", value: function (t, e, n) { throw new Error("not implemented") } }]), t }(); zr = "undefined" == typeof window ? { devicePixelRatio: 1, navigator: { userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36", browserLanguage: "zh-CN", language: "zh-CN", platform: "" }, location: "", document: { documentElement: { style: {} }, createEvent: function () { return !0 }, getElementById: function (t) { return !0 }, createElement: function () { return { className: "", classList: { add: function () { return "" } } } }, createElementNS: function () { return !0 }, addEventListener: function () { return !0 }, removeEventListener: function () { return !0 }, querySelector: function () { return !1 } }, performance: { mark: function (t) { return null }, clearMeasures: function (t) { return null }, clearMarks: function (t) { return null }, measure: function (t, e, n) { return { duration: 0 } }, now: function () { return (new Date).getTime() } }, Blob: "", dispatchEvent: function (t) { return !0 }, Event: function (t, e) { return !0 }, createElement: function () { return !0 }, createElementNS: function () { return !0 }, XMLHttpRequest: function () { return !0 }, addEventListener: function () { return !0 }, removeEventListener: function () { return !0 }, requestAnimationFrame: function () { return !0 }, cancelAnimationFrame: function () { return !0 }, clearTimeout: function () { return !0 } } : window; var Br = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM ? my.getSystemInfoSync().pixelRatio : zr.devicePixelRatio; function jr(t, e) { return jr = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t }, jr(t, e) } function Ur(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); Object.defineProperty(t, "prototype", { value: Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), writable: !1 }), e && jr(t, e) } function Vr(t) { return Vr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Vr(t) } function Gr(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Hr(t, e) { if (e && ("object" === Vr(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return Gr(t) } function Wr(t) { return Wr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, Wr(t) } var Xr = Or((function t(e, n) { Ar(this, t), kr(this, "cancelBubble", void 0), kr(this, "cancelable", void 0), kr(this, "target", void 0), kr(this, "currentTarget", void 0), kr(this, "preventDefault", void 0), kr(this, "stopPropagation", void 0), kr(this, "type", void 0), kr(this, "timeStamp", void 0), this.cancelBubble = !1, this.cancelable = !1, this.target = null, this.currentTarget = null, this.preventDefault = function () { }, this.stopPropagation = function () { }, this.type = e, this.timeStamp = Date.now() })); function qr(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Zr(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Zr(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Zr(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var Yr = new WeakMap, Kr = function () { function t() { Ar(this, t), Yr.set(this, {}) } return Or(t, [{ key: "addEventListener", value: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = Yr.get(this); r || (r = {}), r[t] || (r[t] = []), r[t].push(e), Yr.set(this, r), n.capture, n.once, n.passive } }, { key: "removeEventListener", value: function (t, e) { var n = Yr.get(this); if (n) { var r = n[t]; if (r && r.length > 0) for (var i = r.length; i--; i > 0)if (r[i] === e) { r.splice(i, 1); break } } } }, { key: "dispatchEvent", value: function (t) { var e = Yr.get(this)[t.type]; if (e) { var n, r = qr(e); try { for (r.s(); !(n = r.n()).done;) { (0, n.value)(t) } } catch (t) { r.e(t) } finally { r.f() } } } }]), t }(); function Qr(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Jr = function (t) { Ur(n, t); var e = Qr(n); function n() { var t; return Ar(this, n), kr(Gr(t = e.call(this)), "childNodes", void 0), t.childNodes = [], t } return Or(n, [{ key: "appendChild", value: function (t) { this.childNodes.push(t) } }, { key: "cloneNode", value: function () { var t = Object.create(this); return Object.assign(t, this), t } }, { key: "removeChild", value: function (t) { var e = this.childNodes.findIndex((function (e) { return e === t })); return e > -1 ? this.childNodes.splice(e, 1) : null } }]), n }(Kr); function $r(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ti, ei, ni, ri, ii = function (t) { Ur(n, t); var e = $r(n); function n() { var t; return Ar(this, n), kr(Gr(t = e.call(this)), "className", void 0), kr(Gr(t), "children", void 0), t.className = "", t.children = [], t } return Or(n, [{ key: "setAttribute", value: function (t, e) { this[t] = e } }, { key: "getAttribute", value: function (t) { return this[t] } }, { key: "setAttributeNS", value: function (t, e) { this[t] = e } }, { key: "getAttributeNS", value: function (t) { return this[t] } }]), n }(Jr); if ("undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM) { var oi = my.getSystemInfoSync(); ti = oi.screenWidth, ei = oi.screenHeight, ni = oi.windowWidth, ri = oi.windowHeight } else { var ai = zr.innerWidth, si = zr.innerHeight; ti = ai, ei = si, ni = ai, ri = si } var li = { width: ti, height: ei, availWidth: ni, availHeight: ri, availLeft: 0, availTop: 0 }, ui = li.availWidth, ci = li.availHeight, pi = { style: [] }; function hi(t, e) { var n, r; "parentNode" in t || (n = 0 === e ? function () { return null } : 1 === e ? function () { return pi } : function () { return null }, Object.defineProperty(t, "parentNode", { enumerable: !0, get: n })); "parentElement" in t || (r = 0 === e ? function () { return null } : 1 === e ? function () { return pi } : function () { return null }, Object.defineProperty(t, "parentElement", { enumerable: !0, get: r })) } function fi(t) { t.style = t.style || {}, Object.assign(t.style, { top: "0px", left: "0px", width: ui + "px", height: ci + "px", margin: "0px", padding: "0px" }) } function di(t) { "clientLeft" in t || (t.clientLeft = 0, t.clientTop = 0), "clientWidth" in t || (t.clientWidth = ui, t.clientHeight = ci), "getBoundingClientRect" in t || (t.getBoundingClientRect = function () { return { x: 0, y: 0, top: 0, left: 0, width: this.clientWidth, height: this.clientHeight, right: this.clientWidth, bottom: this.clientHeight } }) } function mi(t) { "offsetLeft" in t || (t.offsetLeft = 0, t.offsetTop = 0), "offsetWidth" in t || (t.offsetWidth = ui, t.offsetHeight = ci) } function vi(t) { "scrollLeft" in t || (t.scrollLeft = 0, t.scrollTop = 0), "scrollWidth" in t || (t.scrollWidth = ui, t.scrollHeight = ci) } function yi(t) { var e = function () { return !0 }; t.classList = [], t.classList.add = e, t.classList.remove = e, t.classList.contains = e, t.classList.toggle = e } function gi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function _i() { } var xi = function (t) { Ur(n, t); var e = gi(n); function n() { var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i = arguments.length > 1 ? arguments[1] : void 0; return Ar(this, n), kr(Gr(t = e.call(this)), "className", void 0), kr(Gr(t), "children", void 0), kr(Gr(t), "focus", void 0), kr(Gr(t), "blur", void 0), kr(Gr(t), "insertBefore", void 0), kr(Gr(t), "appendChild", void 0), kr(Gr(t), "removeChild", void 0), kr(Gr(t), "remove", void 0), kr(Gr(t), "innerHTML", void 0), kr(Gr(t), "tagName", void 0), t.className = "", t.children = [], t.focus = _i, t.blur = _i, t.insertBefore = _i, t.appendChild = _i, t.removeChild = _i, t.remove = _i, t.innerHTML = "", t.tagName = r.toUpperCase(), hi(Gr(t), i), fi(Gr(t)), yi(Gr(t)), di(Gr(t)), mi(Gr(t)), vi(Gr(t)), t } return Or(n) }(ii); function bi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var wi = function (t) { Ur(n, t); var e = bi(n); function n(t) { return Ar(this, n), e.call(this, t) } return Or(n, [{ key: "addTextTrack", value: function () { } }, { key: "captureStream", value: function () { } }, { key: "fastSeek", value: function () { } }, { key: "load", value: function () { } }, { key: "pause", value: function () { } }, { key: "play", value: function () { } }]), n }(xi); function Si(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Ei = function (t) { Ur(n, t); var e = Si(n); function n() { return Ar(this, n), e.call(this, "video") } return Or(n) }(wi), Ci = {}; function Ti() { return Ci } var Ai = Or((function t() { Ar(this, t); var e = Ti(), n = e.createImage && e.createImage() || {}; return "tagName" in n || (n.tagName = "IMG", n.__proto__ = t.prototype), hi(n), yi(n), Object.assign(n, { addEventListener: function (t, e) { n["on".concat(t)] = e.bind(n) }, removeEventListener: function (t) { n["on".concat(t)] = null } }), n })), Mi = { href: "", protocol: "", host: "" }; function Oi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ki = function (t) { Ur(n, t); var e = Oi(n); function n() { return Ar(this, n), e.call(this, "body", 0) } return Or(n, [{ key: "addEventListener", value: function (t, e) { } }, { key: "removeEventListener", value: function (t, e, n) { } }, { key: "dispatchEvent", value: function (t) { } }]), n }(xi), Ii = function (t) { Ur(n, t); var e = Oi(n); function n() { return Ar(this, n), e.call(this, "html", 0) } return Or(n, [{ key: "addEventListener", value: function (t, e) { } }, { key: "removeEventListener", value: function (t, e) { } }, { key: "dispatchEvent", value: function (t) { } }]), n }(xi), Pi = {}, Li = { readyState: "complete", visibilityState: "visible", hidden: !1, fullscreen: !0, scripts: [], style: {}, location: Mi, ontouchstart: null, ontouchmove: null, ontouchend: null, onvisibilitychange: null, parentNode: null, parentElement: null, head: null, body: null, documentElement: { style: [] }, createElement: function (t) { return "canvas" === (t = t.toLowerCase()) ? my.createOffscreenCanvas(1024, 128, "2d") : "img" === t ? new Ai : "video" === t ? new Ei : new xi(t) }, createElementNS: function (t, e) { return this.createElement(e) }, createTextNode: function (t) { return t }, getElementById: function (t) { return null }, getElementsByTagName: function (t) { return t = t.toLowerCase(), [] }, getElementsByTagNameNS: function (t, e) { return this.getElementsByTagName(e) }, getElementsByName: function (t) { return [] }, querySelector: function (t) { return null }, querySelectorAll: function (t) { return [] }, addEventListener: function (t, e, n) { Pi[t] || (Pi[t] = []), Pi[t].push(e) }, removeEventListener: function (t, e) { var n = Pi[t]; if (n && n.length > 0) for (var r = n.length; r--; r > 0)if (n[r] === e) { n.splice(r, 1); break } }, dispatchEvent: function (t) { var e = t.type, n = Pi[e]; if (n) for (var r = 0; r < n.length; r++)n[r](t); t.target && "function" == typeof t.target["on" + e] && t.target["on" + e](t) }, createEvent: function (t) { return new Xr(t) } }; Li.documentElement = new Ii, Li.head = new xi("head"), Li.body = new ki; var Ri, Di, Ni, zi, Fi = Object, Bi = function () { function t() { Ar(this, t), kr(this, "_w", void 0), kr(this, "_h", void 0), kr(this, "_data", void 0); var e = arguments.length; if (2 === e) { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) return this._w = arguments[0], this._h = arguments[1], void (this._data = new Uint8ClampedArray(this._w * this._h * 4)) } else 3 === e && "object" === Vr(arguments[0]) && "number" == typeof arguments[1] && "number" == typeof arguments[2] && (this._data = arguments[0], this._w = arguments[1], this._h = arguments[2]); throw new Error("ImageData: params error") } return Or(t, [{ key: "width", get: function () { return this._w } }, { key: "height", get: function () { return this._h } }, { key: "data", get: function () { return this._data } }]), t }(); if ("undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM) { var ji = my.getSystemInfoSync(); Ri = ji.system, Di = ji.platform, Ni = ji.language } else { var Ui = { versions: (zi = zr.navigator.userAgent, { trident: zi.indexOf("Trident") > -1, presto: zi.indexOf("Presto") > -1, webKit: zi.indexOf("AppleWebKit") > -1, gecko: zi.indexOf("Gecko") > -1 && -1 === zi.indexOf("KHTML"), mobile: !!zi.match(/AppleWebKit.*Mobile.*/), ios: !!zi.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), android: zi.indexOf("Android") > -1 || zi.indexOf("Linux") > -1, iPhone: zi.indexOf("iPhone") > -1, iPad: zi.indexOf("iPad") > -1, webApp: -1 === zi.indexOf("Safari"), weixin: zi.indexOf("MicroMessenger") > -1, qq: " qq" === zi.match(/\sQQ/i) }), language: (zr.navigator.browserLanguage || zr.navigator.language).toLowerCase() }; Ui.versions.android ? Di = "android" : Ui.versions.trident ? Di = "IE" : Ui.versions.presto ? Di = "Opera" : Ui.versions.webKit ? Di = "webKit" : Ui.versions.gecko ? Di = "Firefox" : Ui.versions.mobile ? Di = "mobile" : Ui.versions.ios ? Di = "ios" : Ui.versions.iPhone ? Di = "iPhone" : Ui.versions.iPad ? Di = "ipad" : Ui.versions.webApp ? Di = "webApp" : Ui.versions.weixin ? Di = "weixin" : Ui.versions.qq && (Di = "qq"), Ri = zr.navigator.userAgent, Ni = Ui.language } var Vi = -1 !== Ri.toLowerCase().indexOf("android") ? "Android; CPU Android 6.0" : "iPhone; CPU iPhone OS 10_3_1 like Mac OS X", Gi = "Mozilla/5.0 (".concat(Vi, ") AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/").concat(Ni), Hi = { platform: Di, language: Ni, appVersion: "5.0 (".concat(Vi, ") AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1"), userAgent: Gi }, Wi = 0; var Xi = function () { function t(e) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""; Ar(this, t), kr(this, "href", void 0), 0 != e.indexOf("http://") && 0 != e.indexOf("https://") ? this.href = n + e : this.href = e } return Or(t, null, [{ key: "createObjectURL", value: function (t) { var e = t.buffers[0], n = t.type, r = function (t) { for (var e = "", n = new Uint8Array(t), r = n.byteLength, i = 0; i < r; i++)e += String.fromCharCode(n[i]); return Nr(e) }(e); return "data:".concat(n, ";base64, ") + r } }]), t }(); function qi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Zi = new Map, Yi = new Map, Ki = new Map, Qi = function (t) { Ur(n, t); var e = qi(n); function n() { var t; return Ar(this, n), kr(Gr(t = e.call(this)), "onabort", void 0), kr(Gr(t), "onerror", void 0), kr(Gr(t), "onload", void 0), kr(Gr(t), "onloadstart", void 0), kr(Gr(t), "onprogress", void 0), kr(Gr(t), "ontimeout", void 0), kr(Gr(t), "onloadend", void 0), kr(Gr(t), "onreadystatechange", void 0), kr(Gr(t), "readyState", void 0), kr(Gr(t), "response", void 0), kr(Gr(t), "responseText", void 0), kr(Gr(t), "_responseType", void 0), kr(Gr(t), "responseXML", void 0), kr(Gr(t), "status", void 0), kr(Gr(t), "statusText", void 0), kr(Gr(t), "upload", void 0), kr(Gr(t), "withCredentials", void 0), kr(Gr(t), "timeout", void 0), kr(Gr(t), "_url", void 0), kr(Gr(t), "_method", void 0), t.onabort = null, t.onerror = null, t.onload = null, t.onloadstart = null, t.onprogress = null, t.ontimeout = null, t.onloadend = null, t.onreadystatechange = null, t.readyState = 0, t.response = null, t.responseText = null, t._responseType = "text", t.responseXML = null, t.status = 0, t.statusText = "", t.upload = {}, t.withCredentials = !1, Zi.set("requestHeader", { "content-type": "application/x-www-form-urlencoded" }), t } return Or(n, [{ key: "responseType", set: function (t) { this._responseType = t } }, { key: "abort", value: function () { var t = Ki.get("requestTask"); t && t.abort() } }, { key: "getAllResponseHeaders", value: function () { var t = Yi.get("responseHeader"); return Object.keys(t).map((function (e) { return "".concat(e, ": ").concat(t[e]) })).join("\n") } }, { key: "getResponseHeader", value: function (t) { return Yi.get("responseHeader")[t] } }, { key: "open", value: function (t, e, n) { this._method = t, this._url = e } }, { key: "overrideMimeType", value: function () { } }, { key: "send", value: function () { } }, { key: "setRequestHeader", value: function (t, e) { var n = Zi.get("requestHeader"); n[t] = e, Zi.set("requestHeader", n) } }, { key: "addEventListener", value: function (t, e) { var n = this; "function" == typeof e && (this["on" + t] = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t.target = t.target || n, e.call(n, t) }) } }, { key: "removeEventListener", value: function (t, e) { this["on" + t] === e && (this["on" + t] = null) } }]), n }(Kr); function Ji(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function $i(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function to(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } kr(Qi, "UNSEND", void 0), kr(Qi, "OPENED", void 0), kr(Qi, "HEADERS_RECEIVED", void 0), kr(Qi, "LOADING", void 0), kr(Qi, "DONE", void 0), Qi.UNSEND = 0, Qi.OPENED = 1, Qi.HEADERS_RECEIVED = 2, Qi.LOADING = 3, Qi.DONE = 4, function (t) { Ur(n, t); var e = Ji(n); function n(t) { var r; return Ar(this, n), kr(Gr(r = e.call(this, t)), "touches", void 0), kr(Gr(r), "targetTouches", void 0), kr(Gr(r), "changedTouches", void 0), r.touches = [], r.targetTouches = [], r.changedTouches = [], r.target = Ti(), r.currentTarget = Ti(), r } Or(n) }(Xr), function (t) { Ur(n, t); var e = $i(n); function n(t) { var r; return Ar(this, n), kr(Gr(r = e.call(this, t)), "buttons", void 0), kr(Gr(r), "which", void 0), kr(Gr(r), "pointerId", void 0), kr(Gr(r), "bubbles", void 0), kr(Gr(r), "button", void 0), kr(Gr(r), "width", void 0), kr(Gr(r), "height", void 0), kr(Gr(r), "pressure", void 0), kr(Gr(r), "isPrimary", void 0), kr(Gr(r), "pointerType", void 0), kr(Gr(r), "altKey", void 0), kr(Gr(r), "ctrlKey", void 0), kr(Gr(r), "metaKey", void 0), kr(Gr(r), "shiftKey", void 0), r.target = Ti(), r.currentTarget = Ti(), r } Or(n) }(Xr), function (t) { Ur(n, t); var e = to(n); function n(t) { return Ar(this, n), e.call(this, t) } Or(n) }(Xr); var eo = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, no = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram), ro = eo || no, io = { atob: function (t) { var e = String(t).replace(/=+$/, ""); if (e.length % 4 == 1) throw new Dr("'atob' failed: The string to be decoded is not correctly encoded."); for (var n, r, i = "", o = 0, a = 0; r = e.charAt(a++); ~r && (n = o % 4 ? 64 * n + r : r, o++ % 4) ? i += String.fromCharCode(255 & n >> (-2 * o & 6)) : 0)r = Rr.indexOf(r); return i }, btoa: Nr, devicePixelRatio: Br, Blob: Fr, document: Li, Element: ii, Event: Xr, EventTarget: Kr, HTMLCanvasElement: Fi, HTMLElement: xi, HTMLMediaElement: wi, HTMLVideoElement: Ei, Image: Ai, ImageData: Bi, navigator: Hi, Node: Jr, requestAnimationFrame: function (t) { var e = Ti(); return e.requestAnimationFrame ? e.requestAnimationFrame(t) : function (t) { var e = Date.now(), n = Math.max(Wi + 23, e); return setTimeout((function () { t(Wi = n) }), n - e) }(t) }, cancelAnimationFrame: function (t) { var e = Ti(); return e.cancelAnimationFrame ? e.cancelAnimationFrame(t) : clearTimeout(t) }, screen: li, XMLHttpRequest: Qi, performance: { mark: function (t) { return null }, clearMeasures: function (t) { return null }, clearMarks: function (t) { return null }, measure: function (t, e, n) { return { duration: 0 } }, now: function () { } }, URL: Xi, WebGLRenderingContext: { GCCSO_SHADER_BINARY_FJ: 37472, _3DC_XY_AMD: 34810, _3DC_X_AMD: 34809, ACTIVE_ATTRIBUTES: 35721, ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722, ACTIVE_PROGRAM_EXT: 33369, ACTIVE_TEXTURE: 34016, ACTIVE_UNIFORMS: 35718, ACTIVE_UNIFORM_MAX_LENGTH: 35719, ALIASED_LINE_WIDTH_RANGE: 33902, ALIASED_POINT_SIZE_RANGE: 33901, ALL_COMPLETED_NV: 34034, ALL_SHADER_BITS_EXT: 4294967295, ALPHA: 6406, ALPHA16F_EXT: 34844, ALPHA32F_EXT: 34838, ALPHA8_EXT: 32828, ALPHA8_OES: 32828, ALPHA_BITS: 3413, ALPHA_TEST_FUNC_QCOM: 3009, ALPHA_TEST_QCOM: 3008, ALPHA_TEST_REF_QCOM: 3010, ALREADY_SIGNALED_APPLE: 37146, ALWAYS: 519, AMD_compressed_3DC_texture: 1, AMD_compressed_ATC_texture: 1, AMD_performance_monitor: 1, AMD_program_binary_Z400: 1, ANGLE_depth_texture: 1, ANGLE_framebuffer_blit: 1, ANGLE_framebuffer_multisample: 1, ANGLE_instanced_arrays: 1, ANGLE_pack_reverse_row_order: 1, ANGLE_program_binary: 1, ANGLE_texture_compression_dxt3: 1, ANGLE_texture_compression_dxt5: 1, ANGLE_texture_usage: 1, ANGLE_translated_shader_source: 1, ANY_SAMPLES_PASSED_CONSERVATIVE_EXT: 36202, ANY_SAMPLES_PASSED_EXT: 35887, APPLE_copy_texture_levels: 1, APPLE_framebuffer_multisample: 1, APPLE_rgb_422: 1, APPLE_sync: 1, APPLE_texture_format_BGRA8888: 1, APPLE_texture_max_level: 1, ARM_mali_program_binary: 1, ARM_mali_shader_binary: 1, ARM_rgba8: 1, ARRAY_BUFFER: 34962, ARRAY_BUFFER_BINDING: 34964, ATC_RGBA_EXPLICIT_ALPHA_AMD: 35987, ATC_RGBA_INTERPOLATED_ALPHA_AMD: 34798, ATC_RGB_AMD: 35986, ATTACHED_SHADERS: 35717, BACK: 1029, BGRA8_EXT: 37793, BGRA_EXT: 32993, BGRA_IMG: 32993, BINNING_CONTROL_HINT_QCOM: 36784, BLEND: 3042, BLEND_COLOR: 32773, BLEND_DST_ALPHA: 32970, BLEND_DST_RGB: 32968, BLEND_EQUATION: 32777, BLEND_EQUATION_ALPHA: 34877, BLEND_EQUATION_RGB: 32777, BLEND_SRC_ALPHA: 32971, BLEND_SRC_RGB: 32969, BLUE_BITS: 3412, BOOL: 35670, BOOL_VEC2: 35671, BOOL_VEC3: 35672, BOOL_VEC4: 35673, BUFFER: 33504, BUFFER_ACCESS_OES: 35003, BUFFER_MAPPED_OES: 35004, BUFFER_MAP_POINTER_OES: 35005, BUFFER_OBJECT_EXT: 37201, BUFFER_SIZE: 34660, BUFFER_USAGE: 34661, BYTE: 5120, CCW: 2305, CLAMP_TO_BORDER_NV: 33069, CLAMP_TO_EDGE: 33071, COLOR_ATTACHMENT0: 36064, COLOR_ATTACHMENT0_NV: 36064, COLOR_ATTACHMENT10_NV: 36074, COLOR_ATTACHMENT11_NV: 36075, COLOR_ATTACHMENT12_NV: 36076, COLOR_ATTACHMENT13_NV: 36077, COLOR_ATTACHMENT14_NV: 36078, COLOR_ATTACHMENT15_NV: 36079, COLOR_ATTACHMENT1_NV: 36065, COLOR_ATTACHMENT2_NV: 36066, COLOR_ATTACHMENT3_NV: 36067, COLOR_ATTACHMENT4_NV: 36068, COLOR_ATTACHMENT5_NV: 36069, COLOR_ATTACHMENT6_NV: 36070, COLOR_ATTACHMENT7_NV: 36071, COLOR_ATTACHMENT8_NV: 36072, COLOR_ATTACHMENT9_NV: 36073, COLOR_ATTACHMENT_EXT: 37104, COLOR_BUFFER_BIT: 16384, COLOR_BUFFER_BIT0_QCOM: 1, COLOR_BUFFER_BIT1_QCOM: 2, COLOR_BUFFER_BIT2_QCOM: 4, COLOR_BUFFER_BIT3_QCOM: 8, COLOR_BUFFER_BIT4_QCOM: 16, COLOR_BUFFER_BIT5_QCOM: 32, COLOR_BUFFER_BIT6_QCOM: 64, COLOR_BUFFER_BIT7_QCOM: 128, COLOR_CLEAR_VALUE: 3106, COLOR_EXT: 6144, COLOR_WRITEMASK: 3107, COMPARE_REF_TO_TEXTURE_EXT: 34894, COMPILE_STATUS: 35713, COMPRESSED_RGBA_ASTC_10x10_KHR: 37819, COMPRESSED_RGBA_ASTC_10x5_KHR: 37816, COMPRESSED_RGBA_ASTC_10x6_KHR: 37817, COMPRESSED_RGBA_ASTC_10x8_KHR: 37818, COMPRESSED_RGBA_ASTC_12x10_KHR: 37820, COMPRESSED_RGBA_ASTC_12x12_KHR: 37821, COMPRESSED_RGBA_ASTC_4x4_KHR: 37808, COMPRESSED_RGBA_ASTC_5x4_KHR: 37809, COMPRESSED_RGBA_ASTC_5x5_KHR: 37810, COMPRESSED_RGBA_ASTC_6x5_KHR: 37811, COMPRESSED_RGBA_ASTC_6x6_KHR: 37812, COMPRESSED_RGBA_ASTC_8x5_KHR: 37813, COMPRESSED_RGBA_ASTC_8x6_KHR: 37814, COMPRESSED_RGBA_ASTC_8x8_KHR: 37815, COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843, COMPRESSED_RGBA_PVRTC_2BPPV2_IMG: 37175, COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842, COMPRESSED_RGBA_PVRTC_4BPPV2_IMG: 37176, COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777, COMPRESSED_RGBA_S3TC_DXT3_ANGLE: 33778, COMPRESSED_RGBA_S3TC_DXT5_ANGLE: 33779, COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841, COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840, COMPRESSED_RGB_S3TC_DXT1_EXT: 33776, COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 37851, COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 37848, COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 37849, COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 37850, COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 37852, COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 37853, COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 37840, COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 37841, COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 37842, COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 37843, COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 37844, COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 37845, COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 37846, COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 37847, COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV: 35917, COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV: 35918, COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV: 35919, COMPRESSED_SRGB_S3TC_DXT1_NV: 35916, COMPRESSED_TEXTURE_FORMATS: 34467, CONDITION_SATISFIED_APPLE: 37148, CONSTANT_ALPHA: 32771, CONSTANT_COLOR: 32769, CONTEXT_FLAG_DEBUG_BIT: 2, CONTEXT_ROBUST_ACCESS_EXT: 37107, COUNTER_RANGE_AMD: 35777, COUNTER_TYPE_AMD: 35776, COVERAGE_ALL_FRAGMENTS_NV: 36565, COVERAGE_ATTACHMENT_NV: 36562, COVERAGE_AUTOMATIC_NV: 36567, COVERAGE_BUFFERS_NV: 36563, COVERAGE_BUFFER_BIT_NV: 32768, COVERAGE_COMPONENT4_NV: 36561, COVERAGE_COMPONENT_NV: 36560, COVERAGE_EDGE_FRAGMENTS_NV: 36566, COVERAGE_SAMPLES_NV: 36564, CPU_OPTIMIZED_QCOM: 36785, CULL_FACE: 2884, CULL_FACE_MODE: 2885, CURRENT_PROGRAM: 35725, CURRENT_QUERY_EXT: 34917, CURRENT_VERTEX_ATTRIB: 34342, CW: 2304, DEBUG_CALLBACK_FUNCTION: 33348, DEBUG_CALLBACK_USER_PARAM: 33349, DEBUG_GROUP_STACK_DEPTH: 33389, DEBUG_LOGGED_MESSAGES: 37189, DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: 33347, DEBUG_OUTPUT: 37600, DEBUG_OUTPUT_SYNCHRONOUS: 33346, DEBUG_SEVERITY_HIGH: 37190, DEBUG_SEVERITY_LOW: 37192, DEBUG_SEVERITY_MEDIUM: 37191, DEBUG_SEVERITY_NOTIFICATION: 33387, DEBUG_SOURCE_API: 33350, DEBUG_SOURCE_APPLICATION: 33354, DEBUG_SOURCE_OTHER: 33355, DEBUG_SOURCE_SHADER_COMPILER: 33352, DEBUG_SOURCE_THIRD_PARTY: 33353, DEBUG_SOURCE_WINDOW_SYSTEM: 33351, DEBUG_TYPE_DEPRECATED_BEHAVIOR: 33357, DEBUG_TYPE_ERROR: 33356, DEBUG_TYPE_MARKER: 33384, DEBUG_TYPE_OTHER: 33361, DEBUG_TYPE_PERFORMANCE: 33360, DEBUG_TYPE_POP_GROUP: 33386, DEBUG_TYPE_PORTABILITY: 33359, DEBUG_TYPE_PUSH_GROUP: 33385, DEBUG_TYPE_UNDEFINED_BEHAVIOR: 33358, DECR: 7683, DECR_WRAP: 34056, DELETE_STATUS: 35712, DEPTH24_STENCIL8_OES: 35056, DEPTH_ATTACHMENT: 36096, DEPTH_STENCIL_ATTACHMENT: 33306, DEPTH_BITS: 3414, DEPTH_BUFFER_BIT: 256, DEPTH_BUFFER_BIT0_QCOM: 256, DEPTH_BUFFER_BIT1_QCOM: 512, DEPTH_BUFFER_BIT2_QCOM: 1024, DEPTH_BUFFER_BIT3_QCOM: 2048, DEPTH_BUFFER_BIT4_QCOM: 4096, DEPTH_BUFFER_BIT5_QCOM: 8192, DEPTH_BUFFER_BIT6_QCOM: 16384, DEPTH_BUFFER_BIT7_QCOM: 32768, DEPTH_CLEAR_VALUE: 2931, DEPTH_COMPONENT: 6402, DEPTH_COMPONENT16: 33189, DEPTH_COMPONENT16_NONLINEAR_NV: 36396, DEPTH_COMPONENT16_OES: 33189, DEPTH_COMPONENT24_OES: 33190, DEPTH_COMPONENT32_OES: 33191, DEPTH_EXT: 6145, DEPTH_FUNC: 2932, DEPTH_RANGE: 2928, DEPTH_STENCIL: 34041, DEPTH_STENCIL_OES: 34041, DEPTH_TEST: 2929, DEPTH_WRITEMASK: 2930, DITHER: 3024, DMP_shader_binary: 1, DONT_CARE: 4352, DRAW_BUFFER0_NV: 34853, DRAW_BUFFER10_NV: 34863, DRAW_BUFFER11_NV: 34864, DRAW_BUFFER12_NV: 34865, DRAW_BUFFER13_NV: 34866, DRAW_BUFFER14_NV: 34867, DRAW_BUFFER15_NV: 34868, DRAW_BUFFER1_NV: 34854, DRAW_BUFFER2_NV: 34855, DRAW_BUFFER3_NV: 34856, DRAW_BUFFER4_NV: 34857, DRAW_BUFFER5_NV: 34858, DRAW_BUFFER6_NV: 34859, DRAW_BUFFER7_NV: 34860, DRAW_BUFFER8_NV: 34861, DRAW_BUFFER9_NV: 34862, DRAW_BUFFER_EXT: 3073, DRAW_FRAMEBUFFER_ANGLE: 36009, DRAW_FRAMEBUFFER_APPLE: 36009, DRAW_FRAMEBUFFER_BINDING_ANGLE: 36006, DRAW_FRAMEBUFFER_BINDING_APPLE: 36006, DRAW_FRAMEBUFFER_BINDING_NV: 36006, DRAW_FRAMEBUFFER_NV: 36009, DST_ALPHA: 772, DST_COLOR: 774, DYNAMIC_DRAW: 35048, ELEMENT_ARRAY_BUFFER: 34963, ELEMENT_ARRAY_BUFFER_BINDING: 34965, EQUAL: 514, ES_VERSION_2_0: 1, ETC1_RGB8_OES: 36196, ETC1_SRGB8_NV: 35054, EXTENSIONS: 7939, EXT_blend_minmax: 1, EXT_color_buffer_half_float: 1, EXT_debug_label: 1, EXT_debug_marker: 1, EXT_discard_framebuffer: 1, EXT_map_buffer_range: 1, EXT_multi_draw_arrays: 1, EXT_multisampled_render_to_texture: 1, EXT_multiview_draw_buffers: 1, EXT_occlusion_query_boolean: 1, EXT_read_format_bgra: 1, EXT_robustness: 1, EXT_sRGB: 1, EXT_separate_shader_objects: 1, EXT_shader_framebuffer_fetch: 1, EXT_shader_texture_lod: 1, EXT_shadow_samplers: 1, EXT_texture_compression_dxt1: 1, EXT_texture_filter_anisotropic: 1, EXT_texture_format_BGRA8888: 1, EXT_texture_rg: 1, EXT_texture_storage: 1, EXT_texture_type_2_10_10_10_REV: 1, EXT_unpack_subimage: 1, FALSE: 0, FASTEST: 4353, FENCE_CONDITION_NV: 34036, FENCE_STATUS_NV: 34035, FIXED: 5132, FJ_shader_binary_GCCSO: 1, FLOAT: 5126, FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, FRAGMENT_SHADER: 35632, FRAGMENT_SHADER_BIT_EXT: 2, FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723, FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT: 35410, FRAMEBUFFER: 36160, FRAMEBUFFER_ATTACHMENT_ANGLE: 37795, FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296, FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297, FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049, FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048, FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES: 36052, FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051, FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050, FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT: 36204, FRAMEBUFFER_BINDING: 36006, FRAMEBUFFER_COMPLETE: 36053, FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054, FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE: 36182, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE: 36182, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT: 36182, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG: 37172, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV: 36182, FRAMEBUFFER_UNDEFINED_OES: 33305, FRAMEBUFFER_UNSUPPORTED: 36061, FRONT: 1028, FRONT_AND_BACK: 1032, FRONT_FACE: 2886, FUNC_ADD: 32774, FUNC_REVERSE_SUBTRACT: 32779, FUNC_SUBTRACT: 32778, GENERATE_MIPMAP_HINT: 33170, GEQUAL: 518, GPU_OPTIMIZED_QCOM: 36786, GREATER: 516, GREEN_BITS: 3411, GUILTY_CONTEXT_RESET_EXT: 33363, HALF_FLOAT_OES: 36193, HIGH_FLOAT: 36338, HIGH_INT: 36341, IMG_multisampled_render_to_texture: 1, IMG_program_binary: 1, IMG_read_format: 1, IMG_shader_binary: 1, IMG_texture_compression_pvrtc: 1, IMG_texture_compression_pvrtc2: 1, IMPLEMENTATION_COLOR_READ_FORMAT: 35739, IMPLEMENTATION_COLOR_READ_TYPE: 35738, INCR: 7682, INCR_WRAP: 34055, INFO_LOG_LENGTH: 35716, INNOCENT_CONTEXT_RESET_EXT: 33364, INT: 5124, INT_10_10_10_2_OES: 36343, INT_VEC2: 35667, INT_VEC3: 35668, INT_VEC4: 35669, INVALID_ENUM: 1280, INVALID_FRAMEBUFFER_OPERATION: 1286, INVALID_OPERATION: 1282, INVALID_VALUE: 1281, INVERT: 5386, KEEP: 7680, KHR_debug: 1, KHR_texture_compression_astc_ldr: 1, LEFT: 1030, LEQUAL: 515, LESS: 513, LINEAR: 9729, LINEAR_MIPMAP_LINEAR: 9987, LINEAR_MIPMAP_NEAREST: 9985, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, LINE_WIDTH: 2849, LINK_STATUS: 35714, LOSE_CONTEXT_ON_RESET_EXT: 33362, LOW_FLOAT: 36336, LOW_INT: 36339, LUMINANCE: 6409, LUMINANCE16F_EXT: 34846, LUMINANCE32F_EXT: 34840, LUMINANCE4_ALPHA4_OES: 32835, LUMINANCE8_ALPHA8_EXT: 32837, LUMINANCE8_ALPHA8_OES: 32837, LUMINANCE8_EXT: 32832, LUMINANCE8_OES: 32832, LUMINANCE_ALPHA: 6410, LUMINANCE_ALPHA16F_EXT: 34847, LUMINANCE_ALPHA32F_EXT: 34841, MALI_PROGRAM_BINARY_ARM: 36705, MALI_SHADER_BINARY_ARM: 36704, MAP_FLUSH_EXPLICIT_BIT_EXT: 16, MAP_INVALIDATE_BUFFER_BIT_EXT: 8, MAP_INVALIDATE_RANGE_BIT_EXT: 4, MAP_READ_BIT_EXT: 1, MAP_UNSYNCHRONIZED_BIT_EXT: 32, MAP_WRITE_BIT_EXT: 2, MAX_3D_TEXTURE_SIZE_OES: 32883, MAX_COLOR_ATTACHMENTS_NV: 36063, MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661, MAX_CUBE_MAP_TEXTURE_SIZE: 34076, MAX_DEBUG_GROUP_STACK_DEPTH: 33388, MAX_DEBUG_LOGGED_MESSAGES: 37188, MAX_DEBUG_MESSAGE_LENGTH: 37187, MAX_DRAW_BUFFERS_NV: 34852, MAX_EXT: 32776, MAX_FRAGMENT_UNIFORM_VECTORS: 36349, MAX_LABEL_LENGTH: 33512, MAX_MULTIVIEW_BUFFERS_EXT: 37106, MAX_RENDERBUFFER_SIZE: 34024, MAX_SAMPLES_ANGLE: 36183, MAX_SAMPLES_APPLE: 36183, MAX_SAMPLES_EXT: 36183, MAX_SAMPLES_IMG: 37173, MAX_SAMPLES_NV: 36183, MAX_SERVER_WAIT_TIMEOUT_APPLE: 37137, MAX_TEXTURE_IMAGE_UNITS: 34930, MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047, MAX_TEXTURE_SIZE: 3379, MAX_VARYING_VECTORS: 36348, MAX_VERTEX_ATTRIBS: 34921, MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660, MAX_VERTEX_UNIFORM_VECTORS: 36347, MAX_VIEWPORT_DIMS: 3386, MEDIUM_FLOAT: 36337, MEDIUM_INT: 36340, MIN_EXT: 32775, MIRRORED_REPEAT: 33648, MULTISAMPLE_BUFFER_BIT0_QCOM: 16777216, MULTISAMPLE_BUFFER_BIT1_QCOM: 33554432, MULTISAMPLE_BUFFER_BIT2_QCOM: 67108864, MULTISAMPLE_BUFFER_BIT3_QCOM: 134217728, MULTISAMPLE_BUFFER_BIT4_QCOM: 268435456, MULTISAMPLE_BUFFER_BIT5_QCOM: 536870912, MULTISAMPLE_BUFFER_BIT6_QCOM: 1073741824, MULTISAMPLE_BUFFER_BIT7_QCOM: 2147483648, MULTIVIEW_EXT: 37105, NEAREST: 9728, NEAREST_MIPMAP_LINEAR: 9986, NEAREST_MIPMAP_NEAREST: 9984, NEVER: 512, NICEST: 4354, NONE: 0, NOTEQUAL: 517, NO_ERROR: 0, NO_RESET_NOTIFICATION_EXT: 33377, NUM_COMPRESSED_TEXTURE_FORMATS: 34466, NUM_PROGRAM_BINARY_FORMATS_OES: 34814, NUM_SHADER_BINARY_FORMATS: 36345, NV_coverage_sample: 1, NV_depth_nonlinear: 1, NV_draw_buffers: 1, NV_draw_instanced: 1, NV_fbo_color_attachments: 1, NV_fence: 1, NV_framebuffer_blit: 1, NV_framebuffer_multisample: 1, NV_generate_mipmap_sRGB: 1, NV_instanced_arrays: 1, NV_read_buffer: 1, NV_read_buffer_front: 1, NV_read_depth: 1, NV_read_depth_stencil: 1, NV_read_stencil: 1, NV_sRGB_formats: 1, NV_shadow_samplers_array: 1, NV_shadow_samplers_cube: 1, NV_texture_border_clamp: 1, NV_texture_compression_s3tc_update: 1, NV_texture_npot_2D_mipmap: 1, OBJECT_TYPE_APPLE: 37138, OES_EGL_image: 1, OES_EGL_image_external: 1, OES_compressed_ETC1_RGB8_texture: 1, OES_compressed_paletted_texture: 1, OES_depth24: 1, OES_depth32: 1, OES_depth_texture: 1, OES_element_index_uint: 1, OES_fbo_render_mipmap: 1, OES_fragment_precision_high: 1, OES_get_program_binary: 1, OES_mapbuffer: 1, OES_packed_depth_stencil: 1, OES_required_internalformat: 1, OES_rgb8_rgba8: 1, OES_standard_derivatives: 1, OES_stencil1: 1, OES_stencil4: 1, OES_surfaceless_context: 1, OES_texture_3D: 1, OES_texture_float: 1, OES_texture_float_linear: 1, OES_texture_half_float: 1, OES_texture_half_float_linear: 1, OES_texture_npot: 1, OES_vertex_array_object: 1, OES_vertex_half_float: 1, OES_vertex_type_10_10_10_2: 1, ONE: 1, ONE_MINUS_CONSTANT_ALPHA: 32772, ONE_MINUS_CONSTANT_COLOR: 32770, ONE_MINUS_DST_ALPHA: 773, ONE_MINUS_DST_COLOR: 775, ONE_MINUS_SRC_ALPHA: 771, ONE_MINUS_SRC_COLOR: 769, OUT_OF_MEMORY: 1285, PACK_ALIGNMENT: 3333, PACK_REVERSE_ROW_ORDER_ANGLE: 37796, PALETTE4_R5_G6_B5_OES: 35730, PALETTE4_RGB5_A1_OES: 35732, PALETTE4_RGB8_OES: 35728, PALETTE4_RGBA4_OES: 35731, PALETTE4_RGBA8_OES: 35729, PALETTE8_R5_G6_B5_OES: 35735, PALETTE8_RGB5_A1_OES: 35737, PALETTE8_RGB8_OES: 35733, PALETTE8_RGBA4_OES: 35736, PALETTE8_RGBA8_OES: 35734, PERCENTAGE_AMD: 35779, PERFMON_GLOBAL_MODE_QCOM: 36768, PERFMON_RESULT_AMD: 35782, PERFMON_RESULT_AVAILABLE_AMD: 35780, PERFMON_RESULT_SIZE_AMD: 35781, POINTS: 0, POLYGON_OFFSET_FACTOR: 32824, POLYGON_OFFSET_FILL: 32823, POLYGON_OFFSET_UNITS: 10752, PROGRAM: 33506, PROGRAM_BINARY_ANGLE: 37798, PROGRAM_BINARY_FORMATS_OES: 34815, PROGRAM_BINARY_LENGTH_OES: 34625, PROGRAM_OBJECT_EXT: 35648, PROGRAM_PIPELINE_BINDING_EXT: 33370, PROGRAM_PIPELINE_OBJECT_EXT: 35407, PROGRAM_SEPARABLE_EXT: 33368, QCOM_alpha_test: 1, QCOM_binning_control: 1, QCOM_driver_control: 1, QCOM_extended_get: 1, QCOM_extended_get2: 1, QCOM_perfmon_global_mode: 1, QCOM_tiled_rendering: 1, QCOM_writeonly_rendering: 1, QUERY: 33507, QUERY_OBJECT_EXT: 37203, QUERY_RESULT_AVAILABLE_EXT: 34919, QUERY_RESULT_EXT: 34918, R16F_EXT: 33325, R32F_EXT: 33326, R8_EXT: 33321, READ_BUFFER_EXT: 3074, READ_BUFFER_NV: 3074, READ_FRAMEBUFFER_ANGLE: 36008, READ_FRAMEBUFFER_APPLE: 36008, READ_FRAMEBUFFER_BINDING_ANGLE: 36010, READ_FRAMEBUFFER_BINDING_APPLE: 36010, READ_FRAMEBUFFER_BINDING_NV: 36010, READ_FRAMEBUFFER_NV: 36008, RED_BITS: 3410, RED_EXT: 6403, RENDERBUFFER: 36161, RENDERBUFFER_ALPHA_SIZE: 36179, RENDERBUFFER_BINDING: 36007, RENDERBUFFER_BLUE_SIZE: 36178, RENDERBUFFER_DEPTH_SIZE: 36180, RENDERBUFFER_GREEN_SIZE: 36177, RENDERBUFFER_HEIGHT: 36163, RENDERBUFFER_INTERNAL_FORMAT: 36164, RENDERBUFFER_RED_SIZE: 36176, RENDERBUFFER_SAMPLES_ANGLE: 36011, RENDERBUFFER_SAMPLES_APPLE: 36011, RENDERBUFFER_SAMPLES_EXT: 36011, RENDERBUFFER_SAMPLES_IMG: 37171, RENDERBUFFER_SAMPLES_NV: 36011, RENDERBUFFER_STENCIL_SIZE: 36181, RENDERBUFFER_WIDTH: 36162, RENDERER: 7937, RENDER_DIRECT_TO_FRAMEBUFFER_QCOM: 36787, REPEAT: 10497, REPLACE: 7681, REQUIRED_TEXTURE_IMAGE_UNITS_OES: 36200, RESET_NOTIFICATION_STRATEGY_EXT: 33366, RG16F_EXT: 33327, RG32F_EXT: 33328, RG8_EXT: 33323, RGB: 6407, RGB10_A2_EXT: 32857, RGB10_EXT: 32850, RGB16F_EXT: 34843, RGB32F_EXT: 34837, RGB565: 36194, RGB565_OES: 36194, RGB5_A1: 32855, RGB5_A1_OES: 32855, RGB8_OES: 32849, RGBA: 6408, RGBA16F_EXT: 34842, RGBA32F_EXT: 34836, RGBA4: 32854, RGBA4_OES: 32854, RGBA8_OES: 32856, RGB_422_APPLE: 35359, RG_EXT: 33319, RIGHT: 1031, SAMPLER: 33510, SAMPLER_2D: 35678, SAMPLER_2D_ARRAY_SHADOW_NV: 36292, SAMPLER_2D_SHADOW_EXT: 35682, SAMPLER_3D_OES: 35679, SAMPLER_CUBE: 35680, SAMPLER_CUBE_SHADOW_NV: 36293, SAMPLER_EXTERNAL_OES: 36198, SAMPLES: 32937, SAMPLE_ALPHA_TO_COVERAGE: 32926, SAMPLE_BUFFERS: 32936, SAMPLE_COVERAGE: 32928, SAMPLE_COVERAGE_INVERT: 32939, SAMPLE_COVERAGE_VALUE: 32938, SCISSOR_BOX: 3088, SCISSOR_TEST: 3089, SGX_BINARY_IMG: 35850, SGX_PROGRAM_BINARY_IMG: 37168, SHADER: 33505, SHADER_BINARY_DMP: 37456, SHADER_BINARY_FORMATS: 36344, SHADER_BINARY_VIV: 36804, SHADER_COMPILER: 36346, SHADER_OBJECT_EXT: 35656, SHADER_SOURCE_LENGTH: 35720, SHADER_TYPE: 35663, SHADING_LANGUAGE_VERSION: 35724, SHORT: 5122, SIGNALED_APPLE: 37145, SLUMINANCE8_ALPHA8_NV: 35909, SLUMINANCE8_NV: 35911, SLUMINANCE_ALPHA_NV: 35908, SLUMINANCE_NV: 35910, SRC_ALPHA: 770, SRC_ALPHA_SATURATE: 776, SRC_COLOR: 768, SRGB8_ALPHA8_EXT: 35907, SRGB8_NV: 35905, SRGB_ALPHA_EXT: 35906, SRGB_EXT: 35904, STACK_OVERFLOW: 1283, STACK_UNDERFLOW: 1284, STATE_RESTORE: 35804, STATIC_DRAW: 35044, STENCIL_ATTACHMENT: 36128, STENCIL_BACK_FAIL: 34817, STENCIL_BACK_FUNC: 34816, STENCIL_BACK_PASS_DEPTH_FAIL: 34818, STENCIL_BACK_PASS_DEPTH_PASS: 34819, STENCIL_BACK_REF: 36003, STENCIL_BACK_VALUE_MASK: 36004, STENCIL_BACK_WRITEMASK: 36005, STENCIL_BITS: 3415, STENCIL_BUFFER_BIT: 1024, STENCIL_BUFFER_BIT0_QCOM: 65536, STENCIL_BUFFER_BIT1_QCOM: 131072, STENCIL_BUFFER_BIT2_QCOM: 262144, STENCIL_BUFFER_BIT3_QCOM: 524288, STENCIL_BUFFER_BIT4_QCOM: 1048576, STENCIL_BUFFER_BIT5_QCOM: 2097152, STENCIL_BUFFER_BIT6_QCOM: 4194304, STENCIL_BUFFER_BIT7_QCOM: 8388608, STENCIL_CLEAR_VALUE: 2961, STENCIL_EXT: 6146, STENCIL_FAIL: 2964, STENCIL_FUNC: 2962, STENCIL_INDEX1_OES: 36166, STENCIL_INDEX4_OES: 36167, STENCIL_INDEX: 6401, STENCIL_INDEX8: 36168, STENCIL_PASS_DEPTH_FAIL: 2965, STENCIL_PASS_DEPTH_PASS: 2966, STENCIL_REF: 2967, STENCIL_TEST: 2960, STENCIL_VALUE_MASK: 2963, STENCIL_WRITEMASK: 2968, STREAM_DRAW: 35040, SUBPIXEL_BITS: 3408, SYNC_CONDITION_APPLE: 37139, SYNC_FENCE_APPLE: 37142, SYNC_FLAGS_APPLE: 37141, SYNC_FLUSH_COMMANDS_BIT_APPLE: 1, SYNC_GPU_COMMANDS_COMPLETE_APPLE: 37143, SYNC_OBJECT_APPLE: 35411, SYNC_STATUS_APPLE: 37140, TEXTURE: 5890, TEXTURE0: 33984, TEXTURE1: 33985, TEXTURE10: 33994, TEXTURE11: 33995, TEXTURE12: 33996, TEXTURE13: 33997, TEXTURE14: 33998, TEXTURE15: 33999, TEXTURE16: 34e3, TEXTURE17: 34001, TEXTURE18: 34002, TEXTURE19: 34003, TEXTURE2: 33986, TEXTURE20: 34004, TEXTURE21: 34005, TEXTURE22: 34006, TEXTURE23: 34007, TEXTURE24: 34008, TEXTURE25: 34009, TEXTURE26: 34010, TEXTURE27: 34011, TEXTURE28: 34012, TEXTURE29: 34013, TEXTURE3: 33987, TEXTURE30: 34014, TEXTURE31: 34015, TEXTURE4: 33988, TEXTURE5: 33989, TEXTURE6: 33990, TEXTURE7: 33991, TEXTURE8: 33992, TEXTURE9: 33993, TEXTURE_2D: 3553, TEXTURE_3D_OES: 32879, TEXTURE_BINDING_2D: 32873, TEXTURE_BINDING_3D_OES: 32874, TEXTURE_BINDING_CUBE_MAP: 34068, TEXTURE_BINDING_EXTERNAL_OES: 36199, TEXTURE_BORDER_COLOR_NV: 4100, TEXTURE_COMPARE_FUNC_EXT: 34893, TEXTURE_COMPARE_MODE_EXT: 34892, TEXTURE_CUBE_MAP: 34067, TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074, TEXTURE_CUBE_MAP_POSITIVE_X: 34069, TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, TEXTURE_DEPTH_QCOM: 35796, TEXTURE_EXTERNAL_OES: 36197, TEXTURE_FORMAT_QCOM: 35798, TEXTURE_HEIGHT_QCOM: 35795, TEXTURE_IMAGE_VALID_QCOM: 35800, TEXTURE_IMMUTABLE_FORMAT_EXT: 37167, TEXTURE_INTERNAL_FORMAT_QCOM: 35797, TEXTURE_MAG_FILTER: 10240, TEXTURE_MAX_ANISOTROPY_EXT: 34046, TEXTURE_MAX_LEVEL_APPLE: 33085, TEXTURE_MIN_FILTER: 10241, TEXTURE_NUM_LEVELS_QCOM: 35801, TEXTURE_OBJECT_VALID_QCOM: 35803, TEXTURE_SAMPLES_IMG: 37174, TEXTURE_TARGET_QCOM: 35802, TEXTURE_TYPE_QCOM: 35799, TEXTURE_USAGE_ANGLE: 37794, TEXTURE_WIDTH_QCOM: 35794, TEXTURE_WRAP_R_OES: 32882, TEXTURE_WRAP_S: 10242, TEXTURE_WRAP_T: 10243, TIMEOUT_EXPIRED_APPLE: 37147, TIMEOUT_IGNORED_APPLE: 0x10000000000000000, TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE: 37792, TRIANGLES: 4, TRIANGLE_FAN: 6, TRIANGLE_STRIP: 5, TRUE: 1, UNKNOWN_CONTEXT_RESET_EXT: 33365, UNPACK_ALIGNMENT: 3317, UNPACK_ROW_LENGTH: 3314, UNPACK_SKIP_PIXELS: 3316, UNPACK_SKIP_ROWS: 3315, UNSIGNALED_APPLE: 37144, UNSIGNED_BYTE: 5121, UNSIGNED_INT: 5125, UNSIGNED_INT64_AMD: 35778, UNSIGNED_INT_10_10_10_2_OES: 36342, UNSIGNED_INT_24_8_OES: 34042, UNSIGNED_INT_2_10_10_10_REV_EXT: 33640, UNSIGNED_NORMALIZED_EXT: 35863, UNSIGNED_SHORT: 5123, UNSIGNED_SHORT_1_5_5_5_REV_EXT: 33638, UNSIGNED_SHORT_4_4_4_4: 32819, UNSIGNED_SHORT_4_4_4_4_REV_EXT: 33637, UNSIGNED_SHORT_4_4_4_4_REV_IMG: 33637, UNSIGNED_SHORT_5_5_5_1: 32820, UNSIGNED_SHORT_5_6_5: 33635, UNSIGNED_SHORT_8_8_APPLE: 34234, UNSIGNED_SHORT_8_8_REV_APPLE: 34235, VALIDATE_STATUS: 35715, VENDOR: 7936, VERSION: 7938, VERTEX_ARRAY_BINDING_OES: 34229, VERTEX_ARRAY_OBJECT_EXT: 37204, VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975, VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070, VERTEX_ATTRIB_ARRAY_DIVISOR_NV: 35070, VERTEX_ATTRIB_ARRAY_ENABLED: 34338, VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922, VERTEX_ATTRIB_ARRAY_POINTER: 34373, VERTEX_ATTRIB_ARRAY_SIZE: 34339, VERTEX_ATTRIB_ARRAY_STRIDE: 34340, VERTEX_ATTRIB_ARRAY_TYPE: 34341, VERTEX_SHADER: 35633, VERTEX_SHADER_BIT_EXT: 1, VIEWPORT: 2978, VIV_shader_binary: 1, WAIT_FAILED_APPLE: 37149, WRITEONLY_RENDERING_QCOM: 34851, WRITE_ONLY_OES: 35001, Z400_BINARY_AMD: 34624, ZERO: 0, RASTERIZER_DISCARD: 35977, UNPACK_FLIP_Y_WEBGL: 37440, UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441, CONTEXT_LOST_WEBGL: 37442, UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443, BROWSER_DEFAULT_WEBGL: 37444 }, WebGL2RenderingContext: {}, addEventListener: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; Li.addEventListener(t, e, n) }, removeEventListener: function (t, e, n) { Li.removeEventListener(t, e) }, dispatchEvent: function (t) { Li.dispatchEvent(t) }, innerWidth: li.availWidth, innerHeight: li.availHeight, setTimeout: setTimeout, clearTimeout: clearTimeout, setInterval: setInterval, clearInterval: clearInterval }, oo = ro ? io : zr, ao = ro ? Qi : zr.XMLHttpRequest; function so(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function lo(t, e, n) { var r = oo.document.createElement(t); return r.className = e || "", n && n.appendChild(r), r } function uo(t) { var e = t.parentNode; e && e.removeChild(t) } function co(t, e) { if (void 0 !== t.classList) for (var n = function (t) { return so(t).split(/\s+/) }(e), r = 0, i = n.length; r < i; r++)t.classList.add(n[r]); else if (!function (t, e) { if (void 0 !== t.classList) return t.classList.contains(e); var n = fo(t); return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n) }(t, e)) { var o = fo(t); ho(t, (o ? o + " " : "") + e) } } function po(t, e) { void 0 !== t.classList ? t.classList.remove(e) : ho(t, so((" " + fo(t) + " ").replace(" " + e + " ", " "))) } function ho(t, e) { t instanceof HTMLElement ? t.className = e : t.className.baseVal = e } function fo(t) { return t instanceof SVGElement && (t = t.correspondingElement), void 0 === t.className.baseVal ? t.className : t.className.baseVal } function mo(t) { for (; t && t.firstChild;)t.removeChild(t.firstChild) } ro || zr.location; var vo = function (t) { var e, n, r = null == oo || null === (e = oo.document) || void 0 === e || null === (n = e.documentElement) || void 0 === n ? void 0 : n.style; if (!r) return t[0]; for (var i in t) if (t[i] && t[i] in r) return t[i]; return t[0] }(["transform", "WebkitTransform"]); function yo(t, e) { t.style[vo] = e } var go = function () { var t, e = oo.document.querySelector('meta[name="viewport"]'); if (!e) return 1; var n = (null === (t = e.content) || void 0 === t ? void 0 : t.split(",")).find((function (t) { var e = Lr(t.split("="), 2), n = e[0]; return e[1], "initial-scale" === n })); return n ? 1 * n.split("=")[1] : 1 }() < 1 ? 1 : oo.devicePixelRatio; function _o() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } } function xo(t, e, n) { return xo = _o() ? Reflect.construct : function (t, e, n) { var r = [null]; r.push.apply(r, e); var i = new (Function.bind.apply(t, r)); return n && jr(i, n.prototype), i }, xo.apply(null, arguments) } function bo(t) { var e = "function" == typeof Map ? new Map : void 0; return bo = function (t) { if (null === t || (n = t, -1 === Function.toString.call(n).indexOf("[native code]"))) return t; var n; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== e) { if (e.has(t)) return e.get(t); e.set(t, r) } function r() { return xo(t, arguments, Wr(this).constructor) } return r.prototype = Object.create(t.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), jr(r, t) }, bo(t) } function wo(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var So = function (t) { Ur(n, t); var e = wo(n); function n(t, r, i) { var o; return Ar(this, n), kr(Gr(o = e.call(this, t)), "status", void 0), kr(Gr(o), "url", void 0), o.status = r, o.url = i, o.name = o.constructor.name, o.message = t, o } return Or(n, [{ key: "toString", value: function () { return "".concat(this.name, ": ").concat(this.message, " (").concat(this.status, "): ").concat(this.url) } }]), n }(bo(Error)); var Eo = function (t, e) { var n = function (t) { var e = new ao; for (var n in e.open("GET", t.url, !0), t.headers) t.headers.hasOwnProperty(n) && e.setRequestHeader(n, t.headers[n]); return e.withCredentials = "include" === t.credentials, e }(t); return n.responseType = "arraybuffer", n.onerror = function () { e(new Error(n.statusText)) }, n.onload = function () { var r = n.response; if (0 === r.byteLength && 200 === n.status) return e(new Error("http status 200 returned without content.")); n.status >= 200 && n.status < 300 && n.response ? e(null, { data: r, cacheControl: n.getResponseHeader("Cache-Control"), expires: n.getResponseHeader("Expires") }) : e(new So(n.statusText, n.status, t.url)) }, n.send(), n }, Co = function (t, e) { return Eo(t, (function (t, n) { if (t) e(t); else if (n) { var r = new oo.Image; r.crossOrigin = "anonymous"; var i = oo.URL || oo.webkitURL; r.onload = function () { e(null, r), i.revokeObjectURL(r.src) }; var o = new oo.Blob([new Uint8Array(n.data)], { type: "image/png" }); r.src = n.data.byteLength ? i.createObjectURL(o) : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=" } })) }, To = 6371008.8, Ao = { centimeters: 637100880, centimetres: 637100880, degrees: 57.22891354143274, feet: 20902260.511392, inches: 39.37 * To, kilometers: 6371.0088, kilometres: 6371.0088, meters: To, metres: To, miles: 3958.761333810546, millimeters: 6371008800, millimetres: 6371008800, nauticalmiles: To / 1852, radians: 1, yards: 6967335.223679999 }; function Mo(t, e, n) { void 0 === n && (n = {}); var r = { type: "Feature" }; return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r } function Oo(t) { return t % 360 * Math.PI / 180 } var ko = 2 * Math.PI * 6378137 / 2; function Io(t) { var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return t.forEach((function (t) { var n = t.coordinates; Po(e, n) })), e } function Po(t, e) { return Array.isArray(e[0]) ? e.forEach((function (e) { Po(t, e) })) : (t[0] > e[0] && (t[0] = e[0]), t[1] > e[1] && (t[1] = e[1]), t[2] < e[0] && (t[2] = e[0]), t[3] < e[1] && (t[3] = e[1])), t } function Lo(t) { var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { enable: !0, decimal: 1 }, r = (t = Ro(t, e))[0], i = t[1], o = r * ko / 180, a = Math.log(Math.tan((90 + i) * Math.PI / 360)) / (Math.PI / 180); return a = a * ko / 180, n.enable && (o = Number(o.toFixed(n.decimal)), a = Number(a.toFixed(n.decimal))), 3 === t.length ? [o, a, t[2]] : [o, a] } function Ro(t, e) { if (!1 === e) return t; var n = function (t) { if (null == t) throw new Error("lng is required"); return (t > 180 || t < -180) && ((t %= 360) > 180 && (t = -360 + t), t < -180 && (t = 360 + t), 0 === t && (t = 0)), t }(t[0]), r = function (t) { if (null == t) throw new Error("lat is required"); return (t > 90 || t < -90) && ((t %= 180) > 90 && (t = -180 + t), t < -90 && (t = 180 + t), 0 === t && (t = 0)), t }(t[1]); return r > 85 && (r = 85), r < -85 && (r = -85), 3 === t.length ? [n, r, t[2]] : [n, r] } function Do(t) { var e = 85.0511287798, n = Math.max(Math.min(e, t[1]), -e), r = 256 << 20, i = Math.PI / 180, o = t[0] * i, a = n * i; a = Math.log(Math.tan(Math.PI / 4 + a / 2)); return o = r * (.5 / Math.PI * o + .5), a = r * (-.5 / Math.PI * a + (i = .5)), [Math.floor(o), Math.floor(a)] } function No(t, e, n) { var r = Oo(e[1] - t[1]), i = Oo(e[0] - t[0]), o = Oo(t[1]), a = Oo(e[1]), s = Math.pow(Math.sin(r / 2), 2) + Math.pow(Math.sin(i / 2), 2) * Math.cos(o) * Math.cos(a); return function (t, e) { void 0 === e && (e = "kilometers"); var n = Ao[e]; if (!n) throw new Error(e + " units is invalid"); return t * n }(2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)), "meters") } function zo(t, e) { var n = Math.abs(t[1][1] - t[0][1]) * e, r = Math.abs(t[1][0] - t[0][0]) * e; return [[t[0][0] - r, t[0][1] - n], [t[1][0] + r, t[1][1] + n]] } function Fo(t, e) { return t[0][0] <= e[0][0] && t[0][1] <= e[0][1] && t[1][0] >= e[1][0] && t[1][1] >= e[1][1] } function Bo(t) { var e, n, r = (e = t, n = [0, 0], Math.sqrt(Math.pow(e[0] - n[0], 2) + Math.pow(e[1] - n[1], 2))); return [t[0] / r, t[1] / r] } var jo = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50, n = arguments.length > 1 ? arguments[1] : void 0; Ar(this, t), kr(this, "limit", void 0), kr(this, "cache", void 0), kr(this, "destroy", void 0), kr(this, "order", void 0), this.limit = e, this.destroy = n || this.defaultDestroy, this.order = [], this.clear() } return Or(t, [{ key: "clear", value: function () { var t = this; this.order.forEach((function (e) { t.delete(e) })), this.cache = {}, this.order = [] } }, { key: "get", value: function (t) { var e = this.cache[t]; return e && (this.deleteOrder(t), this.appendOrder(t)), e } }, { key: "set", value: function (t, e) { this.cache[t] ? (this.delete(t), this.cache[t] = e, this.appendOrder(t)) : (Object.keys(this.cache).length === this.limit && this.delete(this.order[0]), this.cache[t] = e, this.appendOrder(t)) } }, { key: "delete", value: function (t) { var e = this.cache[t]; e && (this.deleteCache(t), this.deleteOrder(t), this.destroy(e, t)) } }, { key: "deleteCache", value: function (t) { delete this.cache[t] } }, { key: "deleteOrder", value: function (t) { var e = this.order.findIndex((function (e) { return e === t })); e >= 0 && this.order.splice(e, 1) } }, { key: "appendOrder", value: function (t) { this.order.push(t) } }, { key: "defaultDestroy", value: function (t, e) { return null } }]), t }(); function Uo(t, e) { t.forEach((function (t) { e[t] && (e[t] = e[t].bind(e)) })) } function Vo(t, e, n) { t.prototype = e.prototype = n, n.constructor = t } function Go(t, e) { var n = Object.create(t.prototype); for (var r in e) n[r] = e[r]; return n } function Ho() { } !function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16; Ar(this, t), kr(this, "duration", 16), kr(this, "timestamp", (new Date).getTime()), this.duration = e } Or(t, [{ key: "run", value: function (t) { var e = (new Date).getTime(), n = e - this.timestamp; this.timestamp = e, n >= this.duration && t() } }]) }(); var Wo, Xo = .7, qo = 1 / Xo, Zo = "\\s*([+-]?\\d+)\\s*", Yo = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ko = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Qo = /^#([0-9a-f]{3,8})$/, Jo = new RegExp("^rgb\\(" + [Zo, Zo, Zo] + "\\)$"), $o = new RegExp("^rgb\\(" + [Ko, Ko, Ko] + "\\)$"), ta = new RegExp("^rgba\\(" + [Zo, Zo, Zo, Yo] + "\\)$"), ea = new RegExp("^rgba\\(" + [Ko, Ko, Ko, Yo] + "\\)$"), na = new RegExp("^hsl\\(" + [Yo, Ko, Ko] + "\\)$"), ra = new RegExp("^hsla\\(" + [Yo, Ko, Ko, Yo] + "\\)$"), ia = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; function oa() { return this.rgb().formatHex() } function aa() { return this.rgb().formatRgb() } function sa(t) { var e, n; return t = (t + "").trim().toLowerCase(), (e = Qo.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), 6 === n ? la(e) : 3 === n ? new ha(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, (15 & e) << 4 | 15 & e, 1) : 8 === n ? ua(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (255 & e) / 255) : 4 === n ? ua(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, ((15 & e) << 4 | 15 & e) / 255) : null) : (e = Jo.exec(t)) ? new ha(e[1], e[2], e[3], 1) : (e = $o.exec(t)) ? new ha(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, 1) : (e = ta.exec(t)) ? ua(e[1], e[2], e[3], e[4]) : (e = ea.exec(t)) ? ua(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, e[4]) : (e = na.exec(t)) ? va(e[1], e[2] / 100, e[3] / 100, 1) : (e = ra.exec(t)) ? va(e[1], e[2] / 100, e[3] / 100, e[4]) : ia.hasOwnProperty(t) ? la(ia[t]) : "transparent" === t ? new ha(NaN, NaN, NaN, 0) : null } function la(t) { return new ha(t >> 16 & 255, t >> 8 & 255, 255 & t, 1) } function ua(t, e, n, r) { return r <= 0 && (t = e = n = NaN), new ha(t, e, n, r) } function ca(t) { return t instanceof Ho || (t = sa(t)), t ? new ha((t = t.rgb()).r, t.g, t.b, t.opacity) : new ha } function pa(t, e, n, r) { return 1 === arguments.length ? ca(t) : new ha(t, e, n, null == r ? 1 : r) } function ha(t, e, n, r) { this.r = +t, this.g = +e, this.b = +n, this.opacity = +r } function fa() { return "#" + ma(this.r) + ma(this.g) + ma(this.b) } function da() { var t = this.opacity; return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")") } function ma(t) { return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? "0" : "") + t.toString(16) } function va(t, e, n, r) { return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new ga(t, e, n, r) } function ya(t) { if (t instanceof ga) return new ga(t.h, t.s, t.l, t.opacity); if (t instanceof Ho || (t = sa(t)), !t) return new ga; if (t instanceof ga) return t; var e = (t = t.rgb()).r / 255, n = t.g / 255, r = t.b / 255, i = Math.min(e, n, r), o = Math.max(e, n, r), a = NaN, s = o - i, l = (o + i) / 2; return s ? (a = e === o ? (n - r) / s + 6 * (n < r) : n === o ? (r - e) / s + 2 : (e - n) / s + 4, s /= l < .5 ? o + i : 2 - o - i, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new ga(a, s, l, t.opacity) } function ga(t, e, n, r) { this.h = +t, this.s = +e, this.l = +n, this.opacity = +r } function _a(t, e, n) { return 255 * (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) } function xa(t) { var e = sa(t), n = [0, 0, 0, 0]; return null != e && (n[0] = e.r / 255, n[1] = e.g / 255, n[2] = e.b / 255, n[3] = e.opacity), n } function ba(t) { return (t && t[0]) + 256 * (t && t[1]) + 65536 * (t && t[2]) - 1 } function wa(t) { return [t + 1 & 255, t + 1 >> 8 & 255, t + 1 >> 8 >> 8 & 255] } Vo(Ho, sa, { copy: function (t) { return Object.assign(new this.constructor, this, t) }, displayable: function () { return this.rgb().displayable() }, hex: oa, formatHex: oa, formatHsl: function () { return ya(this).formatHsl() }, formatRgb: aa, toString: aa }), Vo(ha, pa, Go(Ho, { brighter: function (t) { return t = null == t ? qo : Math.pow(qo, t), new ha(this.r * t, this.g * t, this.b * t, this.opacity) }, darker: function (t) { return t = null == t ? Xo : Math.pow(Xo, t), new ha(this.r * t, this.g * t, this.b * t, this.opacity) }, rgb: function () { return this }, displayable: function () { return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1 }, hex: fa, formatHex: fa, formatRgb: da, toString: da })), Vo(ga, (function (t, e, n, r) { return 1 === arguments.length ? ya(t) : new ga(t, e, n, null == r ? 1 : r) }), Go(Ho, { brighter: function (t) { return t = null == t ? qo : Math.pow(qo, t), new ga(this.h, this.s, this.l * t, this.opacity) }, darker: function (t) { return t = null == t ? Xo : Math.pow(Xo, t), new ga(this.h, this.s, this.l * t, this.opacity) }, rgb: function () { var t = this.h % 360 + 360 * (this.h < 0), e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < .5 ? n : 1 - n) * e, i = 2 * n - r; return new ha(_a(t >= 240 ? t - 240 : t + 120, i, r), _a(t, i, r), _a(t < 120 ? t + 240 : t - 120, i, r), this.opacity) }, displayable: function () { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 }, formatHsl: function () { var t = this.opacity; return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "hsl(" : "hsla(") + (this.h || 0) + ", " + 100 * (this.s || 0) + "%, " + 100 * (this.l || 0) + "%" + (1 === t ? ")" : ", " + t + ")") } })), t.TooltipAnchorType = void 0, (Wo = t.TooltipAnchorType || (t.TooltipAnchorType = {})).CENTER = "center", Wo.TOP = "top", Wo["TOP-LEFT"] = "top-left", Wo["TOP-RIGHT"] = "top-right", Wo.BOTTOM = "bottom", Wo["BOTTOM-LEFT"] = "bottom-left", Wo.LEFT = "left", Wo.RIGHT = "right"; var Sa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Ea(t, e, n) { var r = t.classList; for (var i in Sa) Sa.hasOwnProperty(i) && r.remove("l7-".concat(n, "-anchor-").concat(i)); r.add("l7-".concat(n, "-anchor-").concat(e)) } function Ca(t, e) { return { enable: t, mask: 255, func: { cmp: 514, ref: e ? 1 : 0, mask: 255 } } } var Ta = 1029, Aa = 1028; function Ma(t) { switch (t) { case "GAODE1.x": case "GAODE2.x": case "GLOBEL": return Ta; default: return Aa } } function Oa(t) { if (0 === t.length) return 0; for (var e = 1 * t[0], n = 1; n < t.length; n++)e += 1 * t[n]; return e } var ka = { min: function (t) { if (0 === t.length) throw new Error("min requires at least one data point"); for (var e = t[0], n = 1; n < t.length; n++)t[n] < e && (e = t[n]); return 1 * e }, max: function (t) { if (0 === t.length) throw new Error("max requires at least one data point"); for (var e = t[0], n = 1; n < t.length; n++)t[n] > e && (e = t[n]); return 1 * e }, mean: function (t) { if (0 === t.length) throw new Error("mean requires at least one data point"); return Oa(t) / t.length }, sum: Oa, mode: function (t) { if (0 === t.length) throw new Error("mean requires at least one data point"); if (t.length < 3) return t[0]; t.sort(); for (var e = t[0], n = NaN, r = 0, i = 1, o = 1; o < t.length + 1; o++)t[o] !== e ? (i > r && (r = i, n = e), i = 1, e = t[o]) : i++; return 1 * n } }; function Ia(t, e) { return t.map((function (t) { return t[e] })) } var Pa = { exports: {} }; Pa.exports = Ra, Pa.exports.default = Ra; var La = 1e20; function Ra(t, e, n, r, i, o) { this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = r || .25, this.fontFamily = i || "sans-serif", this.fontWeight = o || "normal", this.radius = n || 8; var a = this.size = this.fontSize + 2 * this.buffer, s = a + 2 * this.buffer, l = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM; l ? this.canvas = my.createOffscreenCanvas(a, a, "2d") : (this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = a), this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textAlign = "left", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(s * s), this.gridInner = new Float64Array(s * s), this.f = new Float64Array(s), this.z = new Float64Array(s + 1), this.v = new Uint16Array(s), this.useMetrics = void 0 !== this.ctx.measureText("A").actualBoundingBoxLeft, this.middle = l ? Math.round(a / 2 * 1) : Math.round(a / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)) } function Da(t, e, n, r, i, o) { for (var a = 0; a < e; a++)Na(t, a, e, n, r, i, o); for (var s = 0; s < n; s++)Na(t, s * e, 1, e, r, i, o) } function Na(t, e, n, r, i, o, a) { var s, l, u, c; for (o[0] = 0, a[0] = -La, a[1] = La, s = 0; s < r; s++)i[s] = t[e + s * n]; for (s = 1, l = 0, u = 0; s < r; s++) { do { c = o[l], u = (i[s] - i[c] + s * s - c * c) / (s - c) / 2 } while (u <= a[l] && --l > -1); o[++l] = s, a[l] = u, a[l + 1] = La } for (s = 0, l = 0; s < r; s++) { for (; a[l + 1] < s;)l++; c = o[l], t[e + s * n] = i[c] + (s - c) * (s - c) } } Ra.prototype._draw = function (t, e) { var n, r, i, o, a, s, l, u, c, p = this.ctx.measureText(t), h = p.width, f = 2 * this.buffer; e && this.useMetrics ? (a = Math.floor(p.actualBoundingBoxAscent), u = this.buffer + Math.ceil(p.actualBoundingBoxAscent), s = this.buffer, l = this.buffer, n = (r = Math.min(this.size, Math.ceil(p.actualBoundingBoxRight - p.actualBoundingBoxLeft))) + f, i = (o = Math.min(this.size - s, Math.ceil(p.actualBoundingBoxAscent + p.actualBoundingBoxDescent))) + f, this.ctx.textBaseline = "alphabetic") : (n = r = this.size, i = o = this.size, a = 19 * this.fontSize / 24, s = l = 0, u = this.middle, this.ctx.textBaseline = "middle"), r && o && (this.ctx.clearRect(l, s, r, o), this.ctx.fillText(t, this.buffer, u), c = this.ctx.getImageData(l, s, r, o)); var d = new Uint8ClampedArray(n * i); return function (t, e, n, r, i, o, a) { o.fill(La, 0, e * n), a.fill(0, 0, e * n); for (var s = (e - r) / 2, l = 0; l < i; l++)for (var u = 0; u < r; u++) { var c = (l + s) * e + u + s, p = t.data[4 * (l * r + u) + 3] / 255; if (1 === p) o[c] = 0, a[c] = La; else if (0 === p) o[c] = La, a[c] = 0; else { var h = Math.max(0, .5 - p), f = Math.max(0, p - .5); o[c] = h * h, a[c] = f * f } } }(c, n, i, r, o, this.gridOuter, this.gridInner), Da(this.gridOuter, n, i, this.f, this.v, this.z), Da(this.gridInner, n, i, this.f, this.v, this.z), function (t, e, n, r, i, o, a) { for (var s = 0; s < e * n; s++) { var l = Math.sqrt(r[s]) - Math.sqrt(i[s]); t[s] = Math.round(255 - 255 * (l / o + a)) } }(d, n, i, this.gridOuter, this.gridInner, this.radius, this.cutoff), { data: d, metrics: { width: r, height: o, sdfWidth: n, sdfHeight: i, top: a, left: 0, advance: h } } }, Ra.prototype.draw = function (t) { return this._draw(t, !1).data }, Ra.prototype.drawWithMetrics = function (t) { return this._draw(t, !0) }; var za = Pa.exports; function Fa(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Ba(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Fa(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Fa(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function ja(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Ua(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ua(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Ua(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var Va; function Ga(t, e, n) { var r, i = ja(e); try { for (i.s(); !(r = i.n()).done;) { var o = r.value, a = o.icon, s = o.xOffset; t[a.id] = Ba(Ba({}, a), {}, { x: s, y: n, image: a.image, width: a.width, height: a.height }) } } catch (t) { i.e(t) } finally { i.f() } } function Ha(t) { return Math.pow(2, Math.ceil(Math.log2(t))) } function Wa(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Xa(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Xa(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Xa(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function qa(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Za(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? qa(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : qa(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var Ya = function () { for (var t = [], e = 32; e < 128; e++)t.push(String.fromCharCode(e)); return t }(); function Ka(t, e, n, r) { t.font = "".concat(r, " ").concat(n, "px ").concat(e), t.fillStyle = "black", t.textBaseline = "middle" } function Qa(t, e) { for (var n = 0; n < t.length; n++)e.data[4 * n + 3] = t[n] } var Ja, $a = ut.injectable()(Va = function () { function t() { Ar(this, t), kr(this, "fontAtlas", void 0), kr(this, "iconFontMap", void 0), kr(this, "iconFontGlyphs", {}), kr(this, "fontOptions", void 0), kr(this, "key", void 0), kr(this, "cache", new jo(3)) } return Or(t, [{ key: "scale", get: function () { return 1 } }, { key: "canvas", get: function () { var t = this.cache.get(this.key); return t && t.data } }, { key: "mapping", get: function () { var t = this.cache.get(this.key); return t && t.mapping } }, { key: "init", value: function () { this.cache.clear(), this.fontOptions = { fontFamily: "sans-serif", fontWeight: "normal", characterSet: Ya, fontSize: 24, buffer: 3, sdf: !0, cutoff: .25, radius: 8, iconfont: !1 }, this.key = "", this.iconFontMap = new Map } }, { key: "addIconGlyphs", value: function (t) { var e = this; t.forEach((function (t) { e.iconFontGlyphs[t.name] = t.unicode })) } }, { key: "addIconFont", value: function (t, e) { this.iconFontMap.set(t, e) } }, { key: "getIconFontKey", value: function (t) { return this.iconFontMap.get(t) || t } }, { key: "getGlyph", value: function (t) { return this.iconFontGlyphs[t] ? String.fromCharCode(parseInt(this.iconFontGlyphs[t], 16)) : "" } }, { key: "setFontOptions", value: function (t) { this.fontOptions = Za(Za({}, this.fontOptions), t), this.key = this.getKey(); var e = this.getNewChars(this.key, this.fontOptions.characterSet), n = this.cache.get(this.key); if (!n || 0 !== e.length) { var r = this.generateFontAtlas(this.key, e, n); this.fontAtlas = r, this.cache.set(this.key, r) } } }, { key: "destroy", value: function () { this.cache.clear(), this.iconFontMap.clear() } }, { key: "generateFontAtlas", value: function (t, e, n) { var r = this.fontOptions, i = r.fontFamily, o = r.fontWeight, a = r.fontSize, s = r.buffer, l = r.sdf, u = r.radius, c = r.cutoff, p = r.iconfont, h = n && n.data; h || ((h = oo.document.createElement("canvas")).width = 1024); var f = h.getContext("2d"); Ka(f, i, a, o); var d = function (t) { var e = t.characterSet, n = t.getFontWidth, r = t.fontHeight, i = t.buffer, o = t.maxCanvasWidth, a = t.mapping, s = void 0 === a ? {} : a, l = t.xOffset, u = void 0 === l ? 0 : l, c = t.yOffset, p = void 0 === c ? 0 : c, h = 0, f = u; Array.from(e).forEach((function (t, e) { if (!s[t]) { var r = n(t, e); f + 30 > o && (f = 0, h++), s[t] = { x: f, y: p + 30 * h, width: 30, height: 30, advance: r }, f += 30 } })); var d = r + 2 * i; return { mapping: s, xOffset: f, yOffset: p + h * d, canvasHeight: Ha(p + (h + 1) * d) } }(Za({ getFontWidth: function (t) { return f.measureText(t).width }, fontHeight: 1 * a, buffer: s, characterSet: e, maxCanvasWidth: 1024 }, n && { mapping: n.mapping, xOffset: n.xOffset, yOffset: n.yOffset })), m = d.mapping, v = d.canvasHeight, y = d.xOffset, g = d.yOffset, _ = f.getImageData(0, 0, h.width, h.height); if (h.height = v, f.putImageData(_, 0, 0), Ka(f, i, a, o), l) { var x, b = new za(a, s, u, c, i, o), w = f.getImageData(0, 0, b.size, b.size), S = Wa(e); try { for (S.s(); !(x = S.n()).done;) { var E = x.value; if (p) { var C = String.fromCharCode(parseInt(E.replace("&#x", "").replace(";", ""), 16)); Qa(b.draw(C), w) } else Qa(b.draw(E), w); f.putImageData(w, m[E].x, m[E].y) } } catch (t) { S.e(t) } finally { S.f() } } else { var T, A = Wa(e); try { for (A.s(); !(T = A.n()).done;) { var M = T.value; f.fillText(M, m[M].x, m[M].y + 1 * a) } } catch (t) { A.e(t) } finally { A.f() } } return { xOffset: y, yOffset: g, mapping: m, data: h, width: h.width, height: h.height } } }, { key: "getKey", value: function () { return "key" } }, { key: "getNewChars", value: function (t, e) { var n = this.cache.get(t); if (!n) return e; var r = [], i = n.mapping, o = new Set(Object.keys(i)); return new Set(e).forEach((function (t) { o.has(t) || r.push(t) })), r } }]), t }()) || Va; function ts(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var es = ut.injectable()(Ja = function (t) { Ur(n, t); var e = ts(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "canvasHeight", 128), kr(Gr(t), "texture", void 0), kr(Gr(t), "canvas", void 0), kr(Gr(t), "iconData", void 0), kr(Gr(t), "iconMap", void 0), kr(Gr(t), "ctx", void 0), kr(Gr(t), "loadingImageCount", 0), t } return Or(n, [{ key: "isLoading", value: function () { return 0 === this.loadingImageCount } }, { key: "init", value: function () { this.iconData = [], this.iconMap = {}, this.canvas = oo.document.createElement("canvas"), this.canvas.width = 128, this.canvas.height = 128, this.ctx = this.canvas.getContext("2d") } }, { key: "addImage", value: function (t, e) { var n = this, r = new Image; if (this.loadingImageCount++, this.hasImage(t)) throw new Error("Image Id already exists"); this.iconData.push({ id: t, size: 64 }), this.updateIconMap(), this.loadImage(e).then((function (e) { r = e; var i = n.iconData.find((function (e) { return e.id === t })); i && (i.image = r, i.width = r.width, i.height = r.height), n.update() })) } }, { key: "addImageMini", value: function (t, e, n) { var r = this, i = n.getSceneConfig().canvas, o = i.createImage(); if (this.loadingImageCount++, this.hasImage(t)) throw new Error("Image Id already exists"); this.iconData.push({ id: t, size: 64 }), this.updateIconMap(), this.loadImageMini(e, i).then((function (e) { o = e; var n = r.iconData.find((function (e) { return e.id === t })); n && (n.image = o, n.width = o.width, n.height = o.height), r.update() })) } }, { key: "getTexture", value: function () { return this.texture } }, { key: "getIconMap", value: function () { return this.iconMap } }, { key: "getCanvas", value: function () { return this.canvas } }, { key: "hasImage", value: function (t) { return this.iconMap.hasOwnProperty(t) } }, { key: "removeImage", value: function (t) { this.hasImage(t) && (this.iconData = this.iconData.filter((function (e) { return e.id !== t })), delete this.iconMap[t], this.update()) } }, { key: "destroy", value: function () { this.removeAllListeners("imageUpdate"), this.iconData = [], this.iconMap = {} } }, { key: "loadImage", value: function (t) { return new Promise((function (e, n) { if (t instanceof HTMLImageElement) e(t); else { var r = new Image; r.crossOrigin = "anonymous", r.onload = function () { e(r) }, r.onerror = function () { n(new Error("Could not load image at " + t)) }, r.src = t instanceof File ? URL.createObjectURL(t) : t } })) } }, { key: "update", value: function () { this.updateIconMap(), this.updateIconAtlas(), this.loadingImageCount--, 0 === this.loadingImageCount && this.emit("imageUpdate") } }, { key: "updateIconAtlas", value: function () { var t = this; this.canvas.width = 1024, this.canvas.height = this.canvasHeight, Object.keys(this.iconMap).forEach((function (e) { var n = t.iconMap[e], r = n.x, i = n.y, o = n.image, a = n.width, s = void 0 === a ? 64 : a, l = n.height, u = void 0 === l ? 64 : l, c = Math.max(s, u) / 64, p = u / c, h = s / c; o && t.ctx.drawImage(o, r + (64 - h) / 2, i + (64 - p) / 2, h, p) })) } }, { key: "updateIconMap", value: function () { var t = function (t, e, n) { var r, i = 0, o = 0, a = 0, s = [], l = {}, u = ja(t); try { for (u.s(); !(r = u.n()).done;) { var c = r.value; if (!l[c.id]) { var p = c.size; i + p + e > n && (Ga(l, s, o), i = 0, o = a + o + e, a = 0, s = []), s.push({ icon: c, xOffset: i }), i = i + p + e, a = Math.max(a, p) } } } catch (t) { u.e(t) } finally { u.f() } return s.length > 0 && Ga(l, s, o), { mapping: l, canvasHeight: Ha(a + o + e) } }(this.iconData, 3, 1024), e = t.mapping, n = t.canvasHeight; this.iconMap = e, this.canvasHeight = n } }, { key: "loadImageMini", value: function (t, e) { return new Promise((function (n, r) { var i = e.createImage(); i.crossOrigin = "anonymous", i.onload = function () { n(i) }, i.onerror = function () { r(new Error("Could not load image at " + t)) }, i.src = t })) } }]), n }(st.exports.EventEmitter)) || Ja, ns = 1e-6, rs = "undefined" != typeof Float32Array ? Float32Array : Array, is = Math.random; function os() { var t = new rs(16); return rs != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t } function as(t) { var e = new rs(16); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e } function ss(t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m) { var v = new rs(16); return v[0] = t, v[1] = e, v[2] = n, v[3] = r, v[4] = i, v[5] = o, v[6] = a, v[7] = s, v[8] = l, v[9] = u, v[10] = c, v[11] = p, v[12] = h, v[13] = f, v[14] = d, v[15] = m, v } function ls(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function us(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], l = e[6], u = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], m = e[13], v = e[14], y = e[15], g = n * s - r * a, _ = n * l - i * a, x = n * u - o * a, b = r * l - i * s, w = r * u - o * s, S = i * u - o * l, E = c * m - p * d, C = c * v - h * d, T = c * y - f * d, A = p * v - h * m, M = p * y - f * m, O = h * y - f * v, k = g * O - _ * M + x * A + b * T - w * C + S * E; return k ? (k = 1 / k, t[0] = (s * O - l * M + u * A) * k, t[1] = (i * M - r * O - o * A) * k, t[2] = (m * S - v * w + y * b) * k, t[3] = (h * w - p * S - f * b) * k, t[4] = (l * T - a * O - u * C) * k, t[5] = (n * O - i * T + o * C) * k, t[6] = (v * x - d * S - y * _) * k, t[7] = (c * S - h * x + f * _) * k, t[8] = (a * M - s * T + u * E) * k, t[9] = (r * T - n * M - o * E) * k, t[10] = (d * w - m * x + y * g) * k, t[11] = (p * x - c * w - f * g) * k, t[12] = (s * C - a * A - l * E) * k, t[13] = (n * A - r * C + i * E) * k, t[14] = (m * _ - d * b - v * g) * k, t[15] = (c * b - p * _ + h * g) * k, t) : null } function cs(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], h = e[9], f = e[10], d = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = n[0], x = n[1], b = n[2], w = n[3]; return t[0] = _ * r + x * s + b * p + w * m, t[1] = _ * i + x * l + b * h + w * v, t[2] = _ * o + x * u + b * f + w * y, t[3] = _ * a + x * c + b * d + w * g, _ = n[4], x = n[5], b = n[6], w = n[7], t[4] = _ * r + x * s + b * p + w * m, t[5] = _ * i + x * l + b * h + w * v, t[6] = _ * o + x * u + b * f + w * y, t[7] = _ * a + x * c + b * d + w * g, _ = n[8], x = n[9], b = n[10], w = n[11], t[8] = _ * r + x * s + b * p + w * m, t[9] = _ * i + x * l + b * h + w * v, t[10] = _ * o + x * u + b * f + w * y, t[11] = _ * a + x * c + b * d + w * g, _ = n[12], x = n[13], b = n[14], w = n[15], t[12] = _ * r + x * s + b * p + w * m, t[13] = _ * i + x * l + b * h + w * v, t[14] = _ * o + x * u + b * f + w * y, t[15] = _ * a + x * c + b * d + w * g, t } function ps(t, e, n) { var r, i, o, a, s, l, u, c, p, h, f, d, m = n[0], v = n[1], y = n[2]; return e === t ? (t[12] = e[0] * m + e[4] * v + e[8] * y + e[12], t[13] = e[1] * m + e[5] * v + e[9] * y + e[13], t[14] = e[2] * m + e[6] * v + e[10] * y + e[14], t[15] = e[3] * m + e[7] * v + e[11] * y + e[15]) : (r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], h = e[9], f = e[10], d = e[11], t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = s, t[5] = l, t[6] = u, t[7] = c, t[8] = p, t[9] = h, t[10] = f, t[11] = d, t[12] = r * m + s * v + p * y + e[12], t[13] = i * m + l * v + h * y + e[13], t[14] = o * m + u * v + f * y + e[14], t[15] = a * m + c * v + d * y + e[15]), t } function hs(t, e, n) { var r = n[0], i = n[1], o = n[2]; return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * o, t[9] = e[9] * o, t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t } function fs(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[4], a = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], h = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * i + u * r, t[5] = a * i + c * r, t[6] = s * i + p * r, t[7] = l * i + h * r, t[8] = u * i - o * r, t[9] = c * i - a * r, t[10] = p * i - s * r, t[11] = h * i - l * r, t } function ds(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[0], a = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], h = e[11]; return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i - u * r, t[1] = a * i - c * r, t[2] = s * i - p * r, t[3] = l * i - h * r, t[8] = o * r + u * i, t[9] = a * r + c * i, t[10] = s * r + p * i, t[11] = l * r + h * i, t } function ms(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[0], a = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], h = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i + u * r, t[1] = a * i + c * r, t[2] = s * i + p * r, t[3] = l * i + h * r, t[4] = u * i - o * r, t[5] = c * i - a * r, t[6] = p * i - s * r, t[7] = h * i - l * r, t } function vs(t, e) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t } function ys(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = r + r, l = i + i, u = o + o, c = r * s, p = r * l, h = r * u, f = i * l, d = i * u, m = o * u, v = a * s, y = a * l, g = a * u; return t[0] = 1 - (f + m), t[1] = p + g, t[2] = h - y, t[3] = 0, t[4] = p - g, t[5] = 1 - (c + m), t[6] = d + v, t[7] = 0, t[8] = h + y, t[9] = d - v, t[10] = 1 - (c + f), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t } function gs(t, e) { var n = e[0], r = e[1], i = e[2], o = e[4], a = e[5], s = e[6], l = e[8], u = e[9], c = e[10]; return t[0] = Math.hypot(n, r, i), t[1] = Math.hypot(o, a, s), t[2] = Math.hypot(l, u, c), t } function _s(t, e, n, r, i) { var o, a = 1 / Math.tan(e / 2); return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = (i + r) * o, t[14] = 2 * i * r * o) : (t[10] = -1, t[14] = -2 * r), t } Math.hypot || (Math.hypot = function () { for (var t = 0, e = arguments.length; e--;)t += arguments[e] * arguments[e]; return Math.sqrt(t) }); var xs = _s; function bs(t, e, n, r, i, o, a) { var s = 1 / (e - n), l = 1 / (r - i), u = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * l, t[14] = (a + o) * u, t[15] = 1, t } var ws = bs; function Ss(t, e, n, r) { var i, o, a, s, l, u, c, p, h, f, d = e[0], m = e[1], v = e[2], y = r[0], g = r[1], _ = r[2], x = n[0], b = n[1], w = n[2]; return Math.abs(d - x) < ns && Math.abs(m - b) < ns && Math.abs(v - w) < ns ? ls(t) : (c = d - x, p = m - b, h = v - w, i = g * (h *= f = 1 / Math.hypot(c, p, h)) - _ * (p *= f), o = _ * (c *= f) - y * h, a = y * p - g * c, (f = Math.hypot(i, o, a)) ? (i *= f = 1 / f, o *= f, a *= f) : (i = 0, o = 0, a = 0), s = p * a - h * o, l = h * i - c * a, u = c * o - p * i, (f = Math.hypot(s, l, u)) ? (s *= f = 1 / f, l *= f, u *= f) : (s = 0, l = 0, u = 0), t[0] = i, t[1] = s, t[2] = c, t[3] = 0, t[4] = o, t[5] = l, t[6] = p, t[7] = 0, t[8] = a, t[9] = u, t[10] = h, t[11] = 0, t[12] = -(i * d + o * m + a * v), t[13] = -(s * d + l * m + u * v), t[14] = -(c * d + p * m + h * v), t[15] = 1, t) } function Es(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t } function Cs(t, e) { var n = t[0], r = t[1], i = t[2], o = t[3], a = t[4], s = t[5], l = t[6], u = t[7], c = t[8], p = t[9], h = t[10], f = t[11], d = t[12], m = t[13], v = t[14], y = t[15], g = e[0], _ = e[1], x = e[2], b = e[3], w = e[4], S = e[5], E = e[6], C = e[7], T = e[8], A = e[9], M = e[10], O = e[11], k = e[12], I = e[13], P = e[14], L = e[15]; return Math.abs(n - g) <= ns * Math.max(1, Math.abs(n), Math.abs(g)) && Math.abs(r - _) <= ns * Math.max(1, Math.abs(r), Math.abs(_)) && Math.abs(i - x) <= ns * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(o - b) <= ns * Math.max(1, Math.abs(o), Math.abs(b)) && Math.abs(a - w) <= ns * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(s - S) <= ns * Math.max(1, Math.abs(s), Math.abs(S)) && Math.abs(l - E) <= ns * Math.max(1, Math.abs(l), Math.abs(E)) && Math.abs(u - C) <= ns * Math.max(1, Math.abs(u), Math.abs(C)) && Math.abs(c - T) <= ns * Math.max(1, Math.abs(c), Math.abs(T)) && Math.abs(p - A) <= ns * Math.max(1, Math.abs(p), Math.abs(A)) && Math.abs(h - M) <= ns * Math.max(1, Math.abs(h), Math.abs(M)) && Math.abs(f - O) <= ns * Math.max(1, Math.abs(f), Math.abs(O)) && Math.abs(d - k) <= ns * Math.max(1, Math.abs(d), Math.abs(k)) && Math.abs(m - I) <= ns * Math.max(1, Math.abs(m), Math.abs(I)) && Math.abs(v - P) <= ns * Math.max(1, Math.abs(v), Math.abs(P)) && Math.abs(y - L) <= ns * Math.max(1, Math.abs(y), Math.abs(L)) } var Ts = cs, As = Es, Ms = Object.freeze({ __proto__: null, create: os, clone: as, copy: function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, fromValues: ss, set: function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v) { return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = l, t[8] = u, t[9] = c, t[10] = p, t[11] = h, t[12] = f, t[13] = d, t[14] = m, t[15] = v, t }, identity: ls, transpose: function (t, e) { if (t === e) { var n = e[1], r = e[2], i = e[3], o = e[6], a = e[7], s = e[11]; t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = o, t[11] = e[14], t[12] = i, t[13] = a, t[14] = s } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15]; return t }, invert: us, adjoint: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], l = e[6], u = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], m = e[13], v = e[14], y = e[15]; return t[0] = s * (h * y - f * v) - p * (l * y - u * v) + m * (l * f - u * h), t[1] = -(r * (h * y - f * v) - p * (i * y - o * v) + m * (i * f - o * h)), t[2] = r * (l * y - u * v) - s * (i * y - o * v) + m * (i * u - o * l), t[3] = -(r * (l * f - u * h) - s * (i * f - o * h) + p * (i * u - o * l)), t[4] = -(a * (h * y - f * v) - c * (l * y - u * v) + d * (l * f - u * h)), t[5] = n * (h * y - f * v) - c * (i * y - o * v) + d * (i * f - o * h), t[6] = -(n * (l * y - u * v) - a * (i * y - o * v) + d * (i * u - o * l)), t[7] = n * (l * f - u * h) - a * (i * f - o * h) + c * (i * u - o * l), t[8] = a * (p * y - f * m) - c * (s * y - u * m) + d * (s * f - u * p), t[9] = -(n * (p * y - f * m) - c * (r * y - o * m) + d * (r * f - o * p)), t[10] = n * (s * y - u * m) - a * (r * y - o * m) + d * (r * u - o * s), t[11] = -(n * (s * f - u * p) - a * (r * f - o * p) + c * (r * u - o * s)), t[12] = -(a * (p * v - h * m) - c * (s * v - l * m) + d * (s * h - l * p)), t[13] = n * (p * v - h * m) - c * (r * v - i * m) + d * (r * h - i * p), t[14] = -(n * (s * v - l * m) - a * (r * v - i * m) + d * (r * l - i * s)), t[15] = n * (s * h - l * p) - a * (r * h - i * p) + c * (r * l - i * s), t }, determinant: function (t) { var e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], a = t[5], s = t[6], l = t[7], u = t[8], c = t[9], p = t[10], h = t[11], f = t[12], d = t[13], m = t[14], v = t[15]; return (e * a - n * o) * (p * v - h * m) - (e * s - r * o) * (c * v - h * d) + (e * l - i * o) * (c * m - p * d) + (n * s - r * a) * (u * v - h * f) - (n * l - i * a) * (u * m - p * f) + (r * l - i * s) * (u * d - c * f) }, multiply: cs, translate: ps, scale: hs, rotate: function (t, e, n, r) { var i, o, a, s, l, u, c, p, h, f, d, m, v, y, g, _, x, b, w, S, E, C, T, A, M = r[0], O = r[1], k = r[2], I = Math.hypot(M, O, k); return I < ns ? null : (M *= I = 1 / I, O *= I, k *= I, i = Math.sin(n), a = 1 - (o = Math.cos(n)), s = e[0], l = e[1], u = e[2], c = e[3], p = e[4], h = e[5], f = e[6], d = e[7], m = e[8], v = e[9], y = e[10], g = e[11], _ = M * M * a + o, x = O * M * a + k * i, b = k * M * a - O * i, w = M * O * a - k * i, S = O * O * a + o, E = k * O * a + M * i, C = M * k * a + O * i, T = O * k * a - M * i, A = k * k * a + o, t[0] = s * _ + p * x + m * b, t[1] = l * _ + h * x + v * b, t[2] = u * _ + f * x + y * b, t[3] = c * _ + d * x + g * b, t[4] = s * w + p * S + m * E, t[5] = l * w + h * S + v * E, t[6] = u * w + f * S + y * E, t[7] = c * w + d * S + g * E, t[8] = s * C + p * T + m * A, t[9] = l * C + h * T + v * A, t[10] = u * C + f * T + y * A, t[11] = c * C + d * T + g * A, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t) }, rotateX: fs, rotateY: ds, rotateZ: ms, fromTranslation: vs, fromScaling: function (t, e) { return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromRotation: function (t, e, n) { var r, i, o, a = n[0], s = n[1], l = n[2], u = Math.hypot(a, s, l); return u < ns ? null : (a *= u = 1 / u, s *= u, l *= u, r = Math.sin(e), o = 1 - (i = Math.cos(e)), t[0] = a * a * o + i, t[1] = s * a * o + l * r, t[2] = l * a * o - s * r, t[3] = 0, t[4] = a * s * o - l * r, t[5] = s * s * o + i, t[6] = l * s * o + a * r, t[7] = 0, t[8] = a * l * o + s * r, t[9] = s * l * o - a * r, t[10] = l * l * o + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) }, fromXRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromYRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromZRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromRotationTranslation: ys, fromQuat2: function (t, e) { var n = new rs(3), r = -e[0], i = -e[1], o = -e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = r * r + i * i + o * o + a * a; return p > 0 ? (n[0] = 2 * (s * a + c * r + l * o - u * i) / p, n[1] = 2 * (l * a + c * i + u * r - s * o) / p, n[2] = 2 * (u * a + c * o + s * i - l * r) / p) : (n[0] = 2 * (s * a + c * r + l * o - u * i), n[1] = 2 * (l * a + c * i + u * r - s * o), n[2] = 2 * (u * a + c * o + s * i - l * r)), ys(t, e, n), t }, getTranslation: function (t, e) { return t[0] = e[12], t[1] = e[13], t[2] = e[14], t }, getScaling: gs, getRotation: function (t, e) { var n = new rs(3); gs(n, e); var r = 1 / n[0], i = 1 / n[1], o = 1 / n[2], a = e[0] * r, s = e[1] * i, l = e[2] * o, u = e[4] * r, c = e[5] * i, p = e[6] * o, h = e[8] * r, f = e[9] * i, d = e[10] * o, m = a + c + d, v = 0; return m > 0 ? (v = 2 * Math.sqrt(m + 1), t[3] = .25 * v, t[0] = (p - f) / v, t[1] = (h - l) / v, t[2] = (s - u) / v) : a > c && a > d ? (v = 2 * Math.sqrt(1 + a - c - d), t[3] = (p - f) / v, t[0] = .25 * v, t[1] = (s + u) / v, t[2] = (h + l) / v) : c > d ? (v = 2 * Math.sqrt(1 + c - a - d), t[3] = (h - l) / v, t[0] = (s + u) / v, t[1] = .25 * v, t[2] = (p + f) / v) : (v = 2 * Math.sqrt(1 + d - a - c), t[3] = (s - u) / v, t[0] = (h + l) / v, t[1] = (p + f) / v, t[2] = .25 * v), t }, fromRotationTranslationScale: function (t, e, n, r) { var i = e[0], o = e[1], a = e[2], s = e[3], l = i + i, u = o + o, c = a + a, p = i * l, h = i * u, f = i * c, d = o * u, m = o * c, v = a * c, y = s * l, g = s * u, _ = s * c, x = r[0], b = r[1], w = r[2]; return t[0] = (1 - (d + v)) * x, t[1] = (h + _) * x, t[2] = (f - g) * x, t[3] = 0, t[4] = (h - _) * b, t[5] = (1 - (p + v)) * b, t[6] = (m + y) * b, t[7] = 0, t[8] = (f + g) * w, t[9] = (m - y) * w, t[10] = (1 - (p + d)) * w, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t }, fromRotationTranslationScaleOrigin: function (t, e, n, r, i) { var o = e[0], a = e[1], s = e[2], l = e[3], u = o + o, c = a + a, p = s + s, h = o * u, f = o * c, d = o * p, m = a * c, v = a * p, y = s * p, g = l * u, _ = l * c, x = l * p, b = r[0], w = r[1], S = r[2], E = i[0], C = i[1], T = i[2], A = (1 - (m + y)) * b, M = (f + x) * b, O = (d - _) * b, k = (f - x) * w, I = (1 - (h + y)) * w, P = (v + g) * w, L = (d + _) * S, R = (v - g) * S, D = (1 - (h + m)) * S; return t[0] = A, t[1] = M, t[2] = O, t[3] = 0, t[4] = k, t[5] = I, t[6] = P, t[7] = 0, t[8] = L, t[9] = R, t[10] = D, t[11] = 0, t[12] = n[0] + E - (A * E + k * C + L * T), t[13] = n[1] + C - (M * E + I * C + R * T), t[14] = n[2] + T - (O * E + P * C + D * T), t[15] = 1, t }, fromQuat: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = n + n, s = r + r, l = i + i, u = n * a, c = r * a, p = r * s, h = i * a, f = i * s, d = i * l, m = o * a, v = o * s, y = o * l; return t[0] = 1 - p - d, t[1] = c + y, t[2] = h - v, t[3] = 0, t[4] = c - y, t[5] = 1 - u - d, t[6] = f + m, t[7] = 0, t[8] = h + v, t[9] = f - m, t[10] = 1 - u - p, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, frustum: function (t, e, n, r, i, o, a) { var s = 1 / (n - e), l = 1 / (i - r), u = 1 / (o - a); return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * l, t[6] = 0, t[7] = 0, t[8] = (n + e) * s, t[9] = (i + r) * l, t[10] = (a + o) * u, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * o * 2 * u, t[15] = 0, t }, perspectiveNO: _s, perspective: xs, perspectiveZO: function (t, e, n, r, i) { var o, a = 1 / Math.tan(e / 2); return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = i * o, t[14] = i * r * o) : (t[10] = -1, t[14] = -r), t }, perspectiveFromFieldOfView: function (t, e, n, r) { var i = Math.tan(e.upDegrees * Math.PI / 180), o = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), s = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (a + s), u = 2 / (i + o); return t[0] = l, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = -(a - s) * l * .5, t[9] = (i - o) * u * .5, t[10] = r / (n - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * n / (n - r), t[15] = 0, t }, orthoNO: bs, ortho: ws, orthoZO: function (t, e, n, r, i, o, a) { var s = 1 / (e - n), l = 1 / (r - i), u = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * l, t[14] = o * u, t[15] = 1, t }, lookAt: Ss, targetTo: function (t, e, n, r) { var i = e[0], o = e[1], a = e[2], s = r[0], l = r[1], u = r[2], c = i - n[0], p = o - n[1], h = a - n[2], f = c * c + p * p + h * h; f > 0 && (c *= f = 1 / Math.sqrt(f), p *= f, h *= f); var d = l * h - u * p, m = u * c - s * h, v = s * p - l * c; return (f = d * d + m * m + v * v) > 0 && (d *= f = 1 / Math.sqrt(f), m *= f, v *= f), t[0] = d, t[1] = m, t[2] = v, t[3] = 0, t[4] = p * v - h * m, t[5] = h * d - c * v, t[6] = c * m - p * d, t[7] = 0, t[8] = c, t[9] = p, t[10] = h, t[11] = 0, t[12] = i, t[13] = o, t[14] = a, t[15] = 1, t }, str: function (t) { return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")" }, frob: function (t) { return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]) }, add: function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t }, subtract: Es, multiplyScalar: function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t }, multiplyScalarAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t[9] = e[9] + n[9] * r, t[10] = e[10] + n[10] * r, t[11] = e[11] + n[11] * r, t[12] = e[12] + n[12] * r, t[13] = e[13] + n[13] * r, t[14] = e[14] + n[14] * r, t[15] = e[15] + n[15] * r, t }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15] }, equals: Cs, mul: Ts, sub: As }); function Os() { var t = new rs(3); return rs != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t } function ks(t) { var e = t[0], n = t[1], r = t[2]; return Math.hypot(e, n, r) } function Is(t, e, n) { var r = new rs(3); return r[0] = t, r[1] = e, r[2] = n, r } function Ps(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t } function Ls(t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t } function Rs(t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t } function Ds(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2]; return Math.hypot(n, r, i) } function Ns(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2]; return n * n + r * r + i * i } function zs(t) { var e = t[0], n = t[1], r = t[2]; return e * e + n * n + r * r } function Fs(t, e) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t } function Bs(t, e) { var n = e[0], r = e[1], i = e[2], o = n * n + r * r + i * i; return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o, t } function js(t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } function Us(t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[0], s = n[1], l = n[2]; return t[0] = i * l - o * s, t[1] = o * a - r * l, t[2] = r * s - i * a, t } function Vs(t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[3] * r + n[7] * i + n[11] * o + n[15]; return a = a || 1, t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a, t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a, t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a, t } function Gs(t, e) { var n = t[0], r = t[1], i = t[2], o = e[0], a = e[1], s = e[2], l = Math.sqrt(n * n + r * r + i * i) * Math.sqrt(o * o + a * a + s * s), u = l && js(t, e) / l; return Math.acos(Math.min(Math.max(u, -1), 1)) } var Hs, Ws = Ps, Xs = Ls, qs = Rs, Zs = Ds, Ys = Ns, Ks = ks, Qs = zs, Js = (Hs = Os(), function (t, e, n, r, i, o) { var a, s; for (e || (e = 3), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n; a < s; a += e)Hs[0] = t[a], Hs[1] = t[a + 1], Hs[2] = t[a + 2], i(Hs, Hs, o), t[a] = Hs[0], t[a + 1] = Hs[1], t[a + 2] = Hs[2]; return t }), $s = Object.freeze({ __proto__: null, create: Os, clone: function (t) { var e = new rs(3); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e }, length: ks, fromValues: Is, copy: function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t }, set: function (t, e, n, r) { return t[0] = e, t[1] = n, t[2] = r, t }, add: function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t }, subtract: Ps, multiply: Ls, divide: Rs, ceil: function (t, e) { return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t }, floor: function (t, e) { return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t }, min: function (t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t }, max: function (t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t }, round: function (t, e) { return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t }, scale: function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t }, scaleAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t }, distance: Ds, squaredDistance: Ns, squaredLength: zs, negate: Fs, inverse: function (t, e) { return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t }, normalize: Bs, dot: js, cross: Us, lerp: function (t, e, n, r) { var i = e[0], o = e[1], a = e[2]; return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t[2] = a + r * (n[2] - a), t }, hermite: function (t, e, n, r, i, o) { var a = o * o, s = a * (2 * o - 3) + 1, l = a * (o - 2) + o, u = a * (o - 1), c = a * (3 - 2 * o); return t[0] = e[0] * s + n[0] * l + r[0] * u + i[0] * c, t[1] = e[1] * s + n[1] * l + r[1] * u + i[1] * c, t[2] = e[2] * s + n[2] * l + r[2] * u + i[2] * c, t }, bezier: function (t, e, n, r, i, o) { var a = 1 - o, s = a * a, l = o * o, u = s * a, c = 3 * o * s, p = 3 * l * a, h = l * o; return t[0] = e[0] * u + n[0] * c + r[0] * p + i[0] * h, t[1] = e[1] * u + n[1] * c + r[1] * p + i[1] * h, t[2] = e[2] * u + n[2] * c + r[2] * p + i[2] * h, t }, random: function (t, e) { e = e || 1; var n = 2 * is() * Math.PI, r = 2 * is() - 1, i = Math.sqrt(1 - r * r) * e; return t[0] = Math.cos(n) * i, t[1] = Math.sin(n) * i, t[2] = r * e, t }, transformMat4: Vs, transformMat3: function (t, e, n) { var r = e[0], i = e[1], o = e[2]; return t[0] = r * n[0] + i * n[3] + o * n[6], t[1] = r * n[1] + i * n[4] + o * n[7], t[2] = r * n[2] + i * n[5] + o * n[8], t }, transformQuat: function (t, e, n) { var r = n[0], i = n[1], o = n[2], a = n[3], s = e[0], l = e[1], u = e[2], c = i * u - o * l, p = o * s - r * u, h = r * l - i * s, f = i * h - o * p, d = o * c - r * h, m = r * p - i * c, v = 2 * a; return c *= v, p *= v, h *= v, f *= 2, d *= 2, m *= 2, t[0] = s + c + f, t[1] = l + p + d, t[2] = u + h + m, t }, rotateX: function (t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t }, rotateY: function (t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t }, rotateZ: function (t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t }, angle: Gs, zero: function (t) { return t[0] = 0, t[1] = 0, t[2] = 0, t }, str: function (t) { return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")" }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] }, equals: function (t, e) { var n = t[0], r = t[1], i = t[2], o = e[0], a = e[1], s = e[2]; return Math.abs(n - o) <= ns * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= ns * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - s) <= ns * Math.max(1, Math.abs(i), Math.abs(s)) }, sub: Ws, mul: Xs, div: qs, dist: Zs, sqrDist: Ys, len: Ks, sqrLen: Qs, forEach: Js }); function tl() { var t = new rs(4); return rs != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t } function el(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3]; return t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, t } function nl() { var t = new rs(2); return rs != Float32Array && (t[0] = 0, t[1] = 0), t } function rl(t, e) { var n = new rs(2); return n[0] = t, n[1] = e, n } function il(t, e) { return t[0] = e[0], t[1] = e[1], t } function ol(t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t } function al(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t } function sl(t, e) { var n = e[0], r = e[1], i = n * n + r * r; return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t } function ll(t, e) { return t[0] * e[0] + t[1] * e[1] } function ul(t, e, n, r) { var i = e[0], o = e[1]; return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t } !function () { var t = tl() }(); var cl, pl = al; !function () { var t = nl() }(); var hl, fl = ut.injectable()(cl = function () { function t() { Ar(this, t), kr(this, "viewport", void 0), kr(this, "overridedViewProjectionMatrix", void 0), kr(this, "jitteredViewProjectionMatrix", void 0), kr(this, "jitteredProjectionMatrix", void 0), kr(this, "viewMatrixInverse", void 0), kr(this, "cameraPosition", void 0) } return Or(t, [{ key: "init", value: function () { } }, { key: "update", value: function (t) { this.viewport = t, this.viewMatrixInverse = os(), us(this.viewMatrixInverse, t.getViewMatrix()), this.cameraPosition = [this.viewMatrixInverse[12], this.viewMatrixInverse[13], this.viewMatrixInverse[14]] } }, { key: "getProjectionMatrix", value: function () { return this.jitteredProjectionMatrix || this.viewport.getProjectionMatrix() } }, { key: "getModelMatrix", value: function () { return this.viewport.getModelMatrix() } }, { key: "getViewMatrix", value: function () { return this.viewport.getViewMatrix() } }, { key: "getViewMatrixUncentered", value: function () { return this.viewport.getViewMatrixUncentered() } }, { key: "getViewProjectionMatrixUncentered", value: function () { return this.viewport.getViewProjectionMatrixUncentered() } }, { key: "getViewProjectionMatrix", value: function () { return this.overridedViewProjectionMatrix || this.jitteredViewProjectionMatrix || this.viewport.getViewProjectionMatrix() } }, { key: "getZoom", value: function () { return this.viewport.getZoom() } }, { key: "getZoomScale", value: function () { return this.viewport.getZoomScale() } }, { key: "getCenter", value: function () { var t = Lr(this.viewport.getCenter(), 2); return [t[0], t[1]] } }, { key: "getFocalDistance", value: function () { return this.viewport.getFocalDistance() } }, { key: "getCameraPosition", value: function () { return this.cameraPosition } }, { key: "projectFlat", value: function (t, e) { return this.viewport.projectFlat(t, e) } }, { key: "setViewProjectionMatrix", value: function (t) { this.overridedViewProjectionMatrix = t } }, { key: "jitterProjectionMatrix", value: function (t, e) { var n = vs(os(), [t, e, 0]); this.jitteredProjectionMatrix = cs(os(), n, this.viewport.getProjectionMatrix()), this.jitteredViewProjectionMatrix = cs(os(), this.jitteredProjectionMatrix, this.viewport.getViewMatrix()) } }, { key: "clearJitterProjectionMatrix", value: function () { this.jitteredProjectionMatrix = void 0, this.jitteredViewProjectionMatrix = void 0 } }]), t }()) || cl; function dl(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return ml(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ml(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function ml(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var vl, yl, gl = ut.injectable()(hl = function () { function t() { Ar(this, t), kr(this, "container", void 0), kr(this, "controlCorners", void 0), kr(this, "controlContainer", void 0), kr(this, "scene", void 0), kr(this, "mapsService", void 0), kr(this, "controls", []), kr(this, "unAddControls", []) } return Or(t, [{ key: "init", value: function (t, e) { this.container = t.container, this.scene = e, this.mapsService = e.get(Tr.IMapService), this.initControlPos() } }, { key: "addControl", value: function (t, e) { e.get(Tr.IMapService).map ? (t.addTo(this.scene), this.controls.push(t)) : this.unAddControls.push(t) } }, { key: "getControlByName", value: function (t) { return this.controls.find((function (e) { return e.controlOption.name === t })) } }, { key: "removeControl", value: function (t) { var e = this.controls.indexOf(t); return e > -1 && this.controls.splice(e, 1), t.remove(), this } }, { key: "addControls", value: function () { var t = this; this.unAddControls.forEach((function (e) { e.addTo(t.scene), t.controls.push(e) })), this.unAddControls = [] } }, { key: "destroy", value: function () { var t, e = dl(this.controls); try { for (e.s(); !(t = e.n()).done;) { t.value.remove() } } catch (t) { e.e(t) } finally { e.f() } this.controls = [], this.clearControlPos() } }, { key: "initControlPos", value: function () { var t = this.controlCorners = {}, e = "l7-", n = this.controlContainer = lo("div", e + "control-container", this.container); function r() { var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], i = r.map((function (t) { return e + t })).join(" "); t[r.join("")] = lo("div", i, n) } r(["top", "left"]), r(["top", "right"]), r(["bottom", "left"]), r(["bottom", "right"]), r(["top", "center"]), r(["right", "center"]), r(["left", "center"]), r(["bottom", "center"]) } }, { key: "clearControlPos", value: function () { for (var t in this.controlCorners) this.controlCorners[t] && uo(this.controlCorners[t]); this.controlContainer && uo(this.controlContainer), delete this.controlCorners, delete this.controlContainer } }]), t }()) || hl, _l = ut.injectable()(vl = function () { function t() { Ar(this, t), kr(this, "container", void 0), kr(this, "scene", void 0), kr(this, "mapsService", void 0), kr(this, "markers", []), kr(this, "markerLayers", []), kr(this, "unAddMarkers", []), kr(this, "unAddMarkerLayers", []) } return Or(t, [{ key: "addMarkerLayer", value: function (t) { this.mapsService.map && this.mapsService.getMarkerContainer() ? (this.markerLayers.push(t), t.addTo(this.scene)) : this.unAddMarkerLayers.push(t) } }, { key: "removeMarkerLayer", value: function (t) { t.destroy(), this.markerLayers.indexOf(t); var e = this.markerLayers.indexOf(t); e > -1 && this.markerLayers.splice(e, 1) } }, { key: "addMarker", value: function (t) { this.mapsService.map && this.mapsService.getMarkerContainer() ? (this.markers.push(t), t.addTo(this.scene)) : this.unAddMarkers.push(t) } }, { key: "addMarkers", value: function () { var t = this; this.unAddMarkers.forEach((function (e) { e.addTo(t.scene), t.markers.push(e) })), this.unAddMarkers = [] } }, { key: "addMarkerLayers", value: function () { var t = this; this.unAddMarkerLayers.forEach((function (e) { t.markerLayers.push(e), e.addTo(t.scene) })), this.unAddMarkers = [] } }, { key: "removeMarker", value: function (t) { t.remove(), this.markers.indexOf(t); var e = this.markers.indexOf(t); e > -1 && this.markers.splice(e, 1) } }, { key: "removeAllMarkers", value: function () { this.destroy() } }, { key: "init", value: function (t) { this.scene = t, this.mapsService = t.get(Tr.IMapService) } }, { key: "destroy", value: function () { this.markers.forEach((function (t) { t.remove() })), this.markers = [], this.markerLayers.forEach((function (t) { t.destroy() })), this.markerLayers = [] } }, { key: "removeMakerLayerMarker", value: function (t) { t.destroy() } }]), t }()) || vl, xl = ut.injectable()(yl = function () { function t() { Ar(this, t), kr(this, "scene", void 0), kr(this, "popup", void 0), kr(this, "mapsService", void 0), kr(this, "unAddPopup", void 0) } return Or(t, [{ key: "removePopup", value: function (t) { t.remove() } }, { key: "destroy", value: function () { this.popup.remove() } }, { key: "addPopup", value: function (t) { this.popup && this.popup.remove(), this.mapsService.map && this.mapsService.getMarkerContainer() ? (t.addTo(this.scene), this.popup = t) : this.unAddPopup = t } }, { key: "initPopup", value: function () { this.unAddPopup && (this.addPopup(this.unAddPopup), this.unAddPopup = null) } }, { key: "init", value: function (t) { this.scene = t, this.mapsService = t.get(Tr.IMapService) } }]), t }()) || yl; var bl = function () { this.__data__ = [], this.size = 0 }; var wl = function (t, e) { return t === e || t != t && e != e }, Sl = wl; var El = function (t, e) { for (var n = t.length; n--;)if (Sl(t[n][0], e)) return n; return -1 }, Cl = El, Tl = Array.prototype.splice; var Al = function (t) { var e = this.__data__, n = Cl(e, t); return !(n < 0) && (n == e.length - 1 ? e.pop() : Tl.call(e, n, 1), --this.size, !0) }, Ml = El; var Ol = function (t) { var e = this.__data__, n = Ml(e, t); return n < 0 ? void 0 : e[n][1] }, kl = El; var Il = El; var Pl = function (t, e) { var n = this.__data__, r = Il(n, t); return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this }, Ll = bl, Rl = Al, Dl = Ol, Nl = function (t) { return kl(this.__data__, t) > -1 }, zl = Pl; function Fl(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } Fl.prototype.clear = Ll, Fl.prototype.delete = Rl, Fl.prototype.get = Dl, Fl.prototype.has = Nl, Fl.prototype.set = zl; var Bl = Fl, jl = Bl; var Ul = function () { this.__data__ = new jl, this.size = 0 }; var Vl = function (t) { var e = this.__data__, n = e.delete(t); return this.size = e.size, n }; var Gl = function (t) { return this.__data__.get(t) }; var Hl = function (t) { return this.__data__.has(t) }, Wl = "object" == typeof D && D && D.Object === Object && D, Xl = Wl, ql = "object" == typeof self && self && self.Object === Object && self, Zl = Xl || ql || Function("return this")(), Yl = Zl.Symbol, Kl = Yl, Ql = Object.prototype, Jl = Ql.hasOwnProperty, $l = Ql.toString, tu = Kl ? Kl.toStringTag : void 0; var eu = function (t) { var e = Jl.call(t, tu), n = t[tu]; try { t[tu] = void 0; var r = !0 } catch (t) { } var i = $l.call(t); return r && (e ? t[tu] = n : delete t[tu]), i }, nu = Object.prototype.toString; var ru = eu, iu = function (t) { return nu.call(t) }, ou = Yl ? Yl.toStringTag : void 0; var au = function (t) { return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : ou && ou in Object(t) ? ru(t) : iu(t) }; var su = function (t) { var e = typeof t; return null != t && ("object" == e || "function" == e) }, lu = au, uu = su; var cu, pu = function (t) { if (!uu(t)) return !1; var e = lu(t); return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e }, hu = Zl["__core-js_shared__"], fu = (cu = /[^.]+$/.exec(hu && hu.keys && hu.keys.IE_PROTO || "")) ? "Symbol(src)_1." + cu : ""; var du = function (t) { return !!fu && fu in t }, mu = Function.prototype.toString; var vu = function (t) { if (null != t) { try { return mu.call(t) } catch (t) { } try { return t + "" } catch (t) { } } return "" }, yu = pu, gu = du, _u = su, xu = vu, bu = /^\[object .+?Constructor\]$/, wu = Function.prototype, Su = Object.prototype, Eu = wu.toString, Cu = Su.hasOwnProperty, Tu = RegExp("^" + Eu.call(Cu).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); var Au = function (t, e) { return null == t ? void 0 : t[e] }, Mu = function (t) { return !(!_u(t) || gu(t)) && (yu(t) ? Tu : bu).test(xu(t)) }, Ou = Au; var ku = function (t, e) { var n = Ou(t, e); return Mu(n) ? n : void 0 }, Iu = ku(Zl, "Map"), Pu = ku(Object, "create"), Lu = Pu; var Ru = function () { this.__data__ = Lu ? Lu(null) : {}, this.size = 0 }; var Du = function (t) { var e = this.has(t) && delete this.__data__[t]; return this.size -= e ? 1 : 0, e }, Nu = Pu, zu = Object.prototype.hasOwnProperty; var Fu = function (t) { var e = this.__data__; if (Nu) { var n = e[t]; return "__lodash_hash_undefined__" === n ? void 0 : n } return zu.call(e, t) ? e[t] : void 0 }, Bu = Pu, ju = Object.prototype.hasOwnProperty; var Uu = function (t) { var e = this.__data__; return Bu ? void 0 !== e[t] : ju.call(e, t) }, Vu = Pu; var Gu = function (t, e) { var n = this.__data__; return this.size += this.has(t) ? 0 : 1, n[t] = Vu && void 0 === e ? "__lodash_hash_undefined__" : e, this }, Hu = Ru, Wu = Du, Xu = Fu, qu = Uu, Zu = Gu; function Yu(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } Yu.prototype.clear = Hu, Yu.prototype.delete = Wu, Yu.prototype.get = Xu, Yu.prototype.has = qu, Yu.prototype.set = Zu; var Ku = Yu, Qu = Bl, Ju = Iu; var $u = function (t) { var e = typeof t; return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t }; var tc = function (t, e) { var n = t.__data__; return $u(e) ? n["string" == typeof e ? "string" : "hash"] : n.map }, ec = tc; var nc = function (t) { var e = ec(this, t).delete(t); return this.size -= e ? 1 : 0, e }, rc = tc; var ic = tc; var oc = tc; var ac = function (t, e) { var n = oc(this, t), r = n.size; return n.set(t, e), this.size += n.size == r ? 0 : 1, this }, sc = function () { this.size = 0, this.__data__ = { hash: new Ku, map: new (Ju || Qu), string: new Ku } }, lc = nc, uc = function (t) { return rc(this, t).get(t) }, cc = function (t) { return ic(this, t).has(t) }, pc = ac; function hc(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } hc.prototype.clear = sc, hc.prototype.delete = lc, hc.prototype.get = uc, hc.prototype.has = cc, hc.prototype.set = pc; var fc = hc, dc = Bl, mc = Iu, vc = fc; var yc = function (t, e) { var n = this.__data__; if (n instanceof dc) { var r = n.__data__; if (!mc || r.length < 199) return r.push([t, e]), this.size = ++n.size, this; n = this.__data__ = new vc(r) } return n.set(t, e), this.size = n.size, this }, gc = Bl, _c = Ul, xc = Vl, bc = Gl, wc = Hl, Sc = yc; function Ec(t) { var e = this.__data__ = new gc(t); this.size = e.size } Ec.prototype.clear = _c, Ec.prototype.delete = xc, Ec.prototype.get = bc, Ec.prototype.has = wc, Ec.prototype.set = Sc; var Cc = Ec, Tc = ku, Ac = function () { try { var t = Tc(Object, "defineProperty"); return t({}, "", {}), t } catch (t) { } }(), Mc = Ac, Oc = Mc; var kc = function (t, e, n) { "__proto__" == e && Oc ? Oc(t, e, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : t[e] = n }, Ic = kc, Pc = wl; var Lc = function (t, e, n) { (void 0 !== n && !Pc(t[e], n) || void 0 === n && !(e in t)) && Ic(t, e, n) }; var Rc = function (t) { return function (e, n, r) { for (var i = -1, o = Object(e), a = r(e), s = a.length; s--;) { var l = a[t ? s : ++i]; if (!1 === n(o[l], l, o)) break } return e } }, Dc = Rc(), Nc = { exports: {} }; !function (t, e) { var n = Zl, r = e && !e.nodeType && e, i = r && t && !t.nodeType && t, o = i && i.exports === r ? n.Buffer : void 0, a = o ? o.allocUnsafe : void 0; t.exports = function (t, e) { if (e) return t.slice(); var n = t.length, r = a ? a(n) : new t.constructor(n); return t.copy(r), r } }(Nc, Nc.exports); var zc = Zl.Uint8Array, Fc = zc; var Bc = function (t) { var e = new t.constructor(t.byteLength); return new Fc(e).set(new Fc(t)), e }, jc = Bc; var Uc = function (t, e) { var n = e ? jc(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.length) }; var Vc = function (t, e) { var n = -1, r = t.length; for (e || (e = Array(r)); ++n < r;)e[n] = t[n]; return e }, Gc = su, Hc = Object.create, Wc = function () { function t() { } return function (e) { if (!Gc(e)) return {}; if (Hc) return Hc(e); t.prototype = e; var n = new t; return t.prototype = void 0, n } }(), Xc = Wc; var qc = function (t, e) { return function (n) { return t(e(n)) } }, Zc = qc(Object.getPrototypeOf, Object), Yc = Object.prototype; var Kc = function (t) { var e = t && t.constructor; return t === ("function" == typeof e && e.prototype || Yc) }, Qc = Xc, Jc = Zc, $c = Kc; var tp = function (t) { return "function" != typeof t.constructor || $c(t) ? {} : Qc(Jc(t)) }; var ep = function (t) { return null != t && "object" == typeof t }, np = au, rp = ep; var ip = function (t) { return rp(t) && "[object Arguments]" == np(t) }, op = ep, ap = Object.prototype, sp = ap.hasOwnProperty, lp = ap.propertyIsEnumerable, up = ip(function () { return arguments }()) ? ip : function (t) { return op(t) && sp.call(t, "callee") && !lp.call(t, "callee") }, cp = up, pp = Array.isArray; var hp = function (t) { return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991 }, fp = pu, dp = hp; var mp = function (t) { return null != t && dp(t.length) && !fp(t) }, vp = mp, yp = ep; var gp = function (t) { return yp(t) && vp(t) }, _p = { exports: {} }; var xp = function () { return !1 }; !function (t, e) { var n = Zl, r = xp, i = e && !e.nodeType && e, o = i && t && !t.nodeType && t, a = o && o.exports === i ? n.Buffer : void 0, s = (a ? a.isBuffer : void 0) || r; t.exports = s }(_p, _p.exports); var bp = au, wp = Zc, Sp = ep, Ep = Function.prototype, Cp = Object.prototype, Tp = Ep.toString, Ap = Cp.hasOwnProperty, Mp = Tp.call(Object); var Op = function (t) { if (!Sp(t) || "[object Object]" != bp(t)) return !1; var e = wp(t); if (null === e) return !0; var n = Ap.call(e, "constructor") && e.constructor; return "function" == typeof n && n instanceof n && Tp.call(n) == Mp }, kp = au, Ip = hp, Pp = ep, Lp = {}; Lp["[object Float32Array]"] = Lp["[object Float64Array]"] = Lp["[object Int8Array]"] = Lp["[object Int16Array]"] = Lp["[object Int32Array]"] = Lp["[object Uint8Array]"] = Lp["[object Uint8ClampedArray]"] = Lp["[object Uint16Array]"] = Lp["[object Uint32Array]"] = !0, Lp["[object Arguments]"] = Lp["[object Array]"] = Lp["[object ArrayBuffer]"] = Lp["[object Boolean]"] = Lp["[object DataView]"] = Lp["[object Date]"] = Lp["[object Error]"] = Lp["[object Function]"] = Lp["[object Map]"] = Lp["[object Number]"] = Lp["[object Object]"] = Lp["[object RegExp]"] = Lp["[object Set]"] = Lp["[object String]"] = Lp["[object WeakMap]"] = !1; var Rp = function (t) { return Pp(t) && Ip(t.length) && !!Lp[kp(t)] }; var Dp = function (t) { return function (e) { return t(e) } }, Np = { exports: {} }; !function (t, e) { var n = Wl, r = e && !e.nodeType && e, i = r && t && !t.nodeType && t, o = i && i.exports === r && n.process, a = function () { try { var t = i && i.require && i.require("util").types; return t || o && o.binding && o.binding("util") } catch (t) { } }(); t.exports = a }(Np, Np.exports); var zp = Rp, Fp = Dp, Bp = Np.exports, jp = Bp && Bp.isTypedArray, Up = jp ? Fp(jp) : zp; var Vp = function (t, e) { if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e] }, Gp = kc, Hp = wl, Wp = Object.prototype.hasOwnProperty; var Xp = function (t, e, n) { var r = t[e]; Wp.call(t, e) && Hp(r, n) && (void 0 !== n || e in t) || Gp(t, e, n) }, qp = Xp, Zp = kc; var Yp = function (t, e, n, r) { var i = !n; n || (n = {}); for (var o = -1, a = e.length; ++o < a;) { var s = e[o], l = r ? r(n[s], t[s], s, n, t) : void 0; void 0 === l && (l = t[s]), i ? Zp(n, s, l) : qp(n, s, l) } return n }; var Kp = function (t, e) { for (var n = -1, r = Array(t); ++n < t;)r[n] = e(n); return r }, Qp = /^(?:0|[1-9]\d*)$/; var Jp = function (t, e) { var n = typeof t; return !!(e = null == e ? 9007199254740991 : e) && ("number" == n || "symbol" != n && Qp.test(t)) && t > -1 && t % 1 == 0 && t < e }, $p = Kp, th = cp, eh = pp, nh = _p.exports, rh = Jp, ih = Up, oh = Object.prototype.hasOwnProperty; var ah = function (t, e) { var n = eh(t), r = !n && th(t), i = !n && !r && nh(t), o = !n && !r && !i && ih(t), a = n || r || i || o, s = a ? $p(t.length, String) : [], l = s.length; for (var u in t) !e && !oh.call(t, u) || a && ("length" == u || i && ("offset" == u || "parent" == u) || o && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || rh(u, l)) || s.push(u); return s }; var sh = function (t) { var e = []; if (null != t) for (var n in Object(t)) e.push(n); return e }, lh = su, uh = Kc, ch = sh, ph = Object.prototype.hasOwnProperty; var hh = function (t) { if (!lh(t)) return ch(t); var e = uh(t), n = []; for (var r in t) ("constructor" != r || !e && ph.call(t, r)) && n.push(r); return n }, fh = ah, dh = hh, mh = mp; var vh = function (t) { return mh(t) ? fh(t, !0) : dh(t) }, yh = Yp, gh = vh; var _h = Lc, xh = Nc.exports, bh = Uc, wh = Vc, Sh = tp, Eh = cp, Ch = pp, Th = gp, Ah = _p.exports, Mh = pu, Oh = su, kh = Op, Ih = Up, Ph = Vp, Lh = function (t) { return yh(t, gh(t)) }; var Rh = function (t, e, n, r, i, o, a) { var s = Ph(t, n), l = Ph(e, n), u = a.get(l); if (u) _h(t, n, u); else { var c = o ? o(s, l, n + "", t, e, a) : void 0, p = void 0 === c; if (p) { var h = Ch(l), f = !h && Ah(l), d = !h && !f && Ih(l); c = l, h || f || d ? Ch(s) ? c = s : Th(s) ? c = wh(s) : f ? (p = !1, c = xh(l, !0)) : d ? (p = !1, c = bh(l, !0)) : c = [] : kh(l) || Eh(l) ? (c = s, Eh(s) ? c = Lh(s) : Oh(s) && !Mh(s) || (c = Sh(l))) : p = !1 } p && (a.set(l, c), i(c, l, r, o, a), a.delete(l)), _h(t, n, c) } }, Dh = Cc, Nh = Lc, zh = Dc, Fh = Rh, Bh = su, jh = vh, Uh = Vp; var Vh = function t(e, n, r, i, o) { e !== n && zh(n, (function (a, s) { if (o || (o = new Dh), Bh(a)) Fh(e, n, s, r, t, i, o); else { var l = i ? i(Uh(e, s), a, s + "", e, n, o) : void 0; void 0 === l && (l = a), Nh(e, s, l) } }), jh) }; var Gh = function (t) { return t }; var Hh = function (t, e, n) { switch (n.length) { case 0: return t.call(e); case 1: return t.call(e, n[0]); case 2: return t.call(e, n[0], n[1]); case 3: return t.call(e, n[0], n[1], n[2]) }return t.apply(e, n) }, Wh = Hh, Xh = Math.max; var qh = function (t, e, n) { return e = Xh(void 0 === e ? t.length - 1 : e, 0), function () { for (var r = arguments, i = -1, o = Xh(r.length - e, 0), a = Array(o); ++i < o;)a[i] = r[e + i]; i = -1; for (var s = Array(e + 1); ++i < e;)s[i] = r[i]; return s[e] = n(a), Wh(t, this, s) } }; var Zh = function (t) { return function () { return t } }, Yh = Mc, Kh = Yh ? function (t, e) { return Yh(t, "toString", { configurable: !0, enumerable: !1, value: Zh(e), writable: !0 }) } : Gh, Qh = Kh, Jh = Date.now; var $h = function (t) { var e = 0, n = 0; return function () { var r = Jh(), i = 16 - (r - n); if (n = r, i > 0) { if (++e >= 800) return arguments[0] } else e = 0; return t.apply(void 0, arguments) } }, tf = $h(Qh), ef = Gh, nf = qh, rf = tf; var of = function (t, e) { return rf(nf(t, e, ef), t + "") }, af = wl, sf = mp, lf = Jp, uf = su; var cf = function (t, e, n) { if (!uf(n)) return !1; var r = typeof e; return !!("number" == r ? sf(n) && lf(e, n.length) : "string" == r && e in n) && af(n[e], t) }, pf = of, hf = cf; var ff, df = function (t) { return pf((function (e, n) { var r = -1, i = n.length, o = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0; for (o = t.length > 3 && "function" == typeof o ? (i--, o) : void 0, a && hf(n[0], n[1], a) && (o = i < 3 ? void 0 : o, i = 1), e = Object(e); ++r < i;) { var s = n[r]; s && t(e, s, r, o) } return e })) }, mf = Vh, vf = df((function (t, e, n) { mf(t, e, n) })), yf = vf, gf = { MapToken: "您正在使用 Demo测试地图token，如果生产环境中使用去对应地图请注册Token", SDK: "请确认引入了mapbox-gl api且在L7之前引入" }; function _f(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function xf(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? _f(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _f(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var bf = { id: "map", logoPosition: "bottomleft", logoVisible: !0, antialias: !0, preserveDrawingBuffer: !1, pickBufferScale: 1, fitBoundsOptions: { animate: !1 } }, wf = { colors: ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"], size: 10, shape: "circle", scales: {}, shape2d: ["circle", "triangle", "square", "pentagon", "hexagon", "octogon", "hexagram", "rhombus", "vesica"], shape3d: ["cylinder", "triangleColumn", "hexagonColumn", "squareColumn"], minZoom: -1, maxZoom: 24, visible: !0, autoFit: !1, pickingBuffer: 0, enablePropagation: !1, zIndex: 0, blend: "normal", pickedFeatureID: -1, enableMultiPassRenderer: !1, enablePicking: !0, active: !1, activeColor: "#2f54eb", enableHighlight: !1, enableSelect: !1, highlightColor: "#2f54eb", activeMix: 0, selectColor: "blue", selectMix: 0, enableTAA: !1, jitterScale: 1, enableLighting: !1, animateOption: { enable: !1, interval: .2, duration: 4, trailLength: .15 }, forward: !0 }, Sf = ut.injectable()(ff = function () { function t() { Ar(this, t), kr(this, "sceneConfigCache", {}), kr(this, "layerConfigCache", {}) } return Or(t, [{ key: "getSceneConfig", value: function (t) { return this.sceneConfigCache[t] } }, { key: "getSceneWarninfo", value: function (t) { return gf[t] } }, { key: "setSceneConfig", value: function (t, e) { this.sceneConfigCache[t] = xf(xf({}, bf), e) } }, { key: "getLayerConfig", value: function (t) { return this.layerConfigCache[t] } }, { key: "setLayerConfig", value: function (t, e, n) { this.layerConfigCache[e] = xf({}, yf({}, this.sceneConfigCache[t], wf, n)) } }, { key: "clean", value: function () { this.sceneConfigCache = {}, this.layerConfigCache = {} } }]), t }()) || ff; function Ef(t, e, n, r) { n && Object.defineProperty(t, e, { enumerable: n.enumerable, configurable: n.configurable, writable: n.writable, value: n.initializer ? n.initializer.call(r) : void 0 }) } function Cf(t, e, n, r, i) { var o = {}; return Object.keys(r).forEach((function (t) { o[t] = r[t] })), o.enumerable = !!o.enumerable, o.configurable = !!o.configurable, ("value" in o || o.initializer) && (o.writable = !0), o = n.slice().reverse().reduce((function (n, r) { return r(t, e, n) || n }), o), i && void 0 !== o.initializer && (o.value = o.initializer ? o.initializer.call(i) : void 0, o.initializer = void 0), void 0 === o.initializer && (Object.defineProperty(t, e, o), o = null), o } var Tf, Af = Math.PI / 180, Mf = 4003e4; function Of(t) { var e = t.latitude, n = void 0 === e ? 0 : e, r = t.zoom, i = void 0 === r ? 0 : r, o = t.scale, a = t.highPrecision, s = void 0 !== a && a, l = t.flipY, u = void 0 !== l && l, c = {}, p = 512 * (o = void 0 !== o ? o : Math.pow(2, i)), h = Math.cos(n * Af), f = p / 360, d = f / h, m = p / Mf / h; if (c.pixelsPerMeter = [m, -m, m], c.metersPerPixel = [1 / m, -1 / m, 1 / m], c.pixelsPerDegree = [f, -d, m], c.degreesPerPixel = [1 / f, -1 / d, 1 / m], s) { var v = Af * Math.tan(n * Af) / h, y = f * v / 2, g = p / Mf * v, _ = g / d * m; c.pixelsPerDegree2 = [0, -y, g], c.pixelsPerMeter2 = [_, 0, _], u && (c.pixelsPerDegree2[1] = -c.pixelsPerDegree2[1], c.pixelsPerMeter2[1] = -c.pixelsPerMeter2[1]) } return u && (c.pixelsPerMeter[1] = -c.pixelsPerMeter[1], c.metersPerPixel[1] = -c.metersPerPixel[1], c.pixelsPerDegree[1] = -c.pixelsPerDegree[1], c.degreesPerPixel[1] = -c.degreesPerPixel[1]), c } !function (t) { t[t.LNGLAT = 1] = "LNGLAT", t[t.LNGLAT_OFFSET = 2] = "LNGLAT_OFFSET", t[t.VECTOR_TILE = 3] = "VECTOR_TILE", t[t.IDENTITY = 4] = "IDENTITY", t[t.P20 = 5] = "P20", t[t.P20_OFFSET = 6] = "P20_OFFSET", t[t.METER_OFFSET = 7] = "METER_OFFSET", t[t.P20_2 = 8] = "P20_2" }(Tf || (Tf = {})); var kf, If, Pf, Lf, Rf, Df = "u_CoordinateSystem", Nf = "u_ViewportCenter", zf = "u_ViewportCenterProjection", Ff = "u_PixelsPerDegree", Bf = "u_PixelsPerDegree2", jf = "u_PixelsPerMeter", Uf = "u_Mvp", Vf = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], Gf = (kf = ut.injectable(), If = ut.inject(Tr.ICameraService), kf((Lf = function () { function t() { Ar(this, t), kr(this, "needRefresh", !0), Ef(this, "cameraService", Rf, this), kr(this, "coordinateSystem", void 0), kr(this, "viewportCenter", void 0), kr(this, "viewportCenterProjection", void 0), kr(this, "pixelsPerDegree", void 0), kr(this, "pixelsPerDegree2", void 0), kr(this, "pixelsPerMeter", void 0) } return Or(t, [{ key: "refresh", value: function () { var t = this.cameraService.getZoom(), e = this.cameraService.getZoomScale(), n = this.cameraService.getCenter(), r = Of({ latitude: n[1], zoom: t }), i = r.pixelsPerMeter, o = r.pixelsPerDegree; this.viewportCenter = n, this.viewportCenterProjection = [0, 0, 0, 0], this.pixelsPerMeter = i, this.pixelsPerDegree = o, this.pixelsPerDegree2 = [0, 0, 0], this.coordinateSystem === Tf.LNGLAT || this.coordinateSystem === Tf.P20 ? this.cameraService.setViewProjectionMatrix(void 0) : this.coordinateSystem === Tf.LNGLAT_OFFSET ? this.calculateLnglatOffset(n, t) : this.coordinateSystem === Tf.P20_OFFSET && this.calculateLnglatOffset(n, t, e, !0), this.needRefresh = !1 } }, { key: "getCoordinateSystem", value: function () { return this.coordinateSystem } }, { key: "setCoordinateSystem", value: function (t) { this.coordinateSystem = t } }, { key: "getViewportCenter", value: function () { return this.viewportCenter } }, { key: "getViewportCenterProjection", value: function () { return this.viewportCenterProjection } }, { key: "getPixelsPerDegree", value: function () { return this.pixelsPerDegree } }, { key: "getPixelsPerDegree2", value: function () { return this.pixelsPerDegree2 } }, { key: "getPixelsPerMeter", value: function () { return this.pixelsPerMeter } }, { key: "calculateLnglatOffset", value: function (t, e, n, r) { var i = Of({ latitude: t[1], zoom: e, scale: n, flipY: r, highPrecision: !0 }), o = i.pixelsPerMeter, a = i.pixelsPerDegree, s = i.pixelsPerDegree2, l = this.cameraService.getViewMatrix(), u = this.cameraService.getProjectionMatrix(), c = cs([], u, l), p = this.cameraService.projectFlat([Math.fround(t[0]), Math.fround(t[1])], Math.pow(2, e)); this.viewportCenterProjection = el([], [p[0], p[1], 0, 1], c), c = cs([], u, l = this.cameraService.getViewMatrixUncentered() || l), c = cs([], c, Vf), this.cameraService.setViewProjectionMatrix(c), this.pixelsPerMeter = o, this.pixelsPerDegree = a, this.pixelsPerDegree2 = s } }]), t }(), Rf = Cf(Lf.prototype, "cameraService", [If], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Pf = Lf)) || Pf), Hf = { exports: {} };
    /*! Hammer.JS - v2.0.7 - 2016-04-22
         * http://hammerjs.github.io/
         *
         * Copyright (c) 2016 Jorik Tangelder;
         * Licensed under the MIT license */
    !function (t) { !function (e, n, r, i) { var o, a = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, s = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram), l = a || s, u = ["", "webkit", "Moz", "MS", "ms", "o"], c = l ? "" : n.createElement("div"), p = Math.round, h = Math.abs, f = Date.now; function d(t, e, n) { return setTimeout(b(t, n), e) } function m(t, e, n) { return !!Array.isArray(t) && (v(t, n[e], n), !0) } function v(t, e, n) { var r; if (t) if (t.forEach) t.forEach(e, n); else if (t.length !== i) for (r = 0; r < t.length;)e.call(n, t[r], r, t), r++; else for (r in t) t.hasOwnProperty(r) && e.call(n, t[r], r, t) } function y(t, n, r) { var i = "DEPRECATED METHOD: " + n + "\n" + r + " AT \n"; return function () { var n = new Error("get-stack-trace"), r = n && n.stack ? n.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", o = e.console && (e.console.warn || e.console.log); return o && o.call(e.console, i, r), t.apply(this, arguments) } } o = "function" != typeof Object.assign ? function (t) { if (t === i || null === t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 1; n < arguments.length; n++) { var r = arguments[n]; if (r !== i && null !== r) for (var o in r) r.hasOwnProperty(o) && (e[o] = r[o]) } return e } : Object.assign; var g = y((function (t, e, n) { for (var r = Object.keys(e), o = 0; o < r.length;)(!n || n && t[r[o]] === i) && (t[r[o]] = e[r[o]]), o++; return t }), "extend", "Use `assign`."), _ = y((function (t, e) { return g(t, e, !0) }), "merge", "Use `assign`."); function x(t, e, n) { var r, i = e.prototype; (r = t.prototype = Object.create(i)).constructor = t, r._super = i, n && o(r, n) } function b(t, e) { return function () { return t.apply(e, arguments) } } function w(t, e) { return "function" == typeof t ? t.apply(e && e[0] || i, e) : t } function S(t, e) { return t === i ? e : t } function E(t, e, n) { v(M(e), (function (e) { t.addEventListener(e, n, !1) })) } function C(t, e, n) { v(M(e), (function (e) { t.removeEventListener(e, n, !1) })) } function T(t, e) { for (; t;) { if (t == e) return !0; t = t.parentNode } return !1 } function A(t, e) { return t.indexOf(e) > -1 } function M(t) { return t.trim().split(/\s+/g) } function O(t, e, n) { if (t.indexOf && !n) return t.indexOf(e); for (var r = 0; r < t.length;) { if (n && t[r][n] == e || !n && t[r] === e) return r; r++ } return -1 } function k(t) { return Array.prototype.slice.call(t, 0) } function I(t, e, n) { for (var r = [], i = [], o = 0; o < t.length;) { var a = e ? t[o][e] : t[o]; O(i, a) < 0 && r.push(t[o]), i[o] = a, o++ } return n && (r = e ? r.sort((function (t, n) { return t[e] > n[e] })) : r.sort()), r } function P(t, e) { for (var n, r, o = e[0].toUpperCase() + e.slice(1), a = 0; a < u.length;) { if ((r = (n = u[a]) ? n + o : e) in t) return r; a++ } return i } var L = 1; function R(t) { var n = t.ownerDocument || t; return n.defaultView || n.parentWindow || e } var D = "ontouchstart" in e, N = P(e, "PointerEvent") !== i, z = D && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), F = "touch", B = "mouse", j = 24, U = ["x", "y"], V = ["clientX", "clientY"]; function G(t, e) { var n = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { w(t.options.enable, [t]) && n.handler(e) }, this.init() } function H(t, e, n) { var r = n.pointers.length, o = n.changedPointers.length, a = 1 & e && r - o == 0, s = 12 & e && r - o == 0; n.isFirst = !!a, n.isFinal = !!s, a && (t.session = {}), n.eventType = e, function (t, e) { var n = t.session, r = e.pointers, o = r.length; n.firstInput || (n.firstInput = W(e)); o > 1 && !n.firstMultiple ? n.firstMultiple = W(e) : 1 === o && (n.firstMultiple = !1); var a = n.firstInput, s = n.firstMultiple, l = s ? s.center : a.center, u = e.center = X(r); e.timeStamp = f(), e.deltaTime = e.timeStamp - a.timeStamp, e.angle = K(l, u), e.distance = Y(l, u), function (t, e) { var n = e.center, r = t.offsetDelta || {}, i = t.prevDelta || {}, o = t.prevInput || {}; 1 !== e.eventType && 4 !== o.eventType || (i = t.prevDelta = { x: o.deltaX || 0, y: o.deltaY || 0 }, r = t.offsetDelta = { x: n.x, y: n.y }); e.deltaX = i.x + (n.x - r.x), e.deltaY = i.y + (n.y - r.y) }(n, e), e.offsetDirection = Z(e.deltaX, e.deltaY); var c = q(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = c.x, e.overallVelocityY = c.y, e.overallVelocity = h(c.x) > h(c.y) ? c.x : c.y, e.scale = s ? (p = s.pointers, d = r, Y(d[0], d[1], V) / Y(p[0], p[1], V)) : 1, e.rotation = s ? function (t, e) { return K(e[1], e[0], V) + K(t[1], t[0], V) }(s.pointers, r) : 0, e.maxPointers = n.prevInput ? e.pointers.length > n.prevInput.maxPointers ? e.pointers.length : n.prevInput.maxPointers : e.pointers.length, function (t, e) { var n, r, o, a, s = t.lastInterval || e, l = e.timeStamp - s.timeStamp; if (8 != e.eventType && (l > 25 || s.velocity === i)) { var u = e.deltaX - s.deltaX, c = e.deltaY - s.deltaY, p = q(l, u, c); r = p.x, o = p.y, n = h(p.x) > h(p.y) ? p.x : p.y, a = Z(u, c), t.lastInterval = e } else n = s.velocity, r = s.velocityX, o = s.velocityY, a = s.direction; e.velocity = n, e.velocityX = r, e.velocityY = o, e.direction = a }(n, e); var p, d; var m = t.element; T(e.srcEvent.target, m) && (m = e.srcEvent.target); e.target = m }(t, n), t.emit("hammer.input", n), t.recognize(n), t.session.prevInput = n } function W(t) { for (var e = [], n = 0; n < t.pointers.length;)e[n] = { clientX: p(t.pointers[n].clientX), clientY: p(t.pointers[n].clientY) }, n++; return { timeStamp: f(), pointers: e, center: X(e), deltaX: t.deltaX, deltaY: t.deltaY } } function X(t) { var e = t.length; if (1 === e) return { x: p(t[0].clientX), y: p(t[0].clientY) }; for (var n = 0, r = 0, i = 0; i < e;)n += t[i].clientX, r += t[i].clientY, i++; return { x: p(n / e), y: p(r / e) } } function q(t, e, n) { return { x: e / t || 0, y: n / t || 0 } } function Z(t, e) { return t === e ? 1 : h(t) >= h(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 } function Y(t, e, n) { n || (n = U); var r = e[n[0]] - t[n[0]], i = e[n[1]] - t[n[1]]; return Math.sqrt(r * r + i * i) } function K(t, e, n) { n || (n = U); var r = e[n[0]] - t[n[0]], i = e[n[1]] - t[n[1]]; return 180 * Math.atan2(i, r) / Math.PI } G.prototype = { handler: function () { }, init: function () { this.evEl && E(this.element, this.evEl, this.domHandler), this.evTarget && E(this.target, this.evTarget, this.domHandler), this.evWin && E(R(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && C(this.element, this.evEl, this.domHandler), this.evTarget && C(this.target, this.evTarget, this.domHandler), this.evWin && C(R(this.element), this.evWin, this.domHandler) } }; var Q = { mousedown: 1, mousemove: 2, mouseup: 4 }, J = "mousedown", $ = "mousemove mouseup"; function tt() { this.evEl = J, this.evWin = $, this.pressed = !1, G.apply(this, arguments) } x(tt, G, { handler: function (t) { var e = Q[t.type]; 1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: B, srcEvent: t })) } }); var et = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, nt = { 2: F, 3: "pen", 4: B, 5: "kinect" }, rt = "pointerdown", it = "pointermove pointerup pointercancel"; function ot() { this.evEl = rt, this.evWin = it, G.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } l || !e.MSPointerEvent || e.PointerEvent || (rt = "MSPointerDown", it = "MSPointerMove MSPointerUp MSPointerCancel"), x(ot, G, { handler: function (t) { var e = this.store, n = !1, r = t.type.toLowerCase().replace("ms", ""), i = et[r], o = nt[t.pointerType] || t.pointerType, a = o == F, s = O(e, t.pointerId, "pointerId"); 1 & i && (0 === t.button || a) ? s < 0 && (e.push(t), s = e.length - 1) : 12 & i && (n = !0), s < 0 || (e[s] = t, this.callback(this.manager, i, { pointers: e, changedPointers: [t], pointerType: o, srcEvent: t }), n && e.splice(s, 1)) } }); var at = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, st = "touchstart", lt = "touchstart touchmove touchend touchcancel"; function ut() { this.evTarget = st, this.evWin = lt, this.started = !1, G.apply(this, arguments) } function ct(t, e) { var n = k(t.touches), r = k(t.changedTouches); return 12 & e && (n = I(n.concat(r), "identifier", !0)), [n, r] } x(ut, G, { handler: function (t) { var e = at[t.type]; if (1 === e && (this.started = !0), this.started) { var n = ct.call(this, t, e); 12 & e && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: F, srcEvent: t }) } } }); var pt = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, ht = "touchstart touchmove touchend touchcancel"; function ft() { this.evTarget = ht, this.targetIds = {}, G.apply(this, arguments) } function dt(t, e) { var n = k(t.touches), r = this.targetIds; if (3 & e && 1 === n.length) return r[n[0].identifier] = !0, [n, n]; var i, o, a = k(t.changedTouches), s = [], l = this.target; if (o = n.filter((function (t) { return T(t.target, l) })), 1 === e) for (i = 0; i < o.length;)r[o[i].identifier] = !0, i++; for (i = 0; i < a.length;)r[a[i].identifier] && s.push(a[i]), 12 & e && delete r[a[i].identifier], i++; return s.length ? [I(o.concat(s), "identifier", !0), s] : void 0 } x(ft, G, { handler: function (t) { var e = pt[t.type], n = dt.call(this, t, e); n && this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: F, srcEvent: t }) } }); function mt() { G.apply(this, arguments); var t = b(this.handler, this); this.touch = new ft(this.manager, t), this.mouse = new tt(this.manager, t), this.primaryTouch = null, this.lastTouches = [] } function vt(t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, yt.call(this, e)) : 12 & t && yt.call(this, e) } function yt(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var n = { x: e.clientX, y: e.clientY }; this.lastTouches.push(n); var r = this.lastTouches; setTimeout((function () { var t = r.indexOf(n); t > -1 && r.splice(t, 1) }), 2500) } } function gt(t) { for (var e = t.srcEvent.clientX, n = t.srcEvent.clientY, r = 0; r < this.lastTouches.length; r++) { var i = this.lastTouches[r], o = Math.abs(e - i.x), a = Math.abs(n - i.y); if (o <= 25 && a <= 25) return !0 } return !1 } x(mt, G, { handler: function (t, e, n) { var r = n.pointerType == F, i = n.pointerType == B; if (!(i && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) { if (r) vt.call(this, e, n); else if (i && gt.call(this, n)) return; this.callback(t, e, n) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var _t = l ? i : P(c.style, "touchAction"), xt = _t !== i, bt = "compute", wt = "auto", St = "manipulation", Et = "none", Ct = "pan-x", Tt = "pan-y", At = function () { if (!xt) return !1; var t = {}; if (l) return t; var n = e.CSS && e.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (r) { t[r] = !n || e.CSS.supports("touch-action", r) })), t }(); function Mt(t, e) { this.manager = t, this.set(e) } Mt.prototype = { set: function (t) { t == bt && (t = this.compute()), xt && this.manager.element.style && At[t] && (this.manager.element.style[_t] = t), this.actions = t.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var t = []; return v(this.manager.recognizers, (function (e) { w(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) })), function (t) { if (A(t, Et)) return Et; var e = A(t, Ct), n = A(t, Tt); if (e && n) return Et; if (e || n) return e ? Ct : Tt; if (A(t, St)) return St; return wt }(t.join(" ")) }, preventDefaults: function (t) { var e = t.srcEvent, n = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault(); else { var r = this.actions, i = A(r, Et) && !At.none, o = A(r, Tt) && !At["pan-y"], a = A(r, Ct) && !At["pan-x"]; if (i) { var s = 1 === t.pointers.length, l = t.distance < 2, u = t.deltaTime < 250; if (s && l && u) return } if (!a || !o) return i || o && 6 & n || a && n & j ? this.preventSrc(e) : void 0 } }, preventSrc: function (t) { this.manager.session.prevented = !0, t.preventDefault() } }; var Ot = 32; function kt(t) { this.options = o({}, this.defaults, t || {}), this.id = L++, this.manager = null, this.options.enable = S(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function It(t) { return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : "" } function Pt(t) { return 16 == t ? "down" : 8 == t ? "up" : 2 == t ? "left" : 4 == t ? "right" : "" } function Lt(t, e) { var n = e.manager; return n ? n.get(t) : t } function Rt() { kt.apply(this, arguments) } function Dt() { Rt.apply(this, arguments), this.pX = null, this.pY = null } function Nt() { Rt.apply(this, arguments) } function zt() { kt.apply(this, arguments), this._timer = null, this._input = null } function Ft() { Rt.apply(this, arguments) } function Bt() { Rt.apply(this, arguments) } function jt() { kt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Ut(t, e) { return (e = e || {}).recognizers = S(e.recognizers, Ut.defaults.preset), new Vt(t, e) } kt.prototype = { defaults: {}, set: function (t) { return o(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (t) { if (m(t, "recognizeWith", this)) return this; var e = this.simultaneous; return e[(t = Lt(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function (t) { return m(t, "dropRecognizeWith", this) || (t = Lt(t, this), delete this.simultaneous[t.id]), this }, requireFailure: function (t) { if (m(t, "requireFailure", this)) return this; var e = this.requireFail; return -1 === O(e, t = Lt(t, this)) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function (t) { if (m(t, "dropRequireFailure", this)) return this; t = Lt(t, this); var e = O(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (t) { return !!this.simultaneous[t.id] }, emit: function (t) { var e = this, n = this.state; function r(n) { e.manager.emit(n, t) } n < 8 && r(e.options.event + It(n)), r(e.options.event), t.additionalEvent && r(t.additionalEvent), n >= 8 && r(e.options.event + It(n)) }, tryEmit: function (t) { if (this.canEmit()) return this.emit(t); this.state = Ot }, canEmit: function () { for (var t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) return !1; t++ } return !0 }, recognize: function (t) { var e = o({}, t); if (!w(this.options.enable, [this, e])) return this.reset(), void (this.state = Ot); 56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process: function (t) { }, getTouchAction: function () { }, reset: function () { } }, x(Rt, kt, { defaults: { pointers: 1 }, attrTest: function (t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function (t) { var e = this.state, n = t.eventType, r = 6 & e, i = this.attrTest(t); return r && (8 & n || !i) ? 16 | e : r || i ? 4 & n ? 8 | e : 2 & e ? 4 | e : 2 : Ot } }), x(Dt, Rt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var t = this.options.direction, e = []; return 6 & t && e.push(Tt), t & j && e.push(Ct), e }, directionTest: function (t) { var e = this.options, n = !0, r = t.distance, i = t.direction, o = t.deltaX, a = t.deltaY; return i & e.direction || (6 & e.direction ? (i = 0 === o ? 1 : o < 0 ? 2 : 4, n = o != this.pX, r = Math.abs(t.deltaX)) : (i = 0 === a ? 1 : a < 0 ? 8 : 16, n = a != this.pY, r = Math.abs(t.deltaY))), t.direction = i, n && r > e.threshold && i & e.direction }, attrTest: function (t) { return Rt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit: function (t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = Pt(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), x(Nt, Rt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [Et] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (t) { if (1 !== t.scale) { var e = t.scale < 1 ? "in" : "out"; t.additionalEvent = this.options.event + e } this._super.emit.call(this, t) } }), x(zt, kt, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return [wt] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, r = t.distance < e.threshold, i = t.deltaTime > e.time; if (this._input = t, !r || !n || 12 & t.eventType && !i) this.reset(); else if (1 & t.eventType) this.reset(), this._timer = d((function () { this.state = 8, this.tryEmit() }), e.time, this); else if (4 & t.eventType) return 8; return Ot }, reset: function () { clearTimeout(this._timer) }, emit: function (t) { 8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = f(), this.manager.emit(this.options.event, this._input))) } }), x(Ft, Rt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [Et] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), x(Bt, Rt, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return Dt.prototype.getTouchAction.call(this) }, attrTest: function (t) { var e, n = this.options.direction; return 30 & n ? e = t.overallVelocity : 6 & n ? e = t.overallVelocityX : n & j && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && n & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && h(e) > this.options.velocity && 4 & t.eventType }, emit: function (t) { var e = Pt(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), x(jt, kt, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return [St] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, r = t.distance < e.threshold, i = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout(); if (r && i && n) { if (4 != t.eventType) return this.failTimeout(); var o = !this.pTime || t.timeStamp - this.pTime < e.interval, a = !this.pCenter || Y(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, a && o ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % e.taps) return this.hasRequireFailures() ? (this._timer = d((function () { this.state = 8, this.tryEmit() }), e.interval, this), 2) : 8 } return Ot }, failTimeout: function () { return this._timer = d((function () { this.state = Ot }), this.options.interval, this), Ot }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Ut.VERSION = "2.0.7", Ut.defaults = { domEvents: !1, touchAction: bt, enable: !0, inputTarget: null, inputClass: null, preset: [[Ft, { enable: !1 }], [Nt, { enable: !1 }, ["rotate"]], [Bt, { direction: 6 }], [Dt, { direction: 6 }, ["swipe"]], [jt], [jt, { event: "doubletap", taps: 2 }, ["tap"]], [zt]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }; function Vt(t, e) { var n; this.options = o({}, Ut.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((n = this).options.inputClass || (N ? ot : z ? ft : D ? mt : tt))(n, H), this.touchAction = new Mt(this, this.options.touchAction), Gt(this, !0), v(this.options.recognizers, (function (t) { var e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }), this) } function Gt(t, e) { var n, r = t.element; r.style && (v(t.options.cssProps, (function (i, o) { n = P(r.style, o), e ? (t.oldCssProps[n] = r.style[n], r.style[n] = i) : r.style[n] = t.oldCssProps[n] || "" })), e || (t.oldCssProps = {})) } (Vt.prototype = { set: function (t) { return o(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function (t) { this.session.stopped = t ? 2 : 1 }, recognize: function (t) { var e = this.session; if (!e.stopped) { var n; this.touchAction.preventDefaults(t); var r = this.recognizers, i = e.curRecognizer; (!i || i && 8 & i.state) && (i = e.curRecognizer = null); for (var o = 0; o < r.length;)n = r[o], 2 === e.stopped || i && n != i && !n.canRecognizeWith(i) ? n.reset() : n.recognize(t), !i && 14 & n.state && (i = e.curRecognizer = n), o++ } }, get: function (t) { if (t instanceof kt) return t; for (var e = this.recognizers, n = 0; n < e.length; n++)if (e[n].options.event == t) return e[n]; return null }, add: function (t) { if (m(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function (t) { if (m(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers, n = O(e, t); -1 !== n && (e.splice(n, 1), this.touchAction.update()) } return this }, on: function (t, e) { if (t !== i && e !== i) { var n = this.handlers; return v(M(t), (function (t) { n[t] = n[t] || [], n[t].push(e) })), this } }, off: function (t, e) { if (t !== i) { var n = this.handlers; return v(M(t), (function (t) { e ? n[t] && n[t].splice(O(n[t], e), 1) : delete n[t] })), this } }, emit: function (t, e) { this.options.domEvents && function (t, e) { if (l) return; var r = n.createEvent("Event"); r.initEvent(t, !0, !0), r.gesture = e, e.target.dispatchEvent(r) }(t, e); var r = this.handlers[t] && this.handlers[t].slice(); if (r && r.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (var i = 0; i < r.length;)r[i](e), i++ } }, destroy: function () { this.element && Gt(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, l) || (o(Ut, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: Ot, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: j, DIRECTION_ALL: 30, Manager: Vt, Input: G, TouchAction: Mt, TouchInput: ft, MouseInput: tt, PointerEventInput: ot, TouchMouseInput: mt, SingleTouchInput: ut, Recognizer: kt, AttrRecognizer: Rt, Tap: jt, Pan: Dt, Swipe: Bt, Pinch: Nt, Rotate: Ft, Press: zt, on: E, off: C, each: v, merge: _, extend: g, assign: o, inherit: x, bindFn: b, prefixed: P }), ("undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Hammer = Ut, t.exports ? t.exports = Ut : e.Hammer = Ut) }("undefined" != typeof window ? window : { console: null, MSPointerEvent: null, PointerEvent: null, CSS: null }, document) }(Hf); var Wf, Xf, qf, Zf, Yf, Kf, Qf = Hf.exports; function Jf(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } !function (t) { t.Hover = "hover", t.Click = "click", t.Select = "select", t.Active = "active", t.Drag = "drag" }(Wf || (Wf = {})); var $f = { panstart: "dragstart", panmove: "dragging", panend: "dragend", pancancel: "dragcancel" }, td = (Xf = ut.injectable(), qf = ut.inject(Tr.IMapService), Xf((Yf = function (t) { Ur(n, t); var e = Jf(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "indragging", !1), Ef(Gr(t), "mapService", Kf, Gr(t)), kr(Gr(t), "hammertime", void 0), kr(Gr(t), "lastClickTime", 0), kr(Gr(t), "lastClickXY", [-1, -1]), kr(Gr(t), "clickTimer", void 0), kr(Gr(t), "$containter", void 0), kr(Gr(t), "onDrag", (function (e) { var n = t.interactionEvent(e); n.type = $f[n.type], "dragging" === n.type ? t.indragging = !0 : t.indragging = !1, t.emit(Wf.Drag, n) })), kr(Gr(t), "onHammer", (function (e) { e.srcEvent.stopPropagation(); var n = t.interactionEvent(e); t.emit(Wf.Hover, n) })), kr(Gr(t), "onTouch", (function (e) { var n = e.touches[0]; t.onHover({ x: n.pageX, y: n.pageY, type: "touch" }) })), kr(Gr(t), "onHover", (function (e) { var n = e.clientX, r = e.clientY, i = e.type, o = t.mapService.getMapContainer(); if (o) if (ro) n = n - o.left - 0, r = r - o.top - 0; else { var a = o.getBoundingClientRect(), s = a.top; n = n - a.left - o.clientLeft, r = r - s - o.clientTop } var l = t.mapService.containerToLngLat([n, r]); if ("click" !== i) "touch" !== i ? "click" !== i && "dblclick" !== i && t.emit(Wf.Hover, { x: n, y: r, lngLat: l, type: i, target: e }) : t.isDoubleTap(n, r, l); else { if (!ro && "ontouchstart" in document.documentElement == !0) return; t.isDoubleTap(n, r, l) } })), t } return Or(n, [{ key: "init", value: function () { this.addEventListenerOnMap(), this.$containter = this.mapService.getMapContainer() } }, { key: "destroy", value: function () { this.hammertime && this.hammertime.destroy(), this.removeEventListenerOnMap(), this.off(Wf.Hover) } }, { key: "triggerHover", value: function (t) { var e = t.x, n = t.y; this.emit(Wf.Hover, { x: e, y: n }) } }, { key: "triggerSelect", value: function (t) { this.emit(Wf.Select, { featureId: t }) } }, { key: "triggerActive", value: function (t) { this.emit(Wf.Active, { featureId: t }) } }, { key: "handleMiniEvent", value: function (t) { this.onHover({ clientX: t.touches[0].pageX, clientY: t.touches[0].pageY, type: "touch" }) } }, { key: "addEventListenerOnMap", value: function () { var t = this.mapService.getMapContainer(); if (t) if (ro) oo.document.addEventListener("touchstart", this.handleMiniEvent.bind(this)); else { var e = new Qf.Manager(t); e.add(new Qf.Tap({ event: "dblclick", taps: 2 })), e.add(new Qf.Tap({ event: "click" })), e.add(new Qf.Pan({ threshold: 0, pointers: 0 })), e.add(new Qf.Press({})), e.on("dblclick click", this.onHammer), e.on("panstart panmove panend pancancel", this.onDrag), t.addEventListener("mousemove", this.onHover), t.addEventListener("mousedown", this.onHover, !0), t.addEventListener("mouseup", this.onHover), t.addEventListener("contextmenu", this.onHover), this.hammertime = e } } }, { key: "removeEventListenerOnMap", value: function () { if (ro) oo.document.removeEventListener("touchstart", this.handleMiniEvent.bind(this)); else { var t = this.mapService.getMapContainer(); t && (t.removeEventListener("mousemove", this.onHover), this.hammertime.off("panstart panmove panend pancancel", this.onDrag), t.removeEventListener("mousedown", this.onHover), t.removeEventListener("mouseup", this.onHover), t.removeEventListener("contextmenu", this.onHover)) } } }, { key: "interactionEvent", value: function (t) { var e, n, r = t.type; "touch" === t.pointerType ? (n = Math.floor(t.pointers[0].clientY), e = Math.floor(t.pointers[0].clientX)) : (n = Math.floor(t.srcEvent.y), e = Math.floor(t.srcEvent.x)); var i = this.mapService.getMapContainer(); if (i) { var o = i.getBoundingClientRect(), a = o.top; e -= o.left, n -= a } return { x: e, y: n, lngLat: this.mapService.containerToLngLat([e, n]), type: r, target: t.srcEvent } } }, { key: "isDoubleTap", value: function (t, e, n) { var r = this, i = (new Date).getTime(), o = "click"; i - this.lastClickTime < 400 && Math.abs(this.lastClickXY[0] - t) < 10 && Math.abs(this.lastClickXY[1] - e) < 10 ? (this.lastClickTime = 0, this.lastClickXY = [-1, -1], this.clickTimer && clearTimeout(this.clickTimer), o = "dblclick", this.emit(Wf.Hover, { x: t, y: e, lngLat: n, type: o })) : (this.lastClickTime = i, this.lastClickXY = [t, e], this.clickTimer = setTimeout((function () { o = "click", r.emit(Wf.Hover, { x: t, y: e, lngLat: n, type: o }) }), 400)) } }]), n }(lt), Kf = Cf(Yf.prototype, "mapService", [qf], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Zf = Yf)) || Zf); function ed(t, e, n, r, i, o, a) { try { var s = t[o](a), l = s.value } catch (t) { return void n(t) } s.done ? e(l) : Promise.resolve(l).then(r, i) } function nd(t) { return function () { var e = this, n = arguments; return new Promise((function (r, i) { var o = t.apply(e, n); function a(t) { ed(o, r, i, a, s, "next", t) } function s(t) { ed(o, r, i, a, s, "throw", t) } a(void 0) })) } } var rd = { exports: {} }; !function (t) { var e = function (t) { var e, n = Object.prototype, r = n.hasOwnProperty, i = "function" == typeof Symbol ? Symbol : {}, o = i.iterator || "@@iterator", a = i.asyncIterator || "@@asyncIterator", s = i.toStringTag || "@@toStringTag"; function l(t, e, n) { return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { l({}, "") } catch (t) { l = function (t, e, n) { return t[e] = n } } function u(t, e, n, r) { var i = e && e.prototype instanceof v ? e : v, o = Object.create(i.prototype), a = new M(r || []); return o._invoke = function (t, e, n) { var r = p; return function (i, o) { if (r === f) throw new Error("Generator is already running"); if (r === d) { if ("throw" === i) throw o; return k() } for (n.method = i, n.arg = o; ;) { var a = n.delegate; if (a) { var s = C(a, n); if (s) { if (s === m) continue; return s } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if (r === p) throw r = d, n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); r = f; var l = c(t, e, n); if ("normal" === l.type) { if (r = n.done ? d : h, l.arg === m) continue; return { value: l.arg, done: n.done } } "throw" === l.type && (r = d, n.method = "throw", n.arg = l.arg) } } }(t, n, a), o } function c(t, e, n) { try { return { type: "normal", arg: t.call(e, n) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = u; var p = "suspendedStart", h = "suspendedYield", f = "executing", d = "completed", m = {}; function v() { } function y() { } function g() { } var _ = {}; l(_, o, (function () { return this })); var x = Object.getPrototypeOf, b = x && x(x(O([]))); b && b !== n && r.call(b, o) && (_ = b); var w = g.prototype = v.prototype = Object.create(_); function S(t) { ["next", "throw", "return"].forEach((function (e) { l(t, e, (function (t) { return this._invoke(e, t) })) })) } function E(t, e) { function n(i, o, a, s) { var l = c(t[i], t, o); if ("throw" !== l.type) { var u = l.arg, p = u.value; return p && "object" == typeof p && r.call(p, "__await") ? e.resolve(p.__await).then((function (t) { n("next", t, a, s) }), (function (t) { n("throw", t, a, s) })) : e.resolve(p).then((function (t) { u.value = t, a(u) }), (function (t) { return n("throw", t, a, s) })) } s(l.arg) } var i; this._invoke = function (t, r) { function o() { return new e((function (e, i) { n(t, r, e, i) })) } return i = i ? i.then(o, o) : o() } } function C(t, n) { var r = t.iterator[n.method]; if (r === e) { if (n.delegate = null, "throw" === n.method) { if (t.iterator.return && (n.method = "return", n.arg = e, C(t, n), "throw" === n.method)) return m; n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method") } return m } var i = c(r, t.iterator, n.arg); if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n.delegate = null, m; var o = i.arg; return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, m) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, m) } function T(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function A(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function M(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(T, this), this.reset(!0) } function O(t) { if (t) { var n = t[o]; if (n) return n.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var i = -1, a = function n() { for (; ++i < t.length;)if (r.call(t, i)) return n.value = t[i], n.done = !1, n; return n.value = e, n.done = !0, n }; return a.next = a } } return { next: k } } function k() { return { value: e, done: !0 } } return y.prototype = g, l(w, "constructor", g), l(g, "constructor", y), y.displayName = l(g, s, "GeneratorFunction"), t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === y || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, g) : (t.__proto__ = g, l(t, s, "GeneratorFunction")), t.prototype = Object.create(w), t }, t.awrap = function (t) { return { __await: t } }, S(E.prototype), l(E.prototype, a, (function () { return this })), t.AsyncIterator = E, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); var a = new E(u(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then((function (t) { return t.done ? t.value : a.next() })) }, S(w), l(w, s, "Generator"), l(w, o, (function () { return this })), l(w, "toString", (function () { return "[object Generator]" })), t.keys = function (t) { var e = []; for (var n in t) e.push(n); return e.reverse(), function n() { for (; e.length;) { var r = e.pop(); if (r in t) return n.value = r, n.done = !1, n } return n.done = !0, n } }, t.values = O, M.prototype = { constructor: M, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(A), !t) for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var n = this; function i(r, i) { return s.type = "throw", s.arg = t, n.next = r, i && (n.method = "next", n.arg = e), !!i } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var a = this.tryEntries[o], s = a.completion; if ("root" === a.tryLoc) return i("end"); if (a.tryLoc <= this.prev) { var l = r.call(a, "catchLoc"), u = r.call(a, "finallyLoc"); if (l && u) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc) } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0) } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < a.finallyLoc) return i(a.finallyLoc) } } } }, abrupt: function (t, e) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var o = i; break } } o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null); var a = o ? o.completion : {}; return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, m) : this.complete(a) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), m }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), A(n), m } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.tryLoc === t) { var r = n.completion; if ("throw" === r.type) { var i = r.arg; A(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, n, r) { return this.delegate = { iterator: O(t), resultName: n, nextLoc: r }, "next" === this.method && (this.arg = e), m } }, t }(t.exports); try { regeneratorRuntime = e } catch (t) { "object" == typeof globalThis ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e) } }(rd); var id, od, ad, sd, ld, ud, cd, pd, hd, fd, dd, md, vd, yd, gd = rd.exports, _d = 0; function xd(t) { if (ro) return null; var e = t; if ("string" == typeof t && (e = document.getElementById(t)), e) { var n = document.createElement("div"); return n.style.cssText += "\n      position: absolute;\n      z-index:2;\n      height: 100%;\n      width: 100%;\n      pointer-events: none;\n    ", n.id = "l7-scene-".concat(_d++), n.classList.add("l7-scene"), e.appendChild(n), n } return null } function bd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function wd(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? bd(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : bd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } !function (t) { t[t.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", t[t.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", t[t.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_COLOR = 768] = "SRC_COLOR", t[t.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.DST_ALPHA = 772] = "DST_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", t[t.DST_COLOR = 774] = "DST_COLOR", t[t.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.BLEND_EQUATION = 32777] = "BLEND_EQUATION", t[t.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", t[t.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", t[t.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", t[t.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", t[t.MAX_EXT = 32776] = "MAX_EXT", t[t.MIN_EXT = 32775] = "MIN_EXT", t[t.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", t[t.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", t[t.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", t[t.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", t[t.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", t[t.BLEND_COLOR = 32773] = "BLEND_COLOR", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", t[t.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", t[t.STREAM_DRAW = 35040] = "STREAM_DRAW", t[t.STATIC_DRAW = 35044] = "STATIC_DRAW", t[t.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", t[t.BUFFER_SIZE = 34660] = "BUFFER_SIZE", t[t.BUFFER_USAGE = 34661] = "BUFFER_USAGE", t[t.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", t[t.FRONT = 1028] = "FRONT", t[t.BACK = 1029] = "BACK", t[t.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", t[t.CULL_FACE = 2884] = "CULL_FACE", t[t.BLEND = 3042] = "BLEND", t[t.DITHER = 3024] = "DITHER", t[t.STENCIL_TEST = 2960] = "STENCIL_TEST", t[t.DEPTH_TEST = 2929] = "DEPTH_TEST", t[t.SCISSOR_TEST = 3089] = "SCISSOR_TEST", t[t.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", t[t.NO_ERROR = 0] = "NO_ERROR", t[t.INVALID_ENUM = 1280] = "INVALID_ENUM", t[t.INVALID_VALUE = 1281] = "INVALID_VALUE", t[t.INVALID_OPERATION = 1282] = "INVALID_OPERATION", t[t.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", t[t.CW = 2304] = "CW", t[t.CCW = 2305] = "CCW", t[t.LINE_WIDTH = 2849] = "LINE_WIDTH", t[t.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", t[t.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", t[t.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", t[t.FRONT_FACE = 2886] = "FRONT_FACE", t[t.DEPTH_RANGE = 2928] = "DEPTH_RANGE", t[t.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", t[t.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", t[t.DEPTH_FUNC = 2932] = "DEPTH_FUNC", t[t.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", t[t.STENCIL_FUNC = 2962] = "STENCIL_FUNC", t[t.STENCIL_FAIL = 2964] = "STENCIL_FAIL", t[t.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", t[t.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", t[t.STENCIL_REF = 2967] = "STENCIL_REF", t[t.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", t[t.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", t[t.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", t[t.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", t[t.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", t[t.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", t[t.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", t[t.VIEWPORT = 2978] = "VIEWPORT", t[t.SCISSOR_BOX = 3088] = "SCISSOR_BOX", t[t.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", t[t.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", t[t.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", t[t.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", t[t.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", t[t.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", t[t.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", t[t.RED_BITS = 3410] = "RED_BITS", t[t.GREEN_BITS = 3411] = "GREEN_BITS", t[t.BLUE_BITS = 3412] = "BLUE_BITS", t[t.ALPHA_BITS = 3413] = "ALPHA_BITS", t[t.DEPTH_BITS = 3414] = "DEPTH_BITS", t[t.STENCIL_BITS = 3415] = "STENCIL_BITS", t[t.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", t[t.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", t[t.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", t[t.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", t[t.SAMPLES = 32937] = "SAMPLES", t[t.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", t[t.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", t[t.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", t[t.DONT_CARE = 4352] = "DONT_CARE", t[t.FASTEST = 4353] = "FASTEST", t[t.NICEST = 4354] = "NICEST", t[t.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", t[t.BYTE = 5120] = "BYTE", t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.SHORT = 5122] = "SHORT", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.INT = 5124] = "INT", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.FLOAT = 5126] = "FLOAT", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.ALPHA = 6406] = "ALPHA", t[t.RGB = 6407] = "RGB", t[t.RGBA = 6408] = "RGBA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", t[t.VERTEX_SHADER = 35633] = "VERTEX_SHADER", t[t.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", t[t.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", t[t.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", t[t.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", t[t.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", t[t.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", t[t.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", t[t.SHADER_TYPE = 35663] = "SHADER_TYPE", t[t.DELETE_STATUS = 35712] = "DELETE_STATUS", t[t.LINK_STATUS = 35714] = "LINK_STATUS", t[t.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", t[t.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", t[t.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", t[t.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", t[t.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", t[t.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", t[t.NEVER = 512] = "NEVER", t[t.LESS = 513] = "LESS", t[t.EQUAL = 514] = "EQUAL", t[t.LEQUAL = 515] = "LEQUAL", t[t.GREATER = 516] = "GREATER", t[t.NOTEQUAL = 517] = "NOTEQUAL", t[t.GEQUAL = 518] = "GEQUAL", t[t.ALWAYS = 519] = "ALWAYS", t[t.KEEP = 7680] = "KEEP", t[t.REPLACE = 7681] = "REPLACE", t[t.INCR = 7682] = "INCR", t[t.DECR = 7683] = "DECR", t[t.INVERT = 5386] = "INVERT", t[t.INCR_WRAP = 34055] = "INCR_WRAP", t[t.DECR_WRAP = 34056] = "DECR_WRAP", t[t.VENDOR = 7936] = "VENDOR", t[t.RENDERER = 7937] = "RENDERER", t[t.VERSION = 7938] = "VERSION", t[t.NEAREST = 9728] = "NEAREST", t[t.LINEAR = 9729] = "LINEAR", t[t.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", t[t.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", t[t.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", t[t.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE = 5890] = "TEXTURE", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t[t.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", t[t.TEXTURE0 = 33984] = "TEXTURE0", t[t.TEXTURE1 = 33985] = "TEXTURE1", t[t.TEXTURE2 = 33986] = "TEXTURE2", t[t.TEXTURE3 = 33987] = "TEXTURE3", t[t.TEXTURE4 = 33988] = "TEXTURE4", t[t.TEXTURE5 = 33989] = "TEXTURE5", t[t.TEXTURE6 = 33990] = "TEXTURE6", t[t.TEXTURE7 = 33991] = "TEXTURE7", t[t.TEXTURE8 = 33992] = "TEXTURE8", t[t.TEXTURE9 = 33993] = "TEXTURE9", t[t.TEXTURE10 = 33994] = "TEXTURE10", t[t.TEXTURE11 = 33995] = "TEXTURE11", t[t.TEXTURE12 = 33996] = "TEXTURE12", t[t.TEXTURE13 = 33997] = "TEXTURE13", t[t.TEXTURE14 = 33998] = "TEXTURE14", t[t.TEXTURE15 = 33999] = "TEXTURE15", t[t.TEXTURE16 = 34e3] = "TEXTURE16", t[t.TEXTURE17 = 34001] = "TEXTURE17", t[t.TEXTURE18 = 34002] = "TEXTURE18", t[t.TEXTURE19 = 34003] = "TEXTURE19", t[t.TEXTURE20 = 34004] = "TEXTURE20", t[t.TEXTURE21 = 34005] = "TEXTURE21", t[t.TEXTURE22 = 34006] = "TEXTURE22", t[t.TEXTURE23 = 34007] = "TEXTURE23", t[t.TEXTURE24 = 34008] = "TEXTURE24", t[t.TEXTURE25 = 34009] = "TEXTURE25", t[t.TEXTURE26 = 34010] = "TEXTURE26", t[t.TEXTURE27 = 34011] = "TEXTURE27", t[t.TEXTURE28 = 34012] = "TEXTURE28", t[t.TEXTURE29 = 34013] = "TEXTURE29", t[t.TEXTURE30 = 34014] = "TEXTURE30", t[t.TEXTURE31 = 34015] = "TEXTURE31", t[t.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", t[t.REPEAT = 10497] = "REPEAT", t[t.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t[t.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", t[t.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", t[t.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", t[t.INT_VEC2 = 35667] = "INT_VEC2", t[t.INT_VEC3 = 35668] = "INT_VEC3", t[t.INT_VEC4 = 35669] = "INT_VEC4", t[t.BOOL = 35670] = "BOOL", t[t.BOOL_VEC2 = 35671] = "BOOL_VEC2", t[t.BOOL_VEC3 = 35672] = "BOOL_VEC3", t[t.BOOL_VEC4 = 35673] = "BOOL_VEC4", t[t.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", t[t.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", t[t.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", t[t.SAMPLER_2D = 35678] = "SAMPLER_2D", t[t.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", t[t.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", t[t.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", t[t.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", t[t.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", t[t.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", t[t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", t[t.COMPILE_STATUS = 35713] = "COMPILE_STATUS", t[t.LOW_FLOAT = 36336] = "LOW_FLOAT", t[t.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", t[t.HIGH_FLOAT = 36338] = "HIGH_FLOAT", t[t.LOW_INT = 36339] = "LOW_INT", t[t.MEDIUM_INT = 36340] = "MEDIUM_INT", t[t.HIGH_INT = 36341] = "HIGH_INT", t[t.FRAMEBUFFER = 36160] = "FRAMEBUFFER", t[t.RENDERBUFFER = 36161] = "RENDERBUFFER", t[t.RGBA4 = 32854] = "RGBA4", t[t.RGB5_A1 = 32855] = "RGB5_A1", t[t.RGB565 = 36194] = "RGB565", t[t.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", t[t.STENCIL_INDEX = 6401] = "STENCIL_INDEX", t[t.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t[t.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", t[t.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", t[t.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", t[t.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", t[t.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", t[t.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", t[t.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", t[t.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", t[t.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", t[t.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", t[t.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", t[t.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", t[t.NONE = 0] = "NONE", t[t.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", t[t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", t[t.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", t[t.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", t[t.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", t[t.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", t[t.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", t[t.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", t[t.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", t[t.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL" }(id || (id = {})); var Sd, Ed, Cd, Td, Ad, Md, Od, kd, Id, Pd = (od = ut.injectable(), ad = ut.inject(Tr.IMapService), sd = ut.inject(Tr.IRendererService), ld = ut.inject(Tr.IGlobalConfigService), ud = ut.inject(Tr.IInteractionService), cd = ut.inject(Tr.ILayerService), od((hd = function () { function t() { var e = this; Ar(this, t), Ef(this, "mapService", fd, this), Ef(this, "rendererService", dd, this), Ef(this, "configService", md, this), Ef(this, "interactionService", vd, this), Ef(this, "layerService", yd, this), kr(this, "pickingFBO", void 0), kr(this, "width", 0), kr(this, "height", 0), kr(this, "alreadyInPicking", !1), kr(this, "pickBufferScale", 1), kr(this, "lastPickTime", (new Date).getTime()), kr(this, "pickFromPickingFBO", (function (t, n) { var r, i = n.x, o = n.y, a = n.lngLat, s = n.type, l = n.target, u = !1, c = e.rendererService; c.getViewportSize; var p = c.readPixels, h = c.getContainer, f = e.getContainerSize(h()), d = f.width, m = f.height; d *= go, m *= go; var v, y = t.getLayerConfig(), g = y.enableHighlight, _ = y.enableSelect, x = i * go, b = o * go; if (x > d - 1 * go || x < 0 || b > m - 1 * go || b < 0) return !1; if (0 !== (v = p({ x: Math.floor(x / e.pickBufferScale), y: Math.floor((m - (o + 1) * go) / e.pickBufferScale), width: 1, height: 1, data: new Uint8Array(4), framebuffer: e.pickingFBO }))[0] || 0 !== v[1] || 0 !== v[2]) { var w = ba(v), S = t.getSource().getFeatureById(w); w !== t.getCurrentPickId() && "mousemove" === s && (s = "mouseenter"); var E = { x: i, y: o, type: s, lngLat: a, featureId: w, feature: S, target: l }; S && (u = !0, t.setCurrentPickId(w), e.triggerHoverOnLayer(t, E)) } else { var C = { x: i, y: o, lngLat: a, type: null !== t.getCurrentPickId() && "mousemove" === s ? "mouseout" : "un" + s, featureId: null, target: l, feature: null }; e.triggerHoverOnLayer(t, wd(wd({}, C), {}, { type: "unpick" })), e.triggerHoverOnLayer(t, C), t.setCurrentPickId(null) } if (g && e.highlightPickedFeature(t, v), _ && "click" === s && (null === (r = v) || void 0 === r ? void 0 : r.toString()) !== [0, 0, 0, 0].toString()) { var T = ba(v); null === t.getCurrentSelectedId() || T !== t.getCurrentSelectedId() ? (e.selectFeature(t, v), t.setCurrentSelectedId(T)) : (e.selectFeature(t, new Uint8Array([0, 0, 0, 0])), t.setCurrentSelectedId(null)) } return u })) } var e, n, r; return Or(t, [{ key: "init", value: function (t) { var e = this.rendererService, n = e.createTexture2D, r = e.createFramebuffer; e.getViewportSize; var i = e.getContainer, o = this.getContainerSize(i()), a = o.width, s = o.height; a *= go, s *= go, this.pickBufferScale = this.configService.getSceneConfig(t).pickBufferScale || 1, this.pickingFBO = r({ color: n({ width: Math.round(a / this.pickBufferScale), height: Math.round(s / this.pickBufferScale), wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.interactionService.on(Wf.Hover, this.pickingAllLayer.bind(this)) } }, { key: "boxPickLayer", value: (r = nd(gd.mark((function t(e, n, r) { var i, o, a, s = this; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: i = this.rendererService, o = i.useFramebuffer, a = i.clear, this.resizePickingFBO(), o(this.pickingFBO, (function () { a({ framebuffer: s.pickingFBO, color: [0, 0, 0, 0], stencil: 0, depth: 1 }), e.hooks.beforePickingEncode.call(), e.renderModels(), e.hooks.afterPickingEncode.call(); var t = s.pickBox(e, n); r(t) })); case 3: case "end": return t.stop() } }), t, this) }))), function (t, e, n) { return r.apply(this, arguments) }) }, { key: "pickBox", value: function (t, e) { var n = this, r = Lr(e.map((function (t) { var e = t < 0 ? 0 : t; return Math.floor(e * go / n.pickBufferScale) })), 4), i = r[0], o = r[1], a = r[2], s = r[3], l = this.rendererService; l.getViewportSize; var u, c = l.readPixels, p = l.getContainer, h = this.getContainerSize(p()), f = h.width, d = h.height; if (d *= go, i > ((f *= go) - 1) * go / this.pickBufferScale || a < 0 || o > (d - 1) * go / this.pickBufferScale || s < 0) return []; var m = Math.min(f / this.pickBufferScale, a) - i, v = Math.min(d / this.pickBufferScale, s) - o; u = c({ x: i, y: Math.floor(d / this.pickBufferScale - (s + 1)), width: m, height: v, data: new Uint8Array(m * v * 4), framebuffer: this.pickingFBO }); for (var y = [], g = {}, _ = 0; _ < u.length / 4; _ += 1) { var x = ba(u.slice(4 * _, 4 * _ + 4)); if (-1 !== x && !g[x]) { var b = t.getSource().getFeatureById(x); y.push(wd(wd({}, b), {}, { pickedFeatureIdx: x })), g[x] = !0 } } return y } }, { key: "handleCursor", value: function (t, e) { var n = t.getLayerConfig(), r = n.cursor, i = void 0 === r ? "" : r; if (n.cursorEnabled) { var o = "GAODE2.x" === this.mapService.version ? this.mapService.getMapContainer() : this.mapService.getMarkerContainer(), a = null == o ? void 0 : o.style.getPropertyValue("cursor"); "unmousemove" === e && "" !== a ? null == o || o.style.setProperty("cursor", "") : "mousemove" === e && (null == o || o.style.setProperty("cursor", i)) } } }, { key: "destroy", value: function () { this.pickingFBO.destroy(), this.pickingFBO = null } }, { key: "getContainerSize", value: function (t) { return t.getContext ? { width: t.width / go, height: t.height / go } : t.getBoundingClientRect() } }, { key: "pickingAllLayer", value: (n = nd(gd.mark((function t(e) { var n; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (!(this.alreadyInPicking || this.layerService.alreadyInRendering || this.interactionService.indragging) && this.layerService.getShaderPickStat()) { t.next = 2; break } return t.abrupt("return"); case 2: if (this.alreadyInPicking = !0, !((n = (new Date).getTime()) - this.lastPickTime > 10 || "contextmenu" === e.type || "click" === e.type)) { t.next = 7; break } return t.next = 7, this.pickingLayers(e); case 7: this.lastPickTime = n, this.layerService.renderLayers(), this.alreadyInPicking = !1; case 10: case "end": return t.stop() } }), t, this) }))), function (t) { return n.apply(this, arguments) }) }, { key: "resizePickingFBO", value: function () { var t = this.rendererService.getContainer, e = this.getContainerSize(t()), n = e.width, r = e.height; n *= go, r *= go, this.width === n && this.height === r || (this.pickingFBO.resize({ width: Math.round(n / this.pickBufferScale), height: Math.round(r / this.pickBufferScale) }), this.width = n, this.height = r) } }, { key: "pickingLayers", value: (e = nd(gd.mark((function t(e) { var n, r, i, o = this; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: n = this.rendererService, r = n.useFramebuffer, i = n.clear, this.resizePickingFBO(), r(this.pickingFBO, (function () { o.layerService.getRenderList().filter((function (t) { return t.needPick(e.type) })).reverse().some((function (t) { return i({ framebuffer: o.pickingFBO, color: [0, 0, 0, 0], stencil: 0, depth: 1 }), t.hooks.beforePickingEncode.call(), t.masks.length > 0 && t.masks.map((function (t) { t.hooks.beforeRenderData.call(), t.hooks.beforeRender.call(), t.render(), t.hooks.afterRender.call() })), t.renderModels(!0), t.hooks.afterPickingEncode.call(), o.pickFromPickingFBO(t, e) && !t.getLayerConfig().enablePropagation })) })); case 3: case "end": return t.stop() } }), t, this) }))), function (t) { return e.apply(this, arguments) }) }, { key: "triggerHoverOnLayer", value: function (t, e) { var n, r, i, o; o = !0, null == (n = e) || null === (r = n.target) || void 0 === r || null === (i = r.path) || void 0 === i || i.map((function (t) { var e; null != t && t.classList && (null == t || null === (e = t.classList) || void 0 === e || e.forEach((function (t) { "l7-marker" !== t && "l7-popup" !== t || (o = !1) }))) })), o && (this.handleCursor(t, e.type), t.emit(e.type, e)) } }, { key: "highlightPickedFeature", value: function (t, e) { var n = Lr(e, 3), r = n[0], i = n[1], o = n[2]; t.hooks.beforeHighlight.call([r, i, o]) } }, { key: "selectFeature", value: function (t, e) { var n = Lr(e, 3), r = n[0], i = n[1], o = n[2]; t.hooks.beforeSelect.call([r, i, o]) } }]), t }(), fd = Cf(hd.prototype, "mapService", [ad], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), dd = Cf(hd.prototype, "rendererService", [sd], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), md = Cf(hd.prototype, "configService", [ld], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), vd = Cf(hd.prototype, "interactionService", [ud], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), yd = Cf(hd.prototype, "layerService", [cd], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), pd = hd)) || pd), Ld = function () { function t() { var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; Ar(this, t), kr(this, "autoStart", void 0), kr(this, "startTime", 0), kr(this, "oldTime", 0), kr(this, "running", !1), kr(this, "elapsedTime", 0), this.autoStart = e } return Or(t, [{ key: "start", value: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } }, { key: "stop", value: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } }, { key: "getElapsedTime", value: function () { return this.getDelta(), this.elapsedTime } }, { key: "getDelta", value: function () { var t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }]), t }(); function Rd(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Dd(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Dd(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Dd(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var Nd = (Sd = ut.injectable(), Ed = ut.inject(Tr.IRendererService), Cd = ut.inject(Tr.IMapService), Td = ut.inject(Tr.IGlobalConfigService), Sd((Md = function () { function t() { Ar(this, t), kr(this, "clock", new Ld), kr(this, "alreadyInRendering", !1), kr(this, "layers", []), kr(this, "layerList", []), kr(this, "layerRenderID", void 0), kr(this, "sceneInited", !1), kr(this, "animateInstanceCount", 0), kr(this, "shaderPicking", !0), kr(this, "enableRender", !0), Ef(this, "renderService", Od, this), Ef(this, "mapService", kd, this), Ef(this, "configService", Id, this) } var e; return Or(t, [{ key: "add", value: function (t) { this.sceneInited && t.init(), this.layers.push(t), this.updateLayerRenderList() } }, { key: "addMask", value: function (t) { this.sceneInited && t.init() } }, { key: "initLayers", value: function () { this.sceneInited = !0, this.layers.forEach((function (t) { t.inited || t.init() })), this.updateLayerRenderList() } }, { key: "getSceneInited", value: function () { return this.sceneInited } }, { key: "getRenderList", value: function () { return this.layerList } }, { key: "getLayers", value: function () { return this.layers } }, { key: "getLayer", value: function (t) { return this.layers.find((function (e) { return e.id === t })) } }, { key: "getLayerByName", value: function (t) { return this.layers.find((function (e) { return e.name === t })) } }, { key: "cleanRemove", value: function (t, e) { if (e) { var n = e.layerChildren.indexOf(t); n > -1 && e.layerChildren.splice(n, 1) } else { var r = this.layers.indexOf(t); r > -1 && this.layers.splice(r, 1) } this.updateLayerRenderList(), this.renderLayers() } }, { key: "remove", value: function (t, e) { if (e) { var n = e.layerChildren.indexOf(t); n > -1 && e.layerChildren.splice(n, 1) } else { var r = this.layers.indexOf(t); r > -1 && this.layers.splice(r, 1) } this.updateLayerRenderList(), t.destroy(), this.renderLayers() } }, { key: "removeAllLayers", value: function () { this.destroy() } }, { key: "setEnableRender", value: function (t) { this.enableRender = t } }, { key: "renderLayers", value: (e = nd(gd.mark((function t() { var e, n, r; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (!this.alreadyInRendering && this.enableRender) { t.next = 2; break } return t.abrupt("return"); case 2: this.alreadyInRendering = !0, this.clear(), e = Rd(this.layerList), t.prev = 5, e.s(); case 7: if ((n = e.n()).done) { t.next = 21; break } if ((r = n.value).hooks.beforeRenderData.call(), r.hooks.beforeRender.call(), !r.isLayerGroup && r.masks.length > 0 && (this.renderService.clear({ stencil: 0, depth: 1, framebuffer: null }), r.masks.map((function (t) { t.hooks.beforeRenderData.call(), t.hooks.beforeRender.call(), t.render(), t.hooks.afterRender.call() }))), !r.getLayerConfig().enableMultiPassRenderer) { t.next = 17; break } return t.next = 15, r.renderMultiPass(); case 15: t.next = 18; break; case 17: r.render(); case 18: r.hooks.afterRender.call(); case 19: t.next = 7; break; case 21: t.next = 26; break; case 23: t.prev = 23, t.t0 = t.catch(5), e.e(t.t0); case 26: return t.prev = 26, e.f(), t.finish(26); case 29: this.alreadyInRendering = !1; case 30: case "end": return t.stop() } }), t, this, [[5, 23, 26, 29]]) }))), function () { return e.apply(this, arguments) }) }, { key: "updateLayerRenderList", value: function () { var t = this; this.layerList = [], this.layers.filter((function (t) { return t.inited })).filter((function (t) { return t.isVisible() })).sort((function (t, e) { return t.zIndex - e.zIndex })).forEach((function (e) { e.isLayerGroup ? e.layerChildren.filter((function (t) { return t.inited })).filter((function (t) { return t.isVisible() })).sort((function (t, e) { return t.zIndex - e.zIndex })).forEach((function (e) { t.layerList.push(e) })) : t.layerList.push(e) })) } }, { key: "destroy", value: function () { this.layers.forEach((function (t) { t.destroy() })), this.layers = [], this.layerList = [], this.renderLayers() } }, { key: "startAnimate", value: function () { 0 == this.animateInstanceCount++ && (this.clock.start(), this.runRender()) } }, { key: "stopAnimate", value: function () { 0 == --this.animateInstanceCount && (this.stopRender(), this.clock.stop()) } }, { key: "getOESTextureFloat", value: function () { return this.renderService.extensionObject.OES_texture_float } }, { key: "enableShaderPick", value: function () { this.shaderPicking = !0 } }, { key: "disableShaderPick", value: function () { this.shaderPicking = !1 } }, { key: "getShaderPickStat", value: function () { return this.shaderPicking } }, { key: "clear", value: function () { var t = xa(this.mapService.bgColor); this.renderService.clear({ color: t, depth: 1, stencil: 0, framebuffer: null }) } }, { key: "runRender", value: function () { this.renderLayers(), this.layerRenderID = oo.requestAnimationFrame(this.runRender.bind(this)) } }, { key: "stopRender", value: function () { oo.cancelAnimationFrame(this.layerRenderID) } }]), t }(), Od = Cf(Md.prototype, "renderService", [Ed], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), kd = Cf(Md.prototype, "mapService", [Cd], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Id = Cf(Md.prototype, "configService", [Td], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Ad = Md)) || Ad); function zd(t, e) { if (null == t) return {}; var n, r, i = function (t, e) { if (null == t) return {}; var n, r, i = {}, o = Object.keys(t); for (r = 0; r < o.length; r++)n = o[r], e.indexOf(n) >= 0 || (i[n] = t[n]); return i }(t, e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(t); for (r = 0; r < o.length; r++)n = o[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n]) } return i } function Fd(t) { return function (t) { if (Array.isArray(t)) return Ir(t) }(t) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(t) || Pr(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } var Bd, jd, Ud, Vd, Gd, Hd, Wd = function (t) { return null == t }, Xd = function () { function t(e) { var n = this; Ar(this, t), kr(this, "name", void 0), kr(this, "type", void 0), kr(this, "scale", void 0), kr(this, "descriptor", void 0), kr(this, "featureBufferLayout", []), kr(this, "needRescale", !1), kr(this, "needRemapping", !1), kr(this, "needRegenerateVertices", !1), kr(this, "featureRange", { startIndex: 0, endIndex: 1 / 0 }), kr(this, "vertexAttribute", void 0), kr(this, "defaultCallback", (function (t) { var e; return 0 === t.length ? (null === (e = n.scale) || void 0 === e ? void 0 : e.defaultValues) || [] : t.map((function (t, e) { var r; return (null === (r = n.scale) || void 0 === r ? void 0 : r.scalers[e].func)(t) })) })), this.setProps(e) } return Or(t, [{ key: "setProps", value: function (t) { Object.assign(this, t) } }, { key: "mapping", value: function (t) { var e; if (null !== (e = this.scale) && void 0 !== e && e.callback) { var n, r = null === (n = this.scale) || void 0 === n ? void 0 : n.callback.apply(n, Fd(t)); if (!Wd(r)) return [r] } return this.defaultCallback(t) } }, { key: "resetDescriptor", value: function () { this.descriptor && (this.descriptor.buffer.data = []) } }]), t }(), qd = ["buffer", "update", "name"]; function Zd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Yd(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Zd(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Zd(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var Kd = (kr(Bd = {}, id.FLOAT, 4), kr(Bd, id.UNSIGNED_BYTE, 1), kr(Bd, id.UNSIGNED_SHORT, 2), Bd), Qd = (jd = ut.injectable(), Ud = ut.inject(Tr.IRendererService), jd((Gd = function () { function t() { Ar(this, t), kr(this, "attributesAndIndices", void 0), Ef(this, "rendererService", Hd, this), kr(this, "attributes", []), kr(this, "triangulation", void 0), kr(this, "featureLayout", { sizePerElement: 0, elements: [] }) } return Or(t, [{ key: "registerStyleAttribute", value: function (t) { var e = this.getLayerStyleAttribute(t.name || ""); return e ? e.setProps(t) : (e = new Xd(t), this.attributes.push(e)), e } }, { key: "updateStyleAttribute", value: function (t, e, n) { var r = this.getLayerStyleAttribute(t); r || (r = this.registerStyleAttribute(Yd(Yd({}, e), {}, { name: t }))); var i = e.scale; i && r && (r.scale = i, r.needRescale = !0, r.needRemapping = !0, r.needRegenerateVertices = !0, n && n.featureRange && (r.featureRange = n.featureRange)) } }, { key: "getLayerStyleAttributes", value: function () { return this.attributes } }, { key: "getLayerStyleAttribute", value: function (t) { return this.attributes.find((function (e) { return e.name === t })) } }, { key: "getLayerAttributeScale", value: function (t) { var e, n = this.getLayerStyleAttribute(t), r = null == n || null === (e = n.scale) || void 0 === e ? void 0 : e.scalers; return r && r[0] ? r[0].func : null } }, { key: "updateAttributeByFeatureRange", value: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0, i = this.attributes.find((function (e) { return e.name === t })); if (i && i.descriptor) { var o = i.descriptor, a = o.update, s = o.buffer, l = o.size, u = void 0 === l ? 0 : l, c = Kd[s.type || id.FLOAT]; if (a) { var p = this.featureLayout, h = p.elements, f = p.sizePerElement, d = h.slice(n, r); if (!d.length) return; var m = d[0].offset, v = m * u * c, y = d.map((function (t, n) { for (var r = t.featureIdx, i = t.vertices, o = t.normals, s = i.length / f, l = [], u = 0; u < s; u++) { var c = o ? o.slice(3 * u, 3 * u + 3) : []; l.push.apply(l, Fd(a(e[r], r, i.slice(u * f, u * f + f), n, c))) } return l })).reduce((function (t, e) { return t.push.apply(t, Fd(e)), t }), []); i.vertexAttribute.updateBuffer({ data: y, offset: v }) } } } }, { key: "createAttributesAndIndices", value: function (t, e, n) { var r = this; this.featureLayout = { sizePerElement: 0, elements: [] }, e && (this.triangulation = e); var i = this.attributes.map((function (t) { return t.resetDescriptor(), t.descriptor })), o = 0, a = [], s = 3; t.forEach((function (t, e) { var l = r.triangulation(t, n), u = l.indices, c = l.vertices, p = l.normals, h = l.size, f = l.indexes; u.forEach((function (t) { a.push(t + o) })), s = h; var d = c.length / h; r.featureLayout.sizePerElement = s, r.featureLayout.elements.push({ featureIdx: e, vertices: c, normals: p, offset: o }), o += d; for (var m = function (n) { var r = (null == p ? void 0 : p.slice(3 * n, 3 * n + 3)) || [], o = c.slice(n * h, n * h + h), a = 0; f && void 0 !== f[n] && (a = f[n]), i.forEach((function (i, s) { var l; i && i.update && (l = i.buffer.data).push.apply(l, Fd(i.update(t, e, o, n, r, a))) })) }, v = 0; v < d; v++)m(v) })); var l = this.rendererService, u = l.createAttribute, c = l.createBuffer, p = l.createElements, h = {}; i.forEach((function (t, e) { if (t) { var n = t.buffer; t.update, t.name; var i = zd(t, qd), o = u(Yd({ buffer: c(n) }, i)); h[t.name || ""] = o, r.attributes[e].vertexAttribute = o } })); var f = p({ data: a, type: id.UNSIGNED_INT, count: a.length }); return this.attributesAndIndices = { attributes: h, elements: f }, this.attributesAndIndices } }, { key: "clearAllAttributes", value: function () { var t; this.attributes.forEach((function (t) { t.vertexAttribute && t.vertexAttribute.destroy() })), null === (t = this.attributesAndIndices) || void 0 === t || t.elements.destroy(), this.attributes = [] } }]), t }(), Hd = Cf(Gd.prototype, "rendererService", [Ud], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Vd = Gd)) || Vd);
    /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */
    function Jd(t, e, n, r) { return new (n || (n = Promise))((function (i, o) { function a(t) { try { l(r.next(t)) } catch (t) { o(t) } } function s(t) { try { l(r.throw(t)) } catch (t) { o(t) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(a, s) } l((r = r.apply(t, e || [])).next()) })) } function $d(t, e) { var n, r, i, o, a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function s(o) { return function (s) { return function (o) { if (n) throw new TypeError("Generator is already executing."); for (; a;)try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return a.label++, { value: o[1], done: !1 }; case 5: a.label++, r = o[1], o = [0]; continue; case 7: o = a.ops.pop(), a.trys.pop(); continue; default: if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) { a = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (6 === o[0] && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break } i[2] && a.ops.pop(), a.trys.pop(); continue }o = e.call(t, a) } catch (t) { o = [6, t], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s]) } } } function tm(t, e) { var n = "function" == typeof Symbol && t[Symbol.iterator]; if (!n) return t; var r, i, o = n.call(t), a = []; try { for (; (void 0 === e || e-- > 0) && !(r = o.next()).done;)a.push(r.value) } catch (t) { i = { error: t } } finally { try { r && !r.done && (n = o.return) && n.call(o) } finally { if (i) throw i.error } } return a } function em(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function nm(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var rm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { return t && "number" == typeof t.length && t.length >= 0 && t.length % 1 == 0 }, t.exports = e.default })); em(rm); var im = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { return function () { for (var e = [], n = arguments.length; n--;)e[n] = arguments[n]; var r = e.pop(); return t.call(this, e, r) } }, t.exports = e.default })); em(im); var om = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.fallback = o, e.wrap = a; var n, r = e.hasSetImmediate = "function" == typeof setImmediate && setImmediate, i = e.hasNextTick = "object" == typeof process && "function" == typeof process.nextTick; function o(t) { setTimeout(t, 0) } function a(t) { return function (e) { for (var n = [], r = arguments.length - 1; r-- > 0;)n[r] = arguments[r + 1]; return t((function () { return e.apply(void 0, n) })) } } n = r ? setImmediate : i ? process.nextTick : o, e.default = a(n) })); em(om), om.fallback, om.wrap, om.hasSetImmediate, om.hasNextTick; var am = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { if ((0, sm.isAsync)(t)) return function () { for (var e = [], n = arguments.length; n--;)e[n] = arguments[n]; var r = e.pop(), i = t.apply(this, e); return o(i, r) }; return (0, n.default)((function (e, n) { var r; try { r = t.apply(this, e) } catch (t) { return n(t) } if (r && "function" == typeof r.then) return o(r, n); n(null, r) })) }; var n = i(im), r = i(om); function i(t) { return t && t.__esModule ? t : { default: t } } function o(t, e) { return t.then((function (t) { a(e, null, t) }), (function (t) { a(e, t && t.message ? t : new Error(t)) })) } function a(t, e, n) { try { t(e, n) } catch (t) { (0, r.default)((function (t) { throw t }), t) } } t.exports = e.default })); em(am); var sm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.isAsyncIterable = e.isAsyncGenerator = e.isAsync = void 0; var n, r = (n = am) && n.__esModule ? n : { default: n }; function i(t) { return "AsyncFunction" === t[Symbol.toStringTag] } e.default = function (t) { if ("function" != typeof t) throw new Error("expected a function"); return i(t) ? (0, r.default)(t) : t }, e.isAsync = i, e.isAsyncGenerator = function (t) { return "AsyncGenerator" === t[Symbol.toStringTag] }, e.isAsyncIterable = function (t) { return "function" == typeof t[Symbol.asyncIterator] } })); em(sm), sm.isAsyncIterable, sm.isAsyncGenerator, sm.isAsync; var lm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t, e) { void 0 === e && (e = t.length); if (!e) throw new Error("arity is undefined"); function n() { for (var n = this, r = [], i = arguments.length; i--;)r[i] = arguments[i]; return "function" == typeof r[e - 1] ? t.apply(this, r) : new Promise((function (i, o) { r[e - 1] = function (t) { for (var e = [], n = arguments.length - 1; n-- > 0;)e[n] = arguments[n + 1]; if (t) return o(t); i(e.length > 1 ? e : e[0]) }, t.apply(n, r) })) } return Object.defineProperty(n, "name", { configurable: !0, value: "awaitable(" + t.name + ")" }), n }, t.exports = e.default })); em(lm); var um = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = o(rm), r = o(sm), i = o(lm); function o(t) { return t && t.__esModule ? t : { default: t } } e.default = (0, i.default)((function (t, e, i) { var o = (0, n.default)(e) ? [] : {}; t(e, (function (t, e, n) { (0, r.default)(t)((function (t) { for (var r = [], i = arguments.length - 1; i-- > 0;)r[i] = arguments[i + 1]; r.length < 2 && (r = r[0]), o[e] = r, n(t) })) }), (function (t) { return i(t, o) })) }), 3), t.exports = e.default })); em(um); var cm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { function e() { for (var e = [], n = arguments.length; n--;)e[n] = arguments[n]; if (null !== t) { var r = t; t = null, r.apply(this, e) } } return Object.assign(e, t), e }, t.exports = e.default })); em(cm); var pm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { return t[Symbol.iterator] && t[Symbol.iterator]() }, t.exports = e.default })); em(pm); var hm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { if ((0, n.default)(t)) return function (t) { var e = -1, n = t.length; return function () { return ++e < n ? { value: t[e], key: e } : null } }(t); var e = (0, r.default)(t); return e ? function (t) { var e = -1; return function () { var n = t.next(); return n.done ? null : (e++, { value: n.value, key: e }) } }(e) : function (t) { var e = t ? Object.keys(t) : [], n = -1, r = e.length; return function () { var i = e[++n]; return n < r ? { value: t[i], key: i } : null } }(t) }; var n = i(rm), r = i(pm); function i(t) { return t && t.__esModule ? t : { default: t } } t.exports = e.default })); em(hm); var fm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t) { return function () { for (var e = [], n = arguments.length; n--;)e[n] = arguments[n]; if (null === t) throw new Error("Callback was already called."); var r = t; t = null, r.apply(this, e) } }, t.exports = e.default })); em(fm); var dm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); e.default = {}, t.exports = e.default })); em(dm); var mm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t, e, n, i) { var o = !1, a = !1, s = !1, l = 0, u = 0; function c() { l >= e || s || o || (s = !0, t.next().then((function (t) { var e = t.value, r = t.done; if (!a && !o) { if (s = !1, r) return o = !0, void (l <= 0 && i(null)); l++, n(e, u, p), u++, c() } })).catch(h)) } function p(t, e) { if (l -= 1, !a) return t ? h(t) : !1 === t ? (o = !0, void (a = !0)) : e === r.default || o && l <= 0 ? (o = !0, i(null)) : void c() } function h(t) { a || (s = !1, o = !0, i(t)) } c() }; var n, r = (n = dm) && n.__esModule ? n : { default: n }; t.exports = e.default })); em(mm); var vm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = s(cm), r = s(hm), i = s(fm), o = s(mm), a = s(dm); function s(t) { return t && t.__esModule ? t : { default: t } } e.default = function (t) { return function (e, s, l) { if (l = (0, n.default)(l), t <= 0) throw new RangeError("concurrency limit cannot be less than 1"); if (!e) return l(null); if ((0, sm.isAsyncGenerator)(e)) return (0, o.default)(e, t, s, l); if ((0, sm.isAsyncIterable)(e)) return (0, o.default)(e[Symbol.asyncIterator](), t, s, l); var u = (0, r.default)(e), c = !1, p = !1, h = 0, f = !1; function d(t, e) { if (!p) if (h -= 1, t) c = !0, l(t); else if (!1 === t) c = !0, p = !0; else { if (e === a.default || c && h <= 0) return c = !0, l(null); f || m() } } function m() { for (f = !0; h < t && !c;) { var e = u(); if (null === e) return c = !0, void (h <= 0 && l(null)); h += 1, s(e.value, e.key, (0, i.default)(d)) } f = !1 } m() } }, t.exports = e.default })); em(vm); var ym = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = o(vm), r = o(sm), i = o(lm); function o(t) { return t && t.__esModule ? t : { default: t } } e.default = (0, i.default)((function (t, e, i, o) { return (0, n.default)(e)(t, (0, r.default)(i), o) }), 4), t.exports = e.default })); em(ym); var gm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = i(ym), r = i(lm); function i(t) { return t && t.__esModule ? t : { default: t } } e.default = (0, r.default)((function (t, e, r) { return (0, n.default)(t, 1, e, r) }), 3), t.exports = e.default })); em(gm); var _m = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t, e) { return (0, n.default)(r.default, t, e) }; var n = i(um), r = i(gm); function i(t) { return t && t.__esModule ? t : { default: t } } t.exports = e.default })), xm = em(_m), bm = function () { function t() { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; this.args = [], this.tasks = [] } return t.prototype.call = function () { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; return this.args = e, xm(this.tasks) }, t.prototype.tap = function (t, e) { var n = this; this.tasks.push((function (r) { e.apply(void 0, function () { for (var t = [], e = 0; e < arguments.length; e++)t = t.concat(tm(arguments[e])); return t }(n.args)), r(null, t) })) }, t }(), wm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = u(rm), r = u(dm), i = u(ym), o = u(cm), a = u(fm), s = u(sm), l = u(lm); function u(t) { return t && t.__esModule ? t : { default: t } } function c(t, e, n) { n = (0, o.default)(n); var i = 0, s = 0, l = t.length, u = !1; function c(t, e) { !1 === t && (u = !0), !0 !== u && (t ? n(t) : ++s !== l && e !== r.default || n(null)) } for (0 === l && n(null); i < l; i++)e(t[i], i, (0, a.default)(c)) } function p(t, e, n) { return (0, i.default)(t, 1 / 0, e, n) } e.default = (0, l.default)((function (t, e, r) { return ((0, n.default)(t) ? c : p)(t, (0, s.default)(e), r) }), 3), t.exports = e.default })); em(wm); var Sm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t, e) { return (0, r.default)(n.default, t, e) }; var n = i(wm), r = i(um); function i(t) { return t && t.__esModule ? t : { default: t } } t.exports = e.default })), Em = em(Sm), Cm = function () { function t() { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; this.tasks = [] } return t.prototype.promise = function () { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; return Em(this.tasks) }, t.prototype.tapPromise = function (t, e) { var n = this; this.tasks.push((function (r) { return Jd(n, void 0, void 0, (function () { return $d(this, (function (n) { switch (n.label) { case 0: return [4, e()]; case 1: return n.sent(), r(null, t), [2] } })) })) })) }, t }(), Tm = nm((function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = a(cm), r = a(fm), i = a(sm), o = a(lm); function a(t) { return t && t.__esModule ? t : { default: t } } e.default = (0, o.default)((function (t, e) { if (e = (0, n.default)(e), !Array.isArray(t)) return e(new Error("First argument to waterfall must be an array of functions")); if (!t.length) return e(); var o = 0; function a(e) { (0, i.default)(t[o++]).apply(void 0, e.concat([(0, r.default)(s)])) } function s(n) { for (var r = [], i = arguments.length - 1; i-- > 0;)r[i] = arguments[i + 1]; if (!1 !== n) return n || o === t.length ? e.apply(void 0, [n].concat(r)) : void a(r) } a([]) })), t.exports = e.default })), Am = em(Tm), Mm = function () { function t() { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; this.tasks = [] } return t.prototype.call = function () { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; return Am(this.tasks) }, t.prototype.tap = function (t, e) { 0 === this.tasks.length ? this.tasks.push((function (t) { var n = e(); t(!!n && null, n) })) : this.tasks.push((function (n, r) { r(!!e() && null, t) })) }, t }(), Om = function () { function t() { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; this.tasks = [] } return t.prototype.call = function () { for (var t = arguments, e = [], n = 0; n < arguments.length; n++)e[n] = t[n]; return xm(this.tasks) }, t.prototype.tap = function (t, e) { this.tasks.push((function (n) { n(e(), t) })) }, t }(), km = { exports: {} }; function Im(t) { var e = t.target || t.srcElement; e.__resizeRAF__ && cancelAnimationFrame(e.__resizeRAF__), e.__resizeRAF__ = requestAnimationFrame((function () { var n = e.__resizeTrigger__, r = n && n.__resizeListeners__; r && r.forEach((function (e) { e.call(n, t) })) })) } var Pm = function (t, e) { var n, r = this.document, i = r.attachEvent; if ("undefined" != typeof navigator && (n = navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/Edge/)), !t.__resizeListeners__) if (t.__resizeListeners__ = [], i) t.__resizeTrigger__ = t, t.attachEvent("onresize", Im); else { "static" === getComputedStyle(t).position && (t.style.position = "relative"); var o = t.__resizeTrigger__ = r.createElement("object"); o.setAttribute("style", "position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none; z-index: -1; opacity: 0;"), o.setAttribute("class", "resize-sensor"), o.setAttribute("tabindex", "-1"), o.setAttribute("title", ""), o.__resizeElement__ = t, o.onload = function () { this.contentDocument.defaultView.__resizeTrigger__ = this.__resizeElement__, this.contentDocument.defaultView.addEventListener("resize", Im) }, o.type = "text/html", n && t.appendChild(o), o.data = "about:blank", n || t.appendChild(o) } t.__resizeListeners__.push(e) }; km.exports = "undefined" == typeof window ? Pm : Pm.bind(window); var Lm, Rm, Dm, Nm, zm, Fm, Bm, jm, Um, Vm, Gm, Hm, Wm, Xm, qm, Zm, Ym, Km, Qm, Jm, $m, tv, ev, nv, rv, iv, ov, av, sv, lv, uv, cv, pv, hv = km.exports.unbind = function (t, e) { var n = document.attachEvent, r = t.__resizeListeners__ || []; if (e) { var i = r.indexOf(e); -1 !== i && r.splice(i, 1) } else r = t.__resizeListeners__ = []; if (!r.length) { if (n) t.detachEvent("onresize", Im); else if (t.__resizeTrigger__) { var o = t.__resizeTrigger__.contentDocument, a = o && o.defaultView; a && (a.removeEventListener("resize", Im), delete a.__resizeTrigger__), t.__resizeTrigger__ = !t.removeChild(t.__resizeTrigger__) } delete t.__resizeListeners__ } }, fv = km.exports; function dv(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var mv = (Lm = ut.injectable(), Rm = ut.inject(Tr.SceneID), Dm = ut.inject(Tr.IIconService), Nm = ut.inject(Tr.IFontService), zm = ut.inject(Tr.IControlService), Fm = ut.inject(Tr.IGlobalConfigService), Bm = ut.inject(Tr.IMapService), jm = ut.inject(Tr.ICoordinateSystemService), Um = ut.inject(Tr.IRendererService), Vm = ut.inject(Tr.ILayerService), Gm = ut.inject(Tr.ICameraService), Hm = ut.inject(Tr.IInteractionService), Wm = ut.inject(Tr.IPickingService), Xm = ut.inject(Tr.IShaderModuleService), qm = ut.inject(Tr.IMarkerService), Zm = ut.inject(Tr.IPopupService), Lm((Km = function (t) { Ur(r, t); var e, n = dv(r); function r() { var t; return Ar(this, r), kr(Gr(t = n.call(this)), "destroyed", !1), kr(Gr(t), "loaded", !1), kr(Gr(t), "loadFont", !1), kr(Gr(t), "fontFamily", ""), Ef(Gr(t), "id", Qm, Gr(t)), Ef(Gr(t), "iconService", Jm, Gr(t)), Ef(Gr(t), "fontService", $m, Gr(t)), Ef(Gr(t), "controlService", tv, Gr(t)), Ef(Gr(t), "configService", ev, Gr(t)), Ef(Gr(t), "map", nv, Gr(t)), Ef(Gr(t), "coordinateSystemService", rv, Gr(t)), Ef(Gr(t), "rendererService", iv, Gr(t)), Ef(Gr(t), "layerService", ov, Gr(t)), Ef(Gr(t), "cameraService", av, Gr(t)), Ef(Gr(t), "interactionService", sv, Gr(t)), Ef(Gr(t), "pickingService", lv, Gr(t)), Ef(Gr(t), "shaderModuleService", uv, Gr(t)), Ef(Gr(t), "markerService", cv, Gr(t)), Ef(Gr(t), "popupService", pv, Gr(t)), kr(Gr(t), "inited", !1), kr(Gr(t), "initPromise", void 0), kr(Gr(t), "rendering", !1), kr(Gr(t), "$container", void 0), kr(Gr(t), "canvas", void 0), kr(Gr(t), "markerContainer", void 0), kr(Gr(t), "hooks", void 0), kr(Gr(t), "handleWindowResized", (function () { t.emit("resize"), t.$container && (t.initContainer(), function () { if ("function" == typeof Event) oo.dispatchEvent(new Event("resize")); else { var t = oo.document.createEvent("UIEvents"); t.initUIEvent("resize", !0, !1, oo, 0), oo.dispatchEvent(t) } }(), t.coordinateSystemService.needRefresh = !0, t.render()) })), kr(Gr(t), "handleMapCameraChanged", (function (e) { t.cameraService.update(e), t.render() })), t.hooks = { init: new Cm }, t } return Or(r, [{ key: "init", value: function (t) { var e = this; this.configService.setSceneConfig(this.id, t), this.shaderModuleService.registerBuiltinModules(), this.iconService.init(), this.iconService.on("imageUpdate", (function () { return e.render() })), this.fontService.init(), this.hooks.init.tapPromise("initMap", nd(gd.mark((function t() { return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, new Promise((function (t) { e.map.onCameraChanged((function (n) { e.cameraService.init(), e.cameraService.update(n), "GAODE2.x" !== e.map.version && t() })), "GAODE2.x" !== e.map.version ? e.map.init() : t() })); case 2: if ("GAODE2.x" !== e.map.version || !e.map.initViewPort) { t.next = 6; break } return t.next = 5, e.map.init(); case 5: e.map.initViewPort(); case 6: e.map.onCameraChanged(e.handleMapCameraChanged), e.map.addMarkerContainer(), e.markerService.addMarkers(), e.markerService.addMarkerLayers(), e.popupService.initPopup(), e.interactionService.init(), e.interactionService.on(Wf.Drag, e.addSceneEvent.bind(e)); case 13: case "end": return t.stop() } }), t) })))), this.hooks.init.tapPromise("initRenderer", nd(gd.mark((function t() { var n, r; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (n = xd(e.configService.getSceneConfig(e.id).id || ""), e.$container = n, !n) { t.next = 11; break } return e.canvas = lo("canvas", "", n), e.setCanvas(), t.next = 7, e.rendererService.init(e.canvas, e.configService.getSceneConfig(e.id)); case 7: fv(e.$container, e.handleWindowResized), oo.matchMedia && (null === (r = oo.matchMedia("screen and (-webkit-min-device-pixel-ratio: 1.5)")) || void 0 === r || r.addListener(e.handleWindowResized)), t.next = 12; break; case 11: console.error("容器 id 不存在"); case 12: e.pickingService.init(e.id); case 13: case "end": return t.stop() } }), t) })))), this.initPromise = this.hooks.init.promise(), this.render() } }, { key: "initMiniScene", value: function (t) { var e = this; this.configService.setSceneConfig(this.id, t), this.shaderModuleService.registerBuiltinModules(), this.iconService.init(), this.iconService.on("imageUpdate", (function () { return e.render() })), this.fontService.init(), this.hooks.init.tapPromise("initMap", nd(gd.mark((function t() { return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, new Promise((function (t) { e.map.onCameraChanged((function (n) { e.cameraService.init(), e.cameraService.update(n), "GAODE2.x" !== e.map.version && t() })), e.map.initMiniMap() })); case 2: e.map.onCameraChanged(e.handleMapCameraChanged), e.interactionService.init(), e.interactionService.on(Wf.Drag, e.addSceneEvent.bind(e)); case 5: case "end": return t.stop() } }), t) })))), this.hooks.init.tapPromise("initRenderer", nd(gd.mark((function n() { var r; return gd.wrap((function (n) { for (; ;)switch (n.prev = n.next) { case 0: if (r = t.canvas, e.$container = r || null, !e.$container) { n.next = 7; break } return n.next = 5, e.rendererService.init(t.canvas, e.configService.getSceneConfig(e.id)); case 5: n.next = 8; break; case 7: console.error("容器 id 不存在"); case 8: e.pickingService.init(e.id); case 9: case "end": return n.stop() } }), n) })))), this.initPromise = this.hooks.init.promise(), this.render() } }, { key: "addLayer", value: function (t) { this.layerService.sceneService = this, this.layerService.add(t), this.render() } }, { key: "addMask", value: function (t) { this.layerService.sceneService = this, this.layerService.addMask(t), this.render() } }, { key: "render", value: (e = nd(gd.mark((function t() { return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (!this.rendering && !this.destroyed) { t.next = 2; break } return t.abrupt("return"); case 2: if (this.rendering = !0, this.inited) { t.next = 23; break } return t.next = 6, this.initPromise; case 6: if (this.destroyed && this.destroy(), !this.loadFont || !document.fonts) { t.next = 18; break } return t.prev = 8, t.next = 11, document.fonts.load("24px ".concat(this.fontFamily), "L7text"); case 11: t.next = 18; break; case 13: t.prev = 13, t.t0 = t.catch(8), console.warn("当前环境不支持 document.fonts !"), console.warn("当前环境不支持 iconfont !"), console.warn(t.t0); case 18: this.layerService.initLayers(), this.controlService.addControls(), this.loaded = !0, this.emit("loaded"), this.inited = !0; case 23: this.layerService.updateLayerRenderList(), this.layerService.renderLayers(), this.rendering = !1; case 26: case "end": return t.stop() } }), t, this, [[8, 13]]) }))), function () { return e.apply(this, arguments) }) }, { key: "addFontFace", value: function (t, e) { this.fontFamily = t; var n = document.createElement("style"); n.type = "text/css", n.innerText = "\n        @font-face{\n            font-family: '".concat(t, "';\n            src: url('").concat(e, "') format('woff2'),\n            url('").concat(e, "') format('woff'),\n            url('").concat(e, "') format('truetype');\n        }"), document.getElementsByTagName("head")[0].appendChild(n), this.loadFont = !0 } }, { key: "getSceneContainer", value: function () { return this.$container } }, { key: "exportPng", value: function (t) { var e, n = null === (e = this.$container) || void 0 === e ? void 0 : e.getElementsByTagName("canvas")[0]; return this.render(), "jpg" === t ? null == n ? void 0 : n.toDataURL("image/jpeg") : null == n ? void 0 : n.toDataURL("image/png") } }, { key: "getSceneConfig", value: function () { return this.configService.getSceneConfig(this.id) } }, { key: "getPointSizeRange", value: function () { return this.rendererService.getPointSizeRange() } }, { key: "addMarkerContainer", value: function () { var t = this.$container.parentElement; null !== t && (this.markerContainer = lo("div", "l7-marker-container", t)) } }, { key: "getMarkerContainer", value: function () { return this.markerContainer } }, { key: "destroy", value: function () { var t, e, n, r = this; this.inited ? (this.emit("destroy"), this.pickingService.destroy(), this.layerService.destroy(), setTimeout((function () { var t; null === (t = r.$container) || void 0 === t || t.removeChild(r.canvas), r.canvas = null, r.rendererService.destroy() })), this.map.destroy(), this.interactionService.destroy(), this.controlService.destroy(), this.markerService.destroy(), this.fontService.destroy(), this.iconService.destroy(), null === (t = this.$container) || void 0 === t || null === (e = t.parentNode) || void 0 === e || e.removeChild(this.$container), this.removeAllListeners(), this.inited = !1, hv(this.$container, this.handleWindowResized), oo.matchMedia && (null === (n = oo.matchMedia("screen and (min-resolution: 2dppx)")) || void 0 === n || n.removeListener(this.handleWindowResized))) : this.destroyed = !0 } }, { key: "initContainer", value: function () { var t, e, n = go, r = (null === (t = this.$container) || void 0 === t ? void 0 : t.clientWidth) || 400, i = (null === (e = this.$container) || void 0 === e ? void 0 : e.clientHeight) || 300, o = this.canvas; o && (o.width = r * n, o.height = i * n), this.rendererService.viewport({ x: 0, y: 0, width: n * r, height: n * i }) } }, { key: "setCanvas", value: function () { var t, e, n = go, r = (null === (t = this.$container) || void 0 === t ? void 0 : t.clientWidth) || 400, i = (null === (e = this.$container) || void 0 === e ? void 0 : e.clientHeight) || 300, o = this.canvas; o.width = r * n, o.height = i * n, o.style.width = "100%", o.style.height = "100%" } }, { key: "addSceneEvent", value: function (t) { this.emit(t.type, t) } }]), r }(st.exports.EventEmitter), Qm = Cf(Km.prototype, "id", [Rm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Jm = Cf(Km.prototype, "iconService", [Dm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), $m = Cf(Km.prototype, "fontService", [Nm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), tv = Cf(Km.prototype, "controlService", [zm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), ev = Cf(Km.prototype, "configService", [Fm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), nv = Cf(Km.prototype, "map", [Bm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), rv = Cf(Km.prototype, "coordinateSystemService", [jm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), iv = Cf(Km.prototype, "rendererService", [Um], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), ov = Cf(Km.prototype, "layerService", [Vm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), av = Cf(Km.prototype, "cameraService", [Gm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), sv = Cf(Km.prototype, "interactionService", [Hm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), lv = Cf(Km.prototype, "pickingService", [Wm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), uv = Cf(Km.prototype, "shaderModuleService", [Xm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), cv = Cf(Km.prototype, "markerService", [qm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), pv = Cf(Km.prototype, "popupService", [Zm], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Ym = Km)) || Ym); var vv = fc, yv = function (t) { return this.__data__.set(t, "__lodash_hash_undefined__"), this }, gv = function (t) { return this.__data__.has(t) }; function _v(t) { var e = -1, n = null == t ? 0 : t.length; for (this.__data__ = new vv; ++e < n;)this.add(t[e]) } _v.prototype.add = _v.prototype.push = yv, _v.prototype.has = gv; var xv = _v; var bv = function (t, e, n, r) { for (var i = t.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)if (e(t[o], o, t)) return o; return -1 }; var wv = function (t, e, n) { for (var r = n - 1, i = t.length; ++r < i;)if (t[r] === e) return r; return -1 }, Sv = bv, Ev = function (t) { return t != t }, Cv = wv; var Tv = function (t, e, n) { return e == e ? Cv(t, e, n) : Sv(t, Ev, n) }, Av = Tv; var Mv = function (t, e) { return !!(null == t ? 0 : t.length) && Av(t, e, 0) > -1 }; var Ov = function (t, e, n) { for (var r = -1, i = null == t ? 0 : t.length; ++r < i;)if (n(e, t[r])) return !0; return !1 }; var kv = function (t, e) { return t.has(e) }, Iv = ku(Zl, "Set"); var Pv = function (t) { var e = -1, n = Array(t.size); return t.forEach((function (t) { n[++e] = t })), n }, Lv = Iv, Rv = function () { }, Dv = Lv && 1 / Pv(new Lv([, -0]))[1] == 1 / 0 ? function (t) { return new Lv(t) } : Rv, Nv = xv, zv = Mv, Fv = Ov, Bv = kv, jv = Dv, Uv = Pv; var Vv = function (t, e, n) { var r = -1, i = zv, o = t.length, a = !0, s = [], l = s; if (n) a = !1, i = Fv; else if (o >= 200) { var u = e ? null : jv(t); if (u) return Uv(u); a = !1, i = Bv, l = new Nv } else l = e ? [] : s; t: for (; ++r < o;) { var c = t[r], p = e ? e(c) : c; if (c = n || 0 !== c ? c : 0, a && p == p) { for (var h = l.length; h--;)if (l[h] === p) continue t; e && l.push(p), s.push(c) } else i(l, p, n) || (l !== s && l.push(p), s.push(c)) } return s }, Gv = Vv; var Hv = function (t) { return t && t.length ? Gv(t) : [] }; var Wv, Xv = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\s\S]*?);/g; function qv(t) { var e = {}; return { content: t = t.replace(Xv, (function (t, n, r) { var i = r.split(":"), o = i[0].trim(), a = ""; switch (i.length > 1 && (a = i[1].trim()), n) { case "bool": a = "true" === a; break; case "float": case "int": a = Number(a); break; case "vec2": case "vec3": case "vec4": case "ivec2": case "ivec3": case "ivec4": case "mat2": case "mat3": case "mat4": a = a ? a.replace("[", "").replace("]", "").split(",").reduce((function (t, e) { return t.push(Number(e.trim())), t }), []) : new Array(function (t) { var e = 0; switch (t) { case "vec2": case "ivec2": e = 2; break; case "vec3": case "ivec3": e = 3; break; case "vec4": case "ivec4": case "mat2": e = 4; break; case "mat3": e = 9; break; case "mat4": e = 16 }return e }(n)).fill(0) }return e[o] = a, "uniform ".concat(n, " ").concat(o, ";\n") })), uniforms: e } } function Zv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Yv(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Zv(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Zv(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var Kv, Qv, Jv = "#define PI 3.14159265359", $v = /precision\s+(high|low|medium)p\s+float/, ty = /#pragma include (["^+"]?["\ "[a-zA-Z_0-9](.*)"]*?)/g, ey = ut.injectable()(Wv = function () { function t() { Ar(this, t), kr(this, "moduleCache", {}), kr(this, "rawContentCache", {}) } return Or(t, [{ key: "registerBuiltinModules", value: function () { this.destroy(), this.registerModule("common", { vs: Jv, fs: Jv }), this.registerModule("decode", { vs: "#define SHIFT_RIGHT17 1.0 / 131072.0\n#define SHIFT_RIGHT18 1.0 / 262144.0\n#define SHIFT_RIGHT19 1.0 / 524288.0\n#define SHIFT_RIGHT20 1.0 / 1048576.0\n#define SHIFT_RIGHT21 1.0 / 2097152.0\n#define SHIFT_RIGHT22 1.0 / 4194304.0\n#define SHIFT_RIGHT23 1.0 / 8388608.0\n#define SHIFT_RIGHT24 1.0 / 16777216.0\n\n#define SHIFT_LEFT17 131072.0\n#define SHIFT_LEFT18 262144.0\n#define SHIFT_LEFT19 524288.0\n#define SHIFT_LEFT20 1048576.0\n#define SHIFT_LEFT21 2097152.0\n#define SHIFT_LEFT22 4194304.0\n#define SHIFT_LEFT23 8388608.0\n#define SHIFT_LEFT24 16777216.0\n\nvec2 unpack_float(float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\n\nvec4 decode_color(vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\n", fs: "" }), this.registerModule("projection", { vs: "#define TILE_SIZE 512.0\n#define PI 3.1415926536\n#define WORLD_SCALE TILE_SIZE / (PI * 2.0)\n\n#define COORDINATE_SYSTEM_LNGLAT 1.0        // mapbox\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET 2.0 // mapbox offset\n#define COORDINATE_SYSTEM_VECTOR_TILE 3.0\n#define COORDINATE_SYSTEM_IDENTITY 4.0\n#define COORDINATE_SYSTEM_P20 5.0           // amap\n#define COORDINATE_SYSTEM_P20_OFFSET 6.0    // amap offset\n#define COORDINATE_SYSTEM_METER_OFFSET 7.0\n\n#define COORDINATE_SYSTEM_P20_2 8.0         // amap2.0\n\nuniform mat4 u_ViewMatrix;\nuniform mat4 u_ProjectionMatrix;\nuniform mat4 u_ViewProjectionMatrix;\nuniform float u_Zoom : 1;\nuniform float u_ZoomScale : 1;\n\nuniform float u_CoordinateSystem;\nuniform vec2 u_ViewportCenter;\nuniform vec4 u_ViewportCenterProjection;\nuniform vec3 u_PixelsPerDegree;\nuniform vec3 u_PixelsPerDegree2;\nuniform vec3 u_PixelsPerMeter;\n\nuniform vec2 u_ViewportSize;\nuniform float u_DevicePixelRatio;\nuniform float u_FocalDistance;\nuniform vec3 u_CameraPosition;\n\n// uniform mat4 u_Mvp;\n\n// web mercator coords -> world coords\nvec2 project_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  return vec2(\n    radians(x) + PI,\n    PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nfloat project_scale(float meters) {\n  return meters * u_PixelsPerMeter.z;\n}\n\n\n// offset coords -> world coords\nvec4 project_offset(vec4 offset) {\n  float dy = offset.y;\n  dy = clamp(dy, -1., 1.);\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\n}\n\nvec3 project_normal(vec3 normal) {\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\n}\n\nvec3 project_offset_normal(vec3 vector) {\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01\n    || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * u_PixelsPerDegree);\n  }\n  return project_normal(vector);\n}\n// || u_CoordinateSystem < COORDINATE_SYSTEM_P20_OFFSET + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_P20_OFFSET - 0.01\n// reverse Y\nvec3 reverse_offset_normal(vec3 vector) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 ||u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET ) {\n    return vector * vec3(1.0, -1.0, 1.0);\n  }\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\n    return vector;\n  }\n  return vector;\n}\n\nvec4 project_position(vec4 position) {\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\n  float c = COORDINATE_SYSTEM_LNGLAT;\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    float X = position.x - u_ViewportCenter.x;\n    float Y = position.y - u_ViewportCenter.y;\n    return project_offset(vec4(X, Y, position.z, position.w));\n  }\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\n    return vec4(\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\n      project_scale(position.z),\n      position.w\n    );\n  }\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\n    return vec4(\n      (project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale - vec2(215440491., 106744817.)) * vec2(1., -1.),\n      project_scale(position.z),\n      position.w\n    );\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // return vec4(\n    //   (position.xy * WORLD_SCALE * u_ZoomScale) * vec2(1., -1.), \n    //   project_scale(position.z), \n    //   position.w);\n\n     return vec4(\n      position.xy, \n      project_scale(position.z), \n      position.w);\n  }\n  return position;\n\n  // TODO: 瓦片坐标系 & 常规世界坐标系\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\n  return offset * u_FocalDistance;\n}\n\nfloat project_pixel_allmap(float pixel) {\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    return pixel * pow(2.0, u_Zoom);\n  }\n  return pixel;\n}\n\n// 适配纹理贴图的等像素大小\nfloat project_pixel_texture(float pixel) {\n  // mapbox zoom > 12\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    return pixel * pow(0.5, u_Zoom);\n  }\n\n  // amap2 zoom > 12\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\n  }\n\n  // amap zoom > 12\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    return pixel * pow(0.5, u_Zoom);\n  }\n  \n  // amap zoom < 12\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\n    return pixel * pow(2.0, (20.0 - u_Zoom));\n  }\n  return pixel * 2.0;\n}\n\n// 在不论什么底图下需要统一处理的时候使用\nfloat project_float_pixel(float pixel) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // mapbox P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n    return pixel * pow(2.0, (19.0 - u_Zoom));\n  }\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    // amap P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n    return pixel * pow(2.0, (19.0 - u_Zoom));\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // amap2 P20_2 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减3\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\n  }\n  return pixel;\n}\n\nfloat project_pixel(float pixel) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    // amap P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n    return pixel * pow(2.0, (19.0 - u_Zoom));\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // amap2 P20_2 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减3\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\n  }\n  return pixel;\n}\nvec2 project_pixel(vec2 pixel) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    // P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n    return pixel * pow(2.0, (19.0 - u_Zoom));\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // P20_2 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减3\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\n  }\n  return pixel * -1.;\n}\nvec3 project_pixel(vec3 pixel) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n    // P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n    return pixel * pow(2.0, (19.0 - u_Zoom));\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // P20_2 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减3\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\n  }\n  return pixel * -1.;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // Needs to be divided with project_uCommonUnitsPerMeter\n    position.w *= u_PixelsPerMeter.z;\n  }\n\n  return viewProjectionMatrix * position + center;\n}\n\n// Projects from common space coordinates to clip space\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(\n    position,\n    u_ViewProjectionMatrix,\n    u_ViewportCenterProjection\n  );\n}\n\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // Needs to be divided with project_uCommonUnitsPerMeter\n     pos.w = pos.w / u_PixelsPerMeter.z;\n  }\n  return pos;\n}\n\n\nbool isEqual( float a,  float b) {\n    return  a< b + 0.001 && a > b - 0.001;\n}", fs: "" }), this.registerModule("project", { vs: "\n#define E 2.718281828459045\nvec2 ProjectFlat(vec2 lnglat){\n  float maxs=85.0511287798;\n  float lat=max(min(maxs,lnglat.y),-maxs);\n  float scale= 268435456.;\n  float d=PI/180.;\n  float x=lnglat.x*d;\n  float y=lat*d;\n  y=log(tan((PI/4.)+(y/2.)));\n\n  float a=.5/PI,\n  b=.5,\n  c=-.5/PI;\n  d=.5;\n  x=scale*(a*x+b);\n  y=scale*(c*y+d);\n  return vec2(x,y);\n}\n\nvec2 unProjectFlat(vec2 px){\n  float a=.5/PI;\n  float b=.5;\n  float c=-.5/PI;\n  float d=.5;\n  float scale = 268435456.;\n  float x=(px.x/scale-b)/a;\n  float y=(px.y/scale-d)/c;\n  y=(atan(pow(E,y))-(PI/4.))*2.;\n  d=PI/180.;\n  float lat=y/d;\n  float lng=x/d;\n  return vec2(lng,lat);\n}\n\nfloat pixelDistance(vec2 from, vec2 to) {\n vec2 a1 = ProjectFlat(from);\n vec2 b1 = ProjectFlat(to);\n return distance(a1, b1);\n}\n\n// gaode2.0\nvec2 customProject(vec2 lnglat) { // 经纬度 => 平面坐标\n  float t = lnglat.x;\n  float e = lnglat.y;\n  float Sm = 180.0 / PI;\n  float Tm = 6378137.0;\n  float Rm = PI / 180.0;\n  float r = 85.0511287798;\n  e = max(min(r, e), -r);\n  t *= Rm;\n  e *= Rm;\n  e = log(tan(PI / 4.0 + e / 2.0));\n  return vec2(t * Tm, e * Tm);\n}\n\nvec2 unProjCustomCoord(vec2 point) { // 平面坐标 => 经纬度\n  float Sm = 57.29577951308232; //180 / Math.PI\n  float Tm = 6378137.0;\n  float t = point.x;\n  float e = point.y;\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\n}\n\n\nfloat customPixelDistance(vec2 from, vec2 to) {\n vec2 a1 = ProjectFlat(from);\n vec2 b1 = ProjectFlat(to);\n return distance(a1, b1);\n}", fs: "" }), this.registerModule("sdf_2d", { vs: "", fs: "/**\n * 2D signed distance field functions\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdEquilateralTriangle(vec2 p) {\n  float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPentagon(vec2 p, float r) {\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n  p.x = abs(p.x);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagon(vec2 p, float r) {\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdOctogon(vec2 p, float r) {\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n  p = abs(p);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagram(vec2 p, float r) {\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdRhombus(vec2 p, vec2 b) {\n  vec2 q = abs(p);\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d); // can delay this sqrt\n  return ((p.y-b)*d>p.x*b)\n          ? length(p-vec2(0.0,b))\n          : length(p-vec2(-d,0.0))-r;\n}\n" }), this.registerModule("lighting", { vs: "// Blinn-Phong model\n// apply lighting in vertex shader instead of fragment shader\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\nuniform float u_Ambient : 1.0;\nuniform float u_Diffuse : 1.0;\nuniform float u_Specular : 1.0;\nuniform int u_NumOfDirectionalLights : 1;\nuniform int u_NumOfSpotLights : 0;\n\n#define SHININESS 32.0\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\n#define MAX_NUM_OF_SPOT_LIGHTS 3\n\nstruct DirectionalLight {\n  vec3 direction;\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n};\n\nstruct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n  float constant;\n  float linear;\n  float quadratic;\n  float angle;\n  float blur;\n  float exponent;\n};\n\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\n\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\n  vec3 lightDir = normalize(light.direction);\n  // diffuse shading\n  float diff = max(dot(normal, lightDir), 0.0);\n  // Blinn-Phong specular shading\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\n\n  vec3 ambient = light.ambient * u_Ambient;\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\n  vec3 specular = light.specular * spec * u_Specular;\n\n  return ambient + diffuse + specular;\n}\n\n// vec3 calc_spot_light(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {\n//   vec3 lightDir = normalize(light.position - fragPos);\n//   // diffuse shading\n//   float diff = max(dot(normal, lightDir), 0.0);\n//   // specular shading\n//   vec3 reflectDir = reflect(-lightDir, normal);\n//   float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\n//   // attenuation\n//   float distance = length(light.position - fragPos);\n//   float attenuation = 1.0 / (light.constant + light.linear * distance +\n//           light.quadratic * (distance * distance));\n\n//   vec3 ambient = light.ambient * u_Ambient;\n//   vec3 diffuse = light.diffuse * diff * u_Diffuse;\n//   vec3 specular = light.specular * spec * u_Specular;\n\n//   float spotEffect = dot(normalize(light.direction), -lightDir);\n//   float spotCosCutoff = cos(light.angle / 180.0 * PI);\n//   float spotCosOuterCutoff = cos((light.angle + light.blur) / 180.0 * PI);\n//   float spotCosInnerCutoff = cos((light.angle - light.blur) / 180.0 * PI);\n//   if (spotEffect > spotCosCutoff) {\n//     spotEffect = pow(smoothstep(spotCosOuterCutoff, spotCosInnerCutoff, spotEffect), light.exponent);\n//   } else {\n//     spotEffect = 0.0;\n//   }\n\n//   return ambient + attenuation * (spotEffect * diffuse + specular);\n// }\n\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\n  vec3 weight = vec3(0.0);\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\n    if (i >= u_NumOfDirectionalLights) {\n      break;\n    }\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\n  }\n  // for (int i = 0; i < MAX_NUM_OF_SPOT_LIGHTS; i++) {\n  //   if (i >= u_NumOfSpotLights) {\n  //     break;\n  //   }\n  //   weight += calc_spot_light(u_SpotLights[i], normal, position, viewDir);\n  // }\n  return weight;\n}\n", fs: "" }), this.registerModule("light", { vs: "#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\n\nfloat calc_lighting(vec4 pos) {\n\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\n\n    vec3 worldNormal = a_Normal;\n      // //cal light weight\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\n\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\n\n    vec3 halfDir = normalize(viewDir+lightDir);\n      // //lambert\n    float lambert = dot(worldNormal, lightDir);\n        //specular\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\n        //sum to light weight\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\n\n    return lightWeight;\n}\n", fs: "" }), this.registerModule("picking", { vs: "attribute vec3 a_PickingColor;\nvarying vec4 v_PickingResult;\n\nuniform vec3 u_PickingColor : [0, 0, 0];\nuniform vec3 u_CurrentSelectedId : [0, 0, 0];\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\nuniform vec4 u_SelectColor : [0, 0, 0, 0];\nuniform float u_PickingStage : 0.0;\nuniform float u_PickingThreshold : 1.0;\nuniform float u_PickingBuffer: 0.0;\nuniform float u_shaderPick;\nuniform float u_EnableSelect: 0.0;\n\n#define PICKING_NONE 0.0\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\n#define NORMAL 0.0\n#define HIGHLIGHT 1.0\n#define SELECT 2.0\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    abs(vertexColor.r - u_PickingColor.r) < u_PickingThreshold &&\n    abs(vertexColor.g - u_PickingColor.g) < u_PickingThreshold &&\n    abs(vertexColor.b - u_PickingColor.b) < u_PickingThreshold;\n}\n\n// 判断当前点是否已经被 select 选中\nbool isVertexSelected(vec3 vertexColor) {\n  return\n    abs(vertexColor.r - u_CurrentSelectedId.r) < u_PickingThreshold &&\n    abs(vertexColor.g - u_CurrentSelectedId.g) < u_PickingThreshold &&\n    abs(vertexColor.b - u_CurrentSelectedId.b) < u_PickingThreshold;\n}\n\nvoid setPickingColor(vec3 pickingColor) {\n  if(u_shaderPick < 0.5) {\n    return;\n  }\n  // compares only in highlight stage\n\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\n\n  // if (u_EnableSelect == 1.0 && u_PickingStage == PICKING_HIGHLIGHT && isVertexSelected(pickingColor)) {\n  //   // 选中态\n  //   v_PickingResult.a = SELECT;\n  // } else if (u_PickingStage == PICKING_HIGHLIGHT && isVertexPicked(pickingColor)) {\n  //   // 高亮态\n  //   v_PickingResult.a = HIGHLIGHT;\n  // } else {\n  //   v_PickingResult.a = NORMAL;\n  // }\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nfloat setPickingSize(float x) {\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\n}\n\nfloat setPickingOrder(float z) {\n   bool selected = bool(v_PickingResult.a);\n   return selected ? z + 1. : 0.;\n}\n", fs: "varying vec4 v_PickingResult;\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\nuniform vec4 u_SelectColor : [0, 0, 0, 0];\nuniform float u_PickingStage : 0.0;\nuniform float u_shaderPick;\n\nuniform float u_activeMix: 0;\n\n#define PICKING_NONE 0.0\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\n#define HIGHLIGHT 1.0\n#define SELECT 2.0\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 filterHighlightColor(vec4 color, float weight) {\n  // float selected = v_PickingResult.a;\n  bool selected = bool(v_PickingResult.a);\n\n  // if (selected == SELECT) {\n  if (selected) {\n  //   // 点击选中状态\n  //   vec4 selectColor = u_SelectColor * COLOR_SCALE;\n  //   return selectColor;\n  // } else if (selected == HIGHLIGHT) {\n  //   // hover 高亮状态\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\n\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 filterPickingColor(vec4 color) {\n  vec3 pickingColor = v_PickingResult.rgb;\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 filterColor(vec4 color) {\n  // TODO: 过滤多余的 shader 计算\n  // return color;\n  if(u_shaderPick < 0.5) {\n    return color; // 暂时去除 直接取消计算在选中时拖拽地图会有问题\n  } else {\n    return filterPickingColor(filterHighlightColor(color, 1.0));\n  }\n  \n}\n\n// TODO: 优化水波点 blend additive 模式下有的拾取效果 \nvec4 filterColorAnimate(vec4 color) {\n  // TODO: 过滤多余的 shader 计算\n  if(u_shaderPick < 0.5) {\n    return color; // 暂时去除 直接取消计算在选中时拖拽地图会有问题\n  } else {\n    return filterPickingColor(filterHighlightColor(color, color.a));\n  }\n}\n\nvec4 filterColorWithLight(vec4 color, float lightWeight) {\n  // TODO: 过滤多余的 shader 计算\n  // return color;\n  if(u_shaderPick < 0.5) {\n    return color; // 暂时去除 直接取消计算在选中时拖拽地图会有问题\n  } else {\n    return filterPickingColor(filterHighlightColor(color, lightWeight));\n  }\n}\n\n" }), this.registerModule("styleMapping", { vs: "attribute float a_vertexId;\n\nuniform mat4 u_cellTypeLayout;      // 描述数据纹理 cell 结构的矩阵\nuniform sampler2D u_dataTexture;    // 数据纹理\n\nbool hasOpacity() { // 判断 cell 中是否存在 opacity 的数据\n  return u_cellTypeLayout[1][0] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\nbool hasStrokeOpacity() { // 判断 cell 中是否存在 strokeOpacity 的数据\n  return u_cellTypeLayout[1][1] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\nbool hasStrokeWidth() { // 判断 cell 中是否存在 strokeWidth 的数据\n  return u_cellTypeLayout[1][2] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\nbool hasStroke() { // 判断 cell 中是否存在 stroke 的数据\n  return u_cellTypeLayout[1][3] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\nbool hasOffsets() { // 判断 cell 中是否存在 offsets 的数据\n  return u_cellTypeLayout[2][0] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\nbool hasThetaOffset() { // 判断 cell 中是否存在 thetaOffset 的数据\n  return u_cellTypeLayout[2][1] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\n}\n\n// 根据坐标位置先是计算 uv ，然后根据 uv 从数据纹理中取值\nfloat pos2value(vec2 pos, float columnWidth, float rowHeight) {\n  float u = (pos.r - 1.0) * columnWidth + columnWidth/2.0;\n  float v = 1.0 - ((pos.g - 1.0) * rowHeight + rowHeight/2.0);\n  return texture2D(u_dataTexture, vec2(u, v)).r;\n}\n\n/*\n  currentRow 当前行\n  currentColumn 当前列\n  columnCount 有多少列\n  nextStep 需要计算当前 cell 后的第几个 cell （当前 cell 则 nextStep = 0）\n*/\nvec2 nextPos(float currentRow, float currentColumn, float columnCount, float nextStep) {\n  float nextColumn = currentColumn;\n  float nextRow = currentRow;\n  if(currentColumn + nextStep <= columnCount){\n    nextColumn = currentColumn + nextStep;\n  } else {\n    nextColumn = mod(currentColumn + nextStep, columnCount); // 不会出现跨两行\n    nextRow = currentRow + 1.0;\n  }\n  return vec2(nextColumn, nextRow);\n}\n\n// 计算当前单个 cell 的大小\nfloat calCellCount() { \n  //   u_cellTypeLayout\n  //   cal_height, WIDTH, 0.0, 0.0, // rowCount columnCount - 几行几列\n  //   1.0, 1.0, 1.0, 0.0, // opacity strokeOpacity strokeWidth stroke - 1.0 表示有数据映射、0.0 表示没有\n  //   1.0, 1.0, 0.0, 0.0, // offsets thetaOffset\n  //   0.0, 0.0, 0.0, 0.0\n  \n  return  u_cellTypeLayout[1][0] +        // opacity\n          u_cellTypeLayout[1][1] +        // strokeOpacity\n          u_cellTypeLayout[1][2] +        // strokeWidth\n          u_cellTypeLayout[1][3] * 4.0 +  // stroke\n          u_cellTypeLayout[2][0] * 2.0 +  // offsets\n          u_cellTypeLayout[2][1];         // thetaOffset\n}", fs: "" }), this.registerModule("styleMappingCalThetaOffset", { vs: "\n// 计算 thetaOffset 和标示在 cell 中取值位置的偏移量 textureOffset\nvec2 calThetaOffsetAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\n  if(!hasThetaOffset()) { // 数据纹理中不存在 thetaOffset 的时候取默认值（用户在 style 中传入的是常量）\n    return vec2(u_thetaOffset, textureOffset);\n  } else {\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    float textureThetaOffset = pos2value(valuePos, columnWidth, rowHeight);\n    return vec2(textureThetaOffset, textureOffset + 1.0);\n  }\n}\n", fs: "" }), this.registerModule("styleMappingCalOpacity", { vs: "\n// 计算 opacity 和标示在 cell 中取值位置的偏移量 textureOffset\nvec2 calOpacityAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\n  if(!hasOpacity()) { // 数据纹理中不存在 opacity 的时候取默认值（用户在 style 中传入的是常量）\n    return vec2(u_opacity, textureOffset);\n  } else {\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    float textureOpacity = pos2value(valuePos, columnWidth, rowHeight);\n    return vec2(textureOpacity, textureOffset + 1.0);\n  }\n}\n", fs: "" }), this.registerModule("styleMappingCalStrokeOpacity", { vs: "\n// 计算 strokeOpaicty 和标示在 cell 中取值位置的偏移量 textureOffset\nvec2 calStrokeOpacityAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\n  if(!hasStrokeOpacity()) {\n    return vec2(u_stroke_opacity, textureOffset);\n  } else {\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    float textureStrokeOpacity = pos2value(valuePos, columnWidth, rowHeight);\n    return vec2(textureStrokeOpacity, textureOffset + 1.0);\n  }\n}\n", fs: "" }), this.registerModule("styleMappingCalStrokeWidth", { vs: "\n// 计算 strokeWidth 和标示在 cell 中取值位置的偏移量 textureOffset\nvec2 calStrokeWidthAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\n  if(!hasStrokeWidth()) {\n    return vec2(u_stroke_width, textureOffset);\n  } else {\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    float textureStrokeWidth = pos2value(valuePos, columnWidth, rowHeight);\n    return vec2(textureStrokeWidth, textureOffset + 1.0);\n  }\n}\n", fs: "" }) } }, { key: "registerModule", value: function (t, e) { if (!this.rawContentCache[t]) { var n = e.vs, r = e.fs, i = e.uniforms, o = qv(n), a = o.content, s = o.uniforms, l = qv(r), u = l.content, c = l.uniforms; this.rawContentCache[t] = { fs: u, uniforms: Yv(Yv(Yv({}, s), c), i), vs: a } } } }, { key: "destroy", value: function () { this.moduleCache = {}, this.rawContentCache = {} } }, { key: "getModule", value: function (t) { var e = this; if (this.moduleCache[t]) return this.moduleCache[t]; var n = this.rawContentCache[t].vs, r = this.rawContentCache[t].fs, i = this.processModule(n, [], "vs"), o = i.content, a = i.includeList, s = this.processModule(r, [], "fs"), l = s.content, u = s.includeList, c = l, p = Hv(a.concat(u).concat(t)).reduce((function (t, n) { return Yv(Yv({}, t), e.rawContentCache[n].uniforms) }), {}); return $v.test(l) || (c = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif\n" + l), this.moduleCache[t] = { fs: c.trim(), uniforms: p, vs: o.trim() }, this.moduleCache[t] } }, { key: "processModule", value: function (t, e, n) { var r = this; return { content: t.replace(ty, (function (t, i) { var o = i.split(" ")[0].replace(/"/g, ""); if (e.indexOf(o) > -1) return ""; var a = r.rawContentCache[o][n]; return e.push(o), r.processModule(a, e, n).content })), includeList: e } } }]), t }()) || Wv; function ny(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Wr(t));); return t } function ry() { return ry = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var r = ny(t, e); if (r) { var i = Object.getOwnPropertyDescriptor(r, e); return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value } }, ry.apply(this, arguments) } !function (t) { t.Normal = "normal", t.PostProcessing = "post-processing" }(Kv || (Kv = {})); var iy, oy = ut.injectable()(Qv = function () { function t() { Ar(this, t), kr(this, "shaderModuleService", void 0), kr(this, "rendererService", void 0), kr(this, "cameraService", void 0), kr(this, "mapService", void 0), kr(this, "interactionService", void 0), kr(this, "layerService", void 0), kr(this, "config", void 0) } return Or(t, [{ key: "getName", value: function () { return "" } }, { key: "getType", value: function () { return Kv.Normal } }, { key: "init", value: function (t, e) { this.config = e, this.rendererService = t.getContainer().get(Tr.IRendererService), this.cameraService = t.getContainer().get(Tr.ICameraService), this.mapService = t.getContainer().get(Tr.IMapService), this.interactionService = t.getContainer().get(Tr.IInteractionService), this.layerService = t.getContainer().get(Tr.ILayerService), this.shaderModuleService = t.getContainer().get(Tr.IShaderModuleService) } }, { key: "render", value: function (t) { } }]), t }()) || Qv; function ay(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var sy, ly, uy, cy, py, hy = ut.injectable()(iy = function (t) { Ur(n, t); var e = ay(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getName", value: function () { return "clear" } }, { key: "init", value: function (t, e) { ry(Wr(n.prototype), "init", this).call(this, t, e) } }, { key: "render", value: function () { this.rendererService.clear({ color: [0, 0, 0, 0], depth: 1, framebuffer: null }) } }]), n }(oy)) || iy; function fy(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return dy(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dy(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function dy(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var vy, yy = (sy = ut.injectable(), ly = ut.inject(Tr.IPostProcessor), sy((cy = function () { function t() { Ar(this, t), kr(this, "passes", []), Ef(this, "postProcessor", py, this), kr(this, "layer", void 0), kr(this, "renderFlag", void 0), kr(this, "width", 0), kr(this, "height", 0) } var e; return Or(t, [{ key: "setLayer", value: function (t) { this.layer = t } }, { key: "setRenderFlag", value: function (t) { this.renderFlag = t } }, { key: "getRenderFlag", value: function () { return this.renderFlag } }, { key: "getPostProcessor", value: function () { return this.postProcessor } }, { key: "render", value: (e = nd(gd.mark((function t() { var e, n, r; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: e = fy(this.passes), t.prev = 1, e.s(); case 3: if ((n = e.n()).done) { t.next = 9; break } return r = n.value, t.next = 7, r.render(this.layer); case 7: t.next = 3; break; case 9: t.next = 14; break; case 11: t.prev = 11, t.t0 = t.catch(1), e.e(t.t0); case 14: return t.prev = 14, e.f(), t.finish(14); case 17: return t.next = 19, this.postProcessor.render(this.layer); case 19: case "end": return t.stop() } }), t, this, [[1, 11, 14, 17]]) }))), function () { return e.apply(this, arguments) }) }, { key: "resize", value: function (t, e) { this.width === t && this.height === e || (this.postProcessor.resize(t, e), this.width = t, this.height = e) } }, { key: "add", value: function (t, e) { t.getType() === Kv.PostProcessing ? this.postProcessor.add(t, this.layer, e) : (t.init(this.layer, e), this.passes.push(t)) } }, { key: "insert", value: function (t, e, n) { t.init(this.layer, e), this.passes.splice(n, 0, t) } }, { key: "destroy", value: function () { this.passes.length = 0 } }]), t }(), py = Cf(cy.prototype, "postProcessor", [ly], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), uy = cy)) || uy); function gy(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function _y(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? gy(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : gy(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function xy(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var by = ut.injectable()(vy = function (t) { Ur(n, t); var e = xy(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "pickingFBO", void 0), kr(Gr(t), "layer", void 0), kr(Gr(t), "width", 0), kr(Gr(t), "height", 0), kr(Gr(t), "alreadyInRendering", !1), kr(Gr(t), "pickFromPickingFBO", (function (e) { var n = e.x, r = e.y, i = e.lngLat, o = e.type; if (t.layer.isVisible() && t.layer.needPick(o)) { var a, s = t.rendererService, l = s.getViewportSize, u = s.readPixels, c = s.useFramebuffer, p = l(), h = p.width, f = p.height, d = t.layer.getLayerConfig(), m = d.enableHighlight, v = d.enableSelect, y = n * go, g = r * go; if (!(y > h || y < 0 || g > f || g < 0)) c(t.pickingFBO, (function () { var e; if (0 !== (a = u({ x: Math.round(y), y: Math.round(f - (r + 1) * go), width: 1, height: 1, data: new Uint8Array(4), framebuffer: t.pickingFBO }))[0] || 0 !== a[1] || 0 !== a[2]) { var s = ba(a), l = t.layer.getSource().getFeatureById(s), c = { x: n, y: r, type: o, lngLat: i, featureId: s, feature: l }; l && (t.layer.setCurrentPickId(s), t.triggerHoverOnLayer(c)) } else { var p = { x: n, y: r, lngLat: i, type: null === t.layer.getCurrentPickId() ? "un" + o : "mouseout", featureId: null, feature: null }; t.triggerHoverOnLayer(_y(_y({}, p), {}, { type: "unpick" })), t.triggerHoverOnLayer(p), t.layer.setCurrentPickId(null) } m && t.highlightPickedFeature(a), v && "click" === o && (null === (e = a) || void 0 === e ? void 0 : e.toString()) !== [0, 0, 0, 0].toString() && t.selectFeature(a) })) } })), t } return Or(n, [{ key: "getType", value: function () { return Kv.Normal } }, { key: "getName", value: function () { return "pixelPicking" } }, { key: "init", value: function (t, e) { ry(Wr(n.prototype), "init", this).call(this, t, e), this.layer = t; var r = this.rendererService, i = r.createTexture2D, o = r.createFramebuffer, a = (0, r.getViewportSize)(), s = a.width, l = a.height; this.pickingFBO = o({ color: i({ width: s, height: l, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.interactionService.on(Wf.Hover, this.pickFromPickingFBO), this.interactionService.on(Wf.Select, this.selectFeatureHandle.bind(this)), this.interactionService.on(Wf.Active, this.highlightFeatureHandle.bind(this)) } }, { key: "render", value: function (t) { var e = this; if (!this.alreadyInRendering) { var n = this.rendererService, r = n.getViewportSize, i = n.useFramebuffer, o = n.clear, a = r(), s = a.width, l = a.height; this.alreadyInRendering = !0, this.width === s && this.height === l || (this.pickingFBO.resize({ width: s, height: l }), this.width = s, this.height = l), i(this.pickingFBO, (function () { o({ framebuffer: e.pickingFBO, color: [0, 0, 0, 0], stencil: 0, depth: 1 }); var n = e.layer.multiPassRenderer.getRenderFlag(); e.layer.multiPassRenderer.setRenderFlag(!1), t.hooks.beforePickingEncode.call(), t.render(), t.hooks.afterPickingEncode.call(), e.layer.multiPassRenderer.setRenderFlag(n), e.alreadyInRendering = !1 })) } } }, { key: "triggerHoverOnLayer", value: function (t) { this.layer.emit(t.type, t) } }, { key: "highlightPickedFeature", value: function (t) { var e = Lr(t, 3), n = e[0], r = e[1], i = e[2]; this.layer.hooks.beforeHighlight.call([n, r, i]), this.layerService.renderLayers() } }, { key: "selectFeature", value: function (t) { var e = Lr(t, 3), n = e[0], r = e[1], i = e[2]; this.layer.hooks.beforeSelect.call([n, r, i]), this.layerService.renderLayers() } }, { key: "selectFeatureHandle", value: function (t) { var e = wa(t.featureId); this.selectFeature(new Uint8Array(e)) } }, { key: "highlightFeatureHandle", value: function (t) { var e = wa(t.featureId); this.highlightPickedFeature(new Uint8Array(e)) } }]), n }(oy)) || vy; var wy = function (t, e, n) { var r = -1, i = t.length; e < 0 && (e = -e > i ? 0 : i + e), (n = n > i ? i : n) < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>= 0; for (var o = Array(i); ++r < i;)o[r] = t[r + e]; return o }, Sy = wy; var Ey = function (t, e, n) { var r = t.length; return n = void 0 === n ? r : n, !e && n >= r ? t : Sy(t, e, n) }, Cy = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"); var Ty = function (t) { return Cy.test(t) }; var Ay = function (t) { return t.split("") }, My = "[\\ud800-\\udfff]", Oy = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", ky = "\\ud83c[\\udffb-\\udfff]", Iy = "[^\\ud800-\\udfff]", Py = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ly = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ry = "(?:" + Oy + "|" + ky + ")" + "?", Dy = "[\\ufe0e\\ufe0f]?", Ny = Dy + Ry + ("(?:\\u200d(?:" + [Iy, Py, Ly].join("|") + ")" + Dy + Ry + ")*"), zy = "(?:" + [Iy + Oy + "?", Oy, Py, Ly, My].join("|") + ")", Fy = RegExp(ky + "(?=" + ky + ")|" + zy + Ny, "g"); var By = function (t) { return t.match(Fy) || [] }, jy = Ay, Uy = Ty, Vy = By; var Gy = function (t) { return Uy(t) ? Vy(t) : jy(t) }; var Hy = function (t, e) { for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;)i[n] = e(t[n], n, t); return i }, Wy = au, Xy = ep; var qy = Hy, Zy = pp, Yy = function (t) { return "symbol" == typeof t || Xy(t) && "[object Symbol]" == Wy(t) }, Ky = Yl ? Yl.prototype : void 0, Qy = Ky ? Ky.toString : void 0; var Jy = function t(e) { if ("string" == typeof e) return e; if (Zy(e)) return qy(e, t) + ""; if (Yy(e)) return Qy ? Qy.call(e) : ""; var n = e + ""; return "0" == n && 1 / e == -Infinity ? "-0" : n }, $y = Jy; var tg = function (t) { return null == t ? "" : $y(t) }, eg = Ey, ng = Ty, rg = Gy, ig = tg; var og = function (t) { return function (e) { e = ig(e); var n = ng(e) ? rg(e) : void 0, r = n ? n[0] : e.charAt(0), i = n ? eg(n, 1).join("") : e.slice(1); return r[t]() + i } }, ag = og("toUpperCase"), sg = tg, lg = ag; var ug = function (t) { return lg(sg(t).toLowerCase()) }; var cg = function (t, e, n, r) { var i = -1, o = null == t ? 0 : t.length; for (r && o && (n = t[++i]); ++i < o;)n = e(n, t[i], i, t); return n }; var pg = function (t) { return function (e) { return null == t ? void 0 : t[e] } }, hg = pg({ "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "Ç": "C", "ç": "c", "Ð": "D", "ð": "d", "È": "E", "É": "E", "Ê": "E", "Ë": "E", "è": "e", "é": "e", "ê": "e", "ë": "e", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I", "ì": "i", "í": "i", "î": "i", "ï": "i", "Ñ": "N", "ñ": "n", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O", "Ø": "O", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o", "ø": "o", "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "ù": "u", "ú": "u", "û": "u", "ü": "u", "Ý": "Y", "ý": "y", "ÿ": "y", "Æ": "Ae", "æ": "ae", "Þ": "Th", "þ": "th", "ß": "ss", "Ā": "A", "Ă": "A", "Ą": "A", "ā": "a", "ă": "a", "ą": "a", "Ć": "C", "Ĉ": "C", "Ċ": "C", "Č": "C", "ć": "c", "ĉ": "c", "ċ": "c", "č": "c", "Ď": "D", "Đ": "D", "ď": "d", "đ": "d", "Ē": "E", "Ĕ": "E", "Ė": "E", "Ę": "E", "Ě": "E", "ē": "e", "ĕ": "e", "ė": "e", "ę": "e", "ě": "e", "Ĝ": "G", "Ğ": "G", "Ġ": "G", "Ģ": "G", "ĝ": "g", "ğ": "g", "ġ": "g", "ģ": "g", "Ĥ": "H", "Ħ": "H", "ĥ": "h", "ħ": "h", "Ĩ": "I", "Ī": "I", "Ĭ": "I", "Į": "I", "İ": "I", "ĩ": "i", "ī": "i", "ĭ": "i", "į": "i", "ı": "i", "Ĵ": "J", "ĵ": "j", "Ķ": "K", "ķ": "k", "ĸ": "k", "Ĺ": "L", "Ļ": "L", "Ľ": "L", "Ŀ": "L", "Ł": "L", "ĺ": "l", "ļ": "l", "ľ": "l", "ŀ": "l", "ł": "l", "Ń": "N", "Ņ": "N", "Ň": "N", "Ŋ": "N", "ń": "n", "ņ": "n", "ň": "n", "ŋ": "n", "Ō": "O", "Ŏ": "O", "Ő": "O", "ō": "o", "ŏ": "o", "ő": "o", "Ŕ": "R", "Ŗ": "R", "Ř": "R", "ŕ": "r", "ŗ": "r", "ř": "r", "Ś": "S", "Ŝ": "S", "Ş": "S", "Š": "S", "ś": "s", "ŝ": "s", "ş": "s", "š": "s", "Ţ": "T", "Ť": "T", "Ŧ": "T", "ţ": "t", "ť": "t", "ŧ": "t", "Ũ": "U", "Ū": "U", "Ŭ": "U", "Ů": "U", "Ű": "U", "Ų": "U", "ũ": "u", "ū": "u", "ŭ": "u", "ů": "u", "ű": "u", "ų": "u", "Ŵ": "W", "ŵ": "w", "Ŷ": "Y", "ŷ": "y", "Ÿ": "Y", "Ź": "Z", "Ż": "Z", "Ž": "Z", "ź": "z", "ż": "z", "ž": "z", "Ĳ": "IJ", "ĳ": "ij", "Œ": "Oe", "œ": "oe", "ŉ": "'n", "ſ": "s" }), fg = tg, dg = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, mg = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g"); var vg = function (t) { return (t = fg(t)) && t.replace(dg, hg).replace(mg, "") }, yg = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g; var gg = function (t) { return t.match(yg) || [] }, _g = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/; var xg = function (t) { return _g.test(t) }, bg = "\\u2700-\\u27bf", wg = "a-z\\xdf-\\xf6\\xf8-\\xff", Sg = "A-Z\\xc0-\\xd6\\xd8-\\xde", Eg = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Cg = "[" + Eg + "]", Tg = "\\d+", Ag = "[\\u2700-\\u27bf]", Mg = "[" + wg + "]", Og = "[^\\ud800-\\udfff" + Eg + Tg + bg + wg + Sg + "]", kg = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ig = "[\\ud800-\\udbff][\\udc00-\\udfff]", Pg = "[" + Sg + "]", Lg = "(?:" + Mg + "|" + Og + ")", Rg = "(?:" + Pg + "|" + Og + ")", Dg = "(?:['’](?:d|ll|m|re|s|t|ve))?", Ng = "(?:['’](?:D|LL|M|RE|S|T|VE))?", zg = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?", Fg = "[\\ufe0e\\ufe0f]?", Bg = Fg + zg + ("(?:\\u200d(?:" + ["[^\\ud800-\\udfff]", kg, Ig].join("|") + ")" + Fg + zg + ")*"), jg = "(?:" + [Ag, kg, Ig].join("|") + ")" + Bg, Ug = RegExp([Pg + "?" + Mg + "+" + Dg + "(?=" + [Cg, Pg, "$"].join("|") + ")", Rg + "+" + Ng + "(?=" + [Cg, Pg + Lg, "$"].join("|") + ")", Pg + "?" + Lg + "+" + Dg, Pg + "+" + Ng, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Tg, jg].join("|"), "g"); var Vg = function (t) { return t.match(Ug) || [] }, Gg = gg, Hg = xg, Wg = tg, Xg = Vg; var qg = function (t, e, n) { return t = Wg(t), void 0 === (e = n ? void 0 : e) ? Hg(t) ? Xg(t) : Gg(t) : t.match(e) || [] }, Zg = cg, Yg = vg, Kg = qg, Qg = RegExp("['’]", "g"); var Jg, $g, t_, e_, n_, r_ = function (t) { return function (e) { return Zg(Kg(Yg(e).replace(Qg, "")), t, "") } }, i_ = ug, o_ = r_((function (t, e, n) { return e = e.toLowerCase(), t + (n ? i_(e) : e) })), a_ = o_; function s_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function l_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? s_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : s_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var u_, c_ = (Jg = ut.injectable(), $g = ut.inject(Tr.IShaderModuleService), Jg((e_ = function () { function t() { Ar(this, t), Ef(this, "shaderModuleService", n_, this), kr(this, "rendererService", void 0), kr(this, "config", void 0), kr(this, "quad", "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}"), kr(this, "enabled", !0), kr(this, "renderToScreen", !1), kr(this, "model", void 0), kr(this, "name", void 0), kr(this, "optionsToUpdate", {}) } return Or(t, [{ key: "getName", value: function () { return this.name } }, { key: "setName", value: function (t) { this.name = t } }, { key: "getType", value: function () { return Kv.PostProcessing } }, { key: "init", value: function (t, e) { this.config = e, this.rendererService = t.getContainer().get(Tr.IRendererService), this.shaderModuleService = t.getContainer().get(Tr.IShaderModuleService); var n = this.rendererService, r = n.createAttribute, i = n.createBuffer, o = n.createModel, a = this.setupShaders(), s = a.vs, l = a.fs, u = a.uniforms; this.model = o({ vs: s, fs: l, attributes: { a_Position: r({ buffer: i({ data: [-4, -4, 4, -4, 0, 4], type: id.FLOAT }), size: 2 }) }, uniforms: l_(l_({ u_Texture: null }, u), this.config && this.convertOptionsToUniforms(this.config)), depth: { enable: !1 }, count: 3, blend: { enable: "copy" === this.getName() } }) } }, { key: "render", value: function (t, e) { var n = this, r = t.multiPassRenderer.getPostProcessor(), i = this.rendererService, o = i.useFramebuffer, a = i.getViewportSize, s = i.clear, l = a(), u = l.width, c = l.height; o(this.renderToScreen ? null : r.getWriteFBO(), (function () { s({ framebuffer: r.getWriteFBO(), color: [0, 0, 0, 0], depth: 1, stencil: 0 }); var t = l_({ u_BloomFinal: 0, u_Texture: r.getReadFBO(), u_ViewportSize: [u, c] }, n.convertOptionsToUniforms(n.optionsToUpdate)); e && (t.u_BloomFinal = 1, t.u_Texture2 = e), n.model.draw({ uniforms: t }) })) } }, { key: "isEnabled", value: function () { return this.enabled } }, { key: "setEnabled", value: function (t) { this.enabled = t } }, { key: "setRenderToScreen", value: function (t) { this.renderToScreen = t } }, { key: "updateOptions", value: function (t) { this.optionsToUpdate = l_(l_({}, this.optionsToUpdate), t) } }, { key: "setupShaders", value: function () { throw new Error("Method not implemented.") } }, { key: "convertOptionsToUniforms", value: function (t) { var e = {}; return Object.keys(t).forEach((function (n) { Wd(t[n]) || (e["u_".concat(ag(a_(n)))] = t[n]) })), e } }]), t }(), n_ = Cf(e_.prototype, "shaderModuleService", [$g], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), t_ = e_)) || t_); function p_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function h_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? p_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : p_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function f_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var d_, m_ = ut.injectable()(u_ = function (t) { Ur(n, t); var e = f_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("blur-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform float u_BloomFinal: 0.0;\nuniform sampler2D u_Texture;\nuniform sampler2D u_Texture2;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform float u_radius: 5.0;\nuniform float u_intensity: 0.3;\nuniform float u_baseRadio: 0.5;\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nfloat luminance(vec4 color) {\n  return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;\n}\n\nvoid main() {\n  // vec4 baseColor = texture2D(u_Texture, v_UV);\n\n  float r = sqrt(u_radius);\n\n  vec4 c1 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(u_radius, 0.0));\n  // c1 *= luminance(c1);\n  vec4 c2 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(0.0, u_radius));\n  // c2 *= luminance(c2);\n  vec4 c3 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, r));\n  // c3 *= luminance(c3);\n  vec4 c4 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, -r));\n  // c4 *= luminance(c4);\n  vec4 inbloomColor = (c1 + c2 + c3 + c4) * 0.25;\n\n  // float lum = luminance(inbloomColor);\n  // inbloomColor.rgb *= lum;\n\n  if(u_BloomFinal > 0.0) {\n    vec4 baseColor = texture2D(u_Texture2, v_UV);\n    float baselum = luminance(baseColor);\n    gl_FragColor = mix(inbloomColor, baseColor, u_baseRadio);\n    if(baselum <= 0.2) {\n      gl_FragColor = inbloomColor * u_intensity;\n    }\n  } else {\n    gl_FragColor = inbloomColor;\n  }\n}" }); var t = this.shaderModuleService.getModule("blur-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: h_(h_({}, r), {}, { u_ViewportSize: [o, a] }) } } }, { key: "convertOptionsToUniforms", value: function (t) { var e = {}; return Wd(t.bloomRadius) || (e.u_radius = t.bloomRadius), Wd(t.bloomIntensity) || (e.u_intensity = t.bloomIntensity), Wd(t.bloomBaseRadio) || (e.u_baseRadio = t.bloomBaseRadio), e } }]), n }(c_)) || u_; function v_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function y_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? v_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : v_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function g_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var __, x_ = ut.injectable()(d_ = function (t) { Ur(n, t); var e = g_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("blur-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_BlurDir: [1.0, 0.0];\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\n}" }); var t = this.shaderModuleService.getModule("blur-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: y_(y_({}, r), {}, { u_ViewportSize: [o, a] }) } } }, { key: "convertOptionsToUniforms", value: function (t) { var e = {}; return Wd(t.blurRadius) || (e.u_BlurDir = [t.blurRadius, 0]), e } }]), n }(c_)) || d_; function b_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function w_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? b_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : b_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function S_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var E_, C_ = ut.injectable()(__ = function (t) { Ur(n, t); var e = S_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("blur-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_BlurDir: [1.0, 0.0];\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\n}" }); var t = this.shaderModuleService.getModule("blur-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: w_(w_({}, r), {}, { u_ViewportSize: [o, a] }) } } }, { key: "convertOptionsToUniforms", value: function (t) { var e = {}; return Wd(t.blurRadius) || (e.u_BlurDir = [0, t.blurRadius]), e } }]), n }(c_)) || __; function T_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function A_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? T_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : T_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function M_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var O_, k_ = ut.injectable()(E_ = function (t) { Ur(n, t); var e = M_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("colorhalftone-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: 'varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_Center : [0.5, 0.5];\nuniform float u_Angle : 0;\nuniform float u_Size : 8;\n\n#pragma include "common"\n\nfloat scale = PI / u_Size;\n\nfloat pattern(float u_Angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(u_Angle), c = cos(u_Angle);\n  vec2 tex = texCoord * texSize - u_Center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/fun/colorhalftone.js\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n    cmy * 10.0 - 3.0 + vec3(\n      pattern(u_Angle + 0.26179, texSize, texCoord),\n      pattern(u_Angle + 1.30899, texSize, texCoord),\n      pattern(u_Angle, texSize, texCoord)\n    ),\n    0.0,\n    1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(u_Angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = colorHalftone_filterColor(gl_FragColor, u_ViewportSize, v_UV);\n}' }); var t = this.shaderModuleService.getModule("colorhalftone-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: A_(A_({}, r), {}, { u_ViewportSize: [o, a] }) } } }]), n }(c_)) || E_; function I_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var P_, L_ = ut.injectable()(O_ = function (t) { Ur(n, t); var e = I_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { return this.shaderModuleService.registerModule("copy-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n}" }), this.shaderModuleService.getModule("copy-pass") } }]), n }(c_)) || O_; function R_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function D_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? R_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : R_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function N_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var z_, F_ = ut.injectable()(P_ = function (t) { Ur(n, t); var e = N_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("hexagonalpixelate-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_Center : [0.5, 0.5];\nuniform float u_Scale : 10;\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/fun/hexagonalpixelate.js\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - u_Center * texSize) / u_Scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= u_Scale / texSize;\n  return texture2D(texture, choice + u_Center);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = hexagonalPixelate_sampleColor(u_Texture, u_ViewportSize, v_UV);\n}" }); var t = this.shaderModuleService.getModule("hexagonalpixelate-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: D_(D_({}, r), {}, { u_ViewportSize: [o, a] }) } } }]), n }(c_)) || P_; function B_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function j_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? B_(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : B_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function U_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var V_, G_ = ut.injectable()(z_ = function (t) { Ur(n, t); var e = U_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { this.shaderModuleService.registerModule("ink-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform float u_Strength : 0.6;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = u_Strength * u_Strength * u_Strength * u_Strength * u_Strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = ink_sampleColor(u_Texture, u_ViewportSize, v_UV);\n}" }); var t = this.shaderModuleService.getModule("ink-pass"), e = t.vs, n = t.fs, r = t.uniforms, i = this.rendererService.getViewportSize(), o = i.width, a = i.height; return { vs: e, fs: n, uniforms: j_(j_({}, r), {}, { u_ViewportSize: [o, a] }) } } }]), n }(c_)) || z_; function H_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var W_, X_ = ut.injectable()(V_ = function (t) { Ur(n, t); var e = H_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { return this.shaderModuleService.registerModule("noise-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform float u_Amount : 0.5;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * u_Amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = noise_filterColor(gl_FragColor, v_UV);\n}" }), this.shaderModuleService.getModule("noise-pass") } }]), n }(c_)) || V_; function q_(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Z_, Y_, K_, Q_, J_, $_, tx, ex = ut.injectable()(W_ = function (t) { Ur(n, t); var e = q_(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "setupShaders", value: function () { return this.shaderModuleService.registerModule("sepia-pass", { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform float u_Amount : 0.5;\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/sepia.js\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * u_Amount))) + (g * (0.769 * u_Amount)) + (b * (0.189 * u_Amount)));\n  color.g = min(1.0, (r * 0.349 * u_Amount) + (g * (1.0 - (0.314 * u_Amount))) + (b * 0.168 * u_Amount));\n  color.b = min(1.0, (r * 0.272 * u_Amount) + (g * 0.534 * u_Amount) + (b * (1.0 - (0.869 * u_Amount))));\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = sepia_filterColor(gl_FragColor);\n}" }), this.shaderModuleService.getModule("sepia-pass") } }]), n }(c_)) || W_, nx = (Z_ = ut.injectable(), Y_ = ut.inject(Tr.IRendererService), K_ = ut.postConstruct(), Z_((J_ = function () { function t() { Ar(this, t), Ef(this, "rendererService", $_, this), kr(this, "passes", []), kr(this, "readFBO", void 0), kr(this, "writeFBO", void 0) } var e, n; return Or(t, [{ key: "getReadFBO", value: function () { return this.readFBO } }, { key: "getWriteFBO", value: function () { return this.writeFBO } }, { key: "getCurrentFBOTex", value: function () { var t = this.rendererService, e = t.getViewportSize, n = t.createTexture2D, r = e(); return n({ x: 0, y: 0, width: r.width, height: r.height, copy: !0 }) } }, { key: "getReadFBOTex", value: function () { var t = this, e = this.rendererService.useFramebuffer; return new Promise((function (n, r) { e(t.readFBO, nd(gd.mark((function e() { return gd.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: n(t.getCurrentFBOTex()); case 1: case "end": return e.stop() } }), e) })))) })) } }, { key: "renderBloomPass", value: (n = nd(gd.mark((function t(e, n) { var r, i; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, this.getReadFBOTex(); case 2: r = t.sent, i = 0; case 4: if (!(i < 4)) { t.next = 11; break } return t.next = 7, n.render(e, r); case 7: this.swap(), i++, t.next = 4; break; case 11: case "end": return t.stop() } }), t, this) }))), function (t, e) { return n.apply(this, arguments) }) }, { key: "render", value: (e = nd(gd.mark((function t(e) { var n, r; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: n = 0; case 1: if (!(n < this.passes.length)) { t.next = 15; break } if ((r = this.passes[n]).setRenderToScreen(this.isLastEnabledPass(n)), "bloom" !== r.getName()) { t.next = 9; break } return t.next = 7, this.renderBloomPass(e, r); case 7: t.next = 12; break; case 9: return t.next = 11, r.render(e); case 11: n !== this.passes.length - 1 && this.swap(); case 12: n++, t.next = 1; break; case 15: case "end": return t.stop() } }), t, this) }))), function (t) { return e.apply(this, arguments) }) }, { key: "resize", value: function (t, e) { this.readFBO.resize({ width: t, height: e }), this.writeFBO.resize({ width: t, height: e }) } }, { key: "add", value: function (t, e, n) { t.init(e, n), this.passes.push(t) } }, { key: "insert", value: function (t, e, n, r) { t.init(n, r), this.passes.splice(e, 0, t) } }, { key: "getPostProcessingPassByName", value: function (t) { return this.passes.find((function (e) { return e.getName() === t })) } }, { key: "init", value: function () { var t = this.rendererService, e = t.createFramebuffer, n = t.createTexture2D; this.readFBO = e({ color: n({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.writeFBO = e({ color: n({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }) } }, { key: "isLastEnabledPass", value: function (t) { for (var e = t + 1; e < this.passes.length; e++)if (this.passes[e].isEnabled()) return !1; return !0 } }, { key: "swap", value: function () { var t = this.readFBO; this.readFBO = this.writeFBO, this.writeFBO = t } }]), t }(), $_ = Cf(J_.prototype, "rendererService", [Y_], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), Cf(J_.prototype, "init", [K_], Object.getOwnPropertyDescriptor(J_.prototype, "init"), J_.prototype), Q_ = J_)) || Q_); function rx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ix, ox, ax, sx, lx, ux = ut.injectable()(tx = function (t) { Ur(n, t); var e = rx(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getType", value: function () { return Kv.Normal } }, { key: "getName", value: function () { return "render" } }, { key: "init", value: function (t, e) { ry(Wr(n.prototype), "init", this).call(this, t, e) } }, { key: "render", value: function (t) { var e = this.rendererService, n = e.useFramebuffer, r = e.clear, i = t.multiPassRenderer.getPostProcessor().getReadFBO(); n(i, (function () { r({ color: [0, 0, 0, 0], depth: 1, stencil: 0, framebuffer: i }), t.multiPassRenderer.setRenderFlag(!1), t.models.forEach((function (e) { e.draw({ uniforms: t.layerModel.getUninforms() }) })), t.multiPassRenderer.setRenderFlag(!0) })) } }]), n }(oy)) || tx; function cx(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function px(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? cx(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : cx(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function hx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var fx = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n}"; function dx(t, e) { for (var n = 0, r = 1 / e, i = t; i > 0;)n += r * (i % e), i = Math.floor(i / e), r /= e; return n } var mx = 1, vx = (ix = ut.injectable(), ox = ut.inject(Tr.IShaderModuleService), ix((sx = function (t) { Ur(n, t); var e = hx(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return Ef(Gr(t = e.call.apply(e, [this].concat(i))), "shaderModuleService", lx, Gr(t)), kr(Gr(t), "haltonSequence", []), kr(Gr(t), "accumulatingId", 0), kr(Gr(t), "frame", 0), kr(Gr(t), "timer", void 0), kr(Gr(t), "sampleRenderTarget", void 0), kr(Gr(t), "prevRenderTarget", void 0), kr(Gr(t), "outputRenderTarget", void 0), kr(Gr(t), "copyRenderTarget", void 0), kr(Gr(t), "blendModel", void 0), kr(Gr(t), "outputModel", void 0), kr(Gr(t), "copyModel", void 0), t } return Or(n, [{ key: "getType", value: function () { return Kv.Normal } }, { key: "getName", value: function () { return "taa" } }, { key: "init", value: function (t, e) { ry(Wr(n.prototype), "init", this).call(this, t, e); var r = this.rendererService, i = r.createFramebuffer, o = r.createTexture2D; this.sampleRenderTarget = i({ color: o({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.prevRenderTarget = i({ color: o({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.outputRenderTarget = i({ color: o({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }), this.copyRenderTarget = i({ color: o({ width: 1, height: 1, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE }) }); for (var a = 0; a < 30; a++)this.haltonSequence.push([dx(a, 2), dx(a, 3)]); this.blendModel = this.createTriangleModel("blend-pass", "uniform float u_opacity : 1.0;\nuniform float u_MixRatio : 0.5;\n\nuniform sampler2D u_Diffuse1;\nuniform sampler2D u_Diffuse2;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  vec4 texel1 = texture2D(u_Diffuse1, v_UV);\n  vec4 texel2 = texture2D(u_Diffuse2, v_UV);\n  gl_FragColor = u_opacity * mix(texel1, texel2, u_MixRatio);\n}\n"), this.outputModel = this.createTriangleModel("copy-pass", fx, { blend: { enable: !0, func: { srcRGB: id.ONE, dstRGB: id.ONE_MINUS_SRC_ALPHA, srcAlpha: id.ONE, dstAlpha: id.ONE_MINUS_SRC_ALPHA }, equation: { rgb: id.FUNC_ADD, alpha: id.FUNC_ADD } } }), this.copyModel = this.createTriangleModel("copy-pass", fx) } }, { key: "render", value: function (t) { var e = this, n = this.rendererService, r = n.clear, i = n.getViewportSize, o = n.useFramebuffer, a = i(), s = a.width, l = a.height; this.sampleRenderTarget.resize({ width: s, height: l }), this.prevRenderTarget.resize({ width: s, height: l }), this.outputRenderTarget.resize({ width: s, height: l }), this.copyRenderTarget.resize({ width: s, height: l }), this.resetFrame(), this.stopAccumulating(); var u = t.multiPassRenderer.getPostProcessor().getReadFBO(); o(u, (function () { r({ color: [0, 0, 0, 0], depth: 1, stencil: 0, framebuffer: u }), t.multiPassRenderer.setRenderFlag(!1), t.render(), t.multiPassRenderer.setRenderFlag(!0) })); var c = function n(r) { e.accumulatingId && r === e.accumulatingId && (e.isFinished() || (e.doRender(t), oo.requestAnimationFrame((function () { n(r) })))) }; this.accumulatingId = mx++, this.timer = oo.setTimeout((function () { c(e.accumulatingId) }), 50) } }, { key: "doRender", value: function (t) { var e = this, n = this.rendererService, r = n.clear, i = n.getViewportSize, o = n.useFramebuffer, a = i(), s = a.width, l = a.height, u = t.getLayerConfig().jitterScale, c = void 0 === u ? 1 : u, p = this.haltonSequence[this.frame % this.haltonSequence.length]; this.cameraService.jitterProjectionMatrix((2 * p[0] - 1) / s * c, (2 * p[1] - 1) / l * c), t.multiPassRenderer.setRenderFlag(!1), t.hooks.beforeRender.call(), o(this.sampleRenderTarget, (function () { r({ color: [0, 0, 0, 0], depth: 1, stencil: 0, framebuffer: e.sampleRenderTarget }), t.render() })), t.hooks.afterRender.call(), t.multiPassRenderer.setRenderFlag(!0); var h = t.getLayerConfig(); o(this.outputRenderTarget, (function () { e.blendModel.draw({ uniforms: { u_opacity: h.opacity || 1, u_MixRatio: 0 === e.frame ? 1 : .9, u_Diffuse1: e.sampleRenderTarget, u_Diffuse2: 0 === e.frame ? t.multiPassRenderer.getPostProcessor().getReadFBO() : e.prevRenderTarget } }) })), 0 === this.frame && r({ color: [0, 0, 0, 0], depth: 1, stencil: 0, framebuffer: this.copyRenderTarget }), this.frame >= 1 && (o(this.copyRenderTarget, (function () { e.outputModel.draw({ uniforms: { u_Texture: e.outputRenderTarget } }) })), o(t.multiPassRenderer.getPostProcessor().getReadFBO(), (function () { e.copyModel.draw({ uniforms: { u_Texture: e.copyRenderTarget } }) })), t.multiPassRenderer.getPostProcessor().render(t)); var f = this.prevRenderTarget; this.prevRenderTarget = this.outputRenderTarget, this.outputRenderTarget = f, this.frame++, this.cameraService.clearJitterProjectionMatrix() } }, { key: "isFinished", value: function () { return this.frame >= this.haltonSequence.length } }, { key: "resetFrame", value: function () { this.frame = 0 } }, { key: "stopAccumulating", value: function () { this.accumulatingId = 0, oo.clearTimeout(this.timer) } }, { key: "createTriangleModel", value: function (t, e, n) { this.shaderModuleService.registerModule(t, { vs: "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}", fs: e }); var r = this.shaderModuleService.getModule(t), i = r.vs, o = r.fs, a = r.uniforms, s = this.rendererService, l = s.createAttribute, u = s.createBuffer; return (0, s.createModel)(px({ vs: i, fs: o, attributes: { a_Position: l({ buffer: u({ data: [-4, -4, 4, -4, 0, 4], type: id.FLOAT }), size: 2 }) }, uniforms: px({}, a), depth: { enable: !1 }, count: 3 }, n)) } }]), n }(oy), lx = Cf(sx.prototype, "shaderModuleService", [ox], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), ax = sx)) || ax), yx = new ut.Container; yx.bind(Tr.IGlobalConfigService).to(Sf).inSingletonScope(), ut.decorate(ut.injectable(), st.exports.EventEmitter), yx.bind(Tr.IEventEmitter).to(st.exports.EventEmitter); var gx, _x, xx, bx, Sx = Cr(yx, !1), Ex = function (t) { var e = Sx.lazyInject(t); return function (t, n, r) { e.call(this, t, n), r && (r.initializer = function () { return t[n] }) } }, Cx = 0; function Tx(t) { var e = new ut.Container; return e.parent = t, e.bind(Tr.IStyleAttributeService).to(Qd).inSingletonScope(), e.bind(Tr.IMultiPassRenderer).to(yy).inSingletonScope(), e.bind(Tr.IPostProcessor).to(nx).inSingletonScope(), e } t.BlendType = void 0, (gx = t.BlendType || (t.BlendType = {})).normal = "normal", gx.additive = "additive", gx.subtractive = "subtractive", gx.min = "min", gx.max = "max", gx.none = "none", function (t) { t.LINEAR = "linear", t.POWER = "power", t.LOG = "log", t.IDENTITY = "identity", t.TIME = "time", t.QUANTILE = "quantile", t.QUANTIZE = "quantize", t.THRESHOLD = "threshold", t.CAT = "cat" }(_x || (_x = {})), function (t) { t.CONSTANT = "constant", t.VARIABLE = "variable" }(xx || (xx = {})), function (t) { t[t.Attribute = 0] = "Attribute", t[t.InstancedAttribute = 1] = "InstancedAttribute", t[t.Uniform = 2] = "Uniform" }(bx || (bx = {})); var Ax, Mx = ["mapload", "mapchange", "mapAfterFrameChange"], Ox = "u_ProjectionMatrix", kx = "u_ViewMatrix", Ix = "u_ViewProjectionMatrix", Px = "u_Zoom", Lx = "u_ZoomScale", Rx = "u_FocalDistance", Dx = "u_CameraPosition", Nx = ["loaded", "maploaded", "resize", "destroy", "dragstart", "dragging", "dragend", "dragcancel"]; function zx(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Fx(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? zx(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : zx(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Bx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } t.PositionType = void 0, (Ax = t.PositionType || (t.PositionType = {})).TOPRIGHT = "topright", Ax.TOPLEFT = "topleft", Ax.BOTTOMRIGHT = "bottomright", Ax.BOTTOMLEFT = "bottomleft", Ax.TOPCENTER = "topcenter", Ax.BOTTOMCENTER = "bottomcenter", Ax.LEFTCENTER = "leftcenter", Ax.RIGHTCENTER = "rightcenter"; var jx = 0, Ux = function (e) { Ur(r, e); var n = Bx(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this)), "controlOption", void 0), kr(Gr(e), "container", void 0), kr(Gr(e), "sceneContainer", void 0), kr(Gr(e), "mapsService", void 0), kr(Gr(e), "renderService", void 0), kr(Gr(e), "layerService", void 0), kr(Gr(e), "controlService", void 0), kr(Gr(e), "isShow", void 0), e.controlOption = Fx(Fx({}, e.getDefault()), t || {}), e } return Or(r, [{ key: "getDefault", value: function () { return { position: t.PositionType.TOPRIGHT, name: "".concat(jx++) } } }, { key: "setPosition", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t.PositionType.BOTTOMRIGHT, n = this.controlService; return n && n.removeControl(this), this.controlOption.position = e, n && n.addControl(this, this.sceneContainer), this } }, { key: "addTo", value: function (t) { this.mapsService = t.get(Tr.IMapService), this.renderService = t.get(Tr.IRendererService), this.layerService = t.get(Tr.ILayerService), this.controlService = t.get(Tr.IControlService), this.sceneContainer = t, this.isShow = !0, this.container = this.onAdd(); var e = this.container, n = this.controlOption.position, r = this.controlService.controlCorners[n]; return co(e, "l7-control"), -1 !== n.indexOf("bottom") ? r.insertBefore(e, r.firstChild) : r.appendChild(e), this } }, { key: "onAdd", value: function () { throw new Error("Method not implemented.") } }, { key: "onRemove", value: function () { throw new Error("Method not implemented.") } }, { key: "hide", value: function () { co(this.container, "l7-control-hide"), this.isShow = !1 } }, { key: "show", value: function () { po(this.container, "l7-control-hide"), this.isShow = !0 } }, { key: "remove", value: function () { if (!this.mapsService) return this; uo(this.container), this.onRemove() } }, { key: "_refocusOnMap", value: function (t) { if (this.mapsService && t && t.screenX > 0 && t.screenY > 0) { var e = this.mapsService.getContainer(); null !== e && e.focus() } } }]), r }(st.exports.EventEmitter); function Vx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Gx = function (e) { Ur(r, e); var n = Vx(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this, t)), "layerControlInputs", void 0), kr(Gr(e), "layers", void 0), kr(Gr(e), "lastZIndex", void 0), kr(Gr(e), "handlingClick", void 0), kr(Gr(e), "layersLink", void 0), kr(Gr(e), "baseLayersList", void 0), kr(Gr(e), "separator", void 0), kr(Gr(e), "overlaysList", void 0), kr(Gr(e), "form", void 0), e.layerControlInputs = [], e.layers = [], e.lastZIndex = 0, e.handlingClick = !1, e.initLayers(), Uo(["checkDisabledLayers", "onLayerChange", "collapse", "extend", "expand", "onInputClick"], Gr(e)), e } return Or(r, [{ key: "getDefault", value: function () { return { collapsed: !0, position: t.PositionType.TOPRIGHT, autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, name: "layers" } } }, { key: "onAdd", value: function () { var t = this; return this.initLayout(), this.update(), this.mapsService.on("zoomend", this.checkDisabledLayers), this.layers.forEach((function (e) { e.layer.on("remove", t.onLayerChange), e.layer.on("add", t.onLayerChange) })), this.container } }, { key: "addVisualLayer", value: function (t, e) { return this.addLayer(t, e, !0), this.mapsService ? this.update() : this } }, { key: "expand", value: function () { var t = this.renderService.getViewportSize().height; co(this.container, "l7-control-layers-expanded"), this.form.style.height = "null"; var e = t - (this.container.offsetTop + 50); return e < this.form.clientHeight ? (co(this.form, "l7-control-layers-scrollbar"), this.form.style.height = e + "px") : po(this.form, "l7-control-layers-scrollbar"), this.checkDisabledLayers(), this } }, { key: "collapse", value: function () { return po(this.container, "l7-control-layers-expanded"), this } }, { key: "onRemove", value: function () { var t = this; this.mapsService && (this.mapsService.off("click", this.collapse), this.layers.forEach((function (e) { e.layer.off("remove", t.onLayerChange), e.layer.off("add", t.onLayerChange) }))) } }, { key: "initLayout", value: function () { var t = "l7-control-layers", e = this.container = lo("div", t), n = this.controlOption.collapsed; e.setAttribute("aria-haspopup", "true"); var r = this.form = lo("form", t + "-list"); n && (this.mapsService.on("click", this.collapse), e.addEventListener("mouseenter", this.expand), e.addEventListener("mouseleave", this.collapse)), this.layersLink = lo("a", t + "-toggle", e), this.layersLink.title = "Layers", n || this.expand(), this.baseLayersList = lo("div", t + "-base", r), this.separator = lo("div", t + "-separator", r), this.overlaysList = lo("div", t + "-overlays", r), e.appendChild(r) } }, { key: "initLayers", value: function () { var t = this, e = this.controlOption, n = e.baseLayers, r = void 0 === n ? {} : n, i = e.overlayers, o = void 0 === i ? {} : i; Object.keys(r).forEach((function (e, n) { t.addLayer(r[e], e, !1) })), Object.keys(o).forEach((function (e, n) { t.addLayer(o[e], e, !0) })) } }, { key: "update", value: function () { if (!this.container) return this; var t, e, n, r; mo(this.baseLayersList), mo(this.overlaysList), this.layerControlInputs = []; var i = 0; for (n = 0; n < this.layers.length; n++)r = this.layers[n], this.addItem(r), e = e || r.overlay, t = t || !r.overlay, i += r.overlay ? 0 : 1; return this.controlOption.hideSingleBase && (t = t && i > 1, this.baseLayersList.style.display = t ? "" : "none"), this.separator.style.display = e && t ? "" : "none", this } }, { key: "checkDisabledLayers", value: function () { for (var t, e, n = this.layerControlInputs, r = this.mapsService.getZoom(), i = n.length - 1; i >= 0; i--)if (t = n[i], (e = this.layerService.getLayer(t.layerId)) && e.inited) { var o = e.getMinZoom(), a = e.getMaxZoom(); t.disabled = r < o || r > a } } }, { key: "addLayer", value: function (t, e, n) { this.mapsService && (t.on("add", this.onLayerChange), t.on("remove", this.onLayerChange)), this.layers.push({ layer: t, name: e, overlay: n }); var r = this.controlOption, i = r.sortLayers, o = r.sortFunction, a = r.autoZIndex; i && this.layers.sort((function (t, e) { return o(t.layer, e.layer, t.name, e.name) })), a && t.setZIndex && (this.lastZIndex++, t.setZIndex(this.lastZIndex)), this.expandIfNotCollapsed() } }, { key: "expandIfNotCollapsed", value: function () { return this.mapsService && !this.controlOption.collapsed && this.expand(), this } }, { key: "onLayerChange", value: function (t) { this.handlingClick || this.update(); var e = this.layerService.getLayer(t.target.layerId), n = null != e && e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null; n && this.emit(n, e) } }, { key: "createRadioElement", value: function (t, e) { var n = '<input type="radio" class="l7-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", r = document.createElement("div"); return r.innerHTML = n, r.firstChild } }, { key: "addItem", value: function (t) { var e, n = document.createElement("label"), r = this.layerService.getLayer(t.layer.id), i = r && r.inited && t.layer.isVisible(); t.overlay ? ((e = document.createElement("input")).type = "checkbox", e.className = "l7-control-layers-selector", e.defaultChecked = i) : e = this.createRadioElement("l7-base-layers", i), this.layerControlInputs.push(e), e.layerId = t.layer.id, e.addEventListener("click", this.onInputClick); var o = document.createElement("span"); o.innerHTML = " " + t.name; var a = document.createElement("div"); return n.appendChild(a), a.appendChild(e), a.appendChild(o), (t.overlay ? this.overlaysList : this.baseLayersList).appendChild(n), this.checkDisabledLayers(), n } }, { key: "onInputClick", value: function () { var t, e, n = this.layerControlInputs, r = [], i = []; this.handlingClick = !0; for (var o = n.length - 1; o >= 0; o--)t = n[o], e = this.layerService.getLayer(t.layerId), t.checked ? r.push(e) : t.checked || i.push(e); i.forEach((function (t) { t.hide() })), r.forEach((function (t) { t.show() })), this.handlingClick = !1 } }]), r }(Ux); function Hx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Wx = function (e) { Ur(r, e); var n = Hx(r); function r() { return Ar(this, r), n.apply(this, arguments) } return Or(r, [{ key: "getDefault", value: function () { return { position: t.PositionType.BOTTOMLEFT, name: "logo" } } }, { key: "onAdd", value: function () { var t = lo("div", "l7-control-logo"), e = lo("a", "l7-ctrl-logo"); return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://antv.alipay.com/l7", e.setAttribute("aria-label", "AntV logo"), e.setAttribute("rel", "noopener nofollow"), t } }, { key: "onRemove", value: function () { return null } }]), r }(Ux); function Xx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var qx = function (e) { Ur(r, e); var n = Xx(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this, t)), "mScale", void 0), kr(Gr(e), "iScale", void 0), Uo(["update"], Gr(e)), e } return Or(r, [{ key: "getDefault", value: function () { return { position: t.PositionType.BOTTOMLEFT, maxWidth: 100, metric: !0, updateWhenIdle: !1, imperial: !1, name: "scale" } } }, { key: "onAdd", value: function () { var t = "l7-control-scale", e = lo("div", t); this.addScales(t + "-line", e); var n = this.controlOption.updateWhenIdle; return this.mapsService.on(n ? "moveend" : "mapmove", this.update), this.mapsService.on(n ? "zoomend" : "zoomchange", this.update), this.update(), e } }, { key: "onRemove", value: function () { var t = this.controlOption.updateWhenIdle; this.mapsService.off(t ? "zoomend" : "zoomchange", this.update), this.mapsService.off(t ? "moveend" : "mapmove", this.update) } }, { key: "update", value: function () { var t = this.mapsService, e = this.controlOption.maxWidth, n = t.getSize()[1] / 2, r = t.containerToLngLat([0, n]), i = t.containerToLngLat([e, n]), o = No([r.lng, r.lat], [i.lng, i.lat]); this.updateScales(o) } }, { key: "updateScales", value: function (t) { var e = this.controlOption, n = e.metric, r = e.imperial; n && t && this.updateMetric(t), r && t && this.updateImperial(t) } }, { key: "updateMetric", value: function (t) { var e = this.getRoundNum(t), n = e < 1e3 ? e + " m" : e / 1e3 + " km"; this.updateScale(this.mScale, n, e / t) } }, { key: "updateImperial", value: function (t) { var e, n, r, i = 3.2808399 * t; i > 5280 ? (e = i / 5280, n = this.getRoundNum(e), this.updateScale(this.iScale, n + " mi", n / e)) : (r = this.getRoundNum(i), this.updateScale(this.iScale, r + " ft", r / i)) } }, { key: "updateScale", value: function (t, e, n) { var r = this.controlOption.maxWidth; t.style.width = Math.round(r * n) + "px", t.innerHTML = e } }, { key: "getRoundNum", value: function (t) { var e = Math.pow(10, (Math.floor(t) + "").length - 1), n = t / e; return e * (n = n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : 1) } }, { key: "addScales", value: function (t, e) { var n = this.controlOption, r = n.metric, i = n.imperial; r && (this.mScale = lo("div", t, e)), i && (this.iScale = lo("div", t, e)) } }]), r }(Ux); function Zx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var Yx = function (e) { Ur(r, e); var n = Zx(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this, t)), "disabled", void 0), kr(Gr(e), "zoomInButton", void 0), kr(Gr(e), "zoomOutButton", void 0), Uo(["updateDisabled", "zoomIn", "zoomOut"], Gr(e)), e } return Or(r, [{ key: "getDefault", value: function () { return { position: t.PositionType.TOPLEFT, zoomInText: "+", zoomInTitle: "Zoom in", zoomOutText: "&#x2212;", zoomOutTitle: "Zoom out", name: "zoom" } } }, { key: "onAdd", value: function () { var t = "l7-control-zoom", e = lo("div", t + " l7-bar"); return this.zoomInButton = this.createButton(this.controlOption.zoomInText, this.controlOption.zoomInTitle, t + "-in", e, this.zoomIn), this.zoomOutButton = this.createButton(this.controlOption.zoomOutText, this.controlOption.zoomOutTitle, t + "-out", e, this.zoomOut), this.mapsService.on("zoomend", this.updateDisabled), this.mapsService.on("zoomchange", this.updateDisabled), this.updateDisabled(), e } }, { key: "onRemove", value: function () { this.mapsService.off("zoomend", this.updateDisabled), this.mapsService.off("zoomchange", this.updateDisabled) } }, { key: "disable", value: function () { return this.disabled = !0, this.updateDisabled(), this } }, { key: "enable", value: function () { return this.disabled = !1, this.updateDisabled(), this } }, { key: "zoomIn", value: function () { !this.disabled && this.mapsService.getZoom() < this.mapsService.getMaxZoom() && this.mapsService.zoomIn() } }, { key: "zoomOut", value: function () { !this.disabled && this.mapsService.getZoom() > this.mapsService.getMinZoom() && this.mapsService.zoomOut() } }, { key: "createButton", value: function (t, e, n, r, i) { var o = lo("a", n, r); return o.innerHTML = t, o.title = e, o.href = "javascript:void(0)", o.addEventListener("click", i), o } }, { key: "updateDisabled", value: function () { var t = this.mapsService, e = "l7-disabled"; po(this.zoomInButton, e), po(this.zoomOutButton, e), (this.disabled || t.getZoom() <= t.getMinZoom()) && co(this.zoomOutButton, e), (this.disabled || t.getZoom() >= t.getMaxZoom()) && co(this.zoomInButton, e) } }]), r }(Ux); function Kx(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Qx(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Kx(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Kx(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Jx(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var $x = function (e) { Ur(r, e); var n = Jx(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this)), "markerOption", void 0), kr(Gr(e), "defaultMarker", void 0), kr(Gr(e), "popup", void 0), kr(Gr(e), "mapsService", void 0), kr(Gr(e), "sceneSerive", void 0), kr(Gr(e), "lngLat", void 0), kr(Gr(e), "scene", void 0), kr(Gr(e), "added", !1), kr(Gr(e), "eventHandle", (function (t) { e.emit(t.type, { target: t, data: e.markerOption.extData, lngLat: e.lngLat }) })), e.markerOption = Qx(Qx({}, e.getDefault()), t), Uo(["update", "onMove", "onUp", "addDragHandler", "onMapClick"], Gr(e)), e.init(), e } return Or(r, [{ key: "getDefault", value: function () { return { element: void 0, anchor: t.TooltipAnchorType.BOTTOM, offsets: [0, 0], color: "#5B8FF9", draggable: !1 } } }, { key: "addTo", value: function (t) { this.scene = t, this.mapsService = t.get(Tr.IMapService), this.sceneSerive = t.get(Tr.ISceneService); var e = this.markerOption, n = e.element; return e.draggable, this.mapsService.getMarkerContainer().appendChild(n), this.registerMarkerEvent(n), this.mapsService.on("camerachange", this.update), this.mapsService.on("viewchange", this.update), this.update(), this.added = !0, this.emit("added"), this } }, { key: "remove", value: function () { this.mapsService && (this.mapsService.off("click", this.onMapClick), this.mapsService.off("move", this.update), this.mapsService.off("moveend", this.update), this.mapsService.off("mousedown", this.addDragHandler), this.mapsService.off("touchstart", this.addDragHandler), this.mapsService.off("mouseup", this.onUp), this.mapsService.off("touchend", this.onUp)), this.unRegisterMarkerEvent(), this.removeAllListeners(); var t = this.markerOption.element; return t && uo(t), this.popup && this.popup.remove(), this } }, { key: "setLnglat", value: function (t) { return this.lngLat = t, Array.isArray(t) && (this.lngLat = { lng: t[0], lat: t[1] }), this.popup && this.popup.setLnglat(this.lngLat), this.update(), this } }, { key: "getLnglat", value: function () { return this.lngLat } }, { key: "getElement", value: function () { return this.markerOption.element } }, { key: "setElement", value: function (t) { var e = this; if (!this.added) return this.once("added", (function () { e.setElement(t) })), this; var n = this.markerOption.element; return n && uo(n), this.markerOption.element = t, this.init(), this.mapsService.getMarkerContainer().appendChild(t), this.registerMarkerEvent(t), this.update(), this } }, { key: "openPopup", value: function () { var t = this; if (!this.added) return this.once("added", (function () { t.openPopup() })), this; var e = this.popup; return e ? (e.isOpen() || e.addTo(this.scene), this) : this } }, { key: "closePopup", value: function () { var t = this; this.added || this.once("added", (function () { t.closePopup() })); var e = this.popup; return e && e.remove(), this } }, { key: "setPopup", value: function (t) { return this.popup = t, this.lngLat && this.popup.setLnglat(this.lngLat), this } }, { key: "togglePopup", value: function () { var t = this.popup; return t ? (t.isOpen() ? t.remove() : t.addTo(this.scene), this) : this } }, { key: "getPopup", value: function () { return this.popup } }, { key: "getOffset", value: function () { return this.markerOption.offsets } }, { key: "setDraggable", value: function (t) { throw new Error("Method not implemented.") } }, { key: "isDraggable", value: function () { return this.markerOption.draggable } }, { key: "getExtData", value: function () { return this.markerOption.extData } }, { key: "setExtData", value: function (t) { this.markerOption.extData = t } }, { key: "update", value: function () { if (this.mapsService) { var t = this.markerOption, e = t.element, n = t.anchor; this.updatePosition(), yo(e, "".concat(Sa[n])) } } }, { key: "onMapClick", value: function (t) { var e = this.markerOption.element; this.popup && e && this.togglePopup() } }, { key: "updatePosition", value: function () { if (this.mapsService) { var t = this.markerOption, e = t.element, n = t.offsets, r = this.lngLat, i = r.lng, o = r.lat, a = this.mapsService.getBounds(), s = this.mapsService.lngLatToContainer([i, o]); if (e) { e.style.display = "block", e.style.whiteSpace = "nowrap"; var l = this.mapsService.getContainer(), u = 0, c = 0; if (l && (u = l.scrollWidth, c = l.scrollHeight), Math.abs(a[0][0]) > 180 || Math.abs(a[1][0]) > 180) { if (s.x > u) { var p = this.mapsService.lngLatToContainer([i - 360, o]); s.x = p.x } if (s.x < 0) { var h = this.mapsService.lngLatToContainer([i + 360, o]); s.x = h.x } } (s.x > u || s.x < 0 || s.y > c || s.y < 0) && (e.style.display = "none"), e.style.left = s.x + n[0] + "px", e.style.top = s.y - n[1] + "px" } } } }, { key: "init", value: function () { var t = this, e = this.markerOption.element, n = this.markerOption, r = n.color, i = n.anchor; if (!e) { this.defaultMarker = !0, e = lo("div"), this.markerOption.element = e; var o = document.createElementNS("http://www.w3.org/2000/svg", "svg"); o.setAttributeNS(null, "display", "block"), o.setAttributeNS(null, "height", "48px"), o.setAttributeNS(null, "width", "48px"), o.setAttributeNS(null, "viewBox", "0 0 1024 1024"); var a = document.createElementNS("http://www.w3.org/2000/svg", "path"); a.setAttributeNS(null, "d", "M512 490.666667C453.12 490.666667 405.333333 442.88 405.333333 384 405.333333 325.12 453.12 277.333333 512 277.333333 570.88 277.333333 618.666667 325.12 618.666667 384 618.666667 442.88 570.88 490.666667 512 490.666667M512 85.333333C346.88 85.333333 213.333333 218.88 213.333333 384 213.333333 608 512 938.666667 512 938.666667 512 938.666667 810.666667 608 810.666667 384 810.666667 218.88 677.12 85.333333 512 85.333333Z"), a.setAttributeNS(null, "fill", r), o.appendChild(a), e.appendChild(o) } co(e, "l7-marker"), Object.keys(this.markerOption.style || {}).forEach((function (n) { var r, i, o = (null === (r = t.markerOption) || void 0 === r ? void 0 : r.style) && (null === (i = t.markerOption) || void 0 === i ? void 0 : i.style[n]); e && (e.style[n] = o) })), e.addEventListener("click", (function (e) { t.onMapClick(e) })), e.addEventListener("click", this.eventHandle), Ea(e, i, "marker") } }, { key: "registerMarkerEvent", value: function (t) { t.addEventListener("mousemove", this.eventHandle), t.addEventListener("click", this.eventHandle), t.addEventListener("mousedown", this.eventHandle), t.addEventListener("mouseup", this.eventHandle), t.addEventListener("dblclick", this.eventHandle), t.addEventListener("contextmenu", this.eventHandle), t.addEventListener("mouseover", this.eventHandle), t.addEventListener("mouseout", this.eventHandle) } }, { key: "unRegisterMarkerEvent", value: function () { var t = this.getElement(); t.removeEventListener("mousemove", this.eventHandle), t.removeEventListener("click", this.eventHandle), t.removeEventListener("mousedown", this.eventHandle), t.removeEventListener("mouseup", this.eventHandle), t.removeEventListener("dblclick", this.eventHandle), t.removeEventListener("contextmenu", this.eventHandle), t.removeEventListener("mouseover", this.eventHandle), t.removeEventListener("mouseout", this.eventHandle) } }, { key: "addDragHandler", value: function (t) { throw new Error("Method not implemented.") } }, { key: "onUp", value: function (t) { throw new Error("Method not implemented.") } }]), r }(st.exports.EventEmitter), tb = { exports: {} }; !function (t, e) { t.exports = function () { function t(n, r, i, o, a, s) { if (!(a - o <= i)) { var l = o + a >> 1; e(n, r, l, o, a, s % 2), t(n, r, i, o, l - 1, s + 1), t(n, r, i, l + 1, a, s + 1) } } function e(t, r, i, o, a, s) { for (; a > o;) { if (a - o > 600) { var l = a - o + 1, u = i - o + 1, c = Math.log(l), p = .5 * Math.exp(2 * c / 3), h = .5 * Math.sqrt(c * p * (l - p) / l) * (u - l / 2 < 0 ? -1 : 1); e(t, r, i, Math.max(o, Math.floor(i - u * p / l + h)), Math.min(a, Math.floor(i + (l - u) * p / l + h)), s) } var f = r[2 * i + s], d = o, m = a; for (n(t, r, o, i), r[2 * a + s] > f && n(t, r, o, a); d < m;) { for (n(t, r, d, m), d++, m--; r[2 * d + s] < f;)d++; for (; r[2 * m + s] > f;)m-- } r[2 * o + s] === f ? n(t, r, o, m) : n(t, r, ++m, a), m <= i && (o = m + 1), i <= m && (a = m - 1) } } function n(t, e, n, i) { r(t, n, i), r(e, 2 * n, 2 * i), r(e, 2 * n + 1, 2 * i + 1) } function r(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function i(t, e, n, r, i, o, a) { for (var s, l, u = [0, t.length - 1, 0], c = []; u.length;) { var p = u.pop(), h = u.pop(), f = u.pop(); if (h - f <= a) for (var d = f; d <= h; d++)s = e[2 * d], l = e[2 * d + 1], s >= n && s <= i && l >= r && l <= o && c.push(t[d]); else { var m = Math.floor((f + h) / 2); s = e[2 * m], l = e[2 * m + 1], s >= n && s <= i && l >= r && l <= o && c.push(t[m]); var v = (p + 1) % 2; (0 === p ? n <= s : r <= l) && (u.push(f), u.push(m - 1), u.push(v)), (0 === p ? i >= s : o >= l) && (u.push(m + 1), u.push(h), u.push(v)) } } return c } function o(t, e, n, r, i, o) { for (var s = [0, t.length - 1, 0], l = [], u = i * i; s.length;) { var c = s.pop(), p = s.pop(), h = s.pop(); if (p - h <= o) for (var f = h; f <= p; f++)a(e[2 * f], e[2 * f + 1], n, r) <= u && l.push(t[f]); else { var d = Math.floor((h + p) / 2), m = e[2 * d], v = e[2 * d + 1]; a(m, v, n, r) <= u && l.push(t[d]); var y = (c + 1) % 2; (0 === c ? n - i <= m : r - i <= v) && (s.push(h), s.push(d - 1), s.push(y)), (0 === c ? n + i >= m : r + i >= v) && (s.push(d + 1), s.push(p), s.push(y)) } } return l } function a(t, e, n, r) { var i = t - n, o = e - r; return i * i + o * o } var s = function (t) { return t[0] }, l = function (t) { return t[1] }, u = function (e, n, r, i, o) { void 0 === n && (n = s), void 0 === r && (r = l), void 0 === i && (i = 64), void 0 === o && (o = Float64Array), this.nodeSize = i, this.points = e; for (var a = e.length < 65536 ? Uint16Array : Uint32Array, u = this.ids = new a(e.length), c = this.coords = new o(2 * e.length), p = 0; p < e.length; p++)u[p] = p, c[2 * p] = n(e[p]), c[2 * p + 1] = r(e[p]); t(u, c, i, 0, u.length - 1, 0) }; u.prototype.range = function (t, e, n, r) { return i(this.ids, this.coords, t, e, n, r, this.nodeSize) }, u.prototype.within = function (t, e, n) { return o(this.ids, this.coords, t, e, n, this.nodeSize) }; var c = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function (t) { return t } }, p = Math.fround || function (t) { return function (e) { return t[0] = +e, t[0] } }(new Float32Array(1)), h = function (t) { this.options = b(Object.create(c), t), this.trees = new Array(this.options.maxZoom + 1) }; function f(t, e, n, r, i) { return { x: p(t), y: p(e), zoom: 1 / 0, id: n, parentId: -1, numPoints: r, properties: i } } function d(t, e) { var n = t.geometry.coordinates, r = n[0], i = n[1]; return { x: p(y(r)), y: p(g(i)), zoom: 1 / 0, index: e, parentId: -1 } } function m(t) { return { type: "Feature", id: t.id, properties: v(t), geometry: { type: "Point", coordinates: [_(t.x), x(t.y)] } } } function v(t) { var e = t.numPoints, n = e >= 1e4 ? Math.round(e / 1e3) + "k" : e >= 1e3 ? Math.round(e / 100) / 10 + "k" : e; return b(b({}, t.properties), { cluster: !0, cluster_id: t.id, point_count: e, point_count_abbreviated: n }) } function y(t) { return t / 360 + .5 } function g(t) { var e = Math.sin(t * Math.PI / 180), n = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI; return n < 0 ? 0 : n > 1 ? 1 : n } function _(t) { return 360 * (t - .5) } function x(t) { var e = (180 - 360 * t) * Math.PI / 180; return 360 * Math.atan(Math.exp(e)) / Math.PI - 90 } function b(t, e) { for (var n in e) t[n] = e[n]; return t } function w(t) { return t.x } function S(t) { return t.y } return h.prototype.load = function (t) { var e = this.options, n = e.log, r = e.minZoom, i = e.maxZoom, o = e.nodeSize; n && console.time("total time"); var a = "prepare " + t.length + " points"; n && console.time(a), this.points = t; for (var s = [], l = 0; l < t.length; l++)t[l].geometry && s.push(d(t[l], l)); this.trees[i + 1] = new u(s, w, S, o, Float32Array), n && console.timeEnd(a); for (var c = i; c >= r; c--) { var p = +Date.now(); s = this._cluster(s, c), this.trees[c] = new u(s, w, S, o, Float32Array), n && console.log("z%d: %d clusters in %dms", c, s.length, +Date.now() - p) } return n && console.timeEnd("total time"), this }, h.prototype.getClusters = function (t, e) { var n = ((t[0] + 180) % 360 + 360) % 360 - 180, r = Math.max(-90, Math.min(90, t[1])), i = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[3])); if (t[2] - t[0] >= 360) n = -180, i = 180; else if (n > i) { var a = this.getClusters([n, r, 180, o], e), s = this.getClusters([-180, r, i, o], e); return a.concat(s) } for (var l = this.trees[this._limitZoom(e)], u = [], c = 0, p = l.range(y(n), g(o), y(i), g(r)); c < p.length; c += 1) { var h = p[c], f = l.points[h]; u.push(f.numPoints ? m(f) : this.points[f.index]) } return u }, h.prototype.getChildren = function (t) { var e = this._getOriginId(t), n = this._getOriginZoom(t), r = "No cluster with the specified id.", i = this.trees[n]; if (!i) throw new Error(r); var o = i.points[e]; if (!o) throw new Error(r); for (var a = this.options.radius / (this.options.extent * Math.pow(2, n - 1)), s = [], l = 0, u = i.within(o.x, o.y, a); l < u.length; l += 1) { var c = u[l], p = i.points[c]; p.parentId === t && s.push(p.numPoints ? m(p) : this.points[p.index]) } if (0 === s.length) throw new Error(r); return s }, h.prototype.getLeaves = function (t, e, n) { e = e || 10, n = n || 0; var r = []; return this._appendLeaves(r, t, e, n, 0), r }, h.prototype.getTile = function (t, e, n) { var r = this.trees[this._limitZoom(t)], i = Math.pow(2, t), o = this.options, a = o.extent, s = o.radius / a, l = (n - s) / i, u = (n + 1 + s) / i, c = { features: [] }; return this._addTileFeatures(r.range((e - s) / i, l, (e + 1 + s) / i, u), r.points, e, n, i, c), 0 === e && this._addTileFeatures(r.range(1 - s / i, l, 1, u), r.points, i, n, i, c), e === i - 1 && this._addTileFeatures(r.range(0, l, s / i, u), r.points, -1, n, i, c), c.features.length ? c : null }, h.prototype.getClusterExpansionZoom = function (t) { for (var e = this._getOriginZoom(t) - 1; e <= this.options.maxZoom;) { var n = this.getChildren(t); if (e++, 1 !== n.length) break; t = n[0].properties.cluster_id } return e }, h.prototype._appendLeaves = function (t, e, n, r, i) { for (var o = 0, a = this.getChildren(e); o < a.length; o += 1) { var s = a[o], l = s.properties; if (l && l.cluster ? i + l.point_count <= r ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, n, r, i) : i < r ? i++ : t.push(s), t.length === n) break } return i }, h.prototype._addTileFeatures = function (t, e, n, r, i, o) { for (var a = 0, s = t; a < s.length; a += 1) { var l = e[s[a]], u = l.numPoints, c = void 0, p = void 0, h = void 0; if (u) c = v(l), p = l.x, h = l.y; else { var f = this.points[l.index]; c = f.properties, p = y(f.geometry.coordinates[0]), h = g(f.geometry.coordinates[1]) } var d = { type: 1, geometry: [[Math.round(this.options.extent * (p * i - n)), Math.round(this.options.extent * (h * i - r))]], tags: c }, m = void 0; u ? m = l.id : this.options.generateId ? m = l.index : this.points[l.index].id && (m = this.points[l.index].id), void 0 !== m && (d.id = m), o.features.push(d) } }, h.prototype._limitZoom = function (t) { return Math.max(this.options.minZoom, Math.min(+t, this.options.maxZoom + 1)) }, h.prototype._cluster = function (t, e) { for (var n = [], r = this.options, i = r.radius, o = r.extent, a = r.reduce, s = r.minPoints, l = i / (o * Math.pow(2, e)), u = 0; u < t.length; u++) { var c = t[u]; if (!(c.zoom <= e)) { c.zoom = e; for (var p = this.trees[e + 1], h = p.within(c.x, c.y, l), d = c.numPoints || 1, m = d, v = 0, y = h; v < y.length; v += 1) { var g = y[v], _ = p.points[g]; _.zoom > e && (m += _.numPoints || 1) } if (m > d && m >= s) { for (var x = c.x * d, b = c.y * d, w = a && d > 1 ? this._map(c, !0) : null, S = (u << 5) + (e + 1) + this.points.length, E = 0, C = h; E < C.length; E += 1) { var T = C[E], A = p.points[T]; if (!(A.zoom <= e)) { A.zoom = e; var M = A.numPoints || 1; x += A.x * M, b += A.y * M, A.parentId = S, a && (w || (w = this._map(c, !0)), a(w, this._map(A))) } } c.parentId = S, n.push(f(x / m, b / m, S, m, w)) } else if (n.push(c), m > 1) for (var O = 0, k = h; O < k.length; O += 1) { var I = k[O], P = p.points[I]; P.zoom <= e || (P.zoom = e, n.push(P)) } } } return n }, h.prototype._getOriginId = function (t) { return t - this.points.length >> 5 }, h.prototype._getOriginZoom = function (t) { return (t - this.points.length) % 32 }, h.prototype._map = function (t, e) { if (t.numPoints) return e ? b({}, t.properties) : t.properties; var n = this.points[t.index].properties, r = this.options.map(n); return e && r === n ? b({}, r) : r }, h }() }(tb); var eb = tb.exports; function nb(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function rb(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? nb(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : nb(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function ib(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function ob(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function ab(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? ob(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ob(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function sb(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } !function (t) { Ur(n, t); var e = ib(n); function n(t) { var r, i; return Ar(this, n), kr(Gr(i = e.call(this)), "markers", []), kr(Gr(i), "markerLayerOption", void 0), kr(Gr(i), "clusterIndex", void 0), kr(Gr(i), "points", []), kr(Gr(i), "clusterMarkers", []), kr(Gr(i), "mapsService", void 0), kr(Gr(i), "scene", void 0), kr(Gr(i), "zoom", void 0), kr(Gr(i), "bbox", void 0), i.markerLayerOption = yf(i.getDefault(), t), Uo(["update"], Gr(i)), i.zoom = (null === (r = i.markerLayerOption.clusterOption) || void 0 === r ? void 0 : r.zoom) || -99, i } Or(n, [{ key: "getDefault", value: function () { return { cluster: !1, clusterOption: { radius: 80, maxZoom: 20, minZoom: 0, zoom: -99, style: {}, className: "" } } } }, { key: "addTo", value: function (t) { return this.scene = t, this.mapsService = t.get(Tr.IMapService), this.markerLayerOption.cluster && (this.initCluster(), this.update(), this.mapsService.on("camerachange", this.update), this.mapsService.on("viewchange", this.update)), this.addMarkers(), this } }, { key: "addMarker", value: function (t) { this.markerLayerOption.cluster && this.addPoint(t, this.markers.length), this.markers.push(t) } }, { key: "removeMarker", value: function (t) { this.markers.indexOf(t); var e = this.markers.indexOf(t); e > -1 && this.markers.splice(e, 1) } }, { key: "hide", value: function () { this.markers.map((function (t) { t.getElement().style.opacity = "0" })), this.clusterMarkers.map((function (t) { t.getElement().style.opacity = "0" })) } }, { key: "show", value: function () { this.markers.map((function (t) { t.getElement().style.opacity = "1" })), this.clusterMarkers.map((function (t) { t.getElement().style.opacity = "1" })) } }, { key: "getMarkers", value: function () { return this.markerLayerOption.cluster ? this.clusterMarkers : this.markers } }, { key: "addMarkers", value: function () { var t = this; this.getMarkers().forEach((function (e) { e.addTo(t.scene) })) } }, { key: "clear", value: function () { this.markers.forEach((function (t) { t.remove() })), this.clusterMarkers.forEach((function (t) { t.remove() })), this.mapsService.off("camerachange", this.update), this.markers = [], this.clusterMarkers = [] } }, { key: "destroy", value: function () { this.clear(), this.removeAllListeners() } }, { key: "addPoint", value: function (t, e) { var n = t.getLnglat(), r = { geometry: { type: "Point", coordinates: [n.lng, n.lat] }, properties: rb(rb({}, t.getExtData()), {}, { marker_id: e }) }; this.points.push(r) } }, { key: "initCluster", value: function () { if (this.markerLayerOption.cluster) { var t = this.markerLayerOption.clusterOption, e = t.radius, n = t.minZoom, r = void 0 === n ? 0 : n, i = t.maxZoom; this.clusterIndex = new eb({ radius: e, minZoom: r, maxZoom: i }), this.clusterIndex.load(this.points) } } }, { key: "getClusterMarker", value: function (t, e) { var n = this, r = t[0].concat(t[1]), i = this.clusterIndex.getClusters(r, e); this.clusterMarkers.forEach((function (t) { t.remove() })), this.clusterMarkers = [], i.forEach((function (t) { var e, r = n.markerLayerOption.clusterOption, i = r.field, o = r.method; if (t.properties && null !== (e = t.properties) && void 0 !== e && e.cluster_id) { var a, s = n.getLeaves(null === (a = t.properties) || void 0 === a ? void 0 : a.cluster_id); if (t.properties.clusterData = s, i && o) { var l = function (t, e) { return ka[t](e) }(o, Ia(null == s ? void 0 : s.map((function (t) { return kr({}, i, t.properties[i]) })), i)), u = "point_" + o; t.properties[u] = l.toFixed(2) } } var c = n.clusterMarker(t); n.clusterMarkers.push(c), c.addTo(n.scene) })) } }, { key: "getLeaves", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1 / 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; return t ? this.clusterIndex.getLeaves(t, e, n) : null } }, { key: "clusterMarker", value: function (t) { var e = this.markerLayerOption.clusterOption.element, n = void 0 === e ? this.generateElement.bind(this) : e; return new $x({ element: n(t) }).setLnglat({ lng: t.geometry.coordinates[0], lat: t.geometry.coordinates[1] }) } }, { key: "normalMarker", value: function (t) { var e = t.properties.marker_id; return this.markers[e] } }, { key: "update", value: function () { var t = this.mapsService.getZoom(), e = this.mapsService.getBounds(); (!this.bbox || Math.abs(t - this.zoom) >= 1 || !Fo(this.bbox, e)) && (this.bbox = zo(e, .5), this.zoom = Math.floor(t), this.getClusterMarker(this.bbox, this.zoom)) } }, { key: "generateElement", value: function (t) { var e = lo("div", "l7-marker-cluster"), n = lo("div", "", e), r = lo("span", "", n), i = this.markerLayerOption.clusterOption, o = i.field, a = i.method; t.properties.point_count = t.properties.point_count || 1; var s = o && a ? t.properties["point_" + a] || t.properties[o] : t.properties.point_count; return r.textContent = s, e } }]) }(st.exports.EventEmitter), function (e) { Ur(r, e); var n = sb(r); function r(t) { var e; return Ar(this, r), kr(Gr(e = n.call(this)), "popupOption", void 0), kr(Gr(e), "mapsService", void 0), kr(Gr(e), "sceneSerive", void 0), kr(Gr(e), "lngLat", void 0), kr(Gr(e), "content", void 0), kr(Gr(e), "closeButton", void 0), kr(Gr(e), "timeoutInstance", void 0), kr(Gr(e), "container", void 0), kr(Gr(e), "tip", void 0), kr(Gr(e), "scene", void 0), e.popupOption = ab(ab({}, e.getdefault()), t), Uo(["update", "onClickClose", "remove"], Gr(e)), e } Or(r, [{ key: "addTo", value: function (t) { var e = this; return this.mapsService = t.get(Tr.IMapService), this.sceneSerive = t.get(Tr.ISceneService), this.mapsService.on("camerachange", this.update), this.mapsService.on("viewchange", this.update), this.scene = t, this.update(), this.popupOption.closeOnClick && (this.timeoutInstance = setTimeout((function () { e.mapsService.on("click", e.onClickClose) }), 30)), this.emit("open"), this } }, { key: "close", value: function () { this.remove() } }, { key: "open", value: function () { this.addTo(this.scene) } }, { key: "setHTML", value: function (t) { var e, n = window.document.createDocumentFragment(), r = window.document.createElement("body"); for (r.innerHTML = t; e = r.firstChild;)n.appendChild(e); return this.setDOMContent(n) } }, { key: "setLnglat", value: function (t) { return this.lngLat = t, Array.isArray(t) && (this.lngLat = { lng: t[0], lat: t[1] }), this.mapsService && (this.mapsService.on("camerachange", this.update), this.mapsService.on("viewchange", this.update)), this.update(), this } }, { key: "getLnglat", value: function () { return this.lngLat } }, { key: "setText", value: function (t) { return this.setDOMContent(window.document.createTextNode(t)) } }, { key: "setMaxWidth", value: function (t) { return this.popupOption.maxWidth = t, this.update(), this } }, { key: "setDOMContent", value: function (t) { return this.createContent(), this.content.appendChild(t), this.update(), this } }, { key: "remove", value: function () { return this.content && this.removeDom(this.content), this.container && (this.removeDom(this.container), delete this.container), this.mapsService && (this.mapsService.off("camerachange", this.update), this.mapsService.off("viewchange", this.update), this.mapsService.off("click", this.onClickClose), delete this.mapsService), clearTimeout(this.timeoutInstance), this.emit("close"), this } }, { key: "isOpen", value: function () { return !!this.mapsService } }, { key: "createContent", value: function () { this.content && uo(this.content), this.content = lo("div", "l7-popup-content", this.container), this.popupOption.closeButton && (this.closeButton = lo("button", "l7-popup-close-button", this.content), this.popupOption.closeButtonOffsets && (this.closeButton.style.right = this.popupOption.closeButtonOffsets[0] + "px", this.closeButton.style.top = this.popupOption.closeButtonOffsets[1] + "px"), this.closeButton.setAttribute("aria-label", "Close popup"), this.closeButton.innerHTML = "&#215;", this.closeButton.addEventListener("click", this.onClickClose)) } }, { key: "creatDom", value: function (t, e, n) { var r = window.document.createElement(t); return void 0 !== e && (r.className = e), n && n.appendChild(r), r } }, { key: "removeDom", value: function (t) { t.parentNode && t.parentNode.removeChild(t) } }, { key: "getdefault", value: function () { return { closeButton: !0, closeOnClick: !0, maxWidth: "240px", offsets: [0, 0], anchor: t.TooltipAnchorType.BOTTOM, className: "", stopPropagation: !0 } } }, { key: "onClickClose", value: function (t) { t.stopPropagation && t.stopPropagation(), this.remove() } }, { key: "update", value: function () { var t = this, e = this.lngLat, n = this.popupOption, r = n.className, i = n.maxWidth, o = n.anchor; if (this.mapsService && e && this.content) { var a = this.mapsService.getMarkerContainer(); if (!this.container && a) this.container = this.creatDom("div", "l7-popup", a), this.tip = this.creatDom("div", "l7-popup-tip", this.container), this.container.appendChild(this.content), r && r.split(" ").forEach((function (e) { return t.container.classList.add(e) })), this.popupOption.stopPropagation && ["mousemove", "mousedown", "mouseup", "click", "dblclick"].forEach((function (e) { t.container.addEventListener(e, (function (t) { t.stopPropagation() })) })), this.container.style.whiteSpace = "nowrap"; i && this.container.style.maxWidth !== i && (this.container.style.maxWidth = i), this.updatePosition(), yo(this.container, "".concat(Sa[o])), Ea(this.container, o, "popup") } } }, { key: "updatePosition", value: function () { if (this.mapsService) { var t = this.lngLat, e = t.lng, n = t.lat, r = this.popupOption.offsets, i = this.mapsService.lngLatToContainer([e, n]); this.container.style.left = i.x + r[0] + "px", this.container.style.top = i.y - r[1] + "px" } } }]) }(st.exports.EventEmitter), function (t, e) { var n = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, r = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram); if (!n && !r && (e || (e = document), e)) { var i = e.head || e.getElementsByTagName("head")[0]; if (!i) { i = e.createElement("head"); var o = e.body || e.getElementsByTagName("body")[0]; o ? o.parentNode.insertBefore(i, o) : e.documentElement.appendChild(i) } var a = e.createElement("style"); a.type = "text/css", a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), i.appendChild(a) } }(".l7-marker-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: absolute;\n}\n\n.l7-marker {\n  position: absolute !important;\n  top: 0;\n  left: 0;\n  z-index: 5;\n  cursor: pointer;\n}\n\n.l7-marker-cluster {\n  background-clip: padding-box;\n  border-radius: 20px;\n  background-color: rgba(181, 226, 140, 0.6);\n  width: 40px;\n  height: 40px;\n}\n.l7-marker-cluster div {\n  width: 30px;\n  height: 30px;\n  margin-left: 5px;\n  margin-top: 5px;\n  text-align: center;\n  border-radius: 15px;\n  font: 12px 'Helvetica Neue', Arial, Helvetica, sans-serif;\n  background-color: rgba(110, 204, 57, 0.6);\n}\n.l7-marker-cluster span {\n  line-height: 30px;\n}\n\n.l7-popup-anchor-bottom,\n.l7-popup-anchor-bottom-left,\n.l7-popup-anchor-bottom-right {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: reverse;\n      -ms-flex-direction: column-reverse;\n          flex-direction: column-reverse;\n}\n\n.l7-popup-close-button {\n  position: absolute;\n  right: 0;\n  top: 0;\n  border: 0;\n  border-radius: 0 3px 0 0;\n  cursor: pointer;\n  background-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n/* layers control */\n\n.l7-control-layers {\n  -webkit-box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);\n  background: #fff;\n  border-radius: 5px;\n}\n.l7-popup-anchor-top,\n.l7-popup-anchor-top-left,\n.l7-popup-anchor-top-right {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.l7-popup-anchor-left {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n}\n\n.l7-popup-anchor-right {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: reverse;\n      -ms-flex-direction: row-reverse;\n          flex-direction: row-reverse;\n}\n.l7-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  will-change: transform;\n  pointer-events: none;\n  z-index: 5;\n}\n.l7-popup-tip {\n  width: 0;\n  height: 0;\n  border: 10px solid transparent;\n  z-index: 1;\n}\n.l7-popup-anchor-top .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-top: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-left .l7-popup-tip {\n  -webkit-align-self: flex-start;\n  -ms-flex-item-align: start;\n      align-self: flex-start;\n  border-top: none;\n  border-left: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-right .l7-popup-tip {\n  -webkit-align-self: flex-end;\n  -ms-flex-item-align: end;\n      align-self: flex-end;\n  border-top: none;\n  border-right: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-bottom .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-bottom: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-tip {\n  -webkit-align-self: flex-start;\n  -ms-flex-item-align: start;\n      align-self: flex-start;\n  border-bottom: none;\n  border-left: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-tip {\n  -webkit-align-self: flex-end;\n  -ms-flex-item-align: end;\n      align-self: flex-end;\n  border-bottom: none;\n  border-right: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-left .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-left: none;\n  border-right-color: #fff;\n}\n\n.l7-popup-anchor-right .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-right: none;\n  border-left-color: #fff;\n}\n\n.l7-popup-close-button {\n  position: absolute;\n  right: 0;\n  top: 0;\n  border: 0;\n  padding: 0;\n  font-size: 25px;\n  line-height: 20px;\n  border-radius: 0 3px 0 0;\n  cursor: pointer;\n  background-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n.l7-popup-anchor-top-left .l7-popup-content {\n  border-top-left-radius: 0;\n}\n\n.l7-popup-anchor-top-right .l7-popup-content {\n  border-top-right-radius: 0;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-content {\n  border-bottom-left-radius: 0;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-content {\n  border-bottom-right-radius: 0;\n}\n\n.l7-popup-track-pointer {\n  display: none;\n}\n\n.l7-popup-track-pointer * {\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n\n.l7-map:hover .l7-popup-track-pointer {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n}\n\n.l7-map:active .l7-popup-track-pointer {\n  display: none;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n/* general toolbar styles */\n\n.l7-bar {\n  -webkit-box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);\n          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);\n  border-radius: 4px;\n}\n.l7-bar a,\n.l7-bar a:hover {\n  background-color: #fff;\n  width: 30px;\n  height: 30px;\n  font-size: 20px;\n  display: block;\n  text-align: center;\n  text-decoration: none;\n  color: #8e9dab;\n}\n.l7-bar a,\n.l7-control-layers-toggle {\n  background-position: 50% 50%;\n  background-repeat: no-repeat;\n  display: block;\n}\n.l7-bar a:hover {\n  background-color: #f4f4f4;\n}\n.l7-bar a:first-child {\n  border-top-left-radius: 2px;\n  border-top-right-radius: 2px;\n}\n.l7-bar a:last-child {\n  border-bottom-left-radius: 2px;\n  border-bottom-right-radius: 2px;\n  border-bottom: none;\n}\n.l7-bar a.l7-disabled {\n  cursor: default;\n  background-color: #f4f4f4;\n  color: #bbb;\n}\n\n/* control positioning */\n\n.l7-control-container {\n  font: 12px/1.5 'Helvetica Neue', Arial, Helvetica, sans-serif;\n}\n.l7-control-hide {\n  display: none;\n}\n.l7-control {\n  position: relative;\n  z-index: 800;\n  pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\n  pointer-events: auto;\n}\n.l7-control {\n  float: left;\n  clear: both;\n}\n.l7-top,\n.l7-bottom {\n  position: absolute;\n  z-index: 1000;\n  pointer-events: none;\n}\n.l7-top {\n  top: 0;\n}\n.l7-right {\n  right: 0;\n}\n.l7-bottom {\n  bottom: 0;\n}\n.l7-left {\n  left: 0;\n}\n.l7-center {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: absolute;\n  -webkit-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n}\n.l7-bottom.l7-center,\n.l7-top.l7-center {\n  width: 100%;\n}\n.l7-right.l7-center,\n.l7-left.l7-center {\n  height: 100%;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.l7-top.l7-center,\n.l7-left.l7-center {\n  -webkit-box-align: start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n}\n\n.l7-bottom.l7-center,\n.l7-right.l7-center {\n  -webkit-box-align: end;\n      -ms-flex-align: end;\n          align-items: flex-end;\n}\n\n.l7-center .l7-control {\n  margin-right: 10px;\n  margin-bottom: 10px;\n}\n\n.l7-control {\n  float: left;\n  clear: both;\n}\n.l7-right .l7-control {\n  float: right;\n}\n.l7-top .l7-control {\n  margin-top: 10px;\n}\n.l7-bottom .l7-control {\n  margin-bottom: 10px;\n}\n.l7-left .l7-control {\n  margin-left: 10px;\n}\n.l7-right .l7-control {\n  margin-right: 10px;\n}\n\n/* attribution and scale controls */\n\n.l7-control-container .l7-control-attribution {\n  background: #fff;\n  background: rgba(59, 58, 58, 0.7);\n  margin: 0;\n}\n.l7-control-attribution,\n.l7-control-scale-line {\n  padding: 0 5px;\n  color: #333;\n}\n.l7-control-attribution a {\n  text-decoration: none;\n}\n.l7-control-attribution a:hover {\n  text-decoration: underline;\n}\n.l7-container .l7-control-attribution,\n.l7-container .l7-control-scale {\n  font-size: 11px;\n  padding: 5px 5px 2px 5px;\n  background: rgba(255, 255, 255, 0.7);\n}\n.l7-left .l7-control-scale {\n  margin-left: 5px;\n}\n.l7-bottom .l7-control-scale {\n  margin-bottom: 5px;\n}\n.l7-control-scale-line {\n  border: 2px solid #000;\n  border-top: none;\n  color: #000;\n  line-height: 1.1;\n  padding: 2px 5px 1px;\n  font-size: 11px;\n  white-space: nowrap;\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n\n  background: #fff;\n}\n.l7-control-scale-line:not(:first-child) {\n  border-top: 2px solid #777;\n  border-bottom: none;\n  margin-top: -2px;\n}\n.l7-control-scale-line:not(:first-child):not(:last-child) {\n  border-bottom: 2px solid #777;\n}\n\n.l7-touch .l7-control-attribution,\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n  -webkit-box-shadow: none;\n          box-shadow: none;\n}\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n  border: 2px solid rgba(0, 0, 0, 0.2);\n  background-clip: padding-box;\n}\n/*logo */\n\n.l7-ctrl-logo {\n  background-size: 100% 100%;\n  width: 89px;\n  height: 16px;\n  margin: 0 0 -3px -3px;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALIAAAAgCAYAAAHBIxK2AAAABGdBTUEAALGPC/xhBQAAIJZJREFUeAHtfAl8Tkf3/9z7PNmDRFbZSawhQcRSaqva1xCqpataqrT2UkuUUiqlaKtafe1VS1pUiypB0dIgIkpKRPZIELI/2/zO98akN48nltL3838//84nNzNzzpkzc+eee+bMOXMfxijNaMJ7LOrGO/HdYfZ8fb12gD2JJINJdR8WNHVQnRtSn7hilpz0u2DMKaEcFhZmhdzLNbiPyNVlwPxcm4Qh93Fr0gO4Ol5hfqiz6Q14G+QzGpYzQ9nXrUl7X/fgbrXdG3skX7m26+bNW2fQqJ5XmCs6RQKd6EQwB0zgtKgsvCidGF+N8wV/SBLqSKnXzx2WKIHw1xNxq2xtrKsBXqgrbePt1rivJFmloa5OoD129NcVQwa9Phxwaflw3ifvHCus1YIVjW7fwEF66dIhdYO/XV7Qk+9HY/5F7RA+w0G5TdRxq7gw10FBPWwA+3r9jpkYGcoJ5/7YiFxMiYCjLspsekOeCiJ1AhJJNER+8rfTX/j4BNcUMNCLMmhF+wC3cE9RZmMd/0IQjeTtGdwJjURD5EajsRQN1EwEHjAkUVce2LLhnKf8xGId3ZhkX4uxmj7MMKqJz0ZmMr3MJNZBmphV8WDBOCCgo+2QiE7DF3005wvU75e8vMLs4+P3HwwN7do5MzOu2NcjpPHRX/csCqjt2wvtxEAy8xJ3o+7j3jjkcurpn2xtrT0EPiS0oQPKSOfi/ygqL9H/qNbls8EXuer4+65xUa149QnBvGYFgapAN21EZ+pnuH3rrrnKdNA/zCRmjoqGzu36RoL21q38BLAAjRgo6iir63g1QAOcOoU27DAgwKtpPzVMKU+qBWIuve3Jx0zw4j/eQ0CASeNnjUi5mrYH72ZxUfFV0emJ479/BvrM9KxDAgZZEjziTp1d8+pL415sEdJloIAhF7QCZmnQoCkuLkkXNPfkozU8b4wVb30P4i4ADNQ41P08mtSBogHc27Vx70CPEHeUgRNwgUOuTqBR8wwODraGSIkrKipKxqVuI300mntri1jz9OOs0IHeHUdvms2t0iG+vn5nxmnan5QeUff6GGWttpidSjvGbCSZJdAAGTMwtjWSH2G5XrOp3oEv9wuWxqdeUPchZkW8OGqcedmcdujgUcMOH/zltmgL2YW2Fu22fbMz6q2xM+IEvmvHiCGyRq7AK3QLe959+T6v46co0uVBisLk0/9SqIIhcnQiVBPqULJ4dPVd2ypLg6Dx8wxuhAGDHrCOHTtqUfZ2b6KsYYIOuUiXL1/dKW4SMJRxkbbpG9nv5ecVutlt+PSoNvw7VPg8V4X5wqf4YQVp9g+NDQZDITr2cm/8lNIGlbvp+edGD/946eqJqOKmoBJRhjyjrclk0qlZAqeumw8YOEwE6ILdgh0raN9pcHeWx9n3mViPh9IKnlmBVBWI4bfoePDAEcOGPz9WWUDBzMe1cUdft5CnUfb2DvFR8rsz2avrkOdmT18wJisz5zDaqthVWjwAtzRgtBF9VbSdVofXIPWmB2CCouYqUBUFH59QbwwEqg0XykAi96/VuCEetRrm59msEfA+nqEtAUeqNEt324JGJEsDxpMi26gnaCpUxqJk6bahkGFp3akrZO8IBurcVGponpGW+VOdQP++uIAznzE1/cBBvRRZTc+OP0miUBJ78OiyxNxE6uX+KSP3vDIZuEE/z9BgWZZtHHj1oxZbkS6uJFNqIn+SWSy1AubjFtLd171xoHrQooyFQJRB7+0eHBrk2cxNtBW5mgYwoYNFXg5r7CvoFXWxajQ3mjiTc84wVkB2kTWt5NYk3lZ02SCvzphDDVrNZOY2p3mdA0wrhQoGSm5ig6SRyTsqwSxUaMKk+t4tXJIy4/IsoP82yNu7pYusKwk2WdslZmScvGHOyNs1tJ5GNrjVaeT2W2xsLCnuv5J6woQq/QtbXoLCMJqYtbWj208pKbGK4aamgWJR19XlCvpFEdxn6SDOl0byAjXB/cp8rlM/PteZ83k1T92PTuAw0Ly8GychmosWLB/v7xFSW+AeJQ/0auyLiYFEBgQ0dYKdDRsJfFOvpe0V76fgCVrgkNQTao63hAONr2vjFtAFltoTTFLzB415Al7RFdNipHRviWlLbzCHhZ05HxfEy9e7T/zX8FV+XLk+96e8Tl0xOJZfOpjdKp4kzboZXgGrouDj1rTunHnTQl1caoZ/unLNlKnTx32sNxobR0ZGakQTDCY8tEtEkG+LfihDg+NC2ccjpBXoyMTqVaLjTaFLduxe219XqH+67HYGKU5D0pbN30X5+vl0a9m6mZOPTxvFUIayPRAbM1RpS1uztp0a/SD6e9hcYlKVqgi7QEg/DAyRsAUsKSlNLyvT56Bs8e2Ias4LZzfnfEowJyOOVocZDs9jt8YnMDvUZzblZ+jis1rwtqg/KMHgwEThCUOCUS64U/An6iiL9oIGcFjwqMOQQB0JdTyEXd/tfR/1rMzsWCrPBxwPCxJMfJMELVYq0KO+fNkXk6CHRV/qXPSLXA0XZejpqiRZ0IgcY7hzu+AS2TB3quInaNnU2vzSlNqcT/fhHSqAVJgawAunEXxCPU4W9MMlcRN0ryZMAl2XcOHm6YlnYgMAToIOuxks+YBBErGrAa0YtKDDDkeYAaBFErjSUl2uKOfm5v1GE9y1nOLe/4IO+b3YchfKw0wy3lZ6m2arxyr4KV4RURH54qtS/fGufEMZZ7Hja/Ko0ptsgYML0+kKGM+4wbTbmGQUtPfLMfBrWWc3gIZenX4aJmUp9OQdqunk4nv2QmzMus0rO730wtj0qu2DqnuQjCYbrOjYrINq5JuRe/CKQp3QtRMweivm0yur+FBQf9xk6WFQX99Tvw2GDO0390jssWXW1vKf6n4q7Dc1EOXledJwQxF7RV/EomQbptMXssJlNyT5YSe4dq1m/s907eik1WprNKjdur9sW/1AWt7535Ur6/zvN2/lpcds/37eM892mEgTXGHuHD1y4qLRYK0YvrJsMly5knKu0tg0csmObbvfC2/ZbETK9bOnW4TU7xtGEw0a2geZbKysz/Xu9txQvV6fX6VOrMTw/hVsdF8b/tbGgX1feqF1m7Bq5hda+/o+pVgXm9Ztmzk0ctTBlMyEi/fnaoZ9g3HH1xmv5GgwI/m3+oAZUOzkj4fx7rQBt7qdxnhJDiuj/YlBe9dG1pLNbF9D8c2dem2xVMA3NQhjBk6WMyVaelmZVaL0+vmcB/Tz/zVa+8lIPlWW2SLMQh559ZSNCE2sbCq/FBuLyrrbLJVHsYZMr/sdfpiKJOv1pOxtyISp0tQRtHXqhNWQZffSy5d/LBOwJ5H71mrcAnzSSA2Z84ObJPlCbiujSZubkRefZI5X61hL5pavbzMvY4kuTCuzm6nXE4+Ztwf/lBRmcW1zcSkwxsXF6bWmEnbQSPJsoqWMZumwUqYC7QCVi3Y6tMmnCZdYDItiJezj0v3MaLJmRmXX58w0zKJ3w3ww2IwE+fk7JSUll9b2Crl4NfPcJXOav1OH7fyfdSs6cS7zl18Y65GRd36Pmk/S+dwex0/tHTN54pxNJ0/I2tTsM5WccqDFQgn9rW4nyphg4J95ut9gZis7p6Ym3BI4L9eQ+sS/ntrbLXDIE8/fLKaHVP7goyN5whKyKKMHcsWboSasqsznORfSRYEaz3v29uZt4JiDxMC8QVJLjzntg+ow+dBe7BhRJ1MwQ/AVkRbwQbBj7OtTXgVu49qt79LDrW/OX4yrqjEJ/OIPVrwlfM2CB/rW6XQ3wd9SgjsM41SsC9pLt+H0AptK2fdRjFdYHHwdhY0QOsL1VZDimkIHfLLD8xThcmCF+p3SjOxc0WlV+Zervm2x68dN/QQ+MLC2DVSHqOOVw6ZFXDRgCXjUBQ1y7Py+3bO+HyQLO0bArGV2auRrkxRv1orPPgjXF6XVARxJz0vCPvz4vbkoT50899yTenvAD0ljLx0L8Gr2Et4C9XXnTkEiecNKv/xiU/q1nHNXlQmN2iYVlpWwL0qLmSR3ZNFgQCpCogXuLDMa45WrTH8AcCVpTL8Q7ChbVDhAgO6XmwwGj7AWoa9lZ+UcBt3ufZvn6Ar0bUSbP/+42cJQ7NhbNjj3ybpW2p0G3LtP966DUIYk0TbZDr4Kk9Ho7lXLw1+0g6qo6Wtz8+f9sfmARQzqPZNWiCCBJ/NLtrOz9SkoKPxDlmT1SiJIHiuH6oAeF5e1o9XRGjWqa6pXrxbcqlm3YY7Wtifu6WDeU1xHF59an1cDki9wm8nnU7h3AV0fergDNrsln0+BtKUoP0yizYJr/57DhuJ1wnY5/mziepTVr6e3R0hrsbPLyck7BrxIZO/eAi2uuwE4I3Aok5rIAtzPPbjtxQuXtgCOOtQTwkqrPvlqMmBd2vcfDGeSpfGCXrS7H96SujCnBy+oj6LComSoEoGvUA0A6EvZ8DLaO9nYsUOoSzNy57Oi4mJyBu2SpuRcj2rGvZievUsRgleBf5gk6cpabd62egFoaYtr6NFl8DaUoz96LzTAq0kDlNWppLhE2UTg9Tuf8MdG2sw4DRjQU9H7e3b/FE2vomLoU3nJjm92rYSEwoXZuX3EJvDZsWtdz/+sjGlqMJqCXx/90jzALlz4syQl5awi7aj/EwnxPfC1srJy7ti232Sb6jZHRT+VJvm909I3pjKWayxjYdODeLkO1hnC2OLC/mhQWsJO6UvInCtjHQWDB+XKK2tvF3Dq5JkvVR4t/tzwiHk6namuefunwruvEq9ft86RW4Ef9sqQcK2WXRkzYtKBgtsFGYCNHjHpt3enzd+cnpvwo8pHbKQd2Wg9M3qDhjz9tqd+O7tao2XZqP+TKf8Ga3vyzP630EdGRpY+OTnutuiv0iQDqDOxVgaaSDLpjqMuResukoXHpwTw7jT5XnQlfHBBOgPcgxIiEqu+jG4NuoYN63a4mHzio0vJvy7Blhcwa2srWW0NAFZVgh0uaTSKj0LQYFERZVmy+WP1Z2uno25vZyd/tX5FO5T79x72faoF+xm4J5m4geLOPl7PHPvl1CeyLF1T875nkpdckq7qdOwIqY4aEz35i+XEXCYJ30MXs7dnSghSzaSqMunN2n36dZsBfG7uzYt3r0vpaVm/AHbkxJ4xJYWpD80PbapK6bmnL8+dvURRJXsPbXu5W49OU6n/ItA/zEapKr4PA8fC7OVVS1EXgwe8sq9Nh4aJ6nYWdyrFmayLvQsrIwleF8n4Jk9ntlCvo00gZ6ujE6UHBujQAZw2ZY52Cv8fvj/wwahXJu6VGFdu2sh4rdTs+M6+fl7dSAI+kTS0yfkbCWEndbhJIzPdjRu3TgcGBijqbcHc6Km21iz+b7C22KTEaGxFi1slHDyLsrGgKHr5kvYCsW3btkpeynskGYSrmaQnvTufLubhyL6WDGwK0zH9ypvSKMHoQXmuoaztz0diJoHu9VfePp6el3BYeOGstVYJ0Ys/VSR81OjhPmQqKAvbg3hqZNOd9PTsZNAt/3Rhi+5dW/cmy6SzaGfv7HS817NDlUUWsFWfrU9LzkxMFfjHyadMe3MZ7HPzCwJjMnK/8JbNI6rib1GSQfxpoTT7TRs+mYzLSJJoWkTYsKqYWIIbTNzWuaZTA0iWOT4l+2zKxx99fpXCUKxXv+5hn6/akP7n5eRztbw9O5rToi7cnx5+0rWIvi/uSU4/M2BgZJ/ZAwb2KiO9HynaXLp0rIAkTZeff/tc7MFju2Qm0T7r8RPcnJa43MjL1+PtocUif8SrE2ZkpWWX0Tmbex4q5q/KNFLLO8mcHSTXRc7nRsmzSkILCOzWsJkAypLjBXE4U+mdtmSCGclC+AEbC8US0Wh+u5Jz7jraIWREYfRGuJG064n7AAvxCHHIMxorpLcac4q9lHesYjLRb06qrgtZMoVpuecqzCi0tZRg2wq4pXEiKCDwlnIRMMD9WFvrjGqrwhK9RRj5kp+bwLgS37NI8C/wgTOgSPLyV7ibxoa9Rp7kV8nrVo1E3qSjJSr/CuNlBUxHTswSZmLFkhWTtLSGUqSEjO7yXEN1DZW1FBuQrQllxzK5FVuTc5HtnnOIwlRf1X6Waa1GM24KoNGQT69SkpiGFtIyYwwrMK1jb1+9/U9bApV6/7fyxGYAwewzZ1IdiosNBvF2PzHmD8FIWfcoKPIV7ZZ7Q8rImmJGPWPpR0jqdMxEAs5IgEkWCUm6mf6YRITIOXIFUC6heCvIyguhPIR5s1PE9TYrMixlWkM9ZqRwC2jLkywKSm4tPc005KKeOxe+qb+oKhE9fAUOvLLi0ubYH6AVNpoaLU++lnWezs8/OLbw8D09GUp8HkB7wHCEEwVHjBkOxqvX7x906kgOzMvn89qZWLm7SbSXmXwnqLHLMdVmWKAq5eolSY2wtDyp8aIcFNSqekl+Uftjhy5IbduGV0tKulrCdMEGrcRupeYm/iLoLOXkMpJqe4fUN+hZHRM3keQ9Wip3IGiSEIupmLjooXwByeoUA2daCrSw4nx2Kucye86qhJUq7MUKSznt+SqSHcq0KAqY1okZxqySrlcQUIEvJ7e+RDocW2JdmR3T8K0UT2lOwk1viKQnh2oUuaIqrFt120ct4ySGwaALHDPuVb8ZM9+OxjlFOh95oGXzrsvpxk2e/jb7ERB6VL6PQw9hS79427lUqzOOGBGZj5i64IcPYUp1paHDXxzs+UH07NUCvnrVumlzZ334h0ajuZqWc+68gKtz+Bq//CSmq4kbrRL/PDbPyalGKPDJySm7n27V+wtJywozshMPqduYl4Ugw/oHDm455A8ryDjEhp3CkV+/HxEYGKC0/XDRyreXLVmVbKeyE8HTPOE0DNmONhS3Gu0f4NPTHP+gOj7JGRwx4icYzRU7kUlfSzMW9+PJJMTLS03MztqahXs1YuuK8tmAqFgp70FM74eXxpeHTvhkR3eKY2wic6K5YmRoWBE51UdI825tuV/7h8Uh1qQzFAf26vusy8zZE1eKdt6+Xl1ooovbt+795fVUXRuC03rzzyecisZBYwoCsvETRgbcupFfunrl1mwSHtIW7EpqduKF5My4VBIG9w3rt7L+g3qtggsRI3t91IvzNq7d/sKVK1drk8bOtaSZ16zc3pw0sdV332/sLYSYzofd7tdj+H/Aw1O2/S0DhX8wlWvFv7eI0jpJqs1gs33brv09ej6TT7wqFKulIbt7utalw5RKxJwO4+yCEGMDFdjILbFCkNFw6k7py0XP8qu0Fm8nl4UTcW1nY81ORHXjPaL2SZcFcxq2xNbUXsSstB0oiCbA5TkWCCMvYQbda9KotCuVkCbTQGYyNCFb3ESh72wmayOlRbePV6L5m5UAOh+sK8wNh4tzxaeLF99lY6KjunGuri7h0BZf/GfZBfhQfDyaNEnPSUgw70o5bm8yuZrDUcdSTXftYL4EaiT5tobZJqXknsq+p52e+wB28vT+cfQyPYtyxOA+nw/oPXwPyiKl5ibE+Xs06UJb9x/OJB4OdXd3aUMmkPX2XWsnNAvu8EGZJDWhZfi62izyouPDRh2v9cabr/iGt2o6UvCa9c7CqfQFo0Gy0ZyJyyg/uiZw/0SuNocelX9qbvwv8F5+suxzv6VLPo211J6EvRZWnCXL5jUb+sKAoaDBh5SYKzyT1JxzRzAvlQQZRNN+kn6Oepq3JXn8gar+JKZBRPQbffnSJ+qEpAgdCTjnt/UbGCt7jkq+lbZwVmQqGPlcaVJWhRBHPcXd6ciG29xDbOecNtIGCm3VkKJLnqiy0JfcbIvxxx7fOc7Gxkpx6G3ZEDNn1rsLEy5cOb6GIkIuPXt3eef5FwaO3LxpByNteTM9Pb7yGO7az7+fPTBR+Km2bIyZPWPa/Pi1m1b0b0FONnt7Oz/0g0Su6oLLSVd+GP/G9G9154uLtZL2lsnGPo6XFjyDB0wx33JCC/8NBoavKQKBogB8noskH89jxs5dOw78MC7h5/VkUjiSQD+1fvPKDi8+/+ZhX0/lawzl5bv70jZ1dHTQTJ0xfr5gv+/HQ4vXr/smC/GC9Ixz6QL+T+aPo5ExrvT0E/BwX7I0RoR9TSajFebgmWc7TgINjk6OG/POKVnLctKzE06SECtNK2+67nKLOipdIEEOp7jI73QKg+lKWE3aDB56N5wPuUvCpInpCazEEM7yS86wQloh7tBVXFLEbpa8REL8fjkdl2Y158NItDOp/XnZimXM/ZW3lJY+WSH2dwttRt5o+6+3r+6C4A/6Tkq6EjNp4uz44pIS05wZi94V4164ZNYSN1cXKyz54hyowFnK+0X0GJGccXpneKuwQRcvJB3YvXPfAgSX6CPVeBK2avUb1huy79COLecuHp1Dx5fgU+wCId70zapnhNdZaGPwb9mq2SgBRx45uK87p1Xgjh3NjrV0FmHm92YtnirGggfYp09XV5PRFIBNIeDGohstke/9edtrCNmifC0l/YdXXxz3Cxy76dfPVz4DC4L/sYQvkhFh+HT1h62EEP+45+dFEGJ8xp6enXhSfUsWBRkEM45KubIDe5qE+DsE9XSlNM2lbMv0YP4OxaJIzsm+ePd6DivMb8vu6GKYviyJFRq7Se/d+hq4KMa104PZLBLgDXRiRkPhbU5h7s03PNgx4J9UCvBsGqDnBh/YoO07PDUefEtLyzK7tI9Yh80dQtTr1m7JPHL4+HLg6GxB9f2Hy0M1CNtg5wx4VUnWaO1bNn12YJBfizf69hr+5Zujpqx5PnLUp43rtZvVtFHHCBFAdHFxDlu28v1w8JEljf6FIaN/FseJ8DGe4I9wvYAj37Z113XZVnsaZxUyM8+nkYJJw5Gjn386/JFos3Tl+3NQ1nMpDB/aGbmpxkfL329Wu46fcqiD7je7U9u+n0M72jr5nhDt/ldzH7fgIJOJ+0+aNjaw34AeihI6ezph7YiX3zpGk3sjI/fsWfN7q1KQQUibvNIF51kECfMysmuNlFPUjy2sHchWvhzAyXNM9aWshDTsQOmD0vrShwWKkI704vZFddkXRDuXhJgsELKYS9n7CxKkF1b8KNFr8WQS3Gw6g74JztRNeefNDwXXyeNnzSIBI88gl40GpkRyhg4aeeD69RvKQ8aSHbNrfS+Exvy8yn9OQ7Q1z2kCd+D8BDZnGdcTTqTmJCTjRKgky3nQntezc0+JNl7etRT7WqM1XcOuX9ZoKnlvBB1yrdb6CmhwqU2cjNzEs/A2vPj82Nj0tMz9oLWzt/Pfd3DbYNjntJmr06x5Ywf6ZEIRbuBHvz5lWplOp7jrnvRxZPD/byZ8IE0u3IZ16wbaTpw8Zgn6pjBiQq9uQ2Po6/SyjJwEiy/qfQW5/AYkvviyNIEEcgIFqstweou07GgXA4sZ6cxrlNP89X9MDe7sILM9JK4v60CrYyUlejZy0Z/SrL+oHr8EB7w4q7hr78ZZcLMJritXL16jXr5FGZsoQdOqTfNRM2ZNrGvU81pVfXUGWnoZlN2seqOl8PgH/dFWtm4noF07te33KX0GmIv+GjdpOIzs4SCUN2xZ9Q5lyrPbuuW7uT/tPXjLykq6bMmzAfr/pVQs3WmG8W785rMRlCkr//w50eWrKWPx9zyHuzenvZs/MItOl1a85cGvajjbpJNYdYpd97C3YkfH2fGeK0qkdDCg3x4JoI3fXknH6hMNRnFLx9igZTnSwQd28IgExw9fpO9PTVbQVOR6CkFzslvP0pI/+36scLwRp+9A88a4Vxbt2bV3WHz8hUb0uzm3yn9i4H6tVbgHmCQqykcuptBX2/6uYXFk37d4+413pn62Jvo/YPLm+Nfmt+/QZouzs5PiL066dHnrhHEz4xB8QLDnkTv6hxuQtyWAPESKXV9VV5JReyM193QWBNTXlT4Y4boaeGF9fL26og3cbF9vjsmRtdqcq9nxVX6R9NCCDKYf50jfv+3EO5gYHYbjzItATZg1OzVG5t3IFrWmjeGPpL9cCQ8HXYpGw3rQB38XUX2SCd8ilOmMrouXzAmBpgJvsnUNg/u/shBlnMC2dD7Wzy24HTaAzVuFxtSrFxhBk6fd+u1X8+rXaT2Jlcmt6ZzVHQMYPKEk0SecYEVnd/WCpZNzjZoKjII28FrgvK9tDftjly//dkfQIL+WF5dF9nDyrl37WLeYZ+b3j+g5kzaX9s2aN3kV+OLC4iud2vXfiMMqdYJdfk2NBfT/jfTc0P49unXrVKXQiVEWFhUXvT12xgHaK+jpxf3doNH7IUjWf0DPZwXNvh8OHkFZMsiKshRw8/yRBBmNl+VLZ0fb8ZayzH4krdyEnpQnudbiKRxMAbry9Y5gJwnfOzpfUpZF804fp46dOwlxvY5dnnZ64aVIRbOC39ovN8/GAW9ZsrpoSYhBU82dnczPkbpiI5iUcrK1ra2Nl2M1x7oHf/lueOd2/TeYmEnxAID2iSSDdQbZVp6ff7J214IPZ3YnnnLdunUiyNSJuMvfSC/fi8eOnepAp6EOnss5Rydc/kp0EDORfuXOZeyoqSeDmzSIQVtg8Q3K4IGvzkSZW9vd87sdgP+3Ejw05n3hFxroMgffU6f7KBs4uM8fy5euTjFKRkf6ks4FRJ61PJojL7hTePH99z5Kwsuael3R2gBbTPcMwiKVBeBkxh0KtGw7mQ/dhbeUynihvrU2sKEr2JPb1Km7h238a+ylp4zc6IRNXsdObV3JTswqKCw0kUeCNmLxiWp68zLOBpTeLm5LGydt377dXJycnazhewUd/K/YLZPmk8aOf80/LSW96Ntvf8jFRGodXA5iyRf88Es5xQZda0GbkZZVtGP77ntocaKXlRW3wQOv5ugot+vUyqluUGB18CGT5hZ+jwuOfRx0FbzVOcLQaz7Z0Q6eCsDRHzayiodCI58URwXVbR6l/Lghavw6hYGZsDr/rYSNLSKQcfS7AwiOSGWF4eJewRAmRVAD59MPOjPytwUZncAN5yyzhVacDSFlbDJIbO1qkzQXuP9Gql+/bTXj7WLbUq1t4V3H+kN3q5zWOnq5Jn05Jdm6GvMTExPJnC9PCDgYC2/X1Mp6o38j1xv3m0Q1LT5wu985DghlzGcxdqUaKzvSRpLJXtaFhdUpND8mLsZhKQcPuhSTxRL+UWFCkM3bPexZC/N2/9b/nYF/Z+AxZuD/AA8zEhkTLyOGAAAAAElFTkSuQmCC');\n}\n\n/* layers control */\n\n.l7-control-layers {\n  -webkit-box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n  background: #fff;\n  border-radius: 2px;\n}\n.l7-control-layers-toggle {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAkCAYAAAGf7Ah0AAAABGdBTUEAALGPC/xhBQAABzdJREFUWAnVV3lslEUUn/l2F0tpwdAih1HEqCReDcphNCo1EkgFkXa5PNpuC0Fo2e7Wgko8KiaKWrvbK5672xYFpNtiRRuNiY0aURA14BGviBcVlaKltVa6+42/N9v5Mrtt05rwj/PHzjt+8743b+a9N8vYwKgMNlUQyemnMtAkaJajvb3dToQSGp8e6boopkr4VYgEMYwO0vhCTfMVzBcMf8bx086YyODcuM80zTqp9IWat+7evW8sMdIxIqqCLa6oiAaJpuEtcBqcc2HEWMZ0JclgZR/Nchf++ubrzKjJSguXS4tVjXvPjfb3/UAAacGTn/MOMb7QnjNpNqP/bKZ50Ai0tqYmCi0n4zbM+W+lBc7JBOa+QPhDwcTsxJXE2+32edKCL9h8hRDmRzpIOWydAylhrcMfDN+ugBRKSdP3KwPhsFJIPth02FISIYQwYsDYcVfWhy/Bon4JgumffMGmiGTwQ0B/sHml4q2ZFAD3WQIQVhx0IdFw8B189lolN+w8w5PnjPmlhJgtA8/vfn3iye7u3yGzDljDxZEG4097Cp3rSSjBtMHunp6vFR+HHoIxmbgTe1xHKssDHecLNFUjMzbqMs5ZlHF7ute17M84+TMHDzr+OvR9JwKdCms9yRkzJq6bPTsWXh05QOPUN+PUHyPWMPhm6UHd7vaUohWZPSRE8OqxpTyibQa/qcTlbEP0vwF7AWUAT3JM9dy69FfSNza+MU4awNE8iQtXSkJuGLleV852ov2h5jkwVof0mUs8aO4LhTuYYFOAjExId0wcFIPahpaLTkWiX9ECfHG/sLNi1i8+HODfgLFFRI96+INNi0cNTgTS1obKQh03aAuk9DeELzcj4pACYivvwvXrFK/PcQZiQWo+hmidpYMUjQC7EOB6xdNsGfAHwk/RDdOVw9Dm+NTUSWtWLDohDVQ37JkbiUT2DwMeVswZP+gtdM4x3HnLDhjcGM2XLWOISaenIGee9MCSgqgMht/H/q/SZYk0qviV3oKcj5XcioESyOoqIseFYDYloxnAGm/hcrcuk3JV2XBMl+pKqn6mENux11+w12m6jpqMMFn7rPPTHdwfCm8yTfG4tMaNu+GepPUFiqbM7T105ARSPQU+dY/LOC/N2gI65WEkyWUEtjmSppfkLvlRLaQ5VnZFDtGGzbheNRROKZmbu/AvUvh3tE4Wff2/0IUC+y2q+4VVoXBW1BSvkR7Rb8BW84lWJQBdlGozcs7GLy3Nd35OSqTxBqtfgkc1+sPjcqbDgEl6xK0dH5lv545LOCVL1/F+3CoY4eyY1+WcBiC2KYEHQBd5XDkyndE17xCm2Ug6BLcSwb3LigE1AlOYu6TS4HUwVEw0Df1osfBnLDwnpiFDCQPuvQ73Fkqxg8/hEVYLXt66MXbbzOK8bKre1hhkgDT0RDja3fEHytwZxCMLH0YWPkD0fxqjqUZDejDSV3z1LbexqPkEPJxKWLqtKOGbvPnZL460NlE/KgfkIZiRrfjShsQcG2QQDUwwXjcuZcID61Ys6ErUJ/LDOiCfLUzUjVQdEg0O4jn/ABEq0iuIjrEcwE0x/KGWNbjPj4BO00Gni0ZOoIPzLR5X9vMqqaQDqDzzENra4V5zp8sBZQcROYjsLvYUOPdbEVBKeiZ193QjCmwtZCM+ldS6EWYTH3wuNSV1i+pFCj/IAaWgGUfBq0N78qPM3DZcp9TxcTQeyzZm3ON2LatXpSlOP8BIB6qDLddHmHnFrBlpNZmZmdZbNXEB9XsRlZXFennqGHzoXW5DaId4iSoc/Q365EjnRjszPnYXZL9NDWUtGsqzCjAw7xprTypbn7fkaILcYqkInzzeX06C8emO8sKlS7stZQLxVMPes/+O9FVAvEpXob+utY6gZmfrtMjf/RUI+2odhF7wJbq+Gzf3zTj5CAwyaoEwozVoCzN1KKK00z7WUbZx9dIOklsO6CAZpu87i5gpHoJ8gtLh9vZixSO2KckV7qysf5Sc5uq2tjOix3rL0FW3IJuSNV0XM/iDs85LqxvqeKUD8n3LxUobt5WVuLJlS9IM4O9i09VRwWtxLWfpcix+hXjs8mZdjn19YuOiuKRgufzXqOuqQi2r8O+yAk/tl2Q/RMW7ETe8UdX1GJhHDM5qjDHJ5e7bs07qBp7ZsTe9t6/vUXykkLKEdLFbLgLJSUn3rrt1yXEdX/1C23jzVG+5Keg/B5r2wJD9g/NcaUAJq4MvXxxl/TWoATcoGc0Av4eUKnIXZlsvXpLHO0CS2KgOtGQgdeuwqWuUjGbUgrdszLHRXXDLF0oe54AS0kyPnc5Iz/2CmV7EeIzSwcjvsHQPXkUhld/kCP6Xu+DRNjg/SWHh+SnODF+aPeVh9XCydAPEsA4kAqsCzcuiTPiw7+maTj6SwGsVk/9gY9xbUpizR8MNS47aAd0C7s35CG8VdrxYyjl/FcdUgo73nY77X9D/Au9RDMh+aBoVAAAAAElFTkSuQmCC');\n  width: 30px;\n  height: 30px;\n  background-size: 20px 20px;\n}\n\n.l7-touch .l7-control-layers-toggle {\n  width: 44px;\n  height: 44px;\n}\n.l7-control-layers .l7-control-layers-list,\n.l7-control-layers-expanded .l7-control-layers-toggle {\n  display: none;\n}\n.l7-control-layers-expanded .l7-control-layers-list {\n  display: block;\n  position: relative;\n}\n.l7-control-layers-expanded {\n  padding: 6px 10px 6px 6px;\n  color: #59626b;\n  background: #fff;\n}\n.l7-control-layers-scrollbar {\n  overflow-y: scroll;\n  overflow-x: hidden;\n  padding-right: 5px;\n}\n.l7-control-layers-selector {\n  margin-top: 2px;\n  position: relative;\n  top: 1px;\n}\n.l7-control-layers label {\n  display: block;\n  padding: 8px;\n}\n.l7-control-layers label input[type='radio'],\n.l7-control-layers label input[type='checkbox'] {\n  width: 14px;\n  height: 14px;\n  margin: 0;\n}\n.l7-control-layers-separator {\n  height: 0;\n  border-top: 1px solid #d8d8d8;\n  margin: 5px -10px 5px -6px;\n}\n.mapboxgl-ctrl-logo {\n  display: none !important;\n}\n.amap-logo {\n  display: none !important;\n}\n"); var lb = function (t) { return void 0 === t }, ub = {}, cb = {}, pb = function (t) { return cb[t] }, hb = function (t, e) { cb[t] = e }, fb = function (t, e) { ub[t] = e }, db = {}, mb = {}; function vb(t) { return new Function("d", "return {" + t.map((function (t, e) { return JSON.stringify(t) + ": d[" + e + '] || ""' })).join(",") + "}") } function yb(t) { var e = Object.create(null), n = []; return t.forEach((function (t) { for (var r in t) r in e || n.push(e[r] = r) })), n } function gb(t, e) { var n = t + "", r = n.length; return r < e ? new Array(e - r + 1).join(0) + n : n } function _b(t) { var e = t.getUTCHours(), n = t.getUTCMinutes(), r = t.getUTCSeconds(), i = t.getUTCMilliseconds(); return isNaN(t) ? "Invalid Date" : function (t) { return t < 0 ? "-" + gb(-t, 6) : t > 9999 ? "+" + gb(t, 6) : gb(t, 4) }(t.getUTCFullYear()) + "-" + gb(t.getUTCMonth() + 1, 2) + "-" + gb(t.getUTCDate(), 2) + (i ? "T" + gb(e, 2) + ":" + gb(n, 2) + ":" + gb(r, 2) + "." + gb(i, 3) + "Z" : r ? "T" + gb(e, 2) + ":" + gb(n, 2) + ":" + gb(r, 2) + "Z" : n || e ? "T" + gb(e, 2) + ":" + gb(n, 2) + "Z" : "") } var xb = function (t) { var e = new RegExp('["' + t + "\n\r]"), n = t.charCodeAt(0); function r(t, e) { var r, i = [], o = t.length, a = 0, s = 0, l = o <= 0, u = !1; function c() { if (l) return mb; if (u) return u = !1, db; var e, r, i = a; if (34 === t.charCodeAt(i)) { for (; a++ < o && 34 !== t.charCodeAt(a) || 34 === t.charCodeAt(++a);); return (e = a) >= o ? l = !0 : 10 === (r = t.charCodeAt(a++)) ? u = !0 : 13 === r && (u = !0, 10 === t.charCodeAt(a) && ++a), t.slice(i + 1, e - 1).replace(/""/g, '"') } for (; a < o;) { if (10 === (r = t.charCodeAt(e = a++))) u = !0; else if (13 === r) u = !0, 10 === t.charCodeAt(a) && ++a; else if (r !== n) continue; return t.slice(i, e) } return l = !0, t.slice(i, o) } for (10 === t.charCodeAt(o - 1) && --o, 13 === t.charCodeAt(o - 1) && --o; (r = c()) !== mb;) { for (var p = []; r !== db && r !== mb;)p.push(r), r = c(); e && null == (p = e(p, s++)) || i.push(p) } return i } function i(e, n) { return e.map((function (e) { return n.map((function (t) { return a(e[t]) })).join(t) })) } function o(e) { return e.map(a).join(t) } function a(t) { return null == t ? "" : t instanceof Date ? _b(t) : e.test(t += "") ? '"' + t.replace(/"/g, '""') + '"' : t } return { parse: function (t, e) { var n, i, o = r(t, (function (t, r) { if (n) return n(t, r - 1); i = t, n = e ? function (t, e) { var n = vb(t); return function (r, i) { return e(n(r), i, t) } }(t, e) : vb(t) })); return o.columns = i || [], o }, parseRows: r, format: function (e, n) { return null == n && (n = yb(e)), [n.map(a).join(t)].concat(i(e, n)).join("\n") }, formatBody: function (t, e) { return null == e && (e = yb(t)), i(t, e).join("\n") }, formatRows: function (t) { return t.map(o).join("\n") }, formatRow: o, formatValue: a } }(","), bb = xb.parse, wb = {}, Sb = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 6356752.3142 }, Eb = Sb; function Cb(t) { var e = 0; if (t && t.length > 0) { e += Math.abs(Tb(t[0])); for (var n = 1; n < t.length; n++)e -= Math.abs(Tb(t[n])) } return e } function Tb(t) { var e, n, r, i, o, a, s = 0, l = t.length; if (l > 2) { for (a = 0; a < l; a++)a === l - 2 ? (r = l - 2, i = l - 1, o = 0) : a === l - 1 ? (r = l - 1, i = 0, o = 1) : (r = a, i = a + 1, o = a + 2), e = t[r], n = t[i], s += (Ab(t[o][0]) - Ab(e[0])) * Math.sin(Ab(n[1])); s = s * Eb.RADIUS * Eb.RADIUS / 2 } return s } function Ab(t) { return t * Math.PI / 180 } wb.geometry = function t(e) { var n, r = 0; switch (e.type) { case "Polygon": return Cb(e.coordinates); case "MultiPolygon": for (n = 0; n < e.coordinates.length; n++)r += Cb(e.coordinates[n]); return r; case "Point": case "MultiPoint": case "LineString": case "MultiLineString": return 0; case "GeometryCollection": for (n = 0; n < e.geometries.length; n++)r += t(e.geometries[n]); return r } }, wb.ring = Tb; var Mb = wb, Ob = function t(e, n) { switch (e && e.type || null) { case "FeatureCollection": return e.features = e.features.map(kb(t, n)), e; case "GeometryCollection": return e.geometries = e.geometries.map(kb(t, n)), e; case "Feature": return e.geometry = t(e.geometry, n), e; case "Polygon": case "MultiPolygon": return function (t, e) { "Polygon" === t.type ? t.coordinates = Ib(t.coordinates, e) : "MultiPolygon" === t.type && (t.coordinates = t.coordinates.map(kb(Ib, e))); return t }(e, n); default: return e } }; function kb(t, e) { return function (n) { return t(n, e) } } function Ib(t, e) { e = !!e, t[0] = Pb(t[0], e); for (var n = 1; n < t.length; n++)t[n] = Pb(t[n], !e); return t } function Pb(t, e) { return function (t) { return Mb.ring(t) >= 0 }(t) === e ? t : t.reverse() } function Lb(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Rb(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Lb(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Lb(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Db(t, e) { var n = e.x, r = e.y, i = e.x1, o = e.y1, a = e.coordinates, s = []; return Array.isArray(t) ? (t.forEach((function (t, e) { var l = []; (n && r && (l = [parseFloat(t[n]), parseFloat(t[r])]), n && r && i && o) && (l = [[parseFloat(t[n]), parseFloat(t[r])], [parseFloat(t[i]), parseFloat(t[o])]]); if (a) { var u = "Polygon"; Array.isArray(a[0]) || (u = "Point"), Array.isArray(a[0]) && !Array.isArray(a[0][0]) && (u = "LineString"); var c = { type: u, coordinates: Fd(t[a]) }; Ob(c, !0), l = c.coordinates } var p = Rb(Rb({}, t), {}, { _id: e, coordinates: l }); s.push(p) })), { dataArray: s }) : { dataArray: [] } } function Nb(t, e) { !function (t, e) { var n, r, i, o, a, s, l, u, c, p, h = 0, f = "FeatureCollection" === t.type, d = "Feature" === t.type, m = f ? t.features.length : 1; for (n = 0; n < m; n++) { for (s = f ? t.features[n].geometry : d ? t.geometry : t, u = f ? t.features[n].properties : d ? t.properties : {}, c = f ? t.features[n].bbox : d ? t.bbox : void 0, p = f ? t.features[n].id : d ? t.id : void 0, a = (l = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, i = 0; i < a; i++)if (null !== (o = l ? s.geometries[i] : s)) switch (o.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === e(o, h, u, c, p)) return !1; break; case "GeometryCollection": for (r = 0; r < o.geometries.length; r++)if (!1 === e(o.geometries[r], h, u, c, p)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === e(null, h, u, c, p)) return !1; h++ } }(t, (function (t, n, r, i, o) { var a, s = null === t ? null : t.type; switch (s) { case null: case "Point": case "LineString": case "Polygon": return !1 !== e(Mo(t, r, { bbox: i, id: o }), n, 0) && void 0 }switch (s) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }for (var l = 0; l < t.coordinates.length; l++) { var u = t.coordinates[l]; if (!1 === e(Mo({ type: a, coordinates: u }, r), n, l)) return !1 } })) } function zb(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function Fb(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? zb(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : zb(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Bb(t, e) { var n = e.extent, r = void 0 === n ? [121.168, 30.2828, 121.384, 30.4219] : n, i = new Promise((function (e) { !function (t, e) { var n = t, r = []; if ("string" == typeof n) Co({ url: n }, (function (t, n) { r.push(n), e(r) })); else { var i = n.length, o = 0; n.forEach((function (t) { Co({ url: t }, (function (t, n) { o++, r.push(n), o === i && e(r) })) })) } }(t, (function (t) { e(t) })) })); return { originData: t, images: i, _id: 1, dataArray: [{ _id: 0, coordinates: [[r[0], r[1]], [r[2], r[3]]] }] } } var jb = Vh, Ub = df((function (t, e, n, r) { jb(t, e, n, r) })), Vb = Ub, Gb = au, Hb = pp, Wb = ep; var Xb = function (t) { return "string" == typeof t || !Hb(t) && Wb(t) && "[object String]" == Gb(t) }; var qb = function (t, e) { for (var n = -1, r = null == t ? 0 : t.length; ++n < r && !1 !== e(t[n], n, t);); return t }, Zb = qc(Object.keys, Object), Yb = Kc, Kb = Zb, Qb = Object.prototype.hasOwnProperty; var Jb = function (t) { if (!Yb(t)) return Kb(t); var e = []; for (var n in Object(t)) Qb.call(t, n) && "constructor" != n && e.push(n); return e }, $b = ah, tw = Jb, ew = mp; var nw = function (t) { return ew(t) ? $b(t) : tw(t) }, rw = Yp, iw = nw; var ow = function (t, e) { return t && rw(e, iw(e), t) }, aw = Yp, sw = vh; var lw = function (t, e) { return t && aw(e, sw(e), t) }; var uw = function (t, e) { for (var n = -1, r = null == t ? 0 : t.length, i = 0, o = []; ++n < r;) { var a = t[n]; e(a, n, t) && (o[i++] = a) } return o }; var cw = function () { return [] }, pw = uw, hw = cw, fw = Object.prototype.propertyIsEnumerable, dw = Object.getOwnPropertySymbols, mw = dw ? function (t) { return null == t ? [] : (t = Object(t), pw(dw(t), (function (e) { return fw.call(t, e) }))) } : hw, vw = mw, yw = Yp, gw = vw; var _w = function (t, e) { return yw(t, gw(t), e) }; var xw = function (t, e) { for (var n = -1, r = e.length, i = t.length; ++n < r;)t[i + n] = e[n]; return t }, bw = xw, ww = Zc, Sw = vw, Ew = cw, Cw = Object.getOwnPropertySymbols ? function (t) { for (var e = []; t;)bw(e, Sw(t)), t = ww(t); return e } : Ew, Tw = Yp, Aw = Cw; var Mw = function (t, e) { return Tw(t, Aw(t), e) }, Ow = xw, kw = pp; var Iw = function (t, e, n) { var r = e(t); return kw(t) ? r : Ow(r, n(t)) }, Pw = Iw, Lw = vw, Rw = nw; var Dw = function (t) { return Pw(t, Rw, Lw) }, Nw = Iw, zw = Cw, Fw = vh; var Bw = function (t) { return Nw(t, Fw, zw) }, jw = ku(Zl, "DataView"), Uw = Iu, Vw = ku(Zl, "Promise"), Gw = Iv, Hw = ku(Zl, "WeakMap"), Ww = au, Xw = vu, qw = "[object Map]", Zw = "[object Promise]", Yw = "[object Set]", Kw = "[object WeakMap]", Qw = "[object DataView]", Jw = Xw(jw), $w = Xw(Uw), tS = Xw(Vw), eS = Xw(Gw), nS = Xw(Hw), rS = Ww; (jw && rS(new jw(new ArrayBuffer(1))) != Qw || Uw && rS(new Uw) != qw || Vw && rS(Vw.resolve()) != Zw || Gw && rS(new Gw) != Yw || Hw && rS(new Hw) != Kw) && (rS = function (t) { var e = Ww(t), n = "[object Object]" == e ? t.constructor : void 0, r = n ? Xw(n) : ""; if (r) switch (r) { case Jw: return Qw; case $w: return qw; case tS: return Zw; case eS: return Yw; case nS: return Kw }return e }); var iS = rS, oS = Object.prototype.hasOwnProperty; var aS = function (t) { var e = t.length, n = new t.constructor(e); return e && "string" == typeof t[0] && oS.call(t, "index") && (n.index = t.index, n.input = t.input), n }, sS = Bc; var lS = function (t, e) { var n = e ? sS(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.byteLength) }, uS = /\w*$/; var cS = function (t) { var e = new t.constructor(t.source, uS.exec(t)); return e.lastIndex = t.lastIndex, e }, pS = Yl ? Yl.prototype : void 0, hS = pS ? pS.valueOf : void 0; var fS = Bc, dS = lS, mS = cS, vS = function (t) { return hS ? Object(hS.call(t)) : {} }, yS = Uc; var gS = function (t, e, n) { var r = t.constructor; switch (e) { case "[object ArrayBuffer]": return fS(t); case "[object Boolean]": case "[object Date]": return new r(+t); case "[object DataView]": return dS(t, n); case "[object Float32Array]": case "[object Float64Array]": case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return yS(t, n); case "[object Map]": case "[object Set]": return new r; case "[object Number]": case "[object String]": return new r(t); case "[object RegExp]": return mS(t); case "[object Symbol]": return vS(t) } }, _S = iS, xS = ep; var bS = function (t) { return xS(t) && "[object Map]" == _S(t) }, wS = Dp, SS = Np.exports, ES = SS && SS.isMap, CS = ES ? wS(ES) : bS, TS = iS, AS = ep; var MS = function (t) { return AS(t) && "[object Set]" == TS(t) }, OS = Dp, kS = Np.exports, IS = kS && kS.isSet, PS = IS ? OS(IS) : MS, LS = Cc, RS = qb, DS = Xp, NS = ow, zS = lw, FS = Nc.exports, BS = Vc, jS = _w, US = Mw, VS = Dw, GS = Bw, HS = iS, WS = aS, XS = gS, qS = tp, ZS = pp, YS = _p.exports, KS = CS, QS = su, JS = PS, $S = nw, tE = vh, eE = "[object Arguments]", nE = "[object Function]", rE = "[object Object]", iE = {}; iE[eE] = iE["[object Array]"] = iE["[object ArrayBuffer]"] = iE["[object DataView]"] = iE["[object Boolean]"] = iE["[object Date]"] = iE["[object Float32Array]"] = iE["[object Float64Array]"] = iE["[object Int8Array]"] = iE["[object Int16Array]"] = iE["[object Int32Array]"] = iE["[object Map]"] = iE["[object Number]"] = iE[rE] = iE["[object RegExp]"] = iE["[object Set]"] = iE["[object String]"] = iE["[object Symbol]"] = iE["[object Uint8Array]"] = iE["[object Uint8ClampedArray]"] = iE["[object Uint16Array]"] = iE["[object Uint32Array]"] = !0, iE["[object Error]"] = iE[nE] = iE["[object WeakMap]"] = !1; var oE = function t(e, n, r, i, o, a) { var s, l = 1 & n, u = 2 & n, c = 4 & n; if (r && (s = o ? r(e, i, o, a) : r(e)), void 0 !== s) return s; if (!QS(e)) return e; var p = ZS(e); if (p) { if (s = WS(e), !l) return BS(e, s) } else { var h = HS(e), f = h == nE || "[object GeneratorFunction]" == h; if (YS(e)) return FS(e, l); if (h == rE || h == eE || f && !o) { if (s = u || f ? {} : qS(e), !l) return u ? US(e, zS(s, e)) : jS(e, NS(s, e)) } else { if (!iE[h]) return o ? e : {}; s = XS(e, h, l) } } a || (a = new LS); var d = a.get(e); if (d) return d; a.set(e, s), JS(e) ? e.forEach((function (i) { s.add(t(i, n, r, i, e, a)) })) : KS(e) && e.forEach((function (i, o) { s.set(o, t(i, n, r, o, e, a)) })); var m = p ? void 0 : (c ? u ? GS : VS : u ? tE : $S)(e); return RS(m || e, (function (i, o) { m && (i = e[o = i]), DS(s, o, t(i, n, r, o, e, a)) })), s }, aE = oE; var sE = function (t) { return aE(t, 5) }; function lE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function uE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? lE(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : lE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function cE(t, e) { var n = e.radius, r = void 0 === n ? 40 : n, i = e.maxZoom, o = void 0 === i ? 18 : i, a = e.minZoom, s = void 0 === a ? 0 : a, l = e.zoom, u = void 0 === l ? 2 : l; if (t.pointIndex) { var c = t.pointIndex.getClusters(t.extent, Math.floor(u)); return t.dataArray = c.map((function (t, e) { return uE({ coordinates: t.geometry.coordinates, _id: e + 1 }, t.properties) })), t } var p = new eb({ radius: r, minZoom: s, maxZoom: o }), h = { type: "FeatureCollection", features: [] }; return h.features = t.dataArray.map((function (t) { return { type: "Feature", geometry: { type: "Point", coordinates: t.coordinates }, properties: uE({}, t) } })), p.load(h.features), p } function pE(t) { if (0 === t.length) return 0; for (var e, n = t[0], r = 0, i = 1; i < t.length; i++)e = n + 1 * t[i], Math.abs(n) >= Math.abs(t[i]) ? r += n - e + t[i] : r += t[i] - e + n, n = e; return n + 1 * r } var hE = { min: function (t) { if (0 === t.length) throw new Error("min requires at least one data point"); for (var e = t[0], n = 1; n < t.length; n++)t[n] < e && (e = t[n]); return e }, max: function (t) { if (0 === t.length) throw new Error("max requires at least one data point"); for (var e = t[0], n = 1; n < t.length; n++)t[n] > e && (e = t[n]); return e }, mean: function (t) { if (0 === t.length) throw new Error("mean requires at least one data point"); return pE(t) / t.length }, sum: pE }; function fE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function dE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? fE(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : fE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function mE(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function vE(t, e) { if (Array.isArray(e)) return e } var yE = function (t) { Ur(n, t); var e = mE(n); function n(t, r) { var i; return Ar(this, n), kr(Gr(i = e.call(this)), "data", void 0), kr(Gr(i), "extent", void 0), kr(Gr(i), "hooks", { init: new bm }), kr(Gr(i), "parser", { type: "geojson" }), kr(Gr(i), "transforms", []), kr(Gr(i), "cluster", !1), kr(Gr(i), "clusterOptions", { enable: !1, radius: 40, maxZoom: 20, zoom: -99, method: "count" }), kr(Gr(i), "mapService", void 0), kr(Gr(i), "invalidExtent", !1), kr(Gr(i), "dataArrayChanged", !1), kr(Gr(i), "originData", void 0), kr(Gr(i), "rawData", void 0), kr(Gr(i), "cfg", {}), kr(Gr(i), "clusterIndex", void 0), i.originData = t, i.initCfg(r), i.hooks.init.tap("parser", (function () { i.excuteParser() })), i.hooks.init.tap("cluster", (function () { i.initCluster() })), i.hooks.init.tap("transform", (function () { i.executeTrans() })), i.init(), i } return Or(n, [{ key: "setData", value: function (t, e) { this.originData = t, this.dataArrayChanged = !1, this.initCfg(e), this.init(), this.emit("update") } }, { key: "getClusters", value: function (t) { return this.clusterIndex.getClusters(this.caculClusterExtent(2), t) } }, { key: "getClustersLeaves", value: function (t) { return this.clusterIndex.getLeaves(t, 1 / 0) } }, { key: "updateClusterData", value: function (t) { var e = this, n = this.clusterOptions, r = n.method, i = void 0 === r ? "sum" : r, o = n.field, a = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(t)); this.clusterOptions.zoom = t, a.forEach((function (t) { t.id || (t.properties.point_count = 1) })), (o || pu(i)) && (a = a.map((function (t) { var n = t.id; if (n) { var r, a = e.clusterIndex.getLeaves(n, 1 / 0).map((function (t) { return t.properties })); if (Xb(i) && o) { var s = function (t, e) { return t.map((function (t) { return 1 * t[e] })) }(a, o); r = hE[i](s) } pu(i) && (r = i(a)), t.properties.stat = r } else t.properties.point_count = 1; return t }))), this.data = pb("geojson")({ type: "FeatureCollection", features: a }), this.executeTrans() } }, { key: "getFeatureById", value: function (t) { var e = this.parser.type; if ("geojson" !== (void 0 === e ? "geojson" : e) || this.cluster) return t < this.data.dataArray.length ? this.data.dataArray[t] : "null"; var n = t < this.originData.features.length ? this.originData.features[t] : "null", r = sE(n); if (0 !== this.transforms.length || this.dataArrayChanged) { var i = this.data.dataArray.find((function (e) { return e._id === t })); r.properties = i } return r } }, { key: "updateFeaturePropertiesById", value: function (t, e) { this.data.dataArray = this.data.dataArray.map((function (n) { return n._id === t ? dE(dE({}, n), e) : n })), this.dataArrayChanged = !0, this.emit("update") } }, { key: "getFeatureId", value: function (t, e) { var n = this.data.dataArray.find((function (n) { return n[t] === e })); return null == n ? void 0 : n._id } }, { key: "destroy", value: function () { this.removeAllListeners(), this.originData = null, this.clusterIndex = null, this.data = null } }, { key: "caculClusterExtent", value: function (t) { var e, n = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]]; return this.invalidExtent || (n = zo([[(e = this.extent)[0], e[1]], [e[2], e[3]]], t)), n[0].concat(n[1]) } }, { key: "initCfg", value: function (t) { this.cfg = Vb(this.cfg, t, vE); var e = this.cfg; e && (e.parser && (this.parser = e.parser), e.transforms && (this.transforms = e.transforms), this.cluster = e.cluster || !1, e.clusterOptions && (this.cluster = !0, this.clusterOptions = dE(dE({}, this.clusterOptions), e.clusterOptions))) } }, { key: "excuteParser", value: function () { var t = this.parser, e = t.type || "geojson"; if ("imagetile" !== e) { var n = pb(e); this.data = n(this.originData, t), this.extent = Io(this.data.dataArray), this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3] } else this.data = { tileurl: this.originData, dataArray: [] } } }, { key: "executeTrans", value: function () { var t = this; this.transforms.forEach((function (e) { var n = function (t) { return ub[t] }(e.type)(t.data, e); Object.assign(t.data, n) })) } }, { key: "initCluster", value: function () { if (this.cluster) { var t = this.clusterOptions || {}; this.clusterIndex = cE(this.data, t) } } }, { key: "init", value: function () { this.hooks.init.call(this) } }]), n }(st.exports.EventEmitter); function gE(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return _E(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _E(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function _E(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var xE = 6378e3; var bE = Math.PI / 3, wE = [0, bE, 2 * bE, 3 * bE, 4 * bE, 5 * bE]; function SE(t) { return t[0] } function EE(t) { return t[1] } function CE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function TE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? CE(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : CE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function AE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function ME(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? AE(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : AE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } hb("geojson", (function (t, e) { var n = [], r = {}; return t.features = t.features.filter((function (t) { var e = t.geometry; return null != t && e && e.type && e.coordinates && e.coordinates.length > 0 })), Ob(t, !0), 0 === t.features.length ? { dataArray: [], featureKeys: r } : (Nb(t, (function (t, e) { var r = function (t) { if (Array.isArray(t)) return t; if ("Feature" === t.type) { if (null !== t.geometry) return t.geometry.coordinates } else if (t.coordinates) return t.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }(t), i = e, o = Fb(Fb({}, t.properties), {}, { coordinates: r, _id: i }); n.push(o) })), { dataArray: n, featureKeys: r }) })), hb("image", Bb), hb("csv", (function (t, e) { return Db(bb(t), e) })), hb("json", Db), hb("raster", (function (t, e) { var n = e.extent, r = e.width, i = e.height, o = e.min, a = e.max; return { _id: 1, dataArray: [{ _id: 1, data: Array.from(t), width: r, height: i, min: o, max: a, coordinates: [[n[0], n[1]], [n[2], n[3]]] }] } })), fb("cluster", cE), fb("filter", (function (t, e) { var n = e.callback; return n && (t.dataArray = t.dataArray.filter(n)), t })), fb("join", (function (t, e) { var n = e.sourceField, r = e.targetField, i = e.data, o = {}; return i.forEach((function (t) { o[t[n]] = t })), t.dataArray = t.dataArray.map((function (t) { var e = t[r]; return ME(ME({}, t), o[e]) })), t })), fb("map", (function (t, e) { var n = e.callback; return n && (t.dataArray = t.dataArray.map(n)), t })), fb("grid", (function (t, e) { var n = t.dataArray, r = e.size, i = void 0 === r ? 10 : r, o = i / (2 * Math.PI * xE) * (256 << 20) / 2, a = function (t, e) { var n, r, i = 1 / 0, o = -1 / 0, a = gE(t); try { for (a.s(); !(r = a.n()).done;) { n = r.value.coordinates[1], Number.isFinite(n) && (i = n < i ? n : i, o = n > o ? n : o) } } catch (t) { a.e(t) } finally { a.f() } var s = function (t, e) { var n = (i = t, i / xE * (180 / Math.PI)), r = function (t, e) { return e / xE * (180 / Math.PI) / Math.cos(t * Math.PI / 180) }(e, t); var i; return { yOffset: n, xOffset: r } }(e, (i + o) / 2); if (s.xOffset <= 0 || s.yOffset <= 0) return { gridHash: {}, gridOffset: s }; var l, u = {}, c = gE(t); try { for (c.s(); !(l = c.n()).done;) { var p = l.value, h = p.coordinates[1], f = p.coordinates[0]; if (Number.isFinite(h) && Number.isFinite(f)) { var d = Math.floor((h + 90) / s.yOffset), m = Math.floor((f + 180) / s.xOffset), v = "".concat(d, "-").concat(m); u[v] = u[v] || { count: 0, points: [] }, u[v].count += 1, u[v].points.push(p) } } } catch (t) { c.e(t) } finally { c.f() } return { gridHash: u, gridOffset: s } }(n, i), s = function (t, e, n) { return Object.keys(t).reduce((function (r, i, o) { var a = i.split("-"), s = parseInt(a[0], 10), l = parseInt(a[1], 10), u = {}; if (n.field && n.method) { var c = Ia(t[i].points, n.field); u[n.method] = ka[n.method](c) } return Object.assign(u, { _id: o, coordinates: Do([e.xOffset * (l + .5) - 180, e.yOffset * (s + .5) - 90]), rawData: t[i].points, count: t[i].count }), r.push(u), r }), []) }(a.gridHash, a.gridOffset, e); return { yOffset: o, xOffset: o, radius: o, type: "grid", dataArray: s } })), fb("hexagon", (function (t, e) { var n = t.dataArray, r = e.size, i = void 0 === r ? 10 : r, o = e.method, a = void 0 === o ? "sum" : o, s = i / (2 * Math.PI * 6378e3) * (256 << 20) / 2, l = n.map((function (t) { var e = Lr(Do(t.coordinates), 2), n = e[0], r = e[1]; return TE(TE({}, t), {}, { coordinates: [n, r] }) })), u = function () { var t, e, n, r = 0, i = 0, o = 1, a = 1, s = SE, l = EE; function u(t) { var r, i = {}, o = [], a = t.length; for (r = 0; r < a; ++r)if (!isNaN(c = +s.call(null, u = t[r], r, t)) && !isNaN(p = +l.call(null, u, r, t))) { var u, c, p, h = Math.round(p /= n), f = Math.round(c = c / e - (1 & h) / 2), d = p - h; if (3 * Math.abs(d) > 1) { var m = c - f, v = f + (c < f ? -1 : 1) / 2, y = h + (p < h ? -1 : 1), g = c - v, _ = p - y; m * m + d * d > g * g + _ * _ && (f = v + (1 & h ? 1 : -1) / 2, h = y) } var x = f + "-" + h, b = i[x]; b ? b.push(u) : (o.push(b = i[x] = [u]), b.x = (f + (1 & h) / 2) * e, b.y = h * n) } return o } function c(t) { var e = 0, n = 0; return wE.map((function (r) { var i = Math.sin(r) * t, o = -Math.cos(r) * t, a = i - e, s = o - n; return e = i, n = o, [a, s] })) } return u.hexagon = function (e) { return "m" + c(null == e ? t : +e).join("l") + "z" }, u.centers = function () { for (var s = [], l = Math.round(i / n), u = Math.round(r / e), c = l * n; c < a + t; c += n, ++l)for (var p = u * e + (1 & l) * e / 2; p < o + e / 2; p += e)s.push([p, c]); return s }, u.mesh = function () { var e = c(t).slice(0, 4).join("l"); return u.centers().map((function (t) { return "M" + t + "m" + e })).join("") }, u.x = function (t) { return arguments.length ? (s = t, u) : s }, u.y = function (t) { return arguments.length ? (l = t, u) : l }, u.radius = function (r) { return arguments.length ? (e = 2 * (t = +r) * Math.sin(bE), n = 1.5 * t, u) : t }, u.size = function (t) { return arguments.length ? (r = i = 0, o = +t[0], a = +t[1], u) : [o - r, a - i] }, u.extent = function (t) { return arguments.length ? (r = +t[0][0], i = +t[0][1], o = +t[1][0], a = +t[1][1], u) : [[r, i], [o, a]] }, u.radius(1) }().radius(s).x((function (t) { return t.coordinates[0] })).y((function (t) { return t.coordinates[1] })), c = { dataArray: u(l).map((function (t, n) { var r; if (e.field && a) { var i = Ia(t, e.field); t[a] = ka[a](i) } return kr(r = {}, e.method, t[a]), kr(r, "count", t.length), kr(r, "rawData", t), kr(r, "coordinates", [t.x, t.y]), kr(r, "_id", n), r })), radius: s, xOffset: s, yOffset: s, type: "hexagon" }; return c })); var OE, kE = [{ lng1: 100, lat1: 30, lng2: 130, lat2: 30 }], IE = { parser: { type: "json", x: "lng1", y: "lat1", x1: "lng2", y1: "lat2" } }, PE = (kr(OE = {}, t.BlendType.additive, { enable: !0, func: { srcRGB: id.ONE, dstRGB: id.ONE, srcAlpha: 1, dstAlpha: 1 } }), kr(OE, t.BlendType.none, { enable: !1 }), kr(OE, t.BlendType.normal, { enable: !0, func: { srcRGB: id.SRC_ALPHA, dstRGB: id.ONE_MINUS_SRC_ALPHA, srcAlpha: 1, dstAlpha: 1 } }), kr(OE, t.BlendType.subtractive, { enable: !0, func: { srcRGB: id.ONE, dstRGB: id.ONE, srcAlpha: id.ZERO, dstAlpha: id.ONE_MINUS_SRC_COLOR }, equation: { rgb: id.FUNC_SUBTRACT, alpha: id.FUNC_SUBTRACT } }), kr(OE, t.BlendType.max, { enable: !0, func: { srcRGB: id.ONE, dstRGB: id.ONE }, equation: { rgb: id.MAX_EXT } }), kr(OE, t.BlendType.min, { enable: !0, func: { srcRGB: id.ONE, dstRGB: id.ONE }, equation: { rgb: id.MIN_EXT } }), OE), LE = au, RE = ep; var DE = function (t) { return "number" == typeof t || RE(t) && "[object Number]" == LE(t) }; function NE(t, e, n, r, i) { e.updateStyleAttribute(t, n, r, i) } function zE(t, e) { t.opacity && FE("opacity", e, t.opacity), t.strokeWidth && FE("strokeWidth", e, t.strokeWidth), t.strokeOpacity && FE("strokeOpacity", e, t.strokeOpacity), t.stroke && function (t, e, n) { Xb(n) ? NE(t, e, n, void 0) : Array.isArray(n) && 2 === n.length && (Xb(n[0]) && pu(n[1]) || Xb(n[0]) && Array.isArray(n[1]) && n[1].length > 0) ? NE(t, e, n[0], n[1]) : NE(t, e, "#fff", void 0) }("stroke", e, t.stroke), t.offsets && BE("offsets", e, t.offsets), t.textOffset && BE("textOffset", e, t.textOffset), t.thetaOffset && FE("thetaOffset", e, t.thetaOffset) } function FE(t, e, n) { Xb(n) ? NE(t, e, n, (function (t) { return t })) : DE(n) ? NE(t, e, [n], void 0) : Array.isArray(n) && 2 === n.length && (Xb(n[0]) && pu(n[1]) || Xb(n[0]) && Array.isArray(n[1]) && DE(n[1][0]) && DE(n[1][1])) ? NE(t, e, n[0], n[1]) : NE(t, e, [1], void 0) } function BE(t, e, n) { Xb(n) ? NE(t, e, n, (function (t) { return t })) : Array.isArray(n) && 2 === n.length && Xb(n[0]) && pu(n[1]) ? NE(t, e, n[0], n[1]) : Array.isArray(n) && 2 === n.length && DE(n[0]) && DE(n[1]) ? NE(t, e, n, void 0) : NE(t, e, [0, 0], void 0) } function jE(t) { return t.map((function (t) { return "string" == typeof t && (t = [t, {}]), t })) } function UE(t, e, n, r) { var i = t.multiPassRenderer, o = t.getLayerConfig(); return o.enablePicking, o.enableTAA ? i.add(r("taa")) : i.add(r("render")), jE(e).forEach((function (t) { var e = Lr(t, 2), r = e[0], o = e[1]; i.add(n(r), o) })), i.add(n("copy")), i } var VE = [["circle", "cylinder"], ["square", "cylinder"], ["triangle", "cylinder"], ["pentagon", "cylinder"], ["hexagon", "cylinder"], ["octogon", "cylinder"], ["hexagram", "cylinder"], ["rhombus", "cylinder"], ["vesica", "cylinder"]]; var GE, HE, WE, XE = ["passes"], qE = ["moduleName", "vertexShader", "fragmentShader", "triangulation", "segmentNumber"]; function ZE(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return YE(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return YE(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function YE(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function KE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function QE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? KE(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : KE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function JE(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var $E = 0, tC = (GE = Ex(Tr.IGlobalConfigService), HE = function (e) { Ur(o, e); var n, r, i = JE(o); function o() { var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return Ar(this, o), kr(Gr(t = i.call(this)), "id", "".concat($E++)), kr(Gr(t), "name", "".concat($E)), kr(Gr(t), "type", void 0), kr(Gr(t), "visible", !0), kr(Gr(t), "zIndex", 0), kr(Gr(t), "minZoom", void 0), kr(Gr(t), "maxZoom", void 0), kr(Gr(t), "inited", !1), kr(Gr(t), "layerModelNeedUpdate", !1), kr(Gr(t), "pickedFeatureID", null), kr(Gr(t), "selectedFeatureID", null), kr(Gr(t), "styleNeedUpdate", !1), kr(Gr(t), "rendering", void 0), kr(Gr(t), "clusterZoom", 0), kr(Gr(t), "layerType", void 0), kr(Gr(t), "isLayerGroup", !1), kr(Gr(t), "dataState", { dataSourceNeedUpdate: !1, dataMappingNeedUpdate: !1, filterNeedUpdate: !1, featureScaleNeedUpdate: !1, StyleAttrNeedUpdate: !1 }), kr(Gr(t), "hooks", { init: new Om, afterInit: new Om, beforeRender: new Om, beforeRenderData: new Mm, afterRender: new bm, beforePickingEncode: new bm, afterPickingEncode: new bm, beforeHighlight: new bm(["pickedColor"]), afterHighlight: new bm, beforeSelect: new bm(["pickedColor"]), afterSelect: new bm, beforeDestroy: new bm, afterDestroy: new bm }), kr(Gr(t), "models", []), kr(Gr(t), "multiPassRenderer", void 0), kr(Gr(t), "plugins", void 0), kr(Gr(t), "sourceOption", void 0), kr(Gr(t), "layerModel", void 0), kr(Gr(t), "shapeOption", void 0), kr(Gr(t), "sceneContainer", void 0), kr(Gr(t), "layerChildren", []), kr(Gr(t), "masks", []), Ef(Gr(t), "configService", WE, Gr(t)), kr(Gr(t), "shaderModuleService", void 0), kr(Gr(t), "cameraService", void 0), kr(Gr(t), "coordinateService", void 0), kr(Gr(t), "iconService", void 0), kr(Gr(t), "fontService", void 0), kr(Gr(t), "pickingService", void 0), kr(Gr(t), "rendererService", void 0), kr(Gr(t), "layerService", void 0), kr(Gr(t), "interactionService", void 0), kr(Gr(t), "mapService", void 0), kr(Gr(t), "styleAttributeService", void 0), kr(Gr(t), "layerSource", void 0), kr(Gr(t), "postProcessingPassFactory", void 0), kr(Gr(t), "normalPassFactory", void 0), kr(Gr(t), "animateOptions", { enable: !1 }), kr(Gr(t), "container", void 0), kr(Gr(t), "encodedData", void 0), kr(Gr(t), "configSchema", void 0), kr(Gr(t), "currentPickId", null), kr(Gr(t), "rawConfig", void 0), kr(Gr(t), "needUpdateConfig", void 0), kr(Gr(t), "pendingStyleAttributes", []), kr(Gr(t), "scaleOptions", {}), kr(Gr(t), "animateStartTime", void 0), kr(Gr(t), "aniamateStatus", !1), kr(Gr(t), "bottomColor", "rgba(0, 0, 0, 0)"), kr(Gr(t), "isDestroied", !1), kr(Gr(t), "sourceEvent", (function () { t.dataState.dataSourceNeedUpdate = !0; var e = t.getLayerConfig(), n = e.autoFit, r = e.fitBoundsOptions; n && t.fitBounds(r), t.reRender() })), t.name = e.name || t.id, t.zIndex = e.zIndex || 0, t.rawConfig = e, t } return Or(o, [{ key: "addMaskLayer", value: function (t) { this.masks.push(t) } }, { key: "removeMaskLayer", value: function (t) { var e = this.masks.indexOf(t); e > -1 && this.masks.splice(e, 1), t.destroy() } }, { key: "getLayerConfig", value: function () { return this.configService.getLayerConfig(this.id) } }, { key: "updateLayerConfig", value: function (t) { if (this.inited) { var e = this.container.get(Tr.SceneID); zE(t, this), this.configService.setLayerConfig(e, this.id, QE(QE(QE({}, this.configService.getLayerConfig(this.id)), this.needUpdateConfig), t)), this.needUpdateConfig = {} } else this.needUpdateConfig = QE(QE({}, this.needUpdateConfig), t) } }, { key: "setContainer", value: function (t, e) { this.container = t, this.sceneContainer = e } }, { key: "getContainer", value: function () { return this.container } }, { key: "setBottomColor", value: function (t) { this.bottomColor = t } }, { key: "getBottomColor", value: function () { return this.bottomColor } }, { key: "addPlugin", value: function (t) { return this.plugins.push(t), this } }, { key: "init", value: function () { var t = this, e = this.container.get(Tr.SceneID); this.configService.setLayerConfig(e, this.id, this.rawConfig), this.layerType = this.rawConfig.layerType, this.iconService = this.container.get(Tr.IIconService), this.fontService = this.container.get(Tr.IFontService), this.rendererService = this.container.get(Tr.IRendererService), this.layerService = this.container.get(Tr.ILayerService), this.interactionService = this.container.get(Tr.IInteractionService), this.pickingService = this.container.get(Tr.IPickingService), this.mapService = this.container.get(Tr.IMapService); var n = this.getLayerConfig(), r = n.enableMultiPassRenderer, i = n.passes; r && null != i && i.length && i.length > 0 && this.mapService.on("mapAfterFrameChange", (function () { t.renderLayers() })), this.cameraService = this.container.get(Tr.ICameraService), this.coordinateService = this.container.get(Tr.ICoordinateSystemService), this.shaderModuleService = this.container.get(Tr.IShaderModuleService), this.postProcessingPassFactory = this.container.get(Tr.IFactoryPostProcessingPass), this.normalPassFactory = this.container.get(Tr.IFactoryNormalPass), this.styleAttributeService = this.container.get(Tr.IStyleAttributeService), this.multiPassRenderer = this.container.get(Tr.IMultiPassRenderer), this.multiPassRenderer.setLayer(this), this.pendingStyleAttributes.forEach((function (e) { var n = e.attributeName, r = e.attributeField, i = e.attributeValues, o = e.updateOptions; t.styleAttributeService.updateStyleAttribute(n, { scale: QE({ field: r }, t.splitValuesAndCallbackInAttribute(i, t.getLayerConfig()[n])) }, o) })), this.pendingStyleAttributes = [], this.plugins = this.container.getAll(Tr.ILayerPlugin); var o, a = ZE(this.plugins); try { for (a.s(); !(o = a.n()).done;) { o.value.apply(this, { rendererService: this.rendererService, mapService: this.mapService, styleAttributeService: this.styleAttributeService, normalPassFactory: this.normalPassFactory, postProcessingPassFactory: this.postProcessingPassFactory }) } } catch (t) { a.e(t) } finally { a.f() } return this.hooks.init.call(), this.hooks.afterInit.call(), this.emit("inited", { target: this, type: "inited" }), this.emit("add", { target: this, type: "add" }), this } }, { key: "prepareBuildModel", value: function () { this.inited = !0, this.updateLayerConfig(QE(QE({}, this.getDefaultConfig()), this.rawConfig)); var t = this.getLayerConfig().animateOption; null != t && t.enable && (this.layerService.startAnimate(), this.aniamateStatus = !0) } }, { key: "color", value: function (t, e, n) { return this.updateStyleAttribute("color", t, e, n), this } }, { key: "texture", value: function (t, e, n) { return this.updateStyleAttribute("texture", t, e, n), this } }, { key: "rotate", value: function (t, e, n) { return this.updateStyleAttribute("rotate", t, e, n), this } }, { key: "size", value: function (t, e, n) { return this.updateStyleAttribute("size", t, e, n), this } }, { key: "filter", value: function (t, e, n) { return this.updateStyleAttribute("filter", t, e, n), this } }, { key: "shape", value: function (t, e, n) { var r, i, o, a = null === (r = this.styleAttributeService) || void 0 === r || null === (i = r.getLayerStyleAttribute("shape")) || void 0 === i || null === (o = i.scale) || void 0 === o ? void 0 : o.field, s = t; return this.shapeOption = { field: t, values: e }, this.updateStyleAttribute("shape", t, e, n), function (t, e, n) { if ("string" == typeof e && "string" == typeof n && e !== n) { if ("PointLayer" === t.type) return void (t.dataState.dataSourceNeedUpdate = !0); VE.map((function (r) { r.includes(e) && r.includes(n) && (t.dataState.dataSourceNeedUpdate = !0) })) } }(this, a, s), this } }, { key: "label", value: function (t, e, n) { return this.pendingStyleAttributes.push({ attributeName: "label", attributeField: t, attributeValues: e, updateOptions: n }), this } }, { key: "animate", value: function (t) { var e = {}; return su(t) ? (e.enable = !0, e = QE(QE({}, e), t)) : e.enable = t, this.updateLayerConfig({ animateOption: e }), this } }, { key: "source", value: function (t, e) { return null != t && t.data ? (this.setSource(t), this) : (this.sourceOption = { data: t, options: e }, this.clusterZoom = 0, this) } }, { key: "setData", value: function (t, e) { var n = this; return this.inited ? this.layerSource.setData(t, e) : this.on("inited", (function () { n.getSource() ? n.layerSource.setData(t, e) : (n.source(new yE(t, e)), n.sourceEvent()) })), this } }, { key: "style", value: function (t) { var e = this, n = this.getLayerConfig(), r = t.passes, i = zd(t, XE); return r && jE(r).forEach((function (t) { var n = e.multiPassRenderer.getPostProcessor().getPostProcessingPassByName(t[0]); n && n.updateOptions(t[1]) })), this.rawConfig = QE(QE({}, this.rawConfig), i), this.container && (this.updateLayerConfig(this.rawConfig), this.styleNeedUpdate = !0), n && !0 === n.mask && !1 === t.mask && (this.clearModels(), this.models = this.layerModel.buildModels()), this } }, { key: "scale", value: function (t, e) { return su(t) ? this.scaleOptions = QE(QE({}, this.scaleOptions), t) : this.scaleOptions[t] = e, this } }, { key: "renderLayers", value: function () { this.rendering = !0, this.layerService.renderLayers(), this.rendering = !1 } }, { key: "render", value: function () { return 0 !== this.getEncodedData().length && this.renderModels(), this } }, { key: "renderMultiPass", value: (r = nd(gd.mark((function t() { return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (0 === this.getEncodedData().length) { t.next = 7; break } if (!this.multiPassRenderer || !this.multiPassRenderer.getRenderFlag()) { t.next = 6; break } return t.next = 4, this.multiPassRenderer.render(); case 4: t.next = 7; break; case 6: this.multiPassRenderer, this.renderModels(); case 7: case "end": return t.stop() } }), t, this) }))), function () { return r.apply(this, arguments) }) }, { key: "active", value: function (t) { var e = {}; return e.enableHighlight = !!su(t) || t, su(t) ? (e.enableHighlight = !0, t.color && (e.highlightColor = t.color), t.mix && (e.activeMix = t.mix)) : e.enableHighlight = !!t, this.updateLayerConfig(e), this } }, { key: "setActive", value: function (t, e) { var n = this; if (su(t)) { var r = t.x, i = void 0 === r ? 0 : r, o = t.y, a = void 0 === o ? 0 : o; this.updateLayerConfig({ highlightColor: su(e) ? e.color : this.getLayerConfig().highlightColor, activeMix: su(e) ? e.mix : this.getLayerConfig().activeMix }), this.pick({ x: i, y: a }) } else this.updateLayerConfig({ pickedFeatureID: t, highlightColor: su(e) ? e.color : this.getLayerConfig().highlightColor, activeMix: su(e) ? e.mix : this.getLayerConfig().activeMix }), this.hooks.beforeSelect.call(wa(t)).then((function () { setTimeout((function () { n.reRender() }), 1) })) } }, { key: "select", value: function (t) { var e = {}; return e.enableSelect = !!su(t) || t, su(t) ? (e.enableSelect = !0, t.color && (e.selectColor = t.color), t.mix && (e.selectMix = t.mix)) : e.enableSelect = !!t, this.updateLayerConfig(e), this } }, { key: "setSelect", value: function (t, e) { var n = this; if (su(t)) { var r = t.x, i = void 0 === r ? 0 : r, o = t.y, a = void 0 === o ? 0 : o; this.updateLayerConfig({ selectColor: su(e) ? e.color : this.getLayerConfig().selectColor, selectMix: su(e) ? e.mix : this.getLayerConfig().selectMix }), this.pick({ x: i, y: a }) } else this.updateLayerConfig({ pickedFeatureID: t, selectColor: su(e) ? e.color : this.getLayerConfig().selectColor, selectMix: su(e) ? e.mix : this.getLayerConfig().selectMix }), this.hooks.beforeSelect.call(wa(t)).then((function () { setTimeout((function () { n.reRender() }), 1) })) } }, { key: "setBlend", value: function (t) { return this.updateLayerConfig({ blend: t }), this.layerModelNeedUpdate = !0, this.reRender(), this } }, { key: "show", value: function () { return this.updateLayerConfig({ visible: !0 }), this.reRender(), this } }, { key: "hide", value: function () { return this.updateLayerConfig({ visible: !1 }), this.reRender(), this } }, { key: "setIndex", value: function (t) { return this.zIndex = t, this.layerService.updateLayerRenderList(), this.layerService.renderLayers(), this } }, { key: "setCurrentPickId", value: function (t) { this.currentPickId = t } }, { key: "getCurrentPickId", value: function () { return this.currentPickId } }, { key: "setCurrentSelectedId", value: function (t) { this.selectedFeatureID = t } }, { key: "getCurrentSelectedId", value: function () { return this.selectedFeatureID } }, { key: "isVisible", value: function () { var t = this.mapService.getZoom(), e = this.getLayerConfig(), n = e.visible, r = e.minZoom, i = void 0 === r ? -1 / 0 : r, o = e.maxZoom; return !!n && t >= i && t <= (void 0 === o ? 1 / 0 : o) } }, { key: "setMultiPass", value: function (t, e) { if (this.updateLayerConfig({ enableMultiPassRenderer: t }), e && this.updateLayerConfig({ passes: e }), t) { var n = this.getLayerConfig().passes, r = void 0 === n ? [] : n; this.multiPassRenderer = UE(this, r, this.postProcessingPassFactory, this.normalPassFactory), this.multiPassRenderer.setRenderFlag(!0); var i = this.rendererService.getViewportSize(), o = i.width, a = i.height; this.multiPassRenderer.resize(o, a) } return this } }, { key: "setMinZoom", value: function (t) { return this.updateLayerConfig({ minZoom: t }), this } }, { key: "getMinZoom", value: function () { return this.getLayerConfig().minZoom } }, { key: "getMaxZoom", value: function () { return this.getLayerConfig().maxZoom } }, { key: "get", value: function (t) { return this.getLayerConfig()[t] } }, { key: "setMaxZoom", value: function (t) { return this.updateLayerConfig({ maxZoom: t }), this } }, { key: "setAutoFit", value: function (t) { return this.updateLayerConfig({ autoFit: t }), this } }, { key: "fitBounds", value: function (t) { if (!this.inited) return this.updateLayerConfig({ autoFit: !0 }), this; var e = this.getSource().extent; return e.some((function (t) { return Math.abs(t) === 1 / 0 })) || this.mapService.fitBounds([[e[0], e[1]], [e[2], e[3]]], t), this } }, { key: "destroy", value: function () { var t; this.isDestroied || (this.layerChildren.map((function (t) { return t.destroy() })), this.layerChildren = [], this.masks.map((function (t) { return t.destroy() })), this.masks = [], this.hooks.beforeDestroy.call(), this.layerSource.off("update", this.sourceEvent), this.multiPassRenderer.destroy(), this.styleAttributeService.clearAllAttributes(), this.hooks.afterDestroy.call(), null === (t = this.layerModel) || void 0 === t || t.clearModels(), this.models = [], this.layerService.cleanRemove(this), this.emit("remove", { target: this, type: "remove" }), this.emit("destroy", { target: this, type: "destroy" }), this.removeAllListeners(), this.isDestroied = !0) } }, { key: "clear", value: function () { this.styleAttributeService.clearAllAttributes() } }, { key: "clearModels", value: function () { this.models.forEach((function (t) { return t.destroy() })), this.layerModel.clearModels(), this.models = [] } }, { key: "isDirty", value: function () { return !!(this.styleAttributeService.getLayerStyleAttributes() || []).filter((function (t) { return t.needRescale || t.needRemapping || t.needRegenerateVertices })).length } }, { key: "setSource", value: function (t) { if (this.layerSource && this.layerSource.off("update", this.sourceEvent), this.layerSource = t, this.clusterZoom = 0, this.inited && this.layerSource.cluster) { var e = this.mapService.getZoom(); this.layerSource.updateClusterData(e) } this.layerSource.on("update", this.sourceEvent) } }, { key: "getSource", value: function () { return this.layerSource } }, { key: "getScaleOptions", value: function () { return this.scaleOptions } }, { key: "setEncodedData", value: function (t) { this.encodedData = t } }, { key: "getEncodedData", value: function () { return this.encodedData } }, { key: "getScale", value: function (t) { return this.styleAttributeService.getLayerAttributeScale(t) } }, { key: "getLegendItems", value: function (t) { var e = this.styleAttributeService.getLayerAttributeScale(t); return e ? e.invertExtent ? e.range().map((function (n) { return kr({ value: e.invertExtent(n) }, t, n) })) : e.ticks ? e.ticks().map((function (n) { return kr({ value: n }, t, e(n)) })) : null != e && e.domain ? e.domain().filter((function (t) { return !lb(t) })).map((function (n) { return kr({ value: n }, t, e(n)) })) : [] : [] } }, { key: "pick", value: function (t) { var e = t.x, n = t.y; this.interactionService.triggerHover({ x: e, y: n }) } }, { key: "boxSelect", value: function (t, e) { this.pickingService.boxPickLayer(this, t, e) } }, { key: "buildLayerModel", value: function (e) { var n = e.moduleName, r = e.vertexShader, i = e.fragmentShader, o = e.triangulation, a = e.segmentNumber, s = zd(e, qE); this.shaderModuleService.registerModule(n, { vs: r, fs: i }); var l = this.shaderModuleService.getModule(n), u = l.vs, c = l.fs, p = l.uniforms, h = this.rendererService.createModel, f = this.styleAttributeService.createAttributesAndIndices(this.encodedData, o, a); return h(QE({ attributes: f.attributes, uniforms: p, fs: c, vs: u, elements: f.elements, blend: PE[t.BlendType.normal] }, s)) } }, { key: "getTime", value: function () { return this.layerService.clock.getDelta() } }, { key: "setAnimateStartTime", value: function () { this.animateStartTime = this.layerService.clock.getElapsedTime() } }, { key: "stopAnimate", value: function () { this.aniamateStatus && (this.layerService.stopAnimate(), this.aniamateStatus = !1, this.updateLayerConfig({ animateOption: { enable: !1 } })) } }, { key: "getLayerAnimateTime", value: function () { return this.layerService.clock.getElapsedTime() - this.animateStartTime } }, { key: "needPick", value: function (t) { var e = this.getLayerConfig(), n = e.enableHighlight, r = void 0 === n || n, i = e.enableSelect, o = void 0 === i || i, a = -1 !== this.eventNames().indexOf(t) || -1 !== this.eventNames().indexOf("un" + t); return "click" !== t && "dblclick" !== t || !o || (a = !0), "mousemove" !== t || !r && -1 === this.eventNames().indexOf("mouseenter") && -1 === this.eventNames().indexOf("unmousemove") && -1 === this.eventNames().indexOf("mouseout") || (a = !0), this.isVisible() && a } }, { key: "buildModels", value: function () { throw new Error("Method not implemented.") } }, { key: "rebuildModels", value: function () { throw new Error("Method not implemented.") } }, { key: "renderMulPass", value: (n = nd(gd.mark((function t(e) { return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, e.render(); case 2: case "end": return t.stop() } }), t) }))), function (t) { return n.apply(this, arguments) }) }, { key: "renderModels", value: function (t) { var e = this; return this.getEncodedData().length > 0 && (this.layerModelNeedUpdate && this.layerModel && (this.models = this.layerModel.buildModels(), this.hooks.beforeRender.call(), this.layerModelNeedUpdate = !1), this.layerModel.renderUpdate && this.layerModel.renderUpdate(), this.models.forEach((function (n) { n.draw({ uniforms: e.layerModel.getUninforms() }, t) }))), this } }, { key: "updateStyleAttribute", value: function (t, e, n, r) { this.inited ? this.styleAttributeService.updateStyleAttribute(t, { scale: QE({ field: e }, this.splitValuesAndCallbackInAttribute(n, this.getLayerConfig()[e])) }, r) : this.pendingStyleAttributes.push({ attributeName: t, attributeField: e, attributeValues: n, updateOptions: r }) } }, { key: "getShaderPickStat", value: function () { return this.layerService.getShaderPickStat() } }, { key: "setEarthTime", value: function (t) { console.warn("empty fn") } }, { key: "getConfigSchema", value: function () { throw new Error("Method not implemented.") } }, { key: "getModelType", value: function () { throw new Error("Method not implemented.") } }, { key: "getDefaultConfig", value: function () { return {} } }, { key: "reRender", value: function () { this.inited && (this.layerService.updateLayerRenderList(), this.layerService.renderLayers()) } }, { key: "splitValuesAndCallbackInAttribute", value: function (t, e) { return { values: pu(t) ? void 0 : t || e, callback: pu(t) ? t : void 0 } } }]), o }(st.exports.EventEmitter), WE = Cf(HE.prototype, "configService", [GE], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), HE); var eC = function (t, e) { for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)if (e(t[n], n, t)) return !0; return !1 }, nC = xv, rC = eC, iC = kv; var oC = function (t, e, n, r, i, o) { var a = 1 & n, s = t.length, l = e.length; if (s != l && !(a && l > s)) return !1; var u = o.get(t), c = o.get(e); if (u && c) return u == e && c == t; var p = -1, h = !0, f = 2 & n ? new nC : void 0; for (o.set(t, e), o.set(e, t); ++p < s;) { var d = t[p], m = e[p]; if (r) var v = a ? r(m, d, p, e, t, o) : r(d, m, p, t, e, o); if (void 0 !== v) { if (v) continue; h = !1; break } if (f) { if (!rC(e, (function (t, e) { if (!iC(f, e) && (d === t || i(d, t, n, r, o))) return f.push(e) }))) { h = !1; break } } else if (d !== m && !i(d, m, n, r, o)) { h = !1; break } } return o.delete(t), o.delete(e), h }; var aC = function (t) { var e = -1, n = Array(t.size); return t.forEach((function (t, r) { n[++e] = [r, t] })), n }, sC = zc, lC = wl, uC = oC, cC = aC, pC = Pv, hC = Yl ? Yl.prototype : void 0, fC = hC ? hC.valueOf : void 0; var dC = function (t, e, n, r, i, o, a) { switch (n) { case "[object DataView]": if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1; t = t.buffer, e = e.buffer; case "[object ArrayBuffer]": return !(t.byteLength != e.byteLength || !o(new sC(t), new sC(e))); case "[object Boolean]": case "[object Date]": case "[object Number]": return lC(+t, +e); case "[object Error]": return t.name == e.name && t.message == e.message; case "[object RegExp]": case "[object String]": return t == e + ""; case "[object Map]": var s = cC; case "[object Set]": var l = 1 & r; if (s || (s = pC), t.size != e.size && !l) return !1; var u = a.get(t); if (u) return u == e; r |= 2, a.set(t, e); var c = uC(s(t), s(e), r, i, o, a); return a.delete(t), c; case "[object Symbol]": if (fC) return fC.call(t) == fC.call(e) }return !1 }, mC = Dw, vC = Object.prototype.hasOwnProperty; var yC = function (t, e, n, r, i, o) { var a = 1 & n, s = mC(t), l = s.length; if (l != mC(e).length && !a) return !1; for (var u = l; u--;) { var c = s[u]; if (!(a ? c in e : vC.call(e, c))) return !1 } var p = o.get(t), h = o.get(e); if (p && h) return p == e && h == t; var f = !0; o.set(t, e), o.set(e, t); for (var d = a; ++u < l;) { var m = t[c = s[u]], v = e[c]; if (r) var y = a ? r(v, m, c, e, t, o) : r(m, v, c, t, e, o); if (!(void 0 === y ? m === v || i(m, v, n, r, o) : y)) { f = !1; break } d || (d = "constructor" == c) } if (f && !d) { var g = t.constructor, _ = e.constructor; g == _ || !("constructor" in t) || !("constructor" in e) || "function" == typeof g && g instanceof g && "function" == typeof _ && _ instanceof _ || (f = !1) } return o.delete(t), o.delete(e), f }, gC = Cc, _C = oC, xC = dC, bC = yC, wC = iS, SC = pp, EC = _p.exports, CC = Up, TC = "[object Arguments]", AC = "[object Array]", MC = "[object Object]", OC = Object.prototype.hasOwnProperty; var kC = function (t, e, n, r, i, o) { var a = SC(t), s = SC(e), l = a ? AC : wC(t), u = s ? AC : wC(e), c = (l = l == TC ? MC : l) == MC, p = (u = u == TC ? MC : u) == MC, h = l == u; if (h && EC(t)) { if (!EC(e)) return !1; a = !0, c = !1 } if (h && !c) return o || (o = new gC), a || CC(t) ? _C(t, e, n, r, i, o) : xC(t, e, l, n, r, i, o); if (!(1 & n)) { var f = c && OC.call(t, "__wrapped__"), d = p && OC.call(e, "__wrapped__"); if (f || d) { var m = f ? t.value() : t, v = d ? e.value() : e; return o || (o = new gC), i(m, v, n, r, o) } } return !!h && (o || (o = new gC), bC(t, e, n, r, i, o)) }, IC = kC, PC = ep; var LC = function t(e, n, r, i, o) { return e === n || (null == e || null == n || !PC(e) && !PC(n) ? e != e && n != n : IC(e, n, r, i, t, o)) }, RC = LC; var DC, NC, zC, FC = function (t, e) { return RC(t, e) }; function BC(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return jC(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jC(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function jC(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var UC = (DC = Ex(Tr.IGlobalConfigService), NC = function () { function e(t) { Ar(this, e), kr(this, "triangulation", void 0), kr(this, "createTexture2D", void 0), kr(this, "layer", void 0), kr(this, "dataTexture", void 0), kr(this, "DATA_TEXTURE_WIDTH", void 0), kr(this, "rowCount", void 0), kr(this, "cacheStyleProperties", void 0), kr(this, "cellLength", void 0), kr(this, "cellProperties", void 0), kr(this, "cellTypeLayout", void 0), kr(this, "stylePropertyesExist", void 0), kr(this, "dataTextureTest", void 0), Ef(this, "configService", zC, this), kr(this, "shaderModuleService", void 0), kr(this, "rendererService", void 0), kr(this, "iconService", void 0), kr(this, "fontService", void 0), kr(this, "styleAttributeService", void 0), kr(this, "mapService", void 0), kr(this, "cameraService", void 0), kr(this, "layerService", void 0), this.layer = t, this.rendererService = t.getContainer().get(Tr.IRendererService), this.shaderModuleService = t.getContainer().get(Tr.IShaderModuleService), this.styleAttributeService = t.getContainer().get(Tr.IStyleAttributeService), this.mapService = t.getContainer().get(Tr.IMapService), this.iconService = t.getContainer().get(Tr.IIconService), this.fontService = t.getContainer().get(Tr.IFontService), this.cameraService = t.getContainer().get(Tr.ICameraService), this.layerService = t.getContainer().get(Tr.ILayerService), this.registerBuiltinAttributes(), this.startModelAnimate(); var n = this.rendererService.createTexture2D; this.createTexture2D = n, this.DATA_TEXTURE_WIDTH = 1024, this.rowCount = 1, this.cellLength = 0, this.cellProperties = [], this.cacheStyleProperties = { thetaOffset: void 0, opacity: void 0, strokeOpacity: void 0, strokeWidth: void 0, stroke: void 0, offsets: void 0 }, this.stylePropertyesExist = { hasThetaOffset: 0, hasOpacity: 0, hasStrokeOpacity: 0, hasStrokeWidth: 0, hasStroke: 0, hasOffsets: 0 }, this.dataTextureTest = this.layerService.getOESTextureFloat(), this.dataTextureTest || (this.dataTexture = this.createTexture2D({ data: new Uint8Array(4), mag: id.NEAREST, min: id.NEAREST, width: 1, height: 1 })) } return Or(e, [{ key: "clearLastCalRes", value: function () { this.cellProperties = [], this.cellLength = 0, this.stylePropertyesExist = { hasThetaOffset: 0, hasOpacity: 0, hasStrokeOpacity: 0, hasStrokeWidth: 0, hasStroke: 0, hasOffsets: 0 } } }, { key: "getCellTypeLayout", value: function () { return this.dataTextureTest ? [this.rowCount, this.DATA_TEXTURE_WIDTH, 0, 0, this.stylePropertyesExist.hasOpacity, this.stylePropertyesExist.hasStrokeOpacity, this.stylePropertyesExist.hasStrokeWidth, this.stylePropertyesExist.hasStroke, this.stylePropertyesExist.hasOffsets, this.stylePropertyesExist.hasThetaOffset, 0, 0, 0, 0, 0, 1] : [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1] } }, { key: "dataTextureNeedUpdate", value: function (t) { var e = !1; return FC(t.thetaOffset, this.cacheStyleProperties.thetaOffset) || (e = !0, this.cacheStyleProperties.thetaOffset = t.thetaOffset), FC(t.opacity, this.cacheStyleProperties.opacity) || (e = !0, this.cacheStyleProperties.opacity = t.opacity), FC(t.strokeOpacity, this.cacheStyleProperties.strokeOpacity) || (e = !0, this.cacheStyleProperties.strokeOpacity = t.strokeOpacity), FC(t.strokeWidth, this.cacheStyleProperties.strokeWidth) || (e = !0, this.cacheStyleProperties.strokeWidth = t.strokeWidth), FC(t.stroke, this.cacheStyleProperties.stroke) || (e = !0, this.cacheStyleProperties.stroke = t.stroke), FC(t.offsets, this.cacheStyleProperties.offsets) || (e = !0, this.cacheStyleProperties.offsets = t.offsets), void 0 === this.dataTexture && (e = !0), e } }, { key: "judgeStyleAttributes", value: function (t) { this.clearLastCalRes(), void 0 === t.opacity || DE(t.opacity) || (this.cellProperties.push({ attr: "opacity", count: 1 }), this.stylePropertyesExist.hasOpacity = 1, this.cellLength += 1), void 0 === t.strokeOpacity || DE(t.strokeOpacity) || (this.cellProperties.push({ attr: "strokeOpacity", count: 1 }), this.stylePropertyesExist.hasStrokeOpacity = 1, this.cellLength += 1), void 0 === t.strokeWidth || DE(t.strokeWidth) || (this.cellProperties.push({ attr: "strokeWidth", count: 1 }), this.stylePropertyesExist.hasStrokeWidth = 1, this.cellLength += 1), void 0 === t.stroke || this.isStaticColor(t.stroke) || (this.cellProperties.push({ attr: "stroke", count: 4 }), this.stylePropertyesExist.hasStroke = 1, this.cellLength += 4), void 0 === t.offsets || this.isOffsetStatic(t.offsets) || (this.cellProperties.push({ attr: "offsets", count: 2 }), this.stylePropertyesExist.hasOffsets = 1, this.cellLength += 2), void 0 === t.thetaOffset || DE(t.thetaOffset) || (this.cellProperties.push({ attr: "thetaOffset", count: 1 }), this.stylePropertyesExist.hasThetaOffset = 1, this.cellLength += 1) } }, { key: "isStaticColor", value: function (t) { return !!Xb(t) && !!sa(t) } }, { key: "getStrokeColor", value: function (t) { if (this.isStaticColor(t)) { var e = xa(t); return e[0] = e[0] ? e[0] : 0, e[1] = e[1] ? e[1] : 0, e[2] = e[2] ? e[2] : 0, e[3] = e[3] ? e[3] : 0, e } return [0, 0, 0, 0] } }, { key: "isOffsetStatic", value: function (t) { return !!(Array.isArray(t) && 2 === t.length && DE(t[0]) && DE(t[1])) } }, { key: "patchMod", value: function (t, e) { for (var n = 0; n < e; n++)t.push(-1) } }, { key: "patchData", value: function (t, e, n) { var r, i = BC(n); try { for (i.s(); !(r = i.n()).done;) { var o = r.value, a = o.attr, s = o.count, l = e[a]; void 0 !== l ? "stroke" === a ? t.push.apply(t, Fd(xa(l))) : "offsets" === a ? this.isOffsetStatic(l) ? t.push(-l[0], l[1]) : t.push(0, 0) : t.push(DE(l) ? l : 1) : this.patchMod(t, s) } } catch (t) { i.e(t) } finally { i.f() } } }, { key: "calDataFrame", value: function (t, e, n) { for (var r = e.length, i = Math.ceil(r * t / this.DATA_TEXTURE_WIDTH), o = i * this.DATA_TEXTURE_WIDTH, a = [], s = 0; s < r; s++) { var l = e[s]; this.patchData(a, l, n) } for (var u = a.length; u < o; u++)a.push(-1); return { data: a, width: this.DATA_TEXTURE_WIDTH, height: i } } }, { key: "getBlend", value: function () { var e = this.layer.getLayerConfig().blend, n = void 0 === e ? "normal" : e; return PE[t.BlendType[n]] } }, { key: "getDefaultStyle", value: function () { return {} } }, { key: "getUninforms", value: function () { throw new Error("Method not implemented.") } }, { key: "getAnimateUniforms", value: function () { return {} } }, { key: "needUpdate", value: function () { return !1 } }, { key: "buildModels", value: function () { throw new Error("Method not implemented.") } }, { key: "initModels", value: function () { throw new Error("Method not implemented.") } }, { key: "clearModels", value: function () { } }, { key: "getAttribute", value: function () { throw new Error("Method not implemented.") } }, { key: "render", value: function () { throw new Error("Method not implemented.") } }, { key: "registerBuiltinAttributes", value: function () { throw new Error("Method not implemented.") } }, { key: "animateOption2Array", value: function (t) { return [t.enable ? 0 : 1, t.duration || 4, t.interval || .2, t.trailLength || .1] } }, { key: "startModelAnimate", value: function () { this.layer.getLayerConfig().animateOption.enable && this.layer.setAnimateStartTime() } }]), e }(), zC = Cf(NC.prototype, "configService", [DC], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), NC), VC = { exports: {} }; function GC(t, e, n) { n = n || 2; var r, i, o, a, s, l, u, c = e && e.length, p = c ? e[0] * n : t.length, h = HC(t, 0, p, n, !0), f = []; if (!h || h.next === h.prev) return f; if (c && (h = function (t, e, n, r) { var i, o, a, s = []; for (i = 0, o = e.length; i < o; i++)(a = HC(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0), s.push(eT(a)); for (s.sort(QC), i = 0; i < s.length; i++)n = WC(n = JC(s[i], n), n.next); return n }(t, e, h, n)), t.length > 80 * n) { r = o = t[0], i = a = t[1]; for (var d = n; d < p; d += n)(s = t[d]) < r && (r = s), (l = t[d + 1]) < i && (i = l), s > o && (o = s), l > a && (a = l); u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0 } return XC(h, f, n, r, i, u), f } function HC(t, e, n, r, i) { var o, a; if (i === dT(t, e, n, r) > 0) for (o = e; o < n; o += r)a = pT(o, t[o], t[o + 1], a); else for (o = n - r; o >= e; o -= r)a = pT(o, t[o], t[o + 1], a); return a && oT(a, a.next) && (hT(a), a = a.next), a } function WC(t, e) { if (!t) return t; e || (e = t); var n, r = t; do { if (n = !1, r.steiner || !oT(r, r.next) && 0 !== iT(r.prev, r, r.next)) r = r.next; else { if (hT(r), (r = e = r.prev) === r.next) break; n = !0 } } while (n || r !== e); return e } function XC(t, e, n, r, i, o, a) { if (t) { !a && o && function (t, e, n, r) { var i = t; do { null === i.z && (i.z = tT(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { var e, n, r, i, o, a, s, l, u = 1; do { for (n = t, t = null, o = null, a = 0; n;) { for (a++, r = n, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++); for (l = u; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; n = r } o.nextZ = null, u *= 2 } while (a > 1) }(i) }(t, r, i, o); for (var s, l, u = t; t.prev !== t.next;)if (s = t.prev, l = t.next, o ? ZC(t, r, i, o) : qC(t)) e.push(s.i / n), e.push(t.i / n), e.push(l.i / n), hT(t), t = l.next, u = l.next; else if ((t = l) === u) { a ? 1 === a ? XC(t = YC(WC(t), e, n), e, n, r, i, o, 2) : 2 === a && KC(t, e, n, r, i, o) : XC(WC(t), e, n, r, i, o, 1); break } } } function qC(t) { var e = t.prev, n = t, r = t.next; if (iT(e, n, r) >= 0) return !1; for (var i = t.next.next; i !== t.prev;) { if (nT(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && iT(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function ZC(t, e, n, r) { var i = t.prev, o = t, a = t.next; if (iT(i, o, a) >= 0) return !1; for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, l = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, u = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, c = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, p = tT(s, l, e, n, r), h = tT(u, c, e, n, r), f = t.prevZ, d = t.nextZ; f && f.z >= p && d && d.z <= h;) { if (f !== t.prev && f !== t.next && nT(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && iT(f.prev, f, f.next) >= 0) return !1; if (f = f.prevZ, d !== t.prev && d !== t.next && nT(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && iT(d.prev, d, d.next) >= 0) return !1; d = d.nextZ } for (; f && f.z >= p;) { if (f !== t.prev && f !== t.next && nT(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && iT(f.prev, f, f.next) >= 0) return !1; f = f.prevZ } for (; d && d.z <= h;) { if (d !== t.prev && d !== t.next && nT(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && iT(d.prev, d, d.next) >= 0) return !1; d = d.nextZ } return !0 } function YC(t, e, n) { var r = t; do { var i = r.prev, o = r.next.next; !oT(i, o) && aT(i, r, r.next, o) && uT(i, o) && uT(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), hT(r), hT(r.next), r = t = o), r = r.next } while (r !== t); return WC(r) } function KC(t, e, n, r, i, o) { var a = t; do { for (var s = a.next.next; s !== a.prev;) { if (a.i !== s.i && rT(a, s)) { var l = cT(a, s); return a = WC(a, a.next), l = WC(l, l.next), XC(a, e, n, r, i, o), void XC(l, e, n, r, i, o) } s = s.next } a = a.next } while (a !== t) } function QC(t, e) { return t.x - e.x } function JC(t, e) { var n = function (t, e) { var n, r = e, i = t.x, o = t.y, a = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= i && s > a) { if (a = s, s === i) { if (o === r.y) return r; if (o === r.next.y) return r.next } n = r.x < r.next.x ? r : r.next } } r = r.next } while (r !== e); if (!n) return null; if (i === a) return n; var l, u = n, c = n.x, p = n.y, h = 1 / 0; r = n; do { i >= r.x && r.x >= c && i !== r.x && nT(o < p ? i : a, o, c, p, o < p ? a : i, o, r.x, r.y) && (l = Math.abs(o - r.y) / (i - r.x), uT(r, t) && (l < h || l === h && (r.x > n.x || r.x === n.x && $C(n, r))) && (n = r, h = l)), r = r.next } while (r !== u); return n }(t, e); if (!n) return e; var r = cT(n, t), i = WC(n, n.next); return WC(r, r.next), e === n ? i : e } function $C(t, e) { return iT(t.prev, t, e.prev) < 0 && iT(e.next, t, t.next) < 0 } function tT(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function eT(t) { var e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function nT(t, e, n, r, i, o, a, s) { return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0 } function rT(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && aT(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (uT(t, e) && uT(e, t) && function (t, e) { var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e) && (iT(t.prev, t, e.prev) || iT(t, e.prev, e)) || oT(t, e) && iT(t.prev, t, t.next) > 0 && iT(e.prev, e, e.next) > 0) } function iT(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function oT(t, e) { return t.x === e.x && t.y === e.y } function aT(t, e, n, r) { var i = lT(iT(t, e, n)), o = lT(iT(t, e, r)), a = lT(iT(n, r, t)), s = lT(iT(n, r, e)); return i !== o && a !== s || (!(0 !== i || !sT(t, n, e)) || (!(0 !== o || !sT(t, r, e)) || (!(0 !== a || !sT(n, t, r)) || !(0 !== s || !sT(n, e, r))))) } function sT(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function lT(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function uT(t, e) { return iT(t.prev, t, t.next) < 0 ? iT(t, e, t.next) >= 0 && iT(t, t.prev, e) >= 0 : iT(t, e, t.prev) < 0 || iT(t, t.next, e) < 0 } function cT(t, e) { var n = new fT(t.i, t.x, t.y), r = new fT(e.i, e.x, e.y), i = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r } function pT(t, e, n, r) { var i = new fT(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function hT(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function fT(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function dT(t, e, n, r) { for (var i = 0, o = e, a = n - r; o < n; o += r)i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return i } VC.exports = GC, VC.exports.default = GC, GC.deviation = function (t, e, n, r) { var i = e && e.length, o = i ? e[0] * n : t.length, a = Math.abs(dT(t, 0, o, n)); if (i) for (var s = 0, l = e.length; s < l; s++) { var u = e[s] * n, c = s < l - 1 ? e[s + 1] * n : t.length; a -= Math.abs(dT(t, u, c, n)) } var p = 0; for (s = 0; s < r.length; s += 3) { var h = r[s] * n, f = r[s + 1] * n, d = r[s + 2] * n; p += Math.abs((t[h] - t[d]) * (t[f + 1] - t[h + 1]) - (t[h] - t[f]) * (t[d + 1] - t[h + 1])) } return 0 === a && 0 === p ? 0 : Math.abs((p - a) / a) }, GC.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var a = 0; a < e; a++)n.vertices.push(t[i][o][a]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n }; var mT = VC.exports; function vT(t) { return t / 180 * Math.acos(-1) } function yT(t) { var e = vT(t[0]) + Math.PI / 2, n = vT(t[1]), r = 100 + .4 * Math.random(), i = r * Math.cos(n) * Math.cos(e); return [r * Math.cos(n) * Math.sin(e), r * Math.sin(n), i] } var gT = nl(); nl(); var _T = nl(), xT = nl(), bT = nl(); function wT(t, e, n, r, i) { return ol(t, n, r), sl(t, t), [i / ll(e = rl(-t[1], t[0]), rl(-n[1], n[0])), e] } function ST(t, e) { return function (t, e, n) { return t[0] = e, t[1] = n, t }(t, -e[1], e[0]) } function ET(t, e, n) { return pl(t, e, n), sl(t, t), t } function CT(t, e) { return t[0] === e[0] && t[1] === e[1] } var TT, AT, MT, OT = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; Ar(this, t), kr(this, "complex", void 0), kr(this, "join", void 0), kr(this, "cap", void 0), kr(this, "miterLimit", void 0), kr(this, "thickness", void 0), kr(this, "normal", void 0), kr(this, "lastFlip", -1), kr(this, "miter", rl(0, 0)), kr(this, "started", !1), kr(this, "dash", !1), kr(this, "totalDistance", 0), kr(this, "currentIndex", 0), this.join = e.join || "miter", this.cap = e.cap || "butt", this.miterLimit = e.miterLimit || 10, this.thickness = e.thickness || 1, this.dash = e.dash || !1, this.complex = { positions: [], indices: [], normals: [], startIndex: 0, indexes: [] } } return Or(t, [{ key: "extrude_gaode2", value: function (t, e) { var n = this.complex; if (t.length <= 1) return n; this.lastFlip = -1, this.started = !1, this.normal = null, this.totalDistance = 0; for (var r = t.length, i = n.startIndex, o = 1; o < r; o++) { var a, s, l, u = t[o - 1]; u.push(null !== (a = e[o - 1][2]) && void 0 !== a ? a : 0); var c = e[o - 1], p = t[o]; p.push(null !== (s = e[o][2]) && void 0 !== s ? s : 0); var h = e[o], f = o < t.length - 1 ? [].concat(Fd(t[o + 1]), [null !== (l = e[o + 1][2]) && void 0 !== l ? l : 0]) : null, d = o < e.length - 1 ? e[o + 1] : null; i += this.segment_gaode2(n, i, u, p, f, c, h, d) } if (this.dash) for (var m = 0; m < n.positions.length / 6; m++)n.positions[6 * m + 5] = this.totalDistance; return n.startIndex = n.positions.length / 6, n } }, { key: "simpleExtrude_gaode2", value: function (t, e) { var n = this.complex; if (t.length <= 1) return n; this.lastFlip = -1, this.started = !1, this.normal = null, this.totalDistance = 0; for (var r = t.length, i = n.startIndex, o = 1; o < r; o++) { var a, s, l, u = t[o - 1]; u.push(null !== (a = e[o - 1][2]) && void 0 !== a ? a : 0); var c = e[o - 1], p = t[o]; p.push(null !== (s = e[o][2]) && void 0 !== s ? s : 0); var h = e[o], f = o < t.length - 1 ? [].concat(Fd(t[o + 1]), [null !== (l = e[o + 1][2]) && void 0 !== l ? l : 0]) : null, d = o < e.length - 1 ? e[o + 1] : null; i += this.simpleSegment(n, i, u, p, f, c, h, d) } if (this.dash) for (var m = 0; m < n.positions.length / 6; m++)n.positions[6 * m + 5] = this.totalDistance; return n.startIndex = n.positions.length / 6, n } }, { key: "extrude", value: function (t) { var e = this.complex; if (t.length <= 1) return e; this.lastFlip = -1, this.started = !1, this.normal = null, this.totalDistance = 0; for (var n = t.length, r = e.startIndex, i = 1; i < n; i++) { var o = t[i - 1], a = t[i], s = i < t.length - 1 ? t[i + 1] : null; r += this.segment(e, r, o, a, s) } if (this.dash) for (var l = 0; l < e.positions.length / 6; l++)e.positions[6 * l + 5] = this.totalDistance; return e.startIndex = e.positions.length / 6, e } }, { key: "simpleExtrude", value: function (t) { var e = this.complex; if (t.length <= 1) return e; this.lastFlip = -1, this.started = !1, this.normal = null, this.totalDistance = 0; for (var n = t.length, r = e.startIndex, i = 1; i < n; i++) { var o = t[i - 1], a = t[i], s = i < t.length - 1 ? t[i + 1] : null; r += this.simpleSegment(e, r, o, a, s) } if (this.dash) for (var l = 0; l < e.positions.length / 6; l++)e.positions[6 * l + 5] = this.totalDistance; return e.startIndex = e.positions.length / 6, e } }, { key: "segment_gaode2", value: function (t, e, n, r, i, o, a, s) { var l = 0, u = t.indices, c = t.positions, p = t.normals, h = "square" === this.cap, f = "bevel" === this.join, d = Do([a[0], a[1]]), m = Do([o[0], o[1]]); ET(_T, r, n); var v = 0; if (this.dash && (v = this.lineSegmentDistance(d, m), this.totalDistance += v), this.normal || (this.normal = nl(), ST(this.normal, _T)), !this.started) if (this.started = !0, h) { var y = nl(), g = nl(); ol(y, this.normal, _T), ol(g, this.normal, _T), p.push(g[0], g[1], 0), p.push(y[0], y[1], 0), c.push(n[0], n[1], 0 | n[2], this.totalDistance - v, -this.thickness, 0 | n[2]), this.complex.indexes.push(this.currentIndex), c.push(n[0], n[1], 0 | n[2], this.totalDistance - v, this.thickness, 0 | n[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++ } else this.extrusions(c, p, n, this.normal, this.thickness, this.totalDistance - v); if (u.push(e + 0, e + 1, e + 2), i) { CT(r, i) && ol(i, r, sl(i, al(i, r, n))), ET(xT, i, r); var _ = Lr(wT(bT, nl(), _T, xT, this.thickness), 2), x = _[0], b = _[1], w = ll(bT, this.normal) < 0 ? -1 : 1, S = f; if (!S && "miter" === this.join) x > this.miterLimit && (S = !0); S ? (p.push(this.normal[0], this.normal[1], 0), p.push(b[0], b[1], 0), c.push(r[0], r[1], 0 | r[2], this.totalDistance, -this.thickness * w, 0 | r[2]), this.complex.indexes.push(this.currentIndex), c.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness * w, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++, u.push.apply(u, Fd(this.lastFlip !== -w ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), u.push(e + 2, e + 3, e + 4), ST(gT, xT), il(this.normal, gT), p.push(this.normal[0], this.normal[1], 0), c.push(r[0], r[1], 0 | r[2], this.totalDistance, -this.thickness * w, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++, l += 3) : (this.extrusions(c, p, r, b, x, this.totalDistance), u.push.apply(u, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), w = -1, il(this.normal, b), l += 2), this.lastFlip = w } else { if (ST(this.normal, _T), h) { var E = nl(), C = nl(); pl(C, _T, this.normal), ol(E, _T, this.normal), p.push(C[0], C[1], 0), p.push(E[0], E[1], 0), c.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness, 0 | r[2]), this.complex.indexes.push(this.currentIndex), c.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++ } else this.extrusions(c, p, r, this.normal, this.thickness, this.totalDistance); u.push.apply(u, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), l += 2 } return l } }, { key: "simpleSegment", value: function (t, e, n, r, i) { var o = 0, a = t.indices, s = t.positions, l = t.normals, u = Do([r[0], r[1]]), c = Do([n[0], n[1]]); ET(_T, u, c); var p = 0; if (this.dash && (p = this.lineSegmentDistance(u, c), this.totalDistance += p), this.normal || (this.normal = nl(), ST(this.normal, _T)), this.started || (this.started = !0, this.extrusions(s, l, n, this.normal, this.thickness, this.totalDistance - p)), a.push(e + 0, e + 1, e + 2), i) { var h = Do([i[0], i[1]]); CT(u, h) && ol(h, u, sl(h, al(h, u, c))), ET(xT, h, u); var f = Lr(wT(bT, nl(), _T, xT, this.thickness), 2), d = f[0], m = f[1]; ll(bT, this.normal); this.extrusions(s, l, r, m, d, this.totalDistance), a.push.apply(a, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), -1, il(this.normal, m), o += 2, this.lastFlip = -1 } else ST(this.normal, _T), this.extrusions(s, l, r, this.normal, this.thickness, this.totalDistance), a.push.apply(a, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), o += 2; return o } }, { key: "segment", value: function (t, e, n, r, i) { var o = 0, a = t.indices, s = t.positions, l = t.normals, u = "square" === this.cap, c = "bevel" === this.join, p = Do([r[0], r[1]]), h = Do([n[0], n[1]]); ET(_T, p, h); var f = 0; if (this.dash && (f = this.lineSegmentDistance(p, h), this.totalDistance += f), this.normal || (this.normal = nl(), ST(this.normal, _T)), !this.started) if (this.started = !0, u) { var d = nl(), m = nl(); ol(d, this.normal, _T), ol(m, this.normal, _T), l.push(m[0], m[1], 0), l.push(d[0], d[1], 0), s.push(n[0], n[1], 0 | n[2], this.totalDistance - f, -this.thickness, 0 | n[2]), this.complex.indexes.push(this.currentIndex), s.push(n[0], n[1], 0 | n[2], this.totalDistance - f, this.thickness, 0 | n[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++ } else this.extrusions(s, l, n, this.normal, this.thickness, this.totalDistance - f); if (a.push(e + 0, e + 1, e + 2), i) { var v = Do([i[0], i[1]]); CT(p, v) && ol(v, p, sl(v, al(v, p, h))), ET(xT, v, p); var y = Lr(wT(bT, nl(), _T, xT, this.thickness), 2), g = y[0], _ = y[1], x = ll(bT, this.normal) < 0 ? -1 : 1, b = c; if (!b && "miter" === this.join) g > this.miterLimit && (b = !0); b ? (l.push(this.normal[0], this.normal[1], 0), l.push(_[0], _[1], 0), s.push(r[0], r[1], 0 | r[2], this.totalDistance, -this.thickness * x, 0 | r[2]), this.complex.indexes.push(this.currentIndex), s.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness * x, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++, a.push.apply(a, Fd(this.lastFlip !== -x ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), a.push(e + 2, e + 3, e + 4), ST(gT, xT), il(this.normal, gT), l.push(this.normal[0], this.normal[1], 0), s.push(r[0], r[1], 0 | r[2], this.totalDistance, -this.thickness * x, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++, o += 3) : (this.extrusions(s, l, r, _, g, this.totalDistance), a.push.apply(a, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), x = -1, il(this.normal, _), o += 2), this.lastFlip = x } else { if (ST(this.normal, _T), u) { var w = nl(), S = nl(); pl(S, _T, this.normal), ol(w, _T, this.normal), l.push(S[0], S[1], 0), l.push(w[0], w[1], 0), s.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness, 0 | r[2]), this.complex.indexes.push(this.currentIndex), s.push(r[0], r[1], 0 | r[2], this.totalDistance, this.thickness, 0 | r[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++ } else this.extrusions(s, l, r, this.normal, this.thickness, this.totalDistance); a.push.apply(a, Fd(1 === this.lastFlip ? [e, e + 2, e + 3] : [e + 2, e + 1, e + 3])), o += 2 } return o } }, { key: "extrusions", value: function (t, e, n, r, i, o) { e.push(r[0], r[1], 0), e.push(r[0], r[1], 0), t.push(n[0], n[1], 0 | n[2], o, -i, 0 | n[2]), this.complex.indexes.push(this.currentIndex), t.push(n[0], n[1], 0 | n[2], o, i, 0 | n[2]), this.complex.indexes.push(this.currentIndex), this.currentIndex++ } }, { key: "lineSegmentDistance", value: function (t, e) { var n = e[0] - t[0], r = e[1] - t[1]; return Math.sqrt(n * n + r * r) } }]), t }(); function kT(t) { if (DE(t[0])) return t; if (DE(t[0][0])) throw new Error("当前数据不支持标注"); if (DE(t[0][0][0])) { var e = 0, n = 0, r = 0; return t.forEach((function (t) { t.forEach((function (t) { e += t[0], n += t[1], r++ })) })), [e / r, n / r, 0] } throw new Error("当前数据不支持标注") } function IT(t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = t[0][0], r = t[0][t[0].length - 1]; n[0] === r[0] && n[1] === r[1] && (t[0] = t[0].slice(0, t[0].length - 1)); for (var i = t[0].length, o = mT.flatten(t), a = o.vertices, s = o.dimensions, l = [], u = [], c = [], p = 0; p < a.length / s; p++)2 === s ? l.push(a[2 * p], a[2 * p + 1], 1, -1, -1) : l.push(a[3 * p], a[3 * p + 1], 1, -1, -1), c.push(0, 0, 1); var h = mT(o.vertices, o.holes, o.dimensions); u.push.apply(u, Fd(h)); for (var f = function (t) { var n = o.vertices.slice(t * s, (t + 1) * s), r = o.vertices.slice((t + 1) * s, (t + 2) * s); 0 === r.length && (r = o.vertices.slice(0, s)); var i = l.length / 5; l.push(n[0], n[1], 1, 0, 0, r[0], r[1], 1, .1, 0, n[0], n[1], 0, 0, .8, r[0], r[1], 0, .1, .8); var a = PT([r[0], r[1], 1], [n[0], n[1], 0], [n[0], n[1], 1], e); c.push.apply(c, Fd(a).concat(Fd(a), Fd(a), Fd(a))), u.push.apply(u, Fd([1, 2, 0, 3, 2, 1].map((function (t) { return t + i })))) }, d = 0; d < i; d++)f(d); return { positions: l, index: u, normals: c } } function PT(t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i = Os(), o = Os(), a = Os(); r && (t = Lo(t), e = Lo(e), n = Lo(n)); var s = Is.apply($s, Fd(t)), l = Is.apply($s, Fd(e)), u = Is.apply($s, Fd(n)); Ws(i, u, l), Ws(o, s, l), Us(a, i, o); var c = Os(); return Bs(c, a), c } function LT(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = 2 * Math.PI / t, r = [], i = 0; i < t; i++)r.push(n * i + e * Math.PI / 12); var o = r.map((function (t) { return [Math.sin(t + Math.PI / 4), Math.cos(t + Math.PI / 4), 0] })); return o } function RT() { return LT(30) } function DT() { return LT(4) } function NT() { return LT(3) } function zT() { return LT(6, 1) } function FT() { return LT(5) } !function (t) { t.CYLINDER = "cylinder", t.SQUARECOLUMN = "squareColumn", t.TRIANGLECOLUMN = "triangleColumn", t.HEXAGONCOLUMN = "hexagonColumn", t.PENTAGONCOLUMN = "pentagonColumn" }(AT || (AT = {})), function (t) { t.CIRCLE = "circle", t.SQUARE = "square", t.TRIANGLE = "triangle", t.HEXAGON = "hexagon", t.PENTAGON = "pentagon" }(MT || (MT = {})); var BT, jT, UT, VT = (kr(TT = {}, MT.CIRCLE, RT), kr(TT, MT.HEXAGON, zT), kr(TT, MT.TRIANGLE, NT), kr(TT, MT.SQUARE, DT), kr(TT, MT.PENTAGON, FT), kr(TT, AT.CYLINDER, RT), kr(TT, AT.HEXAGONCOLUMN, zT), kr(TT, AT.TRIANGLECOLUMN, NT), kr(TT, AT.SQUARECOLUMN, DT), kr(TT, AT.PENTAGONCOLUMN, FT), TT), GT = {}; function HT(t) { var e = kT(t.coordinates); return { vertices: [].concat(Fd(e), Fd(e), Fd(e), Fd(e)), indices: [0, 1, 2, 2, 3, 0], size: e.length } } function WT(t) { var e = yT(kT(t.coordinates)); return { vertices: [].concat(Fd(e), Fd(e), Fd(e), Fd(e)), indices: [0, 1, 2, 2, 3, 0], size: e.length } } function XT(t) { var e = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (GT && GT[t]) return GT[t]; var n = IT([VT[t] ? VT[t]() : VT.cylinder()], e); return GT[t] = n, n }(t.shape, !1); return { vertices: e.positions, indices: e.index, normals: e.normals, size: 5 } } function qT(t) { var e = kT(t.coordinates); return { vertices: Fd(e), indices: [0], size: e.length } } function ZT(t) { var e = t.coordinates, n = t.originCoordinates, r = t.version, i = new OT({ dash: !0, join: "bevel" }); if ("GAODE2.x" === r) { var o = e; Array.isArray(o[0][0]) || (o = [e]); var a = n; Array.isArray(a[0][0]) || (a = [n]); for (var s = 0; s < o.length; s++) { var l = o[s], u = a[s]; i.extrude_gaode2(l, u) } } else { var c = e; c[0] && !Array.isArray(c[0][0]) && (c = [e]), c.forEach((function (t) { i.extrude(t) })) } var p = i.complex; return { vertices: p.positions, indices: p.indices, normals: p.normals, indexes: p.indexes, size: 6 } } function YT(t) { var e = t.coordinates, n = t.originCoordinates, r = t.version, i = new OT({ dash: !0, join: "bevel" }); if ("GAODE2.x" === r) { var o = e; Array.isArray(o[0][0]) || (o = [e]); var a = n; Array.isArray(a[0][0]) || (a = [n]); for (var s = 0; s < o.length; s++) { var l = o[s], u = a[s]; i.simpleExtrude_gaode2(l, u) } } else { var c = e; c[0] && !Array.isArray(c[0][0]) && (c = [e]), c.forEach((function (t) { i.simpleExtrude(t) })) } var p = i.complex; return { vertices: p.positions, indices: p.indices, normals: p.normals, size: 6 } } function KT(t) { var e = t.coordinates, n = mT.flatten(e), r = n.vertices, i = n.dimensions, o = n.holes; return { indices: mT(r, o, i), vertices: r, size: i } } function QT(t) { var e = t.coordinates, n = mT.flatten(e), r = n.vertices, i = n.dimensions, o = n.holes; return { indices: mT(r, o, i), vertices: JT(r), size: i + 4 } } function JT(t) { for (var e = [], n = function (t) { for (var e = t[0], n = t[1], r = t[0], i = t[1], o = 0, a = 0, s = 0, l = 0; l < t.length; l += 2) { var u = t[l], c = t[l + 1]; u && c && (e = Math.max(u, e), n = Math.max(c, n), r = Math.min(u, r), i = Math.min(c, i), o += u, a += c, s++) } return { center: [o / s, a / s], radius: Math.sqrt(Math.pow(e - r, 2) + Math.pow(n - i, 2)) / 2 } }(t), r = n.center, i = n.radius, o = 0; o < t.length; o += 2) { var a = t[o], s = t[o + 1]; e.push.apply(e, [a, s, 0].concat(Fd(r), [i])) } return e } function $T(t) { var e = IT(t.coordinates, !0); return { vertices: e.positions, indices: e.index, normals: e.normals, size: 5 } } function tA(t) { var e = function (t) { var e = ["cylinder", "triangleColumn", "hexagonColumn", "squareColumn"], n = VT[t] ? VT[t]() : VT.circle(); return -1 === e.indexOf(t) ? (r = [n], i = mT.flatten(r), o = mT(i.vertices, i.holes, i.dimensions), { positions: i.vertices, index: o }) : function (t) { var e = t[0][0], n = t[0][t[0].length - 1]; e[0] === n[0] && e[1] === n[1] && (t[0] = t[0].slice(0, t[0].length - 1)); for (var r = t[0].length, i = mT.flatten(t), o = i.vertices, a = i.dimensions, s = [], l = [], u = 0; u < o.length / a; u++)2 === a ? s.push(o[2 * u], o[2 * u + 1], 1) : s.push(o[3 * u], o[3 * u + 1], 1); var c = mT(i.vertices, i.holes, i.dimensions); l.push.apply(l, Fd(c)); for (var p = function (t) { var e = i.vertices.slice(t * a, (t + 1) * a), n = i.vertices.slice((t + 1) * a, (t + 2) * a); 0 === n.length && (n = i.vertices.slice(0, a)); var r = s.length / 3; s.push(e[0], e[1], 1, n[0], n[1], 1, e[0], e[1], 0, n[0], n[1], 0), l.push.apply(l, Fd([0, 2, 1, 2, 3, 1].map((function (t) { return t + r })))) }, h = 0; h < r; h++)p(h); return { positions: s, index: l } }([n]); var r, i, o }(t.shape); return { vertices: e.positions, indices: e.index, size: 3 } } function eA(t, e) { for (var n = e || 30, r = t.coordinates, i = [], o = [], a = function (t) { i.push(t, 1, t, r[0][0], r[0][1], r[1][0], r[1][1], t, -1, t, r[0][0], r[0][1], r[1][0], r[1][1]), t !== n - 1 && o.push.apply(o, Fd([0, 1, 2, 1, 3, 2].map((function (e) { return 2 * t + e })))) }, s = 0; s < n; s++)a(s); return { vertices: i, indices: o, size: 7 } } function nA(t) { var e = t.coordinates; 2 === e.length && e.push(0), t.size; var n = rA(-1, 1), r = rA(1, 1), i = rA(-1, -1), o = rA(1, -1); return { vertices: [].concat(Fd(e), Fd(n), Fd(e), Fd(i), Fd(e), Fd(o), Fd(e), Fd(r)), indices: [0, 1, 2, 3, 0, 2], size: 5 } } function rA(t, e) { return [(t + 1) / 2, (e + 1) / 2] } function iA(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function oA(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? iA(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : iA(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var aA = (BT = Ex(Tr.IGlobalConfigService), jT = function () { function t(e) { Ar(this, t), Ef(this, "configService", UT, this), kr(this, "config", void 0), this.config = e } return Or(t, [{ key: "setContainer", value: function (t, e, n, r) { t.bind(Tr.MapConfig).toConstantValue(oA(oA({}, this.config), {}, { id: e, canvas: n, hasBaseMap: r })), t.bind(Tr.IMapService).to(this.getServiceConstructor()).inSingletonScope() } }, { key: "getServiceConstructor", value: function () { throw new Error("Method not implemented.") } }]), t }(), UT = Cf(jT.prototype, "configService", [BT], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), jT), sA = { exports: {} }; !function (t, e) { t.exports = function () { function t(t) { var r = []; return t.AMapUI && r.push(e(t.AMapUI)), t.Loca && r.push(n(t.Loca)), Promise.all(r) } function e(t) { return new Promise((function (e, n) { var i = []; if (t.plugins) for (var l = 0; l < t.plugins.length; l += 1)-1 == o.AMapUI.plugins.indexOf(t.plugins[l]) && i.push(t.plugins[l]); if (a.AMapUI === r.failed) n("前次请求 AMapUI 失败"); else if (a.AMapUI === r.notload) { a.AMapUI = r.loading, o.AMapUI.version = t.version || o.AMapUI.version, l = o.AMapUI.version; var u = document.body || document.head, c = document.createElement("script"); c.type = "text/javascript", c.src = "https://webapi.amap.com/ui/" + l + "/main.js", c.onerror = function (t) { a.AMapUI = r.failed, n("请求 AMapUI 失败") }, c.onload = function () { if (a.AMapUI = r.loaded, i.length) window.AMapUI.loadUI(i, (function () { for (var t = 0, n = i.length; t < n; t++) { var r = i[t].split("/").slice(-1)[0]; window.AMapUI[r] = arguments[t] } for (e(); s.AMapUI.length;)s.AMapUI.splice(0, 1)[0]() })); else for (e(); s.AMapUI.length;)s.AMapUI.splice(0, 1)[0]() }, u.appendChild(c) } else a.AMapUI === r.loaded ? t.version && t.version !== o.AMapUI.version ? n("不允许多个版本 AMapUI 混用") : i.length ? window.AMapUI.loadUI(i, (function () { for (var t = 0, n = i.length; t < n; t++) { var r = i[t].split("/").slice(-1)[0]; window.AMapUI[r] = arguments[t] } e() })) : e() : t.version && t.version !== o.AMapUI.version ? n("不允许多个版本 AMapUI 混用") : s.AMapUI.push((function (t) { t ? n(t) : i.length ? window.AMapUI.loadUI(i, (function () { for (var t = 0, n = i.length; t < n; t++) { var r = i[t].split("/").slice(-1)[0]; window.AMapUI[r] = arguments[t] } e() })) : e() })) })) } function n(t) { return new Promise((function (e, n) { if (o.AMap.version.startsWith("2.0")) n("Loca 暂不适配 JSAPI 2.0,请使用 1.4.15"); else if (a.Loca === r.failed) n("前次请求 Loca 失败"); else if (a.Loca === r.notload) { a.Loca = r.loading, o.Loca.version = t.version || o.Loca.version; var i = o.Loca.version, l = o.key, u = document.body || document.head, c = document.createElement("script"); c.type = "text/javascript", c.src = "https://webapi.amap.com/loca?v=" + i + "&key=" + l, c.onerror = function (t) { a.Loca = r.failed, n("请求 AMapUI 失败") }, c.onload = function () { for (a.Loca = r.loaded, e(); s.Loca.length;)s.Loca.splice(0, 1)[0]() }, u.appendChild(c) } else a.Loca === r.loaded ? t.version && t.version !== o.Loca.version ? n("不允许多个版本 Loca 混用") : e() : t.version && t.version !== o.Loca.version ? n("不允许多个版本 Loca 混用") : s.Loca.push((function (t) { t ? n(t) : n() })) })) } if (!window) throw Error("AMap JSAPI can only be used in Browser."); var r, i; (i = r || (r = {})).notload = "notload", i.loading = "loading", i.loaded = "loaded", i.failed = "failed"; var o = { key: "", AMap: { version: "1.4.15", plugins: [] }, AMapUI: { version: "1.1", plugins: [] }, Loca: { version: "1.3.2" } }, a = { AMap: r.notload, AMapUI: r.notload, Loca: r.notload }, s = { AMap: [], AMapUI: [], Loca: [] }, l = [], u = function (t) { "function" == typeof t && (a.AMap === r.loaded ? t(window.AMap) : l.push(t)) }; return { load: function (e) { return new Promise((function (n, i) { if (a.AMap == r.failed) i(""); else if (a.AMap == r.notload) { var s = e.key, c = e.version, p = e.plugins; s ? (window.AMap && "lbs.amap.com" !== location.host && i("禁止多种API加载方式混用"), o.key = s, o.AMap.version = c || o.AMap.version, o.AMap.plugins = p || o.AMap.plugins, a.AMap = r.loading, c = document.body || document.head, window.___onAPILoaded = function (o) { if (delete window.___onAPILoaded, o) a.AMap = r.failed, i(o); else for (a.AMap = r.loaded, t(e).then((function () { n(window.AMap) })).catch(i); l.length;)l.splice(0, 1)[0]() }, (p = document.createElement("script")).type = "text/javascript", p.src = "https://webapi.amap.com/maps?callback=___onAPILoaded&v=" + o.AMap.version + "&key=" + s + "&plugin=" + o.AMap.plugins.join(","), p.onerror = function (t) { a.AMap = r.failed, i(t) }, c.appendChild(p)) : i("请填写key") } else if (a.AMap == r.loaded) if (e.key && e.key !== o.key) i("多个不一致的 key"); else if (e.version && e.version !== o.AMap.version) i("不允许多个版本 JSAPI 混用"); else { if (s = [], e.plugins) for (c = 0; c < e.plugins.length; c += 1)-1 == o.AMap.plugins.indexOf(e.plugins[c]) && s.push(e.plugins[c]); s.length ? window.AMap.plugin(s, (function () { t(e).then((function () { n(window.AMap) })).catch(i) })) : t(e).then((function () { n(window.AMap) })).catch(i) } else if (e.key && e.key !== o.key) i("多个不一致的 key"); else if (e.version && e.version !== o.AMap.version) i("不允许多个版本 JSAPI 混用"); else { var h = []; if (e.plugins) for (c = 0; c < e.plugins.length; c += 1)-1 == o.AMap.plugins.indexOf(e.plugins[c]) && h.push(e.plugins[c]); u((function () { h.length ? window.AMap.plugin(h, (function () { t(e).then((function () { n(window.AMap) })).catch(i) })) : t(e).then((function () { n(window.AMap) })).catch(i) })) } })) }, reset: function () { delete window.AMap, delete window.AMapUI, delete window.Loca, o = { key: "", AMap: { version: "1.4.15", plugins: [] }, AMapUI: { version: "1.1", plugins: [] }, Loca: { version: "1.3.2" } }, a = { AMap: r.notload, AMapUI: r.notload, Loca: r.notload }, s = { AMap: [], AMapUI: [], Loca: [] } } } }() }(sA); var lA, uA = sA.exports, cA = function () { function t(e) { Ar(this, t), kr(this, "size", 1e4), this.size = e || 1e4 } return Or(t, [{ key: "setSize", value: function (t) { this.size = t } }, { key: "getSize", value: function () { return [this.size, this.size] } }, { key: "mercatorXfromLng", value: function (t) { return (180 + t) / 360 * this.size } }, { key: "mercatorYfromLat", value: function (t) { return (1 - (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360) * this.size } }, { key: "lngFromMercatorX", value: function (t) { return t / this.size * 360 - 180 } }, { key: "latFromMercatorY", value: function (t) { var e = 180 - 360 * (1 - t / this.size); return 360 / Math.PI * Math.atan(Math.exp(e * Math.PI / 180)) - 90 } }, { key: "project", value: function (t) { return [this.mercatorXfromLng(t[0]), this.mercatorYfromLat(t[1])] } }, { key: "unproject", value: function (t) { return [this.lngFromMercatorX(t[0]), this.latFromMercatorY(t[1])] } }]), t }(); function pA(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function hA(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? pA(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : pA(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function fA() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = { top: 0, right: 0, bottom: 0, left: 0 }; if ("number" == typeof t) return { top: t, right: t, bottom: t, left: t }; if (Array.isArray(t)) { if (4 === t.length) return { top: t[0], right: t[1], bottom: t[2], left: t[3] }; if (2 === t.length) return { top: t[0], right: t[1], bottom: t[0], left: t[1] } } return hA(hA({}, e), t) } !function (t) { t["GAODE1.x"] = "GAODE1.x", t["GAODE2.x"] = "GAODE2.x", t.MAPBOX = "MAPBOX", t.L7MAP = "L7MAP", t.SIMPLE = "SIMPLE", t.GLOBEL = "GLOBEL" }(lA || (lA = {})); var dA, mA, vA, yA, gA, _A, xA, bA, wA, SA, EA, CA = { dark: "amap://styles/2a09079c3daac9420ee53b67307a8006?isPublic=true", light: "amap://styles/1fd9f8ef9751298f11f5c56968312c70?isPublic=true", normal: "amap://styles/normal", blank: "amap://styles/07c17002b38775b32a7a76c66cf90e99?isPublic=true" }, TA = Math.PI / 180, AA = function () { function t() { Ar(this, t), kr(this, "projectionMatrix", os()), kr(this, "viewMatrix", os()), kr(this, "viewProjectionMatrix", os()), kr(this, "ViewProjectionMatrixUncentered", os()), kr(this, "viewUncenteredMatrix", os()), kr(this, "zoom", void 0), kr(this, "center", void 0) } return Or(t, [{ key: "syncWithMapCamera", value: function (t) { var e = t.zoom, n = void 0 === e ? 1 : e, r = t.pitch, i = void 0 === r ? 0 : r, o = t.bearing, a = void 0 === o ? 0 : o, s = t.center, l = void 0 === s ? [0, 0] : s, u = t.offsetOrigin, c = void 0 === u ? [0, 0] : u, p = t.cameraHeight, h = void 0 === p ? 1 : p, f = t.aspect, d = void 0 === f ? 1 : f, m = t.near, v = void 0 === m ? .1 : m, y = t.far, g = void 0 === y ? 1e3 : y, _ = t.fov, x = void 0 === _ ? 0 : _; this.zoom = n, this.center = l; var b = i * TA, w = (360 - a) * TA; xs(this.projectionMatrix, x, d, v, g); var S = Is(h * Math.sin(b) * Math.sin(w), -h * Math.sin(b) * Math.cos(w), h * Math.cos(b)), E = Is(-Math.cos(b) * Math.sin(w), Math.cos(b) * Math.cos(w), Math.sin(b)); Ss(this.viewMatrix, S, Is(0, 0, 0), E), this.viewUncenteredMatrix = as(this.viewMatrix), ps(this.viewMatrix, this.viewMatrix, Is(-c[0], c[1], 0)), cs(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix), cs(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix) } }, { key: "getZoom", value: function () { return this.zoom } }, { key: "getZoomScale", value: function () { return 524288 } }, { key: "getCenter", value: function () { var t = Lr(this.center, 2); return [t[0], t[1]] } }, { key: "getProjectionMatrix", value: function () { return this.projectionMatrix } }, { key: "getModelMatrix", value: function () { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } }, { key: "getViewMatrix", value: function () { return this.viewMatrix } }, { key: "getViewMatrixUncentered", value: function () { return this.viewUncenteredMatrix } }, { key: "getViewProjectionMatrix", value: function () { return this.viewProjectionMatrix } }, { key: "getViewProjectionMatrixUncentered", value: function () { return this.ViewProjectionMatrixUncentered } }, { key: "getFocalDistance", value: function () { return 1 } }, { key: "projectFlat", value: function (t, e) { var n = 85.0511287798, r = Math.max(Math.min(n, t[1]), -n), i = 256 << 20, o = Math.PI / 180, a = t[0] * o, s = r * o; s = Math.log(Math.tan(Math.PI / 4 + s / 2)); return [a = i * (.5 / Math.PI * a + .5) - 215440491, s = -(i * (-.5 / Math.PI * s + (o = .5)) - 106744817)] } }]), t }(), MA = ["id", "style", "minZoom", "maxZoom", "token", "mapInstance", "plugin"]; function OA(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function kA(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? OA(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : OA(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } !function (t, e) { var n = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, r = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram); if (!n && !r && (e || (e = document), e)) { var i = e.head || e.getElementsByTagName("head")[0]; if (!i) { i = e.createElement("head"); var o = e.body || e.getElementsByTagName("body")[0]; o ? o.parentNode.insertBefore(i, o) : e.documentElement.appendChild(i) } var a = e.createElement("style"); a.type = "text/css", a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), i.appendChild(a) } }(".amap-logo{\n display: none !important;\n}\n"); var IA = 0; window.forceWebGL = !0; var PA = "15cd8a57710d40c9b7c0e3cc120f1200", LA = !1, RA = [], DA = (dA = ut.injectable(), mA = ut.inject(Tr.IGlobalConfigService), vA = ut.inject(Tr.MapConfig), yA = ut.inject(Tr.ICoordinateSystemService), gA = ut.inject(Tr.IEventEmitter), dA((xA = function () { function t() { var e = this; Ar(this, t), kr(this, "version", lA["GAODE1.x"]), kr(this, "simpleMapCoord", new cA), kr(this, "map", void 0), kr(this, "bgColor", "rgba(0, 0, 0, 0)"), Ef(this, "configService", bA, this), Ef(this, "config", wA, this), Ef(this, "coordinateSystemService", SA, this), Ef(this, "eventEmitter", EA, this), kr(this, "markerContainer", void 0), kr(this, "$mapContainer", void 0), kr(this, "viewport", void 0), kr(this, "cameraChangedCallback", void 0), kr(this, "handleCameraChanged", (function (t) { var n = t.camera, r = n.fov, i = n.near, o = n.far, a = n.height, s = n.pitch, l = n.rotation, u = n.aspect, c = n.position, p = e.getCenter(), h = p.lng, f = p.lat; if (e.emit("mapchange"), e.cameraChangedCallback) { e.viewport.syncWithMapCamera({ aspect: u, bearing: 360 - l, far: o, fov: r, cameraHeight: a, near: i, pitch: s, zoom: e.map.getZoom() - 1, center: [h, f], offsetOrigin: [c.x, c.y] }); var d = e.config.offsetZoom, m = void 0 === d ? 12 : d; e.viewport.getZoom() > m ? e.coordinateSystemService.setCoordinateSystem(Tf.P20_OFFSET) : e.coordinateSystemService.setCoordinateSystem(Tf.P20), e.cameraChangedCallback(e.viewport) } })) } var e; return Or(t, [{ key: "setBgColor", value: function (t) { this.bgColor = t } }, { key: "addMarkerContainer", value: function () { var t = this.map.getContainer(); if (null !== t) { var e = t.getElementsByClassName("amap-maps")[0]; this.markerContainer = lo("div", "l7-marker-container", e) } } }, { key: "getMarkerContainer", value: function () { return this.markerContainer } }, { key: "on", value: function (t, e) { -1 !== Mx.indexOf(t) ? this.eventEmitter.on(t, e) : this.map.on(t, e) } }, { key: "off", value: function (t, e) { -1 !== Mx.indexOf(t) ? this.eventEmitter.off(t, e) : this.map.off(t, e) } }, { key: "getContainer", value: function () { return this.map.getContainer() } }, { key: "getMapCanvasContainer", value: function () { var t; return null === (t = this.map.getContainer()) || void 0 === t ? void 0 : t.getElementsByClassName("amap-maps")[0] } }, { key: "getSize", value: function () { var t = this.map.getSize(); return [t.getWidth(), t.getHeight()] } }, { key: "getType", value: function () { return "amap" } }, { key: "getZoom", value: function () { return this.map.getZoom() - 1 } }, { key: "setZoom", value: function (t) { return this.map.setZoom(t + 1) } }, { key: "getCenter", value: function (t) { if (null != t && t.padding) { var e = this.getCenter(), n = Lr(this.getSize(), 2); n[0], n[1]; var r = fA(t.padding), i = this.lngLatToPixel([e.lng, e.lat]), o = [(r.right - r.left) / 2, (r.bottom - r.top) / 2]; return this.pixelToLngLat([i.x - o[0], i.y - o[1]]) } var a = this.map.getCenter(); return { lng: a.getLng(), lat: a.getLat() } } }, { key: "setCenter", value: function (t, e) { if (null != e && e.padding) { var n = fA(e.padding), r = this.lngLatToPixel(t), i = [(n.right - n.left) / 2, (n.bottom - n.top) / 2], o = this.pixelToLngLat([r.x + i[0], r.y + i[1]]); this.map.setCenter([o.lng, o.lat]) } else this.map.setCenter(t) } }, { key: "getPitch", value: function () { return this.map.getPitch() } }, { key: "getRotation", value: function () { return 360 - this.map.getRotation() } }, { key: "getBounds", value: function () { var t = this.map.getBounds().toBounds(), e = t.getNorthEast(), n = t.getSouthWest(), r = this.getCenter(), i = r.lng > e.getLng() || r.lng < n.getLng() ? 180 - e.getLng() : e.getLng(); return [[r.lng < n.getLng() ? n.getLng() - 180 : n.getLng(), n.getLat()], [i, e.getLat()]] } }, { key: "getMinZoom", value: function () { return this.map.get("zooms")[0] - 1 } }, { key: "getMaxZoom", value: function () { return this.map.get("zooms")[1] - 1 } }, { key: "setRotation", value: function (t) { return this.map.setRotation(t) } }, { key: "setPitch", value: function (t) { return this.map.setPitch(t) } }, { key: "zoomIn", value: function () { this.map.zoomIn() } }, { key: "zoomOut", value: function () { this.map.zoomOut() } }, { key: "panTo", value: function (t) { this.map.panTo(t) } }, { key: "panBy", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.map.panBy(t, e) } }, { key: "fitBounds", value: function (t) { this.map.setBounds(new AMap.Bounds([t[0][0], t[0][1], t[1][0], t[1][1]])) } }, { key: "setZoomAndCenter", value: function (t, e) { this.map.setZoomAndCenter(t + 1, e) } }, { key: "setMapStyle", value: function (t) { this.map.setMapStyle(this.getMapStyle(t)) } }, { key: "setMapStatus", value: function (t) { this.map.setStatus(t) } }, { key: "pixelToLngLat", value: function (t) { var e = this.map.pixelToLngLat(new AMap.Pixel(t[0], t[1])); return { lng: e.getLng(), lat: e.getLat() } } }, { key: "lngLatToPixel", value: function (t) { var e = this.map.lnglatToPixel(new AMap.LngLat(t[0], t[1])); return { x: e.getX(), y: e.getY() } } }, { key: "containerToLngLat", value: function (t) { var e = new AMap.Pixel(t[0], t[1]), n = this.map.containerToLngLat(e); return { lng: null == n ? void 0 : n.getLng(), lat: null == n ? void 0 : n.getLat() } } }, { key: "lngLatToContainer", value: function (t) { var e = new AMap.LngLat(t[0], t[1]), n = this.map.lngLatToContainer(e); return { x: n.getX(), y: n.getY() } } }, { key: "lngLatToCoord", value: function (t) { var e = this.map.lngLatToGeodeticCoord(t); return [e.x, -e.y] } }, { key: "lngLatToMercator", value: function (t, e) { return { x: 0, y: 0, z: 0 } } }, { key: "getModelMatrix", value: function (t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1, 1], i = this.viewport.projectFlat(t), o = os(); return ps(o, o, Is(i[0], i[1], e)), hs(o, o, Is(r[0], r[1], r[2])), fs(o, o, n[0]), ds(o, o, n[1]), ms(o, o, n[2]), o } }, { key: "init", value: (e = nd(gd.mark((function t() { var e, n, r, i, o, a, s, l, u, c, p, h, f, d, m = this; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return e = this.config, n = e.id, r = e.style, i = void 0 === r ? "light" : r, o = e.minZoom, a = void 0 === o ? 0 : o, s = e.maxZoom, l = void 0 === s ? 18 : s, u = e.token, c = void 0 === u ? PA : u, p = e.mapInstance, h = e.plugin, f = void 0 === h ? [] : h, d = zd(e, MA), t.next = 3, new Promise((function (t) { var e = function () { if (p) m.map = p, m.$mapContainer = m.map.getContainer(), setTimeout((function () { m.map.on("camerachange", m.handleCameraChanged), t() }), 30); else { m.$mapContainer = m.creatAmapContainer(n); var e = kA({ mapStyle: m.getMapStyle(i), zooms: [a, l], viewMode: "3D" }, d); e.zoom && (e.zoom += 1); var r = new AMap.Map(m.$mapContainer, e); r.on("camerachange", m.handleCameraChanged), r.on("camerachange", (function () { setTimeout((function () { return m.handleAfterMapChange() })) })), m.map = r, setTimeout((function () { t() }), 10) } }; LA || p ? LA && window.AMap || p ? e() : RA.push(e) : (c === PA && console.warn(m.configService.getSceneWarninfo("MapToken")), LA = !0, f.push("Map3D"), uA.load({ key: c, version: "1.4.15", plugins: f }).then((function (t) { e(), RA.length && (RA.forEach((function (t) { return t() })), RA = []) })).catch((function (t) { throw new Error(t) }))) })); case 3: this.viewport = new AA; case 4: case "end": return t.stop() } }), t, this) }))), function () { return e.apply(this, arguments) }) }, { key: "meterToCoord", value: function (t, e) { var n = AMap.GeometryUtil.distance(xo(AMap.LngLat, Fd(t)), xo(AMap.LngLat, Fd(e))), r = Lr(this.lngLatToCoord(t), 2), i = r[0], o = r[1], a = Lr(this.lngLatToCoord(e), 2), s = a[0], l = a[1]; return Math.sqrt(Math.pow(i - s, 2) + Math.pow(o - l, 2)) / n } }, { key: "exportMap", value: function (t) { var e, n = null === (e = this.getContainer()) || void 0 === e ? void 0 : e.getElementsByClassName("amap-layer")[0]; return "jpg" === t ? null == n ? void 0 : n.toDataURL("image/jpeg") : null == n ? void 0 : n.toDataURL("image/png") } }, { key: "emit", value: function (t) { for (var e, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; (e = this.eventEmitter).emit.apply(e, [t].concat(r)) } }, { key: "once", value: function (t) { for (var e, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; (e = this.eventEmitter).once.apply(e, [t].concat(r)) } }, { key: "destroy", value: function () { var t, e; this.map.destroy(), null === (t = this.$mapContainer) || void 0 === t || null === (e = t.parentNode) || void 0 === e || e.removeChild(this.$mapContainer), delete window.initAMap; var n = document.getElementById("amap-script"); n && document.head.removeChild(n) } }, { key: "getMapContainer", value: function () { return this.$mapContainer } }, { key: "onCameraChanged", value: function (t) { this.cameraChangedCallback = t } }, { key: "handleAfterMapChange", value: function () { this.emit("mapAfterFrameChange") } }, { key: "getMapStyle", value: function (t) { return CA[t] ? CA[t] : t } }, { key: "creatAmapContainer", value: function (t) { var e = t; "string" == typeof t && (e = document.getElementById(t)); var n = document.createElement("div"); return n.style.cssText += "\n      position: absolute;\n      top: 0;\n      height: 100%;\n      width: 100%;\n    ", n.id = "l7_amap_div" + IA++, e.appendChild(n), n } }]), t }(), bA = Cf(xA.prototype, "configService", [mA], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), wA = Cf(xA.prototype, "config", [vA], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), SA = Cf(xA.prototype, "coordinateSystemService", [yA], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), EA = Cf(xA.prototype, "eventEmitter", [gA], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), _A = xA)) || _A); function NA(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var zA = function (t) { Ur(n, t); var e = NA(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getServiceConstructor", value: function () { return DA } }]), n }(aA); function FA(t, e) { var n, r, i, o = el([], e, t); return n = o, r = o, i = 1 / o[3], n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = r[3] * i, o } function BA(t, e) { if (!t) throw new Error(e || "viewport-mercator-project: assertion failed.") } var jA = Math.PI, UA = jA / 4, VA = jA / 180, GA = 180 / jA, HA = 4003e4; function WA(t) { return Math.pow(2, t) } function XA(t, e) { var n = Lr(t, 2), r = n[0], i = n[1]; BA(Number.isFinite(r) && Number.isFinite(e)), BA(Number.isFinite(i) && i >= -90 && i <= 90, "invalid latitude"); var o = i * VA; return [(e *= 512) * (r * VA + jA) / (2 * jA), e * (jA - Math.log(Math.tan(UA + .5 * o))) / (2 * jA)] } function qA(t, e) { var n = Lr(t, 2), r = n[0], i = n[1], o = r / (e *= 512) * (2 * jA) - jA, a = 2 * (Math.atan(Math.exp(jA - i / e * (2 * jA))) - UA); return [o * GA, a * GA] } function ZA(t) { var e = t.latitude, n = t.longitude, r = t.zoom, i = t.scale, o = t.highPrecision, a = void 0 !== o && o; i = void 0 !== i ? i : WA(r), BA(Number.isFinite(e) && Number.isFinite(n) && Number.isFinite(i)); var s = {}, l = 512 * i, u = Math.cos(e * VA), c = l / 360, p = c / u, h = l / HA / u; if (s.pixelsPerMeter = [h, -h, h], s.metersPerPixel = [1 / h, -1 / h, 1 / h], s.pixelsPerDegree = [c, -p, h], s.degreesPerPixel = [1 / c, -1 / p, 1 / h], a) { var f = VA * Math.tan(e * VA) / u, d = c * f / 2, m = l / HA * f, v = m / p * h; s.pixelsPerDegree2 = [0, -d, m], s.pixelsPerMeter2 = [v, 0, v] } return s } function YA(t) { var e = t.height, n = t.pitch, r = t.bearing, i = t.altitude, o = t.center, a = void 0 === o ? null : o, s = t.flipY, l = void 0 !== s && s, u = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; return ps(u, u, [0, 0, -i]), hs(u, u, [1, 1, 1 / e]), fs(u, u, -n * VA), ms(u, u, r * VA), l && hs(u, u, [1, -1, 1]), a && ps(u, u, Fs([], a)), u } function KA(t) { var e = t.width, n = t.height, r = t.pitch, i = function (t) { var e = t.width, n = t.height, r = t.altitude, i = void 0 === r ? 1.5 : r, o = t.pitch, a = void 0 === o ? 0 : o, s = t.nearZMultiplier, l = void 0 === s ? 1 : s, u = t.farZMultiplier, c = void 0 === u ? 1 : u, p = a * VA, h = Math.atan(.5 / i), f = Math.sin(h) * i / Math.sin(Math.PI / 2 - p - h), d = Math.cos(Math.PI / 2 - p) * f + i; return { fov: 2 * Math.atan(n / 2 / i), aspect: e / n, focalDistance: i, near: l, far: d * c } }({ width: e, height: n, altitude: t.altitude, pitch: r, nearZMultiplier: t.nearZMultiplier, farZMultiplier: t.farZMultiplier }), o = i.fov, a = i.aspect, s = i.near, l = i.far; return xs([], o, a, s, l) } function QA(t, e) { var n = Lr(t, 3), r = n[0], i = n[1], o = n[2], a = void 0 === o ? 0 : o; return BA(Number.isFinite(r) && Number.isFinite(i) && Number.isFinite(a)), FA(e, [r, i, a, 1]) } function JA(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = Lr(t, 3), i = r[0], o = r[1], a = r[2]; if (BA(Number.isFinite(i) && Number.isFinite(o), "invalid pixel coordinate"), Number.isFinite(a)) { var s = FA(e, [i, o, a, 1]); return s } var l = FA(e, [i, o, 0, 1]), u = FA(e, [i, o, 1, 1]), c = l[2], p = u[2], h = c === p ? 0 : ((n || 0) - c) / (p - c); return ul([], l, u, h) } var $A = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], tM = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = e.width, r = e.height, i = e.viewMatrix, o = void 0 === i ? $A : i, a = e.projectionMatrix, s = void 0 === a ? $A : a; Ar(this, t), this.width = n || 1, this.height = r || 1, this.scale = 1, this.pixelsPerMeter = 1, this.viewMatrix = o, this.projectionMatrix = s; var l = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; cs(l, l, this.projectionMatrix), cs(l, l, this.viewMatrix), this.viewProjectionMatrix = l; var u = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; hs(u, u, [this.width / 2, -this.height / 2, 1]), ps(u, u, [1, -1, 0]), cs(u, u, this.viewProjectionMatrix); var c = us([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], u); if (!c) throw new Error("Pixel project matrix not invertible"); this.pixelProjectionMatrix = u, this.pixelUnprojectionMatrix = c, this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this) } return Or(t, [{ key: "equals", value: function (e) { return e instanceof t && (e.width === this.width && e.height === this.height && Cs(e.projectionMatrix, this.projectionMatrix) && Cs(e.viewMatrix, this.viewMatrix)) } }, { key: "project", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.topLeft, r = void 0 === n || n, i = this.projectPosition(t), o = QA(i, this.pixelProjectionMatrix), a = Lr(o, 2), s = a[0], l = a[1], u = r ? l : this.height - l; return 2 === t.length ? [s, u] : [s, u, o[2]] } }, { key: "unproject", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.topLeft, r = void 0 === n || n, i = e.targetZ, o = Lr(t, 3), a = o[0], s = o[1], l = o[2], u = r ? s : this.height - s, c = i && i * this.pixelsPerMeter, p = JA([a, u, l], this.pixelUnprojectionMatrix, c), h = this.unprojectPosition(p), f = Lr(h, 3), d = f[0], m = f[1], v = f[2]; return Number.isFinite(l) ? [d, m, v] : Number.isFinite(i) ? [d, m, i] : [d, m] } }, { key: "projectPosition", value: function (t) { var e = Lr(this.projectFlat(t), 2); return [e[0], e[1], (t[2] || 0) * this.pixelsPerMeter] } }, { key: "unprojectPosition", value: function (t) { var e = Lr(this.unprojectFlat(t), 2); return [e[0], e[1], (t[2] || 0) / this.pixelsPerMeter] } }, { key: "projectFlat", value: function (t) { return arguments.length > 1 && void 0 !== arguments[1] || this.scale, t } }, { key: "unprojectFlat", value: function (t) { return arguments.length > 1 && void 0 !== arguments[1] || this.scale, t } }]), t }(); function eM(t) { var e = t.width, n = t.height, r = t.bounds, i = t.minExtent, o = void 0 === i ? 0 : i, a = t.maxZoom, s = void 0 === a ? 24 : a, l = t.padding, u = void 0 === l ? 0 : l, c = t.offset, p = void 0 === c ? [0, 0] : c, h = Lr(r, 2), f = Lr(h[0], 2), d = f[0], m = f[1], v = Lr(h[1], 2), y = v[0], g = v[1]; if (Number.isFinite(u)) { u = { top: u, bottom: u, left: u, right: u } } else BA(Number.isFinite(u.top) && Number.isFinite(u.bottom) && Number.isFinite(u.left) && Number.isFinite(u.right)); var _ = new nM({ width: e, height: n, longitude: 0, latitude: 0, zoom: 0 }), x = _.project([d, g]), b = _.project([y, m]), w = [Math.max(Math.abs(b[0] - x[0]), o), Math.max(Math.abs(b[1] - x[1]), o)], S = [e - u.left - u.right - 2 * Math.abs(p[0]), n - u.top - u.bottom - 2 * Math.abs(p[1])]; BA(S[0] > 0 && S[1] > 0); var E = S[0] / w[0], C = S[1] / w[1], T = (u.right - u.left) / 2 / E, A = (u.bottom - u.top) / 2 / C, M = [(b[0] + x[0]) / 2 + T, (b[1] + x[1]) / 2 + A], O = _.unproject(M), k = _.zoom + Math.log2(Math.abs(Math.min(E, C))); return { longitude: O[0], latitude: O[1], zoom: Math.min(k, s) } } var nM = function (t) { function e() { var t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = n.width, i = n.height, o = n.latitude, a = void 0 === o ? 0 : o, s = n.longitude, l = void 0 === s ? 0 : s, u = n.zoom, c = void 0 === u ? 0 : u, p = n.pitch, h = void 0 === p ? 0 : p, f = n.bearing, d = void 0 === f ? 0 : f, m = n.altitude, v = void 0 === m ? 1.5 : m, y = n.nearZMultiplier, g = n.farZMultiplier; Ar(this, e), r = r || 1, i = i || 1; var _ = WA(c); v = Math.max(.75, v); var x = XA([l, a], _); x[2] = 0; var b = KA({ width: r, height: i, pitch: h, bearing: d, altitude: v, nearZMultiplier: y || 1 / i, farZMultiplier: g || 1.01 }), w = YA({ height: i, center: x, pitch: h, bearing: d, altitude: v, flipY: !0 }); return (t = Hr(this, Wr(e).call(this, { width: r, height: i, viewMatrix: w, projectionMatrix: b }))).latitude = a, t.longitude = l, t.zoom = c, t.pitch = h, t.bearing = d, t.altitude = v, t.scale = _, t.center = x, t.pixelsPerMeter = ZA(Gr(Gr(t))).pixelsPerMeter[2], Object.freeze(Gr(Gr(t))), t } return Ur(e, t), Or(e, [{ key: "projectFlat", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.scale; return XA(t, e) } }, { key: "unprojectFlat", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.scale; return qA(t, e) } }, { key: "getMapCenterByLngLatPosition", value: function (t) { var e, n, r = t.lngLat, i = JA(t.pos, this.pixelUnprojectionMatrix), o = ol([], XA(r, this.scale), ((e = [])[0] = -(n = i)[0], e[1] = -n[1], e)); return qA(ol([], this.center, o), this.scale) } }, { key: "getLocationAtPoint", value: function (t) { var e = t.lngLat, n = t.pos; return this.getMapCenterByLngLatPosition({ lngLat: e, pos: n }) } }, { key: "fitBounds", value: function (t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = this.width, i = this.height, o = eM(Object.assign({ width: r, height: i, bounds: t }, n)), a = o.longitude, s = o.latitude, l = o.zoom; return new e({ width: r, height: i, longitude: a, latitude: s, zoom: l }) } }]), e }(tM), rM = { exports: {} }; !function (t, e) { t.exports = function () { var t, e, n; function r(r, i) { if (t) if (e) { var o = "var sharedChunk = {}; (" + t + ")(sharedChunk); (" + e + ")(sharedChunk);", a = {}; t(a), n = i(a), "undefined" != typeof window && (n.workerUrl = window.URL.createObjectURL(new Blob([o], { type: "text/javascript" }))) } else e = i; else t = i } return r(["exports"], (function (t) { function e(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var n = r; function r(t, e, n, r) { this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (r - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = r } r.prototype.sampleCurveX = function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, r.prototype.sampleCurveY = function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, r.prototype.sampleCurveDerivativeX = function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, r.prototype.solveCurveX = function (t, e) { var n, r, i, o, a; for (void 0 === e && (e = 1e-6), i = t, a = 0; a < 8; a++) { if (o = this.sampleCurveX(i) - t, Math.abs(o) < e) return i; var s = this.sampleCurveDerivativeX(i); if (Math.abs(s) < 1e-6) break; i -= o / s } if ((i = t) < (n = 0)) return n; if (i > (r = 1)) return r; for (; n < r;) { if (o = this.sampleCurveX(i), Math.abs(o - t) < e) return i; t > o ? n = i : r = i, i = .5 * (r - n) + n } return i }, r.prototype.solve = function (t, e) { return this.sampleCurveY(this.solveCurveX(t, e)) }; var i = o; function o(t, e) { this.x = t, this.y = e } o.prototype = { clone: function () { return new o(this.x, this.y) }, add: function (t) { return this.clone()._add(t) }, sub: function (t) { return this.clone()._sub(t) }, multByPoint: function (t) { return this.clone()._multByPoint(t) }, divByPoint: function (t) { return this.clone()._divByPoint(t) }, mult: function (t) { return this.clone()._mult(t) }, div: function (t) { return this.clone()._div(t) }, rotate: function (t) { return this.clone()._rotate(t) }, rotateAround: function (t, e) { return this.clone()._rotateAround(t, e) }, matMult: function (t) { return this.clone()._matMult(t) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (t) { return this.x === t.x && this.y === t.y }, dist: function (t) { return Math.sqrt(this.distSqr(t)) }, distSqr: function (t) { var e = t.x - this.x, n = t.y - this.y; return e * e + n * n }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (t) { return Math.atan2(this.y - t.y, this.x - t.x) }, angleWith: function (t) { return this.angleWithSep(t.x, t.y) }, angleWithSep: function (t, e) { return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e) }, _matMult: function (t) { var e = t[2] * this.x + t[3] * this.y; return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, _sub: function (t) { return this.x -= t.x, this.y -= t.y, this }, _mult: function (t) { return this.x *= t, this.y *= t, this }, _div: function (t) { return this.x /= t, this.y /= t, this }, _multByPoint: function (t) { return this.x *= t.x, this.y *= t.y, this }, _divByPoint: function (t) { return this.x /= t.x, this.y /= t.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var t = this.y; return this.y = this.x, this.x = -t, this }, _rotate: function (t) { var e = Math.cos(t), n = Math.sin(t), r = n * this.x + e * this.y; return this.x = e * this.x - n * this.y, this.y = r, this }, _rotateAround: function (t, e) { var n = Math.cos(t), r = Math.sin(t), i = e.y + r * (this.x - e.x) + n * (this.y - e.y); return this.x = e.x + n * (this.x - e.x) - r * (this.y - e.y), this.y = i, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, o.convert = function (t) { return t instanceof o ? t : Array.isArray(t) ? new o(t[0], t[1]) : t }; var a = "undefined" != typeof self ? self : {}, s = Math.pow(2, 53) - 1; function l(t, e, r, i) { var o = new n(t, e, r, i); return function (t) { return o.solve(t) } } var u = l(.25, .1, .25, 1); function c(t, e, n) { return Math.min(n, Math.max(e, t)) } function p(t, e, n) { var r = n - e, i = ((t - e) % r + r) % r + e; return i === e ? n : i } function h(t) { for (var e = [], n = arguments.length - 1; n-- > 0;)e[n] = arguments[n + 1]; for (var r = 0, i = e; r < i.length; r += 1) { var o = i[r]; for (var a in o) t[a] = o[a] } return t } var f = 1; function d() { return f++ } function m() { return function t(e) { return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t) }() } function v(t) { return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t) } function y(t, e) { t.forEach((function (t) { e[t] && (e[t] = e[t].bind(e)) })) } function g(t, e) { return -1 !== t.indexOf(e, t.length - e.length) } function _(t, e, n) { var r = {}; for (var i in t) r[i] = e.call(n || this, t[i], i, t); return r } function x(t, e, n) { var r = {}; for (var i in t) e.call(n || this, t[i], i, t) && (r[i] = t[i]); return r } function b(t) { return Array.isArray(t) ? t.map(b) : "object" == typeof t && t ? _(t, b) : t } var w = {}; function S(t) { w[t] || ("undefined" != typeof console && console.warn(t), w[t] = !0) } function E(t, e, n) { return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x) } function C(t) { for (var e = 0, n = 0, r = t.length, i = r - 1, o = void 0, a = void 0; n < r; i = n++)e += ((a = t[i]).x - (o = t[n]).x) * (o.y + a.y); return e } function T() { return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope } function A(t) { var e = {}; if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (function (t, n, r, i) { var o = r || i; return e[n] = !o || o.toLowerCase(), "" })), e["max-age"]) { var n = parseInt(e["max-age"], 10); isNaN(n) ? delete e["max-age"] : e["max-age"] = n } return e } var M = null; function O(t) { if (null == M) { var e = t.navigator ? t.navigator.userAgent : null; M = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome"))) } return M } function k(t) { try { var e = a[t]; return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0 } catch (t) { return !1 } } var I, P, L, R, D = a.performance && a.performance.now ? a.performance.now.bind(a.performance) : Date.now.bind(Date), N = a.requestAnimationFrame || a.mozRequestAnimationFrame || a.webkitRequestAnimationFrame || a.msRequestAnimationFrame, z = a.cancelAnimationFrame || a.mozCancelAnimationFrame || a.webkitCancelAnimationFrame || a.msCancelAnimationFrame, F = { now: D, frame: function (t) { var e = N(t); return { cancel: function () { return z(e) } } }, getImageData: function (t, e) { void 0 === e && (e = 0); var n = a.document.createElement("canvas"), r = n.getContext("2d"); if (!r) throw new Error("failed to create canvas 2d context"); return n.width = t.width, n.height = t.height, r.drawImage(t, 0, 0, t.width, t.height), r.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e) }, resolveURL: function (t) { return I || (I = a.document.createElement("a")), I.href = t, I.href }, hardwareConcurrency: a.navigator && a.navigator.hardwareConcurrency || 4, get devicePixelRatio() { return a.devicePixelRatio }, get prefersReducedMotion() { return !!a.matchMedia && (null == P && (P = a.matchMedia("(prefers-reduced-motion: reduce)")), P.matches) } }, B = { API_URL: "https://api.mapbox.com", get EVENTS_URL() { return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, j = { supported: !1, testSupport: function (t) { !U && R && (V ? G(t) : L = t) } }, U = !1, V = !1; function G(t) { var e = t.createTexture(); t.bindTexture(t.TEXTURE_2D, e); try { if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, R), t.isContextLost()) return; j.supported = !0 } catch (t) { } t.deleteTexture(e), U = !0 } a.document && ((R = a.document.createElement("img")).onload = function () { L && G(L), L = null, V = !0 }, R.onerror = function () { U = !0, L = null }, R.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="); var H = "01", W = function (t, e) { this._transformRequestFn = t, this._customAccessToken = e, this._createSkuToken() }; function X(t) { return 0 === t.indexOf("mapbox:") } W.prototype._createSkuToken = function () { var t = function () { for (var t = "", e = 0; e < 10; e++)t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())]; return { token: ["1", H, t].join(""), tokenExpiresAt: Date.now() + 432e5 } }(); this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt }, W.prototype._isSkuTokenExpired = function () { return Date.now() > this._skuTokenExpiresAt }, W.prototype.transformRequest = function (t, e) { return this._transformRequestFn && this._transformRequestFn(t, e) || { url: t } }, W.prototype.normalizeStyleURL = function (t, e) { if (!X(t)) return t; var n = K(t); return n.path = "/styles/v1" + n.path, this._makeAPIURL(n, this._customAccessToken || e) }, W.prototype.normalizeGlyphsURL = function (t, e) { if (!X(t)) return t; var n = K(t); return n.path = "/fonts/v1" + n.path, this._makeAPIURL(n, this._customAccessToken || e) }, W.prototype.normalizeSourceURL = function (t, e) { if (!X(t)) return t; var n = K(t); return n.path = "/v4/" + n.authority + ".json", n.params.push("secure"), this._makeAPIURL(n, this._customAccessToken || e) }, W.prototype.normalizeSpriteURL = function (t, e, n, r) { var i = K(t); return X(t) ? (i.path = "/styles/v1" + i.path + "/sprite" + e + n, this._makeAPIURL(i, this._customAccessToken || r)) : (i.path += "" + e + n, Q(i)) }, W.prototype.normalizeTileURL = function (t, e) { if (this._isSkuTokenExpired() && this._createSkuToken(), t && !X(t)) return t; var n = K(t); n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, (F.devicePixelRatio >= 2 || 512 === e ? "@2x" : "") + (j.supported ? ".webp" : "$1")), n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = "/v4" + n.path; var r = this._customAccessToken || function (t) { for (var e = 0, n = t; e < n.length; e += 1) { var r = n[e].match(/^access_token=(.*)$/); if (r) return r[1] } return null }(n.params) || B.ACCESS_TOKEN; return B.REQUIRE_ACCESS_TOKEN && r && this._skuToken && n.params.push("sku=" + this._skuToken), this._makeAPIURL(n, r) }, W.prototype.canonicalizeTileURL = function (t, e) { var n = K(t); if (!n.path.match(/(^\/v4\/)/) || !n.path.match(/\.[\w]+$/)) return t; var r = "mapbox://tiles/"; r += n.path.replace("/v4/", ""); var i = n.params; return e && (i = i.filter((function (t) { return !t.match(/^access_token=/) }))), i.length && (r += "?" + i.join("&")), r }, W.prototype.canonicalizeTileset = function (t, e) { for (var n = !!e && X(e), r = [], i = 0, o = t.tiles || []; i < o.length; i += 1) { var a = o[i]; Z(a) ? r.push(this.canonicalizeTileURL(a, n)) : r.push(a) } return r }, W.prototype._makeAPIURL = function (t, e) { var n = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", r = K(B.API_URL); if (t.protocol = r.protocol, t.authority = r.authority, "http" === t.protocol) { var i = t.params.indexOf("secure"); i >= 0 && t.params.splice(i, 1) } if ("/" !== r.path && (t.path = "" + r.path + t.path), !B.REQUIRE_ACCESS_TOKEN) return Q(t); if (!(e = e || B.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + n); if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + n); return t.params = t.params.filter((function (t) { return -1 === t.indexOf("access_token") })), t.params.push("access_token=" + e), Q(t) }; var q = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i; function Z(t) { return q.test(t) } var Y = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/; function K(t) { var e = t.match(Y); if (!e) throw new Error("Unable to parse URL object"); return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] } } function Q(t) { var e = t.params.length ? "?" + t.params.join("&") : ""; return t.protocol + "://" + t.authority + t.path + e } function J(t) { if (!t) return null; var e = t.split("."); if (!e || 3 !== e.length) return null; try { return JSON.parse(decodeURIComponent(a.atob(e[1]).split("").map((function (t) { return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2) })).join(""))) } catch (t) { return null } } var $ = function (t) { this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null }; $.prototype.getStorageKey = function (t) { var e, n = J(B.ACCESS_TOKEN); return e = n && n.u ? a.btoa(encodeURIComponent(n.u).replace(/%([0-9A-F]{2})/g, (function (t, e) { return String.fromCharCode(Number("0x" + e)) }))) : B.ACCESS_TOKEN || "", t ? "mapbox.eventData." + t + ":" + e : "mapbox.eventData:" + e }, $.prototype.fetchEventData = function () { var t = k("localStorage"), e = this.getStorageKey(), n = this.getStorageKey("uuid"); if (t) try { var r = a.localStorage.getItem(e); r && (this.eventData = JSON.parse(r)); var i = a.localStorage.getItem(n); i && (this.anonId = i) } catch (t) { S("Unable to read from LocalStorage") } }, $.prototype.saveEventData = function () { var t = k("localStorage"), e = this.getStorageKey(), n = this.getStorageKey("uuid"); if (t) try { a.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e, JSON.stringify(this.eventData)) } catch (t) { S("Unable to write to LocalStorage") } }, $.prototype.processRequests = function (t) { }, $.prototype.postEvent = function (t, e, n, r) { var i = this; if (B.EVENTS_URL) { var o = K(B.EVENTS_URL); o.params.push("access_token=" + (r || B.ACCESS_TOKEN || "")); var a = { event: this.type, created: new Date(t).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.2", skuId: H, userId: this.anonId }, s = e ? h(a, e) : a, l = { url: Q(o), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([s]) }; this.pendingRequest = bt(l, (function (t) { i.pendingRequest = null, n(t), i.saveEventData(), i.processRequests(r) })) } }, $.prototype.queueRequest = function (t, e) { this.queue.push(t), this.processRequests(e) }; var tt, et, nt = function (t) { function e() { t.call(this, "map.load"), this.success = {}, this.skuToken = "" } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postMapLoadEvent = function (t, e, n, r) { this.skuToken = n, (B.EVENTS_URL && r || B.ACCESS_TOKEN && Array.isArray(t) && t.some((function (t) { return X(t) || Z(t) }))) && this.queueRequest({ id: e, timestamp: Date.now() }, r) }, e.prototype.processRequests = function (t) { var e = this; if (!this.pendingRequest && 0 !== this.queue.length) { var n = this.queue.shift(), r = n.id, i = n.timestamp; r && this.success[r] || (this.anonId || this.fetchEventData(), v(this.anonId) || (this.anonId = m()), this.postEvent(i, { skuToken: this.skuToken }, (function (t) { t || r && (e.success[r] = !0) }), t)) } }, e }($), rt = new (function (t) { function e(e) { t.call(this, "appUserTurnstile"), this._customAccessToken = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postTurnstileEvent = function (t, e) { B.EVENTS_URL && B.ACCESS_TOKEN && Array.isArray(t) && t.some((function (t) { return X(t) || Z(t) })) && this.queueRequest(Date.now(), e) }, e.prototype.processRequests = function (t) { var e = this; if (!this.pendingRequest && 0 !== this.queue.length) { this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData(); var n = J(B.ACCESS_TOKEN), r = n ? n.u : B.ACCESS_TOKEN, i = r !== this.eventData.tokenU; v(this.anonId) || (this.anonId = m(), i = !0); var o = this.queue.shift(); if (this.eventData.lastSuccess) { var a = new Date(this.eventData.lastSuccess), s = new Date(o), l = (o - this.eventData.lastSuccess) / 864e5; i = i || l >= 1 || l < -1 || a.getDate() !== s.getDate() } else i = !0; if (!i) return this.processRequests(); this.postEvent(o, { "enabled.telemetry": !1 }, (function (t) { t || (e.eventData.lastSuccess = o, e.eventData.tokenU = r) }), t) } }, e }($)), it = rt.postTurnstileEvent.bind(rt), ot = new nt, at = ot.postMapLoadEvent.bind(ot), st = 500, lt = 50; function ut() { a.caches && !tt && (tt = a.caches.open("mapbox-tiles")) } function ct(t) { var e = t.indexOf("?"); return e < 0 ? t : t.slice(0, e) } var pt, ht = 1 / 0; function ft() { return null == pt && (pt = a.OffscreenCanvas && new a.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof a.createImageBitmap), pt } var dt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" }; "function" == typeof Object.freeze && Object.freeze(dt); var mt, vt, yt = function (t) { function e(e, n, r) { 401 === n && Z(r) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t.call(this, e), this.status = n, this.url = r, this.name = this.constructor.name, this.message = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.toString = function () { return this.name + ": " + this.message + " (" + this.status + "): " + this.url }, e }(Error), gt = T() ? function () { return self.worker && self.worker.referrer } : function () { return ("blob:" === a.location.protocol ? a.parent : a).location.href }, _t = function (t, e) { if (!(/^file:/.test(n = t.url) || /^file:/.test(gt()) && !/^\w+:/.test(n))) { if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal")) return function (t, e) { var n, r = new a.AbortController, i = new a.Request(t.url, { method: t.method || "GET", body: t.body, credentials: t.credentials, headers: t.headers, referrer: gt(), signal: r.signal }), o = !1, s = !1, l = (n = i.url).indexOf("sku=") > 0 && Z(n); "json" === t.type && i.headers.set("Accept", "application/json"); var u = function (n, r, o) { if (!s) { if (n && "SecurityError" !== n.message && S(n), r && o) return c(r); var u = Date.now(); a.fetch(i).then((function (n) { if (n.ok) { var r = l ? n.clone() : null; return c(n, r, u) } return e(new yt(n.statusText, n.status, t.url)) })).catch((function (t) { 20 !== t.code && e(new Error(t.message)) })) } }, c = function (n, r, l) { ("arrayBuffer" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text()).then((function (t) { s || (r && l && function (t, e, n) { if (ut(), tt) { var r = { status: e.status, statusText: e.statusText, headers: new a.Headers }; e.headers.forEach((function (t, e) { return r.headers.set(e, t) })); var i = A(e.headers.get("Cache-Control") || ""); i["no-store"] || (i["max-age"] && r.headers.set("Expires", new Date(n + 1e3 * i["max-age"]).toUTCString()), new Date(r.headers.get("Expires")).getTime() - n < 42e4 || function (t, e) { if (void 0 === et) try { new Response(new ReadableStream), et = !0 } catch (t) { et = !1 } et ? e(t.body) : t.blob().then(e) }(e, (function (e) { var n = new a.Response(e, r); ut(), tt && tt.then((function (e) { return e.put(ct(t.url), n) })).catch((function (t) { return S(t.message) })) }))) } }(i, r, l), o = !0, e(null, t, n.headers.get("Cache-Control"), n.headers.get("Expires"))) })).catch((function (t) { s || e(new Error(t.message)) })) }; return l ? function (t, e) { if (ut(), !tt) return e(null); var n = ct(t.url); tt.then((function (t) { t.match(n).then((function (r) { var i = function (t) { if (!t) return !1; var e = new Date(t.headers.get("Expires") || 0), n = A(t.headers.get("Cache-Control") || ""); return e > Date.now() && !n["no-cache"] }(r); t.delete(n), i && t.put(n, r.clone()), e(null, r, i) })).catch(e) })).catch(e) }(i, u) : u(null, null), { cancel: function () { s = !0, o || r.abort() } } }(t, e); if (T() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0) } var n; return function (t, e) { var n = new a.XMLHttpRequest; for (var r in n.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (n.responseType = "arraybuffer"), t.headers) n.setRequestHeader(r, t.headers[r]); return "json" === t.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === t.credentials, n.onerror = function () { e(new Error(n.statusText)) }, n.onload = function () { if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) { var r = n.response; if ("json" === t.type) try { r = JSON.parse(n.response) } catch (t) { return e(t) } e(null, r, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires")) } else e(new yt(n.statusText, n.status, t.url)) }, n.send(t.body), { cancel: function () { return n.abort() } } }(t, e) }, xt = function (t, e) { return _t(h(t, { type: "arrayBuffer" }), e) }, bt = function (t, e) { return _t(h(t, { method: "POST" }), e) }, wt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; mt = [], vt = 0; var St = function (t, e) { if (j.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), vt >= B.MAX_PARALLEL_IMAGE_REQUESTS) { var n = { requestParameters: t, callback: e, cancelled: !1, cancel: function () { this.cancelled = !0 } }; return mt.push(n), n } vt++; var r = !1, i = function () { if (!r) for (r = !0, vt--; mt.length && vt < B.MAX_PARALLEL_IMAGE_REQUESTS;) { var t = mt.shift(); t.cancelled || (t.cancel = St(t.requestParameters, t.callback).cancel) } }, o = xt(t, (function (t, n, r, o) { i(), t ? e(t) : n && (ft() ? function (t, e) { var n = new a.Blob([new Uint8Array(t)], { type: "image/png" }); a.createImageBitmap(n).then((function (t) { e(null, t) })).catch((function (t) { e(new Error("Could not load image because of " + t.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) })) }(n, e) : function (t, e, n, r) { var i = new a.Image, o = a.URL; i.onload = function () { e(null, i), o.revokeObjectURL(i.src), i.onload = null, a.requestAnimationFrame((function () { i.src = wt })) }, i.onerror = function () { return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) }; var s = new a.Blob([new Uint8Array(t)], { type: "image/png" }); i.cacheControl = n, i.expires = r, i.src = t.byteLength ? o.createObjectURL(s) : wt }(n, e, r, o)) })); return { cancel: function () { o.cancel(), i() } } }; function Et(t, e, n) { n[t] && -1 !== n[t].indexOf(e) || (n[t] = n[t] || [], n[t].push(e)) } function Ct(t, e, n) { if (n && n[t]) { var r = n[t].indexOf(e); -1 !== r && n[t].splice(r, 1) } } var Tt = function (t, e) { void 0 === e && (e = {}), h(this, e), this.type = t }, At = function (t) { function e(e, n) { void 0 === n && (n = {}), t.call(this, "error", h({ error: e }, n)) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(Tt), Mt = function () { }; Mt.prototype.on = function (t, e) { return this._listeners = this._listeners || {}, Et(t, e, this._listeners), this }, Mt.prototype.off = function (t, e) { return Ct(t, e, this._listeners), Ct(t, e, this._oneTimeListeners), this }, Mt.prototype.once = function (t, e) { return this._oneTimeListeners = this._oneTimeListeners || {}, Et(t, e, this._oneTimeListeners), this }, Mt.prototype.fire = function (t, e) { "string" == typeof t && (t = new Tt(t, e || {})); var n = t.type; if (this.listens(n)) { t.target = this; for (var r = 0, i = this._listeners && this._listeners[n] ? this._listeners[n].slice() : []; r < i.length; r += 1)i[r].call(this, t); for (var o = 0, a = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : []; o < a.length; o += 1) { var s = a[o]; Ct(n, s, this._oneTimeListeners), s.call(this, t) } var l = this._eventedParent; l && (h(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), l.fire(t)) } else t instanceof At && console.error(t.error); return this }, Mt.prototype.listens = function (t) { return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t) }, Mt.prototype.setEventedParent = function (t, e) { return this._eventedParent = t, this._eventedParentData = e, this }; var Ot = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, kt = function (t, e, n, r) { this.message = (t ? t + ": " : "") + n, r && (this.identifier = r), null != e && e.__line__ && (this.line = e.__line__) }; function It(t) { var e = t.value; return e ? [new kt(t.key, e, "constants have been deprecated as of v8")] : [] } function Pt(t) { for (var e = [], n = arguments.length - 1; n-- > 0;)e[n] = arguments[n + 1]; for (var r = 0, i = e; r < i.length; r += 1) { var o = i[r]; for (var a in o) t[a] = o[a] } return t } function Lt(t) { return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t } function Rt(t) { if (Array.isArray(t)) return t.map(Rt); if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) { var e = {}; for (var n in t) e[n] = Rt(t[n]); return e } return Lt(t) } var Dt = function (t) { function e(e, n) { t.call(this, n), this.message = n, this.key = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(Error), Nt = function (t, e) { void 0 === e && (e = []), this.parent = t, this.bindings = {}; for (var n = 0, r = e; n < r.length; n += 1) { var i = r[n]; this.bindings[i[0]] = i[1] } }; Nt.prototype.concat = function (t) { return new Nt(this, t) }, Nt.prototype.get = function (t) { if (this.bindings[t]) return this.bindings[t]; if (this.parent) return this.parent.get(t); throw new Error(t + " not found in scope.") }, Nt.prototype.has = function (t) { return !!this.bindings[t] || !!this.parent && this.parent.has(t) }; var zt = { kind: "null" }, Ft = { kind: "number" }, Bt = { kind: "string" }, jt = { kind: "boolean" }, Ut = { kind: "color" }, Vt = { kind: "object" }, Gt = { kind: "value" }, Ht = { kind: "collator" }, Wt = { kind: "formatted" }, Xt = { kind: "resolvedImage" }; function qt(t, e) { return { kind: "array", itemType: t, N: e } } function Zt(t) { if ("array" === t.kind) { var e = Zt(t.itemType); return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">" } return t.kind } var Yt = [zt, Ft, Bt, jt, Ut, Wt, Vt, qt(Gt), Xt]; function Kt(t, e) { if ("error" === e.kind) return null; if ("array" === t.kind) { if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Kt(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null } else { if (t.kind === e.kind) return null; if ("value" === t.kind) for (var n = 0, r = Yt; n < r.length; n += 1)if (!Kt(r[n], e)) return null } return "Expected " + Zt(t) + " but found " + Zt(e) + " instead." } function Qt(t, e) { return e.some((function (e) { return e.kind === t.kind })) } function Jt(t, e) { return e.some((function (e) { return "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t })) } var $t = e((function (t, e) { var n = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function r(t) { return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t } function i(t) { return r("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t)) } function o(t) { return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e; var e } function a(t, e, n) { return n < 0 ? n += 1 : n > 1 && (n -= 1), 6 * n < 1 ? t + (e - t) * n * 6 : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t } try { e.parseCSSColor = function (t) { var e, s = t.replace(/ /g, "").toLowerCase(); if (s in n) return n[s].slice(); if ("#" === s[0]) return 4 === s.length ? (e = parseInt(s.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === s.length && (e = parseInt(s.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null; var l = s.indexOf("("), u = s.indexOf(")"); if (-1 !== l && u + 1 === s.length) { var c = s.substr(0, l), p = s.substr(l + 1, u - (l + 1)).split(","), h = 1; switch (c) { case "rgba": if (4 !== p.length) return null; h = o(p.pop()); case "rgb": return 3 !== p.length ? null : [i(p[0]), i(p[1]), i(p[2]), h]; case "hsla": if (4 !== p.length) return null; h = o(p.pop()); case "hsl": if (3 !== p.length) return null; var f = (parseFloat(p[0]) % 360 + 360) % 360 / 360, d = o(p[1]), m = o(p[2]), v = m <= .5 ? m * (d + 1) : m + d - m * d, y = 2 * m - v; return [r(255 * a(y, v, f + 1 / 3)), r(255 * a(y, v, f)), r(255 * a(y, v, f - 1 / 3)), h]; default: return null } } return null } } catch (t) { } })).parseCSSColor, te = function (t, e, n, r) { void 0 === r && (r = 1), this.r = t, this.g = e, this.b = n, this.a = r }; te.parse = function (t) { if (t) { if (t instanceof te) return t; if ("string" == typeof t) { var e = $t(t); if (e) return new te(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) } } }, te.prototype.toString = function () { var t = this.toArray(), e = t[1], n = t[2], r = t[3]; return "rgba(" + Math.round(t[0]) + "," + Math.round(e) + "," + Math.round(n) + "," + r + ")" }, te.prototype.toArray = function () { var t = this.a; return 0 === t ? [0, 0, 0, 0] : [255 * this.r / t, 255 * this.g / t, 255 * this.b / t, t] }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1); var ee = function (t, e, n) { this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) }; ee.prototype.compare = function (t, e) { return this.collator.compare(t, e) }, ee.prototype.resolvedLocale = function () { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale }; var ne = function (t, e, n, r, i) { this.text = t, this.image = e, this.scale = n, this.fontStack = r, this.textColor = i }, re = function (t) { this.sections = t }; re.fromString = function (t) { return new re([new ne(t, null, null, null, null)]) }, re.prototype.isEmpty = function () { return 0 === this.sections.length || !this.sections.some((function (t) { return 0 !== t.text.length || t.image && 0 !== t.image.name.length })) }, re.factory = function (t) { return t instanceof re ? t : re.fromString(t) }, re.prototype.toString = function () { return 0 === this.sections.length ? "" : this.sections.map((function (t) { return t.text })).join("") }, re.prototype.serialize = function () { for (var t = ["format"], e = 0, n = this.sections; e < n.length; e += 1) { var r = n[e]; if (r.image) t.push(["image", r.image.name]); else { t.push(r.text); var i = {}; r.fontStack && (i["text-font"] = ["literal", r.fontStack.split(",")]), r.scale && (i["font-scale"] = r.scale), r.textColor && (i["text-color"] = ["rgba"].concat(r.textColor.toArray())), t.push(i) } } return t }; var ie = function (t) { this.name = t.name, this.available = t.available }; function oe(t, e, n, r) { return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof n && n >= 0 && n <= 255 ? void 0 === r || "number" == typeof r && r >= 0 && r <= 1 ? null : "Invalid rgba value [" + [t, e, n, r].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof r ? [t, e, n, r] : [t, e, n]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255." } function ae(t) { if (null === t) return !0; if ("string" == typeof t) return !0; if ("boolean" == typeof t) return !0; if ("number" == typeof t) return !0; if (t instanceof te) return !0; if (t instanceof ee) return !0; if (t instanceof re) return !0; if (t instanceof ie) return !0; if (Array.isArray(t)) { for (var e = 0, n = t; e < n.length; e += 1)if (!ae(n[e])) return !1; return !0 } if ("object" == typeof t) { for (var r in t) if (!ae(t[r])) return !1; return !0 } return !1 } function se(t) { if (null === t) return zt; if ("string" == typeof t) return Bt; if ("boolean" == typeof t) return jt; if ("number" == typeof t) return Ft; if (t instanceof te) return Ut; if (t instanceof ee) return Ht; if (t instanceof re) return Wt; if (t instanceof ie) return Xt; if (Array.isArray(t)) { for (var e, n = t.length, r = 0, i = t; r < i.length; r += 1) { var o = se(i[r]); if (e) { if (e === o) continue; e = Gt; break } e = o } return qt(e || Gt, n) } return Vt } function le(t) { var e = typeof t; return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof te || t instanceof re || t instanceof ie ? t.toString() : JSON.stringify(t) } ie.prototype.toString = function () { return this.name }, ie.fromString = function (t) { return t ? new ie({ name: t, available: !1 }) : null }, ie.prototype.serialize = function () { return ["image", this.name] }; var ue = function (t, e) { this.type = t, this.value = e }; ue.parse = function (t, e) { if (2 !== t.length) return e.error("'literal' expression requires exactly one argument, but found " + (t.length - 1) + " instead."); if (!ae(t[1])) return e.error("invalid value"); var n = t[1], r = se(n), i = e.expectedType; return "array" !== r.kind || 0 !== r.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (r = i), new ue(r, n) }, ue.prototype.evaluate = function () { return this.value }, ue.prototype.eachChild = function () { }, ue.prototype.outputDefined = function () { return !0 }, ue.prototype.serialize = function () { return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof re ? this.value.serialize() : this.value }; var ce = function (t) { this.name = "ExpressionEvaluationError", this.message = t }; ce.prototype.toJSON = function () { return this.message }; var pe = { string: Bt, number: Ft, boolean: jt, object: Vt }, he = function (t, e) { this.type = t, this.args = e }; he.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var n, r = 1, i = t[0]; if ("array" === i) { var o, a; if (t.length > 2) { var s = t[1]; if ("string" != typeof s || !(s in pe) || "object" === s) return e.error('The item type argument of "array" must be one of string, number, boolean', 1); o = pe[s], r++ } else o = Gt; if (t.length > 3) { if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2); a = t[2], r++ } n = qt(o, a) } else n = pe[i]; for (var l = []; r < t.length; r++) { var u = e.parse(t[r], r, Gt); if (!u) return null; l.push(u) } return new he(n, l) }, he.prototype.evaluate = function (t) { for (var e = 0; e < this.args.length; e++) { var n = this.args[e].evaluate(t); if (!Kt(this.type, se(n))) return n; if (e === this.args.length - 1) throw new ce("Expected value to be of type " + Zt(this.type) + ", but found " + Zt(se(n)) + " instead.") } return null }, he.prototype.eachChild = function (t) { this.args.forEach(t) }, he.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, he.prototype.serialize = function () { var t = this.type, e = [t.kind]; if ("array" === t.kind) { var n = t.itemType; if ("string" === n.kind || "number" === n.kind || "boolean" === n.kind) { e.push(n.kind); var r = t.N; ("number" == typeof r || this.args.length > 1) && e.push(r) } } return e.concat(this.args.map((function (t) { return t.serialize() }))) }; var fe = function (t) { this.type = Wt, this.sections = t }; fe.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var n = t[1]; if (!Array.isArray(n) && "object" == typeof n) return e.error("First argument must be an image or text section."); for (var r = [], i = !1, o = 1; o <= t.length - 1; ++o) { var a = t[o]; if (i && "object" == typeof a && !Array.isArray(a)) { i = !1; var s = null; if (a["font-scale"] && !(s = e.parse(a["font-scale"], 1, Ft))) return null; var l = null; if (a["text-font"] && !(l = e.parse(a["text-font"], 1, qt(Bt)))) return null; var u = null; if (a["text-color"] && !(u = e.parse(a["text-color"], 1, Ut))) return null; var c = r[r.length - 1]; c.scale = s, c.font = l, c.textColor = u } else { var p = e.parse(t[o], 1, Gt); if (!p) return null; var h = p.type.kind; if ("string" !== h && "value" !== h && "null" !== h && "resolvedImage" !== h) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); i = !0, r.push({ content: p, scale: null, font: null, textColor: null }) } } return new fe(r) }, fe.prototype.evaluate = function (t) { return new re(this.sections.map((function (e) { var n = e.content.evaluate(t); return se(n) === Xt ? new ne("", n, null, null, null) : new ne(le(n), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null) }))) }, fe.prototype.eachChild = function (t) { for (var e = 0, n = this.sections; e < n.length; e += 1) { var r = n[e]; t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor) } }, fe.prototype.outputDefined = function () { return !1 }, fe.prototype.serialize = function () { for (var t = ["format"], e = 0, n = this.sections; e < n.length; e += 1) { var r = n[e]; t.push(r.content.serialize()); var i = {}; r.scale && (i["font-scale"] = r.scale.serialize()), r.font && (i["text-font"] = r.font.serialize()), r.textColor && (i["text-color"] = r.textColor.serialize()), t.push(i) } return t }; var de = function (t) { this.type = Xt, this.input = t }; de.parse = function (t, e) { if (2 !== t.length) return e.error("Expected two arguments."); var n = e.parse(t[1], 1, Bt); return n ? new de(n) : e.error("No image name provided.") }, de.prototype.evaluate = function (t) { var e = this.input.evaluate(t), n = ie.fromString(e); return n && t.availableImages && (n.available = t.availableImages.indexOf(e) > -1), n }, de.prototype.eachChild = function (t) { t(this.input) }, de.prototype.outputDefined = function () { return !1 }, de.prototype.serialize = function () { return ["image", this.input.serialize()] }; var me = { "to-boolean": jt, "to-color": Ut, "to-number": Ft, "to-string": Bt }, ve = function (t, e) { this.type = t, this.args = e }; ve.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var n = t[0]; if (("to-boolean" === n || "to-string" === n) && 2 !== t.length) return e.error("Expected one argument."); for (var r = me[n], i = [], o = 1; o < t.length; o++) { var a = e.parse(t[o], o, Gt); if (!a) return null; i.push(a) } return new ve(r, i) }, ve.prototype.evaluate = function (t) { if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t)); if ("color" === this.type.kind) { for (var e, n, r = 0, i = this.args; r < i.length; r += 1) { if (n = null, (e = i[r].evaluate(t)) instanceof te) return e; if ("string" == typeof e) { var o = t.parseColor(e); if (o) return o } else if (Array.isArray(e) && !(n = e.length < 3 || e.length > 4 ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : oe(e[0], e[1], e[2], e[3]))) return new te(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) } throw new ce(n || "Could not parse color from value '" + ("string" == typeof e ? e : String(JSON.stringify(e))) + "'") } if ("number" === this.type.kind) { for (var a = null, s = 0, l = this.args; s < l.length; s += 1) { if (null === (a = l[s].evaluate(t))) return 0; var u = Number(a); if (!isNaN(u)) return u } throw new ce("Could not convert " + JSON.stringify(a) + " to number.") } return "formatted" === this.type.kind ? re.fromString(le(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? ie.fromString(le(this.args[0].evaluate(t))) : le(this.args[0].evaluate(t)) }, ve.prototype.eachChild = function (t) { this.args.forEach(t) }, ve.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, ve.prototype.serialize = function () { if ("formatted" === this.type.kind) return new fe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize(); if ("resolvedImage" === this.type.kind) return new de(this.args[0]).serialize(); var t = ["to-" + this.type.kind]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var ye = ["Unknown", "Point", "LineString", "Polygon"], ge = function () { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null }; ge.prototype.id = function () { return this.feature && "id" in this.feature ? this.feature.id : null }, ge.prototype.geometryType = function () { return this.feature ? "number" == typeof this.feature.type ? ye[this.feature.type] : this.feature.type : null }, ge.prototype.geometry = function () { return this.feature && "geometry" in this.feature ? this.feature.geometry : null }, ge.prototype.canonicalID = function () { return this.canonical }, ge.prototype.properties = function () { return this.feature && this.feature.properties || {} }, ge.prototype.parseColor = function (t) { var e = this._parseColorCache[t]; return e || (e = this._parseColorCache[t] = te.parse(t)), e }; var _e = function (t, e, n, r) { this.name = t, this.type = e, this._evaluate = n, this.args = r }; _e.prototype.evaluate = function (t) { return this._evaluate(t, this.args) }, _e.prototype.eachChild = function (t) { this.args.forEach(t) }, _e.prototype.outputDefined = function () { return !1 }, _e.prototype.serialize = function () { return [this.name].concat(this.args.map((function (t) { return t.serialize() }))) }, _e.parse = function (t, e) { var n, r = t[0], i = _e.definitions[r]; if (!i) return e.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0); for (var o = Array.isArray(i) ? i[0] : i.type, a = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s = a.filter((function (e) { var n = e[0]; return !Array.isArray(n) || n.length === t.length - 1 })), l = null, u = 0, c = s; u < c.length; u += 1) { var p = c[u], h = p[0], f = p[1]; l = new Ue(e.registry, e.path, null, e.scope); for (var d = [], m = !1, v = 1; v < t.length; v++) { var y = t[v], g = Array.isArray(h) ? h[v - 1] : h.type, _ = l.parse(y, 1 + d.length, g); if (!_) { m = !0; break } d.push(_) } if (!m) if (Array.isArray(h) && h.length !== d.length) l.error("Expected " + h.length + " arguments, but found " + d.length + " instead."); else { for (var x = 0; x < d.length; x++) { var b = Array.isArray(h) ? h[x] : h.type, w = d[x]; l.concat(x + 1).checkSubtype(b, w.type) } if (0 === l.errors.length) return new _e(r, o, f, d) } } if (1 === s.length) (n = e.errors).push.apply(n, l.errors); else { for (var S = (s.length ? s : a).map((function (t) { var e; return e = t[0], Array.isArray(e) ? "(" + e.map(Zt).join(", ") + ")" : "(" + Zt(e.type) + "...)" })).join(" | "), E = [], C = 1; C < t.length; C++) { var T = e.parse(t[C], 1 + E.length); if (!T) return null; E.push(Zt(T.type)) } e.error("Expected arguments of type " + S + ", but found (" + E.join(", ") + ") instead.") } return null }, _e.register = function (t, e) { for (var n in _e.definitions = e, e) t[n] = _e }; var xe = function (t, e, n) { this.type = Ht, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = e }; function be(t, e) { t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]) } function we(t, e) { return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]) } function Se(t, e) { var n = (180 + t[0]) / 360, r = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z); return [Math.round(n * i * 8192), Math.round(r * i * 8192)] } function Ee(t, e, n) { return e[1] > t[1] != n[1] > t[1] && t[0] < (n[0] - e[0]) * (t[1] - e[1]) / (n[1] - e[1]) + e[0] } function Ce(t, e) { for (var n, r, i, o, a, s, l, u = !1, c = 0, p = e.length; c < p; c++)for (var h = e[c], f = 0, d = h.length; f < d - 1; f++) { if ((o = (n = t)[0] - (r = h[f])[0]) * (l = n[1] - (i = h[f + 1])[1]) - (s = n[0] - i[0]) * (a = n[1] - r[1]) == 0 && o * s <= 0 && a * l <= 0) return !1; Ee(t, h[f], h[f + 1]) && (u = !u) } return u } function Te(t, e) { for (var n = 0; n < e.length; n++)if (Ce(t, e[n])) return !0; return !1 } function Ae(t, e, n, r) { var i = r[0] - n[0], o = r[1] - n[1], a = (t[0] - n[0]) * o - i * (t[1] - n[1]), s = (e[0] - n[0]) * o - i * (e[1] - n[1]); return a > 0 && s < 0 || a < 0 && s > 0 } function Me(t, e, n) { for (var r = 0, i = n; r < i.length; r += 1)for (var o = i[r], a = 0; a < o.length - 1; ++a)if (0 != (p = [(c = o[a + 1])[0] - (u = o[a])[0], c[1] - u[1]])[0] * (h = [(l = e)[0] - (s = t)[0], l[1] - s[1]])[1] - p[1] * h[0] && Ae(s, l, u, c) && Ae(u, c, s, l)) return !0; var s, l, u, c, p, h; return !1 } function Oe(t, e) { for (var n = 0; n < t.length; ++n)if (!Ce(t[n], e)) return !1; for (var r = 0; r < t.length - 1; ++r)if (Me(t[r], t[r + 1], e)) return !1; return !0 } function ke(t, e) { for (var n = 0; n < e.length; n++)if (Oe(t, e[n])) return !0; return !1 } function Ie(t, e, n) { for (var r = [], i = 0; i < t.length; i++) { for (var o = [], a = 0; a < t[i].length; a++) { var s = Se(t[i][a], n); be(e, s), o.push(s) } r.push(o) } return r } function Pe(t, e, n) { for (var r = [], i = 0; i < t.length; i++) { var o = Ie(t[i], e, n); r.push(o) } return r } function Le(t, e, n, r) { if (t[0] < n[0] || t[0] > n[2]) { var i = .5 * r, o = t[0] - n[0] > i ? -r : n[0] - t[0] > i ? r : 0; 0 === o && (o = t[0] - n[2] > i ? -r : n[2] - t[0] > i ? r : 0), t[0] += o } be(e, t) } function Re(t, e, n, r) { for (var i = 8192 * Math.pow(2, r.z), o = [8192 * r.x, 8192 * r.y], a = [], s = 0, l = t; s < l.length; s += 1)for (var u = 0, c = l[s]; u < c.length; u += 1) { var p = c[u], h = [p.x + o[0], p.y + o[1]]; Le(h, e, n, i), a.push(h) } return a } function De(t, e, n, r) { for (var i, o = 8192 * Math.pow(2, r.z), a = [8192 * r.x, 8192 * r.y], s = [], l = 0, u = t; l < u.length; l += 1) { for (var c = [], p = 0, h = u[l]; p < h.length; p += 1) { var f = h[p], d = [f.x + a[0], f.y + a[1]]; be(e, d), c.push(d) } s.push(c) } if (e[2] - e[0] <= o / 2) { (i = e)[0] = i[1] = 1 / 0, i[2] = i[3] = -1 / 0; for (var m = 0, v = s; m < v.length; m += 1)for (var y = 0, g = v[m]; y < g.length; y += 1)Le(g[y], e, n, o) } return s } xe.parse = function (t, e) { if (2 !== t.length) return e.error("Expected one argument."); var n = t[1]; if ("object" != typeof n || Array.isArray(n)) return e.error("Collator options argument must be an object."); var r = e.parse(void 0 !== n["case-sensitive"] && n["case-sensitive"], 1, jt); if (!r) return null; var i = e.parse(void 0 !== n["diacritic-sensitive"] && n["diacritic-sensitive"], 1, jt); if (!i) return null; var o = null; return n.locale && !(o = e.parse(n.locale, 1, Bt)) ? null : new xe(r, i, o) }, xe.prototype.evaluate = function (t) { return new ee(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null) }, xe.prototype.eachChild = function (t) { t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale) }, xe.prototype.outputDefined = function () { return !1 }, xe.prototype.serialize = function () { var t = {}; return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t] }; var Ne = function (t, e) { this.type = jt, this.geojson = t, this.geometries = e }; function ze(t) { if (t instanceof _e) { if ("get" === t.name && 1 === t.args.length) return !1; if ("feature-state" === t.name) return !1; if ("has" === t.name && 1 === t.args.length) return !1; if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1; if (/^filter-/.test(t.name)) return !1 } if (t instanceof Ne) return !1; var e = !0; return t.eachChild((function (t) { e && !ze(t) && (e = !1) })), e } function Fe(t) { if (t instanceof _e && "feature-state" === t.name) return !1; var e = !0; return t.eachChild((function (t) { e && !Fe(t) && (e = !1) })), e } function Be(t, e) { if (t instanceof _e && e.indexOf(t.name) >= 0) return !1; var n = !0; return t.eachChild((function (t) { n && !Be(t, e) && (n = !1) })), n } Ne.parse = function (t, e) { if (2 !== t.length) return e.error("'within' expression requires exactly one argument, but found " + (t.length - 1) + " instead."); if (ae(t[1])) { var n = t[1]; if ("FeatureCollection" === n.type) for (var r = 0; r < n.features.length; ++r) { var i = n.features[r].geometry.type; if ("Polygon" === i || "MultiPolygon" === i) return new Ne(n, n.features[r].geometry) } else if ("Feature" === n.type) { var o = n.geometry.type; if ("Polygon" === o || "MultiPolygon" === o) return new Ne(n, n.geometry) } else if ("Polygon" === n.type || "MultiPolygon" === n.type) return new Ne(n, n) } return e.error("'within' expression requires valid geojson object that contains polygon geometry type.") }, Ne.prototype.evaluate = function (t) { if (null != t.geometry() && null != t.canonicalID()) { if ("Point" === t.geometryType()) return function (t, e) { var n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t.canonicalID(); if ("Polygon" === e.type) { var o = Ie(e.coordinates, r, i), a = Re(t.geometry(), n, r, i); if (!we(n, r)) return !1; for (var s = 0, l = a; s < l.length; s += 1)if (!Ce(l[s], o)) return !1 } if ("MultiPolygon" === e.type) { var u = Pe(e.coordinates, r, i), c = Re(t.geometry(), n, r, i); if (!we(n, r)) return !1; for (var p = 0, h = c; p < h.length; p += 1)if (!Te(h[p], u)) return !1 } return !0 }(t, this.geometries); if ("LineString" === t.geometryType()) return function (t, e) { var n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t.canonicalID(); if ("Polygon" === e.type) { var o = Ie(e.coordinates, r, i), a = De(t.geometry(), n, r, i); if (!we(n, r)) return !1; for (var s = 0, l = a; s < l.length; s += 1)if (!Oe(l[s], o)) return !1 } if ("MultiPolygon" === e.type) { var u = Pe(e.coordinates, r, i), c = De(t.geometry(), n, r, i); if (!we(n, r)) return !1; for (var p = 0, h = c; p < h.length; p += 1)if (!ke(h[p], u)) return !1 } return !0 }(t, this.geometries) } return !1 }, Ne.prototype.eachChild = function () { }, Ne.prototype.outputDefined = function () { return !0 }, Ne.prototype.serialize = function () { return ["within", this.geojson] }; var je = function (t, e) { this.type = e.type, this.name = t, this.boundExpression = e }; je.parse = function (t, e) { if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument."); var n = t[1]; return e.scope.has(n) ? new je(n, e.scope.get(n)) : e.error('Unknown variable "' + n + '". Make sure "' + n + '" has been bound in an enclosing "let" expression before using it.', 1) }, je.prototype.evaluate = function (t) { return this.boundExpression.evaluate(t) }, je.prototype.eachChild = function () { }, je.prototype.outputDefined = function () { return !1 }, je.prototype.serialize = function () { return ["var", this.name] }; var Ue = function (t, e, n, r, i) { void 0 === e && (e = []), void 0 === r && (r = new Nt), void 0 === i && (i = []), this.registry = t, this.path = e, this.key = e.map((function (t) { return "[" + t + "]" })).join(""), this.scope = r, this.errors = i, this.expectedType = n }; function Ve(t, e) { for (var n, r = t.length - 1, i = 0, o = r, a = 0; i <= o;)if ((n = t[a = Math.floor((i + o) / 2)]) <= e) { if (a === r || e < t[a + 1]) return a; i = a + 1 } else { if (!(n > e)) throw new ce("Input is not a number."); o = a - 1 } return 0 } Ue.prototype.parse = function (t, e, n, r, i) { return void 0 === i && (i = {}), e ? this.concat(e, n, r)._parse(t, i) : this._parse(t, i) }, Ue.prototype._parse = function (t, e) { function n(t, e, n) { return "assert" === n ? new he(e, [t]) : "coerce" === n ? new ve(e, [t]) : t } if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) { if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); var r = t[0]; if ("string" != typeof r) return this.error("Expression name must be a string, but found " + typeof r + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null; var i = this.registry[r]; if (i) { var o = i.parse(t, this); if (!o) return null; if (this.expectedType) { var a = this.expectedType, s = o.type; if ("string" !== a.kind && "number" !== a.kind && "boolean" !== a.kind && "object" !== a.kind && "array" !== a.kind || "value" !== s.kind) if ("color" !== a.kind && "formatted" !== a.kind && "resolvedImage" !== a.kind || "value" !== s.kind && "string" !== s.kind) { if (this.checkSubtype(a, s)) return null } else o = n(o, a, e.typeAnnotation || "coerce"); else o = n(o, a, e.typeAnnotation || "assert") } if (!(o instanceof ue) && "resolvedImage" !== o.type.kind && function t(e) { if (e instanceof je) return t(e.boundExpression); if (e instanceof _e && "error" === e.name) return !1; if (e instanceof xe) return !1; if (e instanceof Ne) return !1; var n = e instanceof ve || e instanceof he, r = !0; return e.eachChild((function (e) { r = n ? r && t(e) : r && e instanceof ue })), !!r && ze(e) && Be(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) }(o)) { var l = new ge; try { o = new ue(o.type, o.evaluate(l)) } catch (t) { return this.error(t.message), null } } return o } return this.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0) } return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof t + " instead.") }, Ue.prototype.concat = function (t, e, n) { var r = "number" == typeof t ? this.path.concat(t) : this.path, i = n ? this.scope.concat(n) : this.scope; return new Ue(this.registry, r, e || null, i, this.errors) }, Ue.prototype.error = function (t) { for (var e = [], n = arguments.length - 1; n-- > 0;)e[n] = arguments[n + 1]; var r = "" + this.key + e.map((function (t) { return "[" + t + "]" })).join(""); this.errors.push(new Dt(r, t)) }, Ue.prototype.checkSubtype = function (t, e) { var n = Kt(t, e); return n && this.error(n), n }; var Ge = function (t, e, n) { this.type = t, this.input = e, this.labels = [], this.outputs = []; for (var r = 0, i = n; r < i.length; r += 1) { var o = i[r], a = o[1]; this.labels.push(o[0]), this.outputs.push(a) } }; function He(t, e, n) { return t * (1 - n) + e * n } Ge.parse = function (t, e) { if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); var n = e.parse(t[1], 1, Ft); if (!n) return null; var r = [], i = null; e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType); for (var o = 1; o < t.length; o += 2) { var a = 1 === o ? -1 / 0 : t[o], s = t[o + 1], l = o, u = o + 1; if ("number" != typeof a) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', l); if (r.length && r[r.length - 1][0] >= a) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', l); var c = e.parse(s, u, i); if (!c) return null; i = i || c.type, r.push([a, c]) } return new Ge(i, n, r) }, Ge.prototype.evaluate = function (t) { var e = this.labels, n = this.outputs; if (1 === e.length) return n[0].evaluate(t); var r = this.input.evaluate(t); if (r <= e[0]) return n[0].evaluate(t); var i = e.length; return r >= e[i - 1] ? n[i - 1].evaluate(t) : n[Ve(e, r)].evaluate(t) }, Ge.prototype.eachChild = function (t) { t(this.input); for (var e = 0, n = this.outputs; e < n.length; e += 1)t(n[e]) }, Ge.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) }, Ge.prototype.serialize = function () { for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++)e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize()); return t }; var We = Object.freeze({ __proto__: null, number: He, color: function (t, e, n) { return new te(He(t.r, e.r, n), He(t.g, e.g, n), He(t.b, e.b, n), He(t.a, e.a, n)) }, array: function (t, e, n) { return t.map((function (t, r) { return He(t, e[r], n) })) } }), Xe = 6 / 29 * 3 * (6 / 29), qe = Math.PI / 180, Ze = 180 / Math.PI; function Ye(t) { return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Xe + 4 / 29 } function Ke(t) { return t > 6 / 29 ? t * t * t : Xe * (t - 4 / 29) } function Qe(t) { return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) } function Je(t) { return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } function $e(t) { var e = Je(t.r), n = Je(t.g), r = Je(t.b), i = Ye((.4124564 * e + .3575761 * n + .1804375 * r) / .95047), o = Ye((.2126729 * e + .7151522 * n + .072175 * r) / 1); return { l: 116 * o - 16, a: 500 * (i - o), b: 200 * (o - Ye((.0193339 * e + .119192 * n + .9503041 * r) / 1.08883)), alpha: t.a } } function tn(t) { var e = (t.l + 16) / 116, n = isNaN(t.a) ? e : e + t.a / 500, r = isNaN(t.b) ? e : e - t.b / 200; return e = 1 * Ke(e), n = .95047 * Ke(n), r = 1.08883 * Ke(r), new te(Qe(3.2404542 * n - 1.5371385 * e - .4985314 * r), Qe(-.969266 * n + 1.8760108 * e + .041556 * r), Qe(.0556434 * n - .2040259 * e + 1.0572252 * r), t.alpha) } function en(t, e, n) { var r = e - t; return t + n * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) } var nn = { forward: $e, reverse: tn, interpolate: function (t, e, n) { return { l: He(t.l, e.l, n), a: He(t.a, e.a, n), b: He(t.b, e.b, n), alpha: He(t.alpha, e.alpha, n) } } }, rn = { forward: function (t) { var e = $e(t), n = e.l, r = e.a, i = e.b, o = Math.atan2(i, r) * Ze; return { h: o < 0 ? o + 360 : o, c: Math.sqrt(r * r + i * i), l: n, alpha: t.a } }, reverse: function (t) { var e = t.h * qe, n = t.c; return tn({ l: t.l, a: Math.cos(e) * n, b: Math.sin(e) * n, alpha: t.alpha }) }, interpolate: function (t, e, n) { return { h: en(t.h, e.h, n), c: He(t.c, e.c, n), l: He(t.l, e.l, n), alpha: He(t.alpha, e.alpha, n) } } }, on = Object.freeze({ __proto__: null, lab: nn, hcl: rn }), an = function (t, e, n, r, i) { this.type = t, this.operator = e, this.interpolation = n, this.input = r, this.labels = [], this.outputs = []; for (var o = 0, a = i; o < a.length; o += 1) { var s = a[o], l = s[1]; this.labels.push(s[0]), this.outputs.push(l) } }; function sn(t, e, n, r) { var i = r - n, o = t - n; return 0 === i ? 0 : 1 === e ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1) } an.interpolationFactor = function (t, e, r, i) { var o = 0; if ("exponential" === t.name) o = sn(e, t.base, r, i); else if ("linear" === t.name) o = sn(e, 1, r, i); else if ("cubic-bezier" === t.name) { var a = t.controlPoints; o = new n(a[0], a[1], a[2], a[3]).solve(sn(e, 1, r, i)) } return o }, an.parse = function (t, e) { var n = t[0], r = t[1], i = t[2], o = t.slice(3); if (!Array.isArray(r) || 0 === r.length) return e.error("Expected an interpolation type expression.", 1); if ("linear" === r[0]) r = { name: "linear" }; else if ("exponential" === r[0]) { var a = r[1]; if ("number" != typeof a) return e.error("Exponential interpolation requires a numeric base.", 1, 1); r = { name: "exponential", base: a } } else { if ("cubic-bezier" !== r[0]) return e.error("Unknown interpolation type " + String(r[0]), 1, 0); var s = r.slice(1); if (4 !== s.length || s.some((function (t) { return "number" != typeof t || t < 0 || t > 1 }))) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); r = { name: "cubic-bezier", controlPoints: s } } if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); if (!(i = e.parse(i, 2, Ft))) return null; var l = [], u = null; "interpolate-hcl" === n || "interpolate-lab" === n ? u = Ut : e.expectedType && "value" !== e.expectedType.kind && (u = e.expectedType); for (var c = 0; c < o.length; c += 2) { var p = o[c], h = o[c + 1], f = c + 3, d = c + 4; if ("number" != typeof p) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f); if (l.length && l[l.length - 1][0] >= p) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f); var m = e.parse(h, d, u); if (!m) return null; u = u || m.type, l.push([p, m]) } return "number" === u.kind || "color" === u.kind || "array" === u.kind && "number" === u.itemType.kind && "number" == typeof u.N ? new an(u, n, r, i, l) : e.error("Type " + Zt(u) + " is not interpolatable.") }, an.prototype.evaluate = function (t) { var e = this.labels, n = this.outputs; if (1 === e.length) return n[0].evaluate(t); var r = this.input.evaluate(t); if (r <= e[0]) return n[0].evaluate(t); var i = e.length; if (r >= e[i - 1]) return n[i - 1].evaluate(t); var o = Ve(e, r), a = an.interpolationFactor(this.interpolation, r, e[o], e[o + 1]), s = n[o].evaluate(t), l = n[o + 1].evaluate(t); return "interpolate" === this.operator ? We[this.type.kind.toLowerCase()](s, l, a) : "interpolate-hcl" === this.operator ? rn.reverse(rn.interpolate(rn.forward(s), rn.forward(l), a)) : nn.reverse(nn.interpolate(nn.forward(s), nn.forward(l), a)) }, an.prototype.eachChild = function (t) { t(this.input); for (var e = 0, n = this.outputs; e < n.length; e += 1)t(n[e]) }, an.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) }, an.prototype.serialize = function () { var t; t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints); for (var e = [this.operator, t, this.input.serialize()], n = 0; n < this.labels.length; n++)e.push(this.labels[n], this.outputs[n].serialize()); return e }; var ln = function (t, e) { this.type = t, this.args = e }; ln.parse = function (t, e) { if (t.length < 2) return e.error("Expectected at least one argument."); var n = null, r = e.expectedType; r && "value" !== r.kind && (n = r); for (var i = [], o = 0, a = t.slice(1); o < a.length; o += 1) { var s = e.parse(a[o], 1 + i.length, n, void 0, { typeAnnotation: "omit" }); if (!s) return null; n = n || s.type, i.push(s) } var l = r && i.some((function (t) { return Kt(r, t.type) })); return new ln(l ? Gt : n, i) }, ln.prototype.evaluate = function (t) { for (var e, n = null, r = 0, i = 0, o = this.args; i < o.length && (r++, (n = o[i].evaluate(t)) && n instanceof ie && !n.available && (e || (e = n.name), n = null, r === this.args.length && (n = e)), null === n); i += 1); return n }, ln.prototype.eachChild = function (t) { this.args.forEach(t) }, ln.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, ln.prototype.serialize = function () { var t = ["coalesce"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var un = function (t, e) { this.type = e.type, this.bindings = [].concat(t), this.result = e }; un.prototype.evaluate = function (t) { return this.result.evaluate(t) }, un.prototype.eachChild = function (t) { for (var e = 0, n = this.bindings; e < n.length; e += 1)t(n[e][1]); t(this.result) }, un.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead."); for (var n = [], r = 1; r < t.length - 1; r += 2) { var i = t[r]; if ("string" != typeof i) return e.error("Expected string, but found " + typeof i + " instead.", r); if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", r); var o = e.parse(t[r + 1], r + 1); if (!o) return null; n.push([i, o]) } var a = e.parse(t[t.length - 1], t.length - 1, e.expectedType, n); return a ? new un(n, a) : null }, un.prototype.outputDefined = function () { return this.result.outputDefined() }, un.prototype.serialize = function () { for (var t = ["let"], e = 0, n = this.bindings; e < n.length; e += 1) { var r = n[e]; t.push(r[0], r[1].serialize()) } return t.push(this.result.serialize()), t }; var cn = function (t, e, n) { this.type = t, this.index = e, this.input = n }; cn.parse = function (t, e) { if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1, Ft), r = e.parse(t[2], 2, qt(e.expectedType || Gt)); return n && r ? new cn(r.type.itemType, n, r) : null }, cn.prototype.evaluate = function (t) { var e = this.index.evaluate(t), n = this.input.evaluate(t); if (e < 0) throw new ce("Array index out of bounds: " + e + " < 0."); if (e >= n.length) throw new ce("Array index out of bounds: " + e + " > " + (n.length - 1) + "."); if (e !== Math.floor(e)) throw new ce("Array index must be an integer, but found " + e + " instead."); return n[e] }, cn.prototype.eachChild = function (t) { t(this.index), t(this.input) }, cn.prototype.outputDefined = function () { return !1 }, cn.prototype.serialize = function () { return ["at", this.index.serialize(), this.input.serialize()] }; var pn = function (t, e) { this.type = jt, this.needle = t, this.haystack = e }; pn.parse = function (t, e) { if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1, Gt), r = e.parse(t[2], 2, Gt); return n && r ? Qt(n.type, [jt, Bt, Ft, zt, Gt]) ? new pn(n, r) : e.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(n.type) + " instead") : null }, pn.prototype.evaluate = function (t) { var e = this.needle.evaluate(t), n = this.haystack.evaluate(t); if (!n) return !1; if (!Jt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Zt(se(e)) + " instead."); if (!Jt(n, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Zt(se(n)) + " instead."); return n.indexOf(e) >= 0 }, pn.prototype.eachChild = function (t) { t(this.needle), t(this.haystack) }, pn.prototype.outputDefined = function () { return !0 }, pn.prototype.serialize = function () { return ["in", this.needle.serialize(), this.haystack.serialize()] }; var hn = function (t, e, n) { this.type = Ft, this.needle = t, this.haystack = e, this.fromIndex = n }; hn.parse = function (t, e) { if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1, Gt), r = e.parse(t[2], 2, Gt); if (!n || !r) return null; if (!Qt(n.type, [jt, Bt, Ft, zt, Gt])) return e.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(n.type) + " instead"); if (4 === t.length) { var i = e.parse(t[3], 3, Ft); return i ? new hn(n, r, i) : null } return new hn(n, r) }, hn.prototype.evaluate = function (t) { var e = this.needle.evaluate(t), n = this.haystack.evaluate(t); if (!Jt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Zt(se(e)) + " instead."); if (!Jt(n, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Zt(se(n)) + " instead."); if (this.fromIndex) { var r = this.fromIndex.evaluate(t); return n.indexOf(e, r) } return n.indexOf(e) }, hn.prototype.eachChild = function (t) { t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex) }, hn.prototype.outputDefined = function () { return !1 }, hn.prototype.serialize = function () { if (null != this.fromIndex && void 0 !== this.fromIndex) { var t = this.fromIndex.serialize(); return ["index-of", this.needle.serialize(), this.haystack.serialize(), t] } return ["index-of", this.needle.serialize(), this.haystack.serialize()] }; var fn = function (t, e, n, r, i, o) { this.inputType = t, this.type = e, this.input = n, this.cases = r, this.outputs = i, this.otherwise = o }; fn.parse = function (t, e) { if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 1) return e.error("Expected an even number of arguments."); var n, r; e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType); for (var i = {}, o = [], a = 2; a < t.length - 1; a += 2) { var s = t[a], l = t[a + 1]; Array.isArray(s) || (s = [s]); var u = e.concat(a); if (0 === s.length) return u.error("Expected at least one branch label."); for (var c = 0, p = s; c < p.length; c += 1) { var h = p[c]; if ("number" != typeof h && "string" != typeof h) return u.error("Branch labels must be numbers or strings."); if ("number" == typeof h && Math.abs(h) > Number.MAX_SAFE_INTEGER) return u.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + "."); if ("number" == typeof h && Math.floor(h) !== h) return u.error("Numeric branch labels must be integer values."); if (n) { if (u.checkSubtype(n, se(h))) return null } else n = se(h); if (void 0 !== i[String(h)]) return u.error("Branch labels must be unique."); i[String(h)] = o.length } var f = e.parse(l, a, r); if (!f) return null; r = r || f.type, o.push(f) } var d = e.parse(t[1], 1, Gt); if (!d) return null; var m = e.parse(t[t.length - 1], t.length - 1, r); return m ? "value" !== d.type.kind && e.concat(1).checkSubtype(n, d.type) ? null : new fn(n, r, d, i, o, m) : null }, fn.prototype.evaluate = function (t) { var e = this.input.evaluate(t); return (se(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t) }, fn.prototype.eachChild = function (t) { t(this.input), this.outputs.forEach(t), t(this.otherwise) }, fn.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) && this.otherwise.outputDefined() }, fn.prototype.serialize = function () { for (var t = this, e = ["match", this.input.serialize()], n = [], r = {}, i = 0, o = Object.keys(this.cases).sort(); i < o.length; i += 1) { var a = o[i]; void 0 === (p = r[this.cases[a]]) ? (r[this.cases[a]] = n.length, n.push([this.cases[a], [a]])) : n[p][1].push(a) } for (var s = function (e) { return "number" === t.inputType.kind ? Number(e) : e }, l = 0, u = n; l < u.length; l += 1) { var c = u[l], p = c[0], h = c[1]; e.push(1 === h.length ? s(h[0]) : h.map(s)), e.push(this.outputs[outputIndex$1].serialize()) } return e.push(this.otherwise.serialize()), e }; var dn = function (t, e, n) { this.type = t, this.branches = e, this.otherwise = n }; dn.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 0) return e.error("Expected an odd number of arguments."); var n; e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType); for (var r = [], i = 1; i < t.length - 1; i += 2) { var o = e.parse(t[i], i, jt); if (!o) return null; var a = e.parse(t[i + 1], i + 1, n); if (!a) return null; r.push([o, a]), n = n || a.type } var s = e.parse(t[t.length - 1], t.length - 1, n); return s ? new dn(n, r, s) : null }, dn.prototype.evaluate = function (t) { for (var e = 0, n = this.branches; e < n.length; e += 1) { var r = n[e], i = r[1]; if (r[0].evaluate(t)) return i.evaluate(t) } return this.otherwise.evaluate(t) }, dn.prototype.eachChild = function (t) { for (var e = 0, n = this.branches; e < n.length; e += 1) { var r = n[e], i = r[1]; t(r[0]), t(i) } t(this.otherwise) }, dn.prototype.outputDefined = function () { return this.branches.every((function (t) { return t[1].outputDefined() })) && this.otherwise.outputDefined() }, dn.prototype.serialize = function () { var t = ["case"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var mn = function (t, e, n, r) { this.type = t, this.input = e, this.beginIndex = n, this.endIndex = r }; function vn(t, e) { return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind } function yn(t, e, n, r) { return 0 === r.compare(e, n) } function gn(t, e, n) { var r = "==" !== t && "!=" !== t; return function () { function i(t, e, n) { this.type = jt, this.lhs = t, this.rhs = e, this.collator = n, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind } return i.parse = function (t, e) { if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments."); var n = t[0], o = e.parse(t[1], 1, Gt); if (!o) return null; if (!vn(n, o.type)) return e.concat(1).error('"' + n + "\" comparisons are not supported for type '" + Zt(o.type) + "'."); var a = e.parse(t[2], 2, Gt); if (!a) return null; if (!vn(n, a.type)) return e.concat(2).error('"' + n + "\" comparisons are not supported for type '" + Zt(a.type) + "'."); if (o.type.kind !== a.type.kind && "value" !== o.type.kind && "value" !== a.type.kind) return e.error("Cannot compare types '" + Zt(o.type) + "' and '" + Zt(a.type) + "'."); r && ("value" === o.type.kind && "value" !== a.type.kind ? o = new he(a.type, [o]) : "value" !== o.type.kind && "value" === a.type.kind && (a = new he(o.type, [a]))); var s = null; if (4 === t.length) { if ("string" !== o.type.kind && "string" !== a.type.kind && "value" !== o.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types."); if (!(s = e.parse(t[3], 3, Ht))) return null } return new i(o, a, s) }, i.prototype.evaluate = function (i) { var o = this.lhs.evaluate(i), a = this.rhs.evaluate(i); if (r && this.hasUntypedArgument) { var s = se(o), l = se(a); if (s.kind !== l.kind || "string" !== s.kind && "number" !== s.kind) throw new ce('Expected arguments for "' + t + '" to be (string, string) or (number, number), but found (' + s.kind + ", " + l.kind + ") instead.") } if (this.collator && !r && this.hasUntypedArgument) { var u = se(o), c = se(a); if ("string" !== u.kind || "string" !== c.kind) return e(i, o, a) } return this.collator ? n(i, o, a, this.collator.evaluate(i)) : e(i, o, a) }, i.prototype.eachChild = function (t) { t(this.lhs), t(this.rhs), this.collator && t(this.collator) }, i.prototype.outputDefined = function () { return !0 }, i.prototype.serialize = function () { var e = [t]; return this.eachChild((function (t) { e.push(t.serialize()) })), e }, i }() } mn.parse = function (t, e) { if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1, Gt), r = e.parse(t[2], 2, Ft); if (!n || !r) return null; if (!Qt(n.type, [qt(Gt), Bt, Gt])) return e.error("Expected first argument to be of type array or string, but found " + Zt(n.type) + " instead"); if (4 === t.length) { var i = e.parse(t[3], 3, Ft); return i ? new mn(n.type, n, r, i) : null } return new mn(n.type, n, r) }, mn.prototype.evaluate = function (t) { var e = this.input.evaluate(t), n = this.beginIndex.evaluate(t); if (!Jt(e, ["string", "array"])) throw new ce("Expected first argument to be of type array or string, but found " + Zt(se(e)) + " instead."); if (this.endIndex) { var r = this.endIndex.evaluate(t); return e.slice(n, r) } return e.slice(n) }, mn.prototype.eachChild = function (t) { t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex) }, mn.prototype.outputDefined = function () { return !1 }, mn.prototype.serialize = function () { if (null != this.endIndex && void 0 !== this.endIndex) { var t = this.endIndex.serialize(); return ["slice", this.input.serialize(), this.beginIndex.serialize(), t] } return ["slice", this.input.serialize(), this.beginIndex.serialize()] }; var _n = gn("==", (function (t, e, n) { return e === n }), yn), xn = gn("!=", (function (t, e, n) { return e !== n }), (function (t, e, n, r) { return !yn(0, e, n, r) })), bn = gn("<", (function (t, e, n) { return e < n }), (function (t, e, n, r) { return r.compare(e, n) < 0 })), wn = gn(">", (function (t, e, n) { return e > n }), (function (t, e, n, r) { return r.compare(e, n) > 0 })), Sn = gn("<=", (function (t, e, n) { return e <= n }), (function (t, e, n, r) { return r.compare(e, n) <= 0 })), En = gn(">=", (function (t, e, n) { return e >= n }), (function (t, e, n, r) { return r.compare(e, n) >= 0 })), Cn = function (t, e, n, r, i) { this.type = Bt, this.number = t, this.locale = e, this.currency = n, this.minFractionDigits = r, this.maxFractionDigits = i }; Cn.parse = function (t, e) { if (3 !== t.length) return e.error("Expected two arguments."); var n = e.parse(t[1], 1, Ft); if (!n) return null; var r = t[2]; if ("object" != typeof r || Array.isArray(r)) return e.error("NumberFormat options argument must be an object."); var i = null; if (r.locale && !(i = e.parse(r.locale, 1, Bt))) return null; var o = null; if (r.currency && !(o = e.parse(r.currency, 1, Bt))) return null; var a = null; if (r["min-fraction-digits"] && !(a = e.parse(r["min-fraction-digits"], 1, Ft))) return null; var s = null; return r["max-fraction-digits"] && !(s = e.parse(r["max-fraction-digits"], 1, Ft)) ? null : new Cn(n, i, o, a, s) }, Cn.prototype.evaluate = function (t) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t)) }, Cn.prototype.eachChild = function (t) { t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits) }, Cn.prototype.outputDefined = function () { return !1 }, Cn.prototype.serialize = function () { var t = {}; return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t] }; var Tn = function (t) { this.type = Ft, this.input = t }; Tn.parse = function (t, e) { if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1); return n ? "array" !== n.type.kind && "string" !== n.type.kind && "value" !== n.type.kind ? e.error("Expected argument of type string or array, but found " + Zt(n.type) + " instead.") : new Tn(n) : null }, Tn.prototype.evaluate = function (t) { var e = this.input.evaluate(t); if ("string" == typeof e) return e.length; if (Array.isArray(e)) return e.length; throw new ce("Expected value to be of type string or array, but found " + Zt(se(e)) + " instead.") }, Tn.prototype.eachChild = function (t) { t(this.input) }, Tn.prototype.outputDefined = function () { return !1 }, Tn.prototype.serialize = function () { var t = ["length"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var An = { "==": _n, "!=": xn, ">": wn, "<": bn, ">=": En, "<=": Sn, array: he, at: cn, boolean: he, case: dn, coalesce: ln, collator: xe, format: fe, image: de, in: pn, "index-of": hn, interpolate: an, "interpolate-hcl": an, "interpolate-lab": an, length: Tn, let: un, literal: ue, match: fn, number: he, "number-format": Cn, object: he, slice: mn, step: Ge, string: he, "to-boolean": ve, "to-color": ve, "to-number": ve, "to-string": ve, var: je, within: Ne }; function Mn(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3]; n = n.evaluate(t), r = r.evaluate(t), i = i.evaluate(t); var a = o ? o.evaluate(t) : 1, s = oe(n, r, i, a); if (s) throw new ce(s); return new te(n / 255 * a, r / 255 * a, i / 255 * a, a) } function On(t, e) { return t in e } function kn(t, e) { var n = e[t]; return void 0 === n ? null : n } function In(t) { return { type: t } } function Pn(t) { return { result: "success", value: t } } function Ln(t) { return { result: "error", value: t } } function Rn(t) { return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"] } function Dn(t) { return !!t.expression && t.expression.parameters.indexOf("zoom") > -1 } function Nn(t) { return !!t.expression && t.expression.interpolated } function zn(t) { return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t } function Fn(t) { return "object" == typeof t && null !== t && !Array.isArray(t) } function Bn(t) { return t } function jn(t, e, n) { return void 0 !== t ? t : void 0 !== e ? e : void 0 !== n ? n : void 0 } function Un(t, e, n, r, i) { return jn(typeof n === i ? r[n] : void 0, t.default, e.default) } function Vn(t, e, n) { if ("number" !== zn(n)) return jn(t.default, e.default); var r = t.stops.length; if (1 === r) return t.stops[0][1]; if (n <= t.stops[0][0]) return t.stops[0][1]; if (n >= t.stops[r - 1][0]) return t.stops[r - 1][1]; var i = Ve(t.stops.map((function (t) { return t[0] })), n); return t.stops[i][1] } function Gn(t, e, n) { var r = void 0 !== t.base ? t.base : 1; if ("number" !== zn(n)) return jn(t.default, e.default); var i = t.stops.length; if (1 === i) return t.stops[0][1]; if (n <= t.stops[0][0]) return t.stops[0][1]; if (n >= t.stops[i - 1][0]) return t.stops[i - 1][1]; var o = Ve(t.stops.map((function (t) { return t[0] })), n), a = function (t, e, n, r) { var i = r - n, o = t - n; return 0 === i ? 0 : 1 === e ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1) }(n, r, t.stops[o][0], t.stops[o + 1][0]), s = t.stops[o][1], l = t.stops[o + 1][1], u = We[e.type] || Bn; if (t.colorSpace && "rgb" !== t.colorSpace) { var c = on[t.colorSpace]; u = function (t, e) { return c.reverse(c.interpolate(c.forward(t), c.forward(e), a)) } } return "function" == typeof s.evaluate ? { evaluate: function () { for (var t = [], e = arguments.length; e--;)t[e] = arguments[e]; var n = s.evaluate.apply(void 0, t), r = l.evaluate.apply(void 0, t); if (void 0 !== n && void 0 !== r) return u(n, r, a) } } : u(s, l, a) } function Hn(t, e, n) { return "color" === e.type ? n = te.parse(n) : "formatted" === e.type ? n = re.fromString(n.toString()) : "resolvedImage" === e.type ? n = ie.fromString(n.toString()) : zn(n) === e.type || "enum" === e.type && e.values[n] || (n = void 0), jn(n, t.default, e.default) } _e.register(An, { error: [{ kind: "error" }, [Bt], function (t, e) { throw new ce(e[0].evaluate(t)) }], typeof: [Bt, [Gt], function (t, e) { return Zt(se(e[0].evaluate(t))) }], "to-rgba": [qt(Ft, 4), [Ut], function (t, e) { return e[0].evaluate(t).toArray() }], rgb: [Ut, [Ft, Ft, Ft], Mn], rgba: [Ut, [Ft, Ft, Ft, Ft], Mn], has: { type: jt, overloads: [[[Bt], function (t, e) { return On(e[0].evaluate(t), t.properties()) }], [[Bt, Vt], function (t, e) { var n = e[1]; return On(e[0].evaluate(t), n.evaluate(t)) }]] }, get: { type: Gt, overloads: [[[Bt], function (t, e) { return kn(e[0].evaluate(t), t.properties()) }], [[Bt, Vt], function (t, e) { var n = e[1]; return kn(e[0].evaluate(t), n.evaluate(t)) }]] }, "feature-state": [Gt, [Bt], function (t, e) { return kn(e[0].evaluate(t), t.featureState || {}) }], properties: [Vt, [], function (t) { return t.properties() }], "geometry-type": [Bt, [], function (t) { return t.geometryType() }], id: [Gt, [], function (t) { return t.id() }], zoom: [Ft, [], function (t) { return t.globals.zoom }], "heatmap-density": [Ft, [], function (t) { return t.globals.heatmapDensity || 0 }], "line-progress": [Ft, [], function (t) { return t.globals.lineProgress || 0 }], accumulated: [Gt, [], function (t) { return void 0 === t.globals.accumulated ? null : t.globals.accumulated }], "+": [Ft, In(Ft), function (t, e) { for (var n = 0, r = 0, i = e; r < i.length; r += 1)n += i[r].evaluate(t); return n }], "*": [Ft, In(Ft), function (t, e) { for (var n = 1, r = 0, i = e; r < i.length; r += 1)n *= i[r].evaluate(t); return n }], "-": { type: Ft, overloads: [[[Ft, Ft], function (t, e) { var n = e[1]; return e[0].evaluate(t) - n.evaluate(t) }], [[Ft], function (t, e) { return -e[0].evaluate(t) }]] }, "/": [Ft, [Ft, Ft], function (t, e) { var n = e[1]; return e[0].evaluate(t) / n.evaluate(t) }], "%": [Ft, [Ft, Ft], function (t, e) { var n = e[1]; return e[0].evaluate(t) % n.evaluate(t) }], ln2: [Ft, [], function () { return Math.LN2 }], pi: [Ft, [], function () { return Math.PI }], e: [Ft, [], function () { return Math.E }], "^": [Ft, [Ft, Ft], function (t, e) { var n = e[1]; return Math.pow(e[0].evaluate(t), n.evaluate(t)) }], sqrt: [Ft, [Ft], function (t, e) { return Math.sqrt(e[0].evaluate(t)) }], log10: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) / Math.LN10 }], ln: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) }], log2: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) / Math.LN2 }], sin: [Ft, [Ft], function (t, e) { return Math.sin(e[0].evaluate(t)) }], cos: [Ft, [Ft], function (t, e) { return Math.cos(e[0].evaluate(t)) }], tan: [Ft, [Ft], function (t, e) { return Math.tan(e[0].evaluate(t)) }], asin: [Ft, [Ft], function (t, e) { return Math.asin(e[0].evaluate(t)) }], acos: [Ft, [Ft], function (t, e) { return Math.acos(e[0].evaluate(t)) }], atan: [Ft, [Ft], function (t, e) { return Math.atan(e[0].evaluate(t)) }], min: [Ft, In(Ft), function (t, e) { return Math.min.apply(Math, e.map((function (e) { return e.evaluate(t) }))) }], max: [Ft, In(Ft), function (t, e) { return Math.max.apply(Math, e.map((function (e) { return e.evaluate(t) }))) }], abs: [Ft, [Ft], function (t, e) { return Math.abs(e[0].evaluate(t)) }], round: [Ft, [Ft], function (t, e) { var n = e[0].evaluate(t); return n < 0 ? -Math.round(-n) : Math.round(n) }], floor: [Ft, [Ft], function (t, e) { return Math.floor(e[0].evaluate(t)) }], ceil: [Ft, [Ft], function (t, e) { return Math.ceil(e[0].evaluate(t)) }], "filter-==": [jt, [Bt, Gt], function (t, e) { var n = e[0], r = e[1]; return t.properties()[n.value] === r.value }], "filter-id-==": [jt, [Gt], function (t, e) { var n = e[0]; return t.id() === n.value }], "filter-type-==": [jt, [Bt], function (t, e) { var n = e[0]; return t.geometryType() === n.value }], "filter-<": [jt, [Bt, Gt], function (t, e) { var n = e[0], r = e[1], i = t.properties()[n.value], o = r.value; return typeof i == typeof o && i < o }], "filter-id-<": [jt, [Gt], function (t, e) { var n = e[0], r = t.id(), i = n.value; return typeof r == typeof i && r < i }], "filter->": [jt, [Bt, Gt], function (t, e) { var n = e[0], r = e[1], i = t.properties()[n.value], o = r.value; return typeof i == typeof o && i > o }], "filter-id->": [jt, [Gt], function (t, e) { var n = e[0], r = t.id(), i = n.value; return typeof r == typeof i && r > i }], "filter-<=": [jt, [Bt, Gt], function (t, e) { var n = e[0], r = e[1], i = t.properties()[n.value], o = r.value; return typeof i == typeof o && i <= o }], "filter-id-<=": [jt, [Gt], function (t, e) { var n = e[0], r = t.id(), i = n.value; return typeof r == typeof i && r <= i }], "filter->=": [jt, [Bt, Gt], function (t, e) { var n = e[0], r = e[1], i = t.properties()[n.value], o = r.value; return typeof i == typeof o && i >= o }], "filter-id->=": [jt, [Gt], function (t, e) { var n = e[0], r = t.id(), i = n.value; return typeof r == typeof i && r >= i }], "filter-has": [jt, [Gt], function (t, e) { return e[0].value in t.properties() }], "filter-has-id": [jt, [], function (t) { return null !== t.id() && void 0 !== t.id() }], "filter-type-in": [jt, [qt(Bt)], function (t, e) { return e[0].value.indexOf(t.geometryType()) >= 0 }], "filter-id-in": [jt, [qt(Gt)], function (t, e) { return e[0].value.indexOf(t.id()) >= 0 }], "filter-in-small": [jt, [Bt, qt(Gt)], function (t, e) { var n = e[0]; return e[1].value.indexOf(t.properties()[n.value]) >= 0 }], "filter-in-large": [jt, [Bt, qt(Gt)], function (t, e) { var n = e[0], r = e[1]; return function (t, e, n, r) { for (; n <= r;) { var i = n + r >> 1; if (e[i] === t) return !0; e[i] > t ? r = i - 1 : n = i + 1 } return !1 }(t.properties()[n.value], r.value, 0, r.value.length - 1) }], all: { type: jt, overloads: [[[jt, jt], function (t, e) { var n = e[1]; return e[0].evaluate(t) && n.evaluate(t) }], [In(jt), function (t, e) { for (var n = 0, r = e; n < r.length; n += 1)if (!r[n].evaluate(t)) return !1; return !0 }]] }, any: { type: jt, overloads: [[[jt, jt], function (t, e) { var n = e[1]; return e[0].evaluate(t) || n.evaluate(t) }], [In(jt), function (t, e) { for (var n = 0, r = e; n < r.length; n += 1)if (r[n].evaluate(t)) return !0; return !1 }]] }, "!": [jt, [jt], function (t, e) { return !e[0].evaluate(t) }], "is-supported-script": [jt, [Bt], function (t, e) { var n = t.globals && t.globals.isSupportedScript; return !n || n(e[0].evaluate(t)) }], upcase: [Bt, [Bt], function (t, e) { return e[0].evaluate(t).toUpperCase() }], downcase: [Bt, [Bt], function (t, e) { return e[0].evaluate(t).toLowerCase() }], concat: [Bt, In(Gt), function (t, e) { return e.map((function (e) { return le(e.evaluate(t)) })).join("") }], "resolved-locale": [Bt, [Ht], function (t, e) { return e[0].evaluate(t).resolvedLocale() }] }); var Wn = function (t, e) { this.expression = t, this._warningHistory = {}, this._evaluator = new ge, this._defaultValue = e ? function (t) { return "color" === t.type && Fn(t.default) ? new te(0, 0, 0, 0) : "color" === t.type ? te.parse(t.default) || null : void 0 === t.default ? null : t.default }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null }; function Xn(t) { return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in An } function qn(t, e) { var n = new Ue(An, [], e ? function (t) { var e = { color: Ut, string: Bt, number: Ft, enum: Bt, boolean: jt, formatted: Wt, resolvedImage: Xt }; return "array" === t.type ? qt(e[t.value] || Gt, t.length) : e[t.type] }(e) : void 0), r = n.parse(t, void 0, void 0, void 0, e && "string" === e.type ? { typeAnnotation: "coerce" } : void 0); return r ? Pn(new Wn(r, e)) : Ln(n.errors) } Wn.prototype.evaluateWithoutErrorHandling = function (t, e, n, r, i, o) { return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = n, this._evaluator.canonical = r, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o, this.expression.evaluate(this._evaluator) }, Wn.prototype.evaluate = function (t, e, n, r, i, o) { this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = n || null, this._evaluator.canonical = r, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o || null; try { var a = this.expression.evaluate(this._evaluator); if (null == a || "number" == typeof a && a != a) return this._defaultValue; if (this._enumValues && !(a in this._enumValues)) throw new ce("Expected value to be one of " + Object.keys(this._enumValues).map((function (t) { return JSON.stringify(t) })).join(", ") + ", but found " + JSON.stringify(a) + " instead."); return a } catch (t) { return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue } }; var Zn = function (t, e) { this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Fe(e.expression) }; Zn.prototype.evaluateWithoutErrorHandling = function (t, e, n, r, i, o) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, n, r, i, o) }, Zn.prototype.evaluate = function (t, e, n, r, i, o) { return this._styleExpression.evaluate(t, e, n, r, i, o) }; var Yn = function (t, e, n, r) { this.kind = t, this.zoomStops = n, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Fe(e.expression), this.interpolationType = r }; function Kn(t, e) { if ("error" === (t = qn(t, e)).result) return t; var n = t.value.expression, r = ze(n); if (!r && !Rn(e)) return Ln([new Dt("", "data expressions not supported")]); var i = Be(n, ["zoom"]); if (!i && !Dn(e)) return Ln([new Dt("", "zoom expressions not supported")]); var o = function t(e) { var n = null; if (e instanceof un) n = t(e.result); else if (e instanceof ln) for (var r = 0, i = e.args; r < i.length && !(n = t(i[r])); r += 1); else (e instanceof Ge || e instanceof an) && e.input instanceof _e && "zoom" === e.input.name && (n = e); return n instanceof Dt || e.eachChild((function (e) { var r = t(e); r instanceof Dt ? n = r : !n && r ? n = new Dt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && r && n !== r && (n = new Dt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) })), n }(n); return o || i ? o instanceof Dt ? Ln([o]) : o instanceof an && !Nn(e) ? Ln([new Dt("", '"interpolate" expressions cannot be used with this property')]) : Pn(o ? new Yn(r ? "camera" : "composite", t.value, o.labels, o instanceof an ? o.interpolation : void 0) : new Zn(r ? "constant" : "source", t.value)) : Ln([new Dt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } Yn.prototype.evaluateWithoutErrorHandling = function (t, e, n, r, i, o) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, n, r, i, o) }, Yn.prototype.evaluate = function (t, e, n, r, i, o) { return this._styleExpression.evaluate(t, e, n, r, i, o) }, Yn.prototype.interpolationFactor = function (t, e, n) { return this.interpolationType ? an.interpolationFactor(this.interpolationType, t, e, n) : 0 }; var Qn = function (t, e) { this._parameters = t, this._specification = e, Pt(this, function t(e, n) { var r, i, o, a = "color" === n.type, s = e.stops && "object" == typeof e.stops[0][0], l = s || !(s || void 0 !== e.property), u = e.type || (Nn(n) ? "exponential" : "interval"); if (a && ((e = Pt({}, e)).stops && (e.stops = e.stops.map((function (t) { return [t[0], te.parse(t[1])] }))), e.default = te.parse(e.default ? e.default : n.default)), e.colorSpace && "rgb" !== e.colorSpace && !on[e.colorSpace]) throw new Error("Unknown color space: " + e.colorSpace); if ("exponential" === u) r = Gn; else if ("interval" === u) r = Vn; else if ("categorical" === u) { r = Un, i = Object.create(null); for (var c = 0, p = e.stops; c < p.length; c += 1) { var h = p[c]; i[h[0]] = h[1] } o = typeof e.stops[0][0] } else { if ("identity" !== u) throw new Error('Unknown function type "' + u + '"'); r = Hn } if (s) { for (var f = {}, d = [], m = 0; m < e.stops.length; m++) { var v = e.stops[m], y = v[0].zoom; void 0 === f[y] && (f[y] = { zoom: y, type: e.type, property: e.property, default: e.default, stops: [] }, d.push(y)), f[y].stops.push([v[0].value, v[1]]) } for (var g = [], _ = 0, x = d; _ < x.length; _ += 1) { var b = x[_]; g.push([f[b].zoom, t(f[b], n)]) } var w = { name: "linear" }; return { kind: "composite", interpolationType: w, interpolationFactor: an.interpolationFactor.bind(void 0, w), zoomStops: g.map((function (t) { return t[0] })), evaluate: function (t, r) { var i = t.zoom; return Gn({ stops: g, base: e.base }, n, i).evaluate(i, r) } } } if (l) { var S = "exponential" === u ? { name: "exponential", base: void 0 !== e.base ? e.base : 1 } : null; return { kind: "camera", interpolationType: S, interpolationFactor: an.interpolationFactor.bind(void 0, S), zoomStops: e.stops.map((function (t) { return t[0] })), evaluate: function (t) { return r(e, n, t.zoom, i, o) } } } return { kind: "source", evaluate: function (t, a) { var s = a && a.properties ? a.properties[e.property] : void 0; return void 0 === s ? jn(e.default, n.default) : r(e, n, s, i, o) } } }(this._parameters, this._specification)) }; function Jn(t) { var e = t.key, n = t.value, r = t.valueSpec || {}, i = t.objectElementValidators || {}, o = t.style, a = t.styleSpec, s = [], l = zn(n); if ("object" !== l) return [new kt(e, n, "object expected, " + l + " found")]; for (var u in n) { var c = u.split(".")[0], p = r[c] || r["*"], h = void 0; if (i[c]) h = i[c]; else if (r[c]) h = Sr; else if (i["*"]) h = i["*"]; else { if (!r["*"]) { s.push(new kt(e, n[u], 'unknown property "' + u + '"')); continue } h = Sr } s = s.concat(h({ key: (e ? e + "." : e) + u, value: n[u], valueSpec: p, style: o, styleSpec: a, object: n, objectKey: u }, n)) } for (var f in r) i[f] || r[f].required && void 0 === r[f].default && void 0 === n[f] && s.push(new kt(e, n, 'missing required property "' + f + '"')); return s } function $n(t) { var e = t.value, n = t.valueSpec, r = t.style, i = t.styleSpec, o = t.key, a = t.arrayElementValidator || Sr; if ("array" !== zn(e)) return [new kt(o, e, "array expected, " + zn(e) + " found")]; if (n.length && e.length !== n.length) return [new kt(o, e, "array length " + n.length + " expected, length " + e.length + " found")]; if (n["min-length"] && e.length < n["min-length"]) return [new kt(o, e, "array length at least " + n["min-length"] + " expected, length " + e.length + " found")]; var s = { type: n.value, values: n.values }; i.$version < 7 && (s.function = n.function), "object" === zn(n.value) && (s = n.value); for (var l = [], u = 0; u < e.length; u++)l = l.concat(a({ array: e, arrayIndex: u, value: e[u], valueSpec: s, style: r, styleSpec: i, key: o + "[" + u + "]" })); return l } function tr(t) { var e = t.key, n = t.value, r = t.valueSpec, i = zn(n); return "number" === i && n != n && (i = "NaN"), "number" !== i ? [new kt(e, n, "number expected, " + i + " found")] : "minimum" in r && n < r.minimum ? [new kt(e, n, n + " is less than the minimum value " + r.minimum)] : "maximum" in r && n > r.maximum ? [new kt(e, n, n + " is greater than the maximum value " + r.maximum)] : [] } function er(t) { var e, n, r, i = t.valueSpec, o = Lt(t.value.type), a = {}, s = "categorical" !== o && void 0 === t.value.property, l = !s, u = "array" === zn(t.value.stops) && "array" === zn(t.value.stops[0]) && "object" === zn(t.value.stops[0][0]), c = Jn({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function (t) { if ("identity" === o) return [new kt(t.key, t.value, 'identity function may not have a "stops" property')]; var e = [], n = t.value; return e = e.concat($n({ key: t.key, value: n, valueSpec: t.valueSpec, style: t.style, styleSpec: t.styleSpec, arrayElementValidator: p })), "array" === zn(n) && 0 === n.length && e.push(new kt(t.key, n, "array must have at least one stop")), e }, default: function (t) { return Sr({ key: t.key, value: t.value, valueSpec: i, style: t.style, styleSpec: t.styleSpec }) } } }); return "identity" === o && s && c.push(new kt(t.key, t.value, 'missing required property "property"')), "identity" === o || t.value.stops || c.push(new kt(t.key, t.value, 'missing required property "stops"')), "exponential" === o && t.valueSpec.expression && !Nn(t.valueSpec) && c.push(new kt(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !Rn(t.valueSpec) ? c.push(new kt(t.key, t.value, "property functions not supported")) : s && !Dn(t.valueSpec) && c.push(new kt(t.key, t.value, "zoom functions not supported"))), "categorical" !== o && !u || void 0 !== t.value.property || c.push(new kt(t.key, t.value, '"property" property is required')), c; function p(t) { var e = [], o = t.value, s = t.key; if ("array" !== zn(o)) return [new kt(s, o, "array expected, " + zn(o) + " found")]; if (2 !== o.length) return [new kt(s, o, "array length 2 expected, length " + o.length + " found")]; if (u) { if ("object" !== zn(o[0])) return [new kt(s, o, "object expected, " + zn(o[0]) + " found")]; if (void 0 === o[0].zoom) return [new kt(s, o, "object stop key must have zoom")]; if (void 0 === o[0].value) return [new kt(s, o, "object stop key must have value")]; if (r && r > Lt(o[0].zoom)) return [new kt(s, o[0].zoom, "stop zoom values must appear in ascending order")]; Lt(o[0].zoom) !== r && (r = Lt(o[0].zoom), n = void 0, a = {}), e = e.concat(Jn({ key: s + "[0]", value: o[0], valueSpec: { zoom: {} }, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { zoom: tr, value: h } })) } else e = e.concat(h({ key: s + "[0]", value: o[0], valueSpec: {}, style: t.style, styleSpec: t.styleSpec }, o)); return Xn(Rt(o[1])) ? e.concat([new kt(s + "[1]", o[1], "expressions are not allowed in function stops.")]) : e.concat(Sr({ key: s + "[1]", value: o[1], valueSpec: i, style: t.style, styleSpec: t.styleSpec })) } function h(t, r) { var s = zn(t.value), l = Lt(t.value), u = null !== t.value ? t.value : r; if (e) { if (s !== e) return [new kt(t.key, u, s + " stop domain type must match previous stop domain type " + e)] } else e = s; if ("number" !== s && "string" !== s && "boolean" !== s) return [new kt(t.key, u, "stop domain value must be a number, string, or boolean")]; if ("number" !== s && "categorical" !== o) { var c = "number expected, " + s + " found"; return Rn(i) && void 0 === o && (c += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new kt(t.key, u, c)] } return "categorical" !== o || "number" !== s || isFinite(l) && Math.floor(l) === l ? "categorical" !== o && "number" === s && void 0 !== n && l < n ? [new kt(t.key, u, "stop domain values must appear in ascending order")] : (n = l, "categorical" === o && l in a ? [new kt(t.key, u, "stop domain values must be unique")] : (a[l] = !0, [])) : [new kt(t.key, u, "integer expected, found " + l)] } } function nr(t) { var e = ("property" === t.expressionContext ? Kn : qn)(Rt(t.value), t.valueSpec); if ("error" === e.result) return e.value.map((function (e) { return new kt("" + t.key + e.key, t.value, e.message) })); var n = e.value.expression || e.value._styleExpression.expression; if ("property" === t.expressionContext && "text-font" === t.propertyKey && !n.outputDefined()) return [new kt(t.key, t.value, 'Invalid data expression for "' + t.propertyKey + '". Output values must be contained as literals within the expression.')]; if ("property" === t.expressionContext && "layout" === t.propertyType && !Fe(n)) return [new kt(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')]; if ("filter" === t.expressionContext && !Fe(n)) return [new kt(t.key, t.value, '"feature-state" data expressions are not supported with filters.')]; if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) { if (!Be(n, ["zoom", "feature-state"])) return [new kt(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if ("cluster-initial" === t.expressionContext && !ze(n)) return [new kt(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function rr(t) { var e = t.key, n = t.value, r = t.valueSpec, i = []; return Array.isArray(r.values) ? -1 === r.values.indexOf(Lt(n)) && i.push(new kt(e, n, "expected one of [" + r.values.join(", ") + "], " + JSON.stringify(n) + " found")) : -1 === Object.keys(r.values).indexOf(Lt(n)) && i.push(new kt(e, n, "expected one of [" + Object.keys(r.values).join(", ") + "], " + JSON.stringify(n) + " found")), i } function ir(t) { if (!0 === t || !1 === t) return !0; if (!Array.isArray(t) || 0 === t.length) return !1; switch (t[0]) { case "has": return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1]; case "in": return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]); case "any": case "all": for (var e = 0, n = t.slice(1); e < n.length; e += 1) { var r = n[e]; if (!ir(r) && "boolean" != typeof r) return !1 } return !0; default: return !0 } } Qn.deserialize = function (t) { return new Qn(t._parameters, t._specification) }, Qn.serialize = function (t) { return { _parameters: t._parameters, _specification: t._specification } }; var or = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function ar(t) { if (null == t) return { filter: function () { return !0 }, needGeometry: !1 }; ir(t) || (t = lr(t)); var e = qn(t, or); if ("error" === e.result) throw new Error(e.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); return { filter: function (t, n, r) { return e.value.evaluate(t, n, {}, r) }, needGeometry: function t(e) { if (!Array.isArray(e)) return !1; if ("within" === e[0]) return !0; for (var n = 1; n < e.length; n++)if (t(e[n])) return !0; return !1 }(t) } } function sr(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function lr(t) { if (!t) return !0; var e, n = t[0]; return t.length <= 1 ? "any" !== n : "==" === n ? ur(t[1], t[2], "==") : "!=" === n ? hr(ur(t[1], t[2], "==")) : "<" === n || ">" === n || "<=" === n || ">=" === n ? ur(t[1], t[2], n) : "any" === n ? (e = t.slice(1), ["any"].concat(e.map(lr))) : "all" === n ? ["all"].concat(t.slice(1).map(lr)) : "none" === n ? ["all"].concat(t.slice(1).map(lr).map(hr)) : "in" === n ? cr(t[1], t.slice(2)) : "!in" === n ? hr(cr(t[1], t.slice(2))) : "has" === n ? pr(t[1]) : "!has" === n ? hr(pr(t[1])) : "within" !== n || t } function ur(t, e, n) { switch (t) { case "$type": return ["filter-type-" + n, e]; case "$id": return ["filter-id-" + n, e]; default: return ["filter-" + n, t, e] } } function cr(t, e) { if (0 === e.length) return !1; switch (t) { case "$type": return ["filter-type-in", ["literal", e]]; case "$id": return ["filter-id-in", ["literal", e]]; default: return e.length > 200 && !e.some((function (t) { return typeof t != typeof e[0] })) ? ["filter-in-large", t, ["literal", e.sort(sr)]] : ["filter-in-small", t, ["literal", e]] } } function pr(t) { switch (t) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", t] } } function hr(t) { return ["!", t] } function fr(t) { return ir(Rt(t.value)) ? nr(Pt({}, t, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t(e) { var n = e.value, r = e.key; if ("array" !== zn(n)) return [new kt(r, n, "array expected, " + zn(n) + " found")]; var i, o = e.styleSpec, a = []; if (n.length < 1) return [new kt(r, n, "filter array must have at least 1 element")]; switch (a = a.concat(rr({ key: r + "[0]", value: n[0], valueSpec: o.filter_operator, style: e.style, styleSpec: e.styleSpec })), Lt(n[0])) { case "<": case "<=": case ">": case ">=": n.length >= 2 && "$type" === Lt(n[1]) && a.push(new kt(r, n, '"$type" cannot be use with operator "' + n[0] + '"')); case "==": case "!=": 3 !== n.length && a.push(new kt(r, n, 'filter array for operator "' + n[0] + '" must have 3 elements')); case "in": case "!in": n.length >= 2 && "string" !== (i = zn(n[1])) && a.push(new kt(r + "[1]", n[1], "string expected, " + i + " found")); for (var s = 2; s < n.length; s++)i = zn(n[s]), "$type" === Lt(n[1]) ? a = a.concat(rr({ key: r + "[" + s + "]", value: n[s], valueSpec: o.geometry_type, style: e.style, styleSpec: e.styleSpec })) : "string" !== i && "number" !== i && "boolean" !== i && a.push(new kt(r + "[" + s + "]", n[s], "string, number, or boolean expected, " + i + " found")); break; case "any": case "all": case "none": for (var l = 1; l < n.length; l++)a = a.concat(t({ key: r + "[" + l + "]", value: n[l], style: e.style, styleSpec: e.styleSpec })); break; case "has": case "!has": i = zn(n[1]), 2 !== n.length ? a.push(new kt(r, n, 'filter array for "' + n[0] + '" operator must have 2 elements')) : "string" !== i && a.push(new kt(r + "[1]", n[1], "string expected, " + i + " found")); break; case "within": i = zn(n[1]), 2 !== n.length ? a.push(new kt(r, n, 'filter array for "' + n[0] + '" operator must have 2 elements')) : "object" !== i && a.push(new kt(r + "[1]", n[1], "object expected, " + i + " found")) }return a }(t) } function dr(t, e) { var n = t.key, r = t.style, i = t.styleSpec, o = t.value, a = t.objectKey, s = i[e + "_" + t.layerType]; if (!s) return []; var l = a.match(/^(.*)-transition$/); if ("paint" === e && l && s[l[1]] && s[l[1]].transition) return Sr({ key: n, value: o, valueSpec: i.transition, style: r, styleSpec: i }); var u, c = t.valueSpec || s[a]; if (!c) return [new kt(n, o, 'unknown property "' + a + '"')]; if ("string" === zn(o) && Rn(c) && !c.tokens && (u = /^{([^}]+)}$/.exec(o))) return [new kt(n, o, '"' + a + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(u[1]) + " }`.")]; var p = []; return "symbol" === t.layerType && ("text-field" === a && r && !r.glyphs && p.push(new kt(n, o, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Fn(Rt(o)) && "identity" === Lt(o.type) && p.push(new kt(n, o, '"text-font" does not support identity functions'))), p.concat(Sr({ key: t.key, value: o, valueSpec: c, style: r, styleSpec: i, expressionContext: "property", propertyType: e, propertyKey: a })) } function mr(t) { return dr(t, "paint") } function vr(t) { return dr(t, "layout") } function yr(t) { var e = [], n = t.value, r = t.key, i = t.style, o = t.styleSpec; n.type || n.ref || e.push(new kt(r, n, 'either "type" or "ref" is required')); var a, s = Lt(n.type), l = Lt(n.ref); if (n.id) for (var u = Lt(n.id), c = 0; c < t.arrayIndex; c++) { var p = i.layers[c]; Lt(p.id) === u && e.push(new kt(r, n.id, 'duplicate layer id "' + n.id + '", previously used at line ' + p.id.__line__)) } if ("ref" in n) ["type", "source", "source-layer", "filter", "layout"].forEach((function (t) { t in n && e.push(new kt(r, n[t], '"' + t + '" is prohibited for ref layers')) })), i.layers.forEach((function (t) { Lt(t.id) === l && (a = t) })), a ? a.ref ? e.push(new kt(r, n.ref, "ref cannot reference another ref layer")) : s = Lt(a.type) : e.push(new kt(r, n.ref, 'ref layer "' + l + '" not found')); else if ("background" !== s) if (n.source) { var h = i.sources && i.sources[n.source], f = h && Lt(h.type); h ? "vector" === f && "raster" === s ? e.push(new kt(r, n.source, 'layer "' + n.id + '" requires a raster source')) : "raster" === f && "raster" !== s ? e.push(new kt(r, n.source, 'layer "' + n.id + '" requires a vector source')) : "vector" !== f || n["source-layer"] ? "raster-dem" === f && "hillshade" !== s ? e.push(new kt(r, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !n.paint || !n.paint["line-gradient"] || "geojson" === f && h.lineMetrics || e.push(new kt(r, n, 'layer "' + n.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e.push(new kt(r, n, 'layer "' + n.id + '" must specify a "source-layer"')) : e.push(new kt(r, n.source, 'source "' + n.source + '" not found')) } else e.push(new kt(r, n, 'missing required property "source"')); return e = e.concat(Jn({ key: r, value: n, valueSpec: o.layer, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function () { return [] }, type: function () { return Sr({ key: r + ".type", value: n.type, valueSpec: o.layer.type, style: t.style, styleSpec: t.styleSpec, object: n, objectKey: "type" }) }, filter: fr, layout: function (t) { return Jn({ layer: n, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return vr(Pt({ layerType: s }, t)) } } }) }, paint: function (t) { return Jn({ layer: n, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return mr(Pt({ layerType: s }, t)) } } }) } } })) } function gr(t) { var e = t.value, n = t.key, r = zn(e); return "string" !== r ? [new kt(n, e, "string expected, " + r + " found")] : [] } var _r = { promoteId: function (t) { var e = t.key, n = t.value; if ("string" === zn(n)) return gr({ key: e, value: n }); var r = []; for (var i in n) r.push.apply(r, gr({ key: e + "." + i, value: n[i] })); return r } }; function xr(t) { var e = t.value, n = t.key, r = t.styleSpec, i = t.style; if (!e.type) return [new kt(n, e, '"type" is required')]; var o, a = Lt(e.type); switch (a) { case "vector": case "raster": case "raster-dem": return Jn({ key: n, value: e, valueSpec: r["source_" + a.replace("-", "_")], style: t.style, styleSpec: r, objectElementValidators: _r }); case "geojson": if (o = Jn({ key: n, value: e, valueSpec: r.source_geojson, style: i, styleSpec: r, objectElementValidators: _r }), e.cluster) for (var s in e.clusterProperties) { var l = e.clusterProperties[s], u = l[0], c = "string" == typeof u ? [u, ["accumulated"], ["get", s]] : u; o.push.apply(o, nr({ key: n + "." + s + ".map", value: l[1], expressionContext: "cluster-map" })), o.push.apply(o, nr({ key: n + "." + s + ".reduce", value: c, expressionContext: "cluster-reduce" })) } return o; case "video": return Jn({ key: n, value: e, valueSpec: r.source_video, style: i, styleSpec: r }); case "image": return Jn({ key: n, value: e, valueSpec: r.source_image, style: i, styleSpec: r }); case "canvas": return [new kt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return rr({ key: n + ".type", value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i, styleSpec: r }) } } function br(t) { var e = t.value, n = t.styleSpec, r = n.light, i = t.style, o = [], a = zn(e); if (void 0 === e) return o; if ("object" !== a) return o.concat([new kt("light", e, "object expected, " + a + " found")]); for (var s in e) { var l = s.match(/^(.*)-transition$/); o = o.concat(l && r[l[1]] && r[l[1]].transition ? Sr({ key: s, value: e[s], valueSpec: n.transition, style: i, styleSpec: n }) : r[s] ? Sr({ key: s, value: e[s], valueSpec: r[s], style: i, styleSpec: n }) : [new kt(s, e[s], 'unknown property "' + s + '"')]) } return o } var wr = { "*": function () { return [] }, array: $n, boolean: function (t) { var e = t.value, n = t.key, r = zn(e); return "boolean" !== r ? [new kt(n, e, "boolean expected, " + r + " found")] : [] }, number: tr, color: function (t) { var e = t.key, n = t.value, r = zn(n); return "string" !== r ? [new kt(e, n, "color expected, " + r + " found")] : null === $t(n) ? [new kt(e, n, 'color expected, "' + n + '" found')] : [] }, constants: It, enum: rr, filter: fr, function: er, layer: yr, object: Jn, source: xr, light: br, string: gr, formatted: function (t) { return 0 === gr(t).length ? [] : nr(t) }, resolvedImage: function (t) { return 0 === gr(t).length ? [] : nr(t) } }; function Sr(t) { var e = t.value, n = t.valueSpec, r = t.styleSpec; return n.expression && Fn(Lt(e)) ? er(t) : n.expression && Xn(Rt(e)) ? nr(t) : n.type && wr[n.type] ? wr[n.type](t) : Jn(Pt({}, t, { valueSpec: n.type ? r[n.type] : n })) } function Er(t) { var e = t.value, n = t.key, r = gr(t); return r.length || (-1 === e.indexOf("{fontstack}") && r.push(new kt(n, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && r.push(new kt(n, e, '"glyphs" url must include a "{range}" token'))), r } function Cr(t, e) { void 0 === e && (e = Ot); var n = []; return n = n.concat(Sr({ key: "", value: t, valueSpec: e.$root, styleSpec: e, style: t, objectElementValidators: { glyphs: Er, "*": function () { return [] } } })), t.constants && (n = n.concat(It({ key: "constants", value: t.constants, style: t, styleSpec: e }))), Tr(n) } function Tr(t) { return [].concat(t).sort((function (t, e) { return t.line - e.line })) } function Ar(t) { return function () { for (var e = [], n = arguments.length; n--;)e[n] = arguments[n]; return Tr(t.apply(this, e)) } } Cr.source = Ar(xr), Cr.light = Ar(br), Cr.layer = Ar(yr), Cr.filter = Ar(fr), Cr.paintProperty = Ar(mr), Cr.layoutProperty = Ar(vr); var Mr = Cr, Or = Mr.light, kr = Mr.paintProperty, Ir = Mr.layoutProperty; function Pr(t, e) { var n = !1; if (e && e.length) for (var r = 0, i = e; r < i.length; r += 1)t.fire(new At(new Error(i[r].message))), n = !0; return n } var Lr = Rr; function Rr(t, e, n) { var r = this.cells = []; if (t instanceof ArrayBuffer) { this.arrayBuffer = t; var i = new Int32Array(this.arrayBuffer); t = i[0], this.d = (e = i[1]) + 2 * (n = i[2]); for (var o = 0; o < this.d * this.d; o++) { var a = i[3 + o], s = i[3 + o + 1]; r.push(a === s ? null : i.subarray(a, s)) } var l = i[3 + r.length + 1]; this.keys = i.subarray(i[3 + r.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly } else { this.d = e + 2 * n; for (var u = 0; u < this.d * this.d; u++)r.push([]); this.keys = [], this.bboxes = [] } this.n = e, this.extent = t, this.padding = n, this.scale = e / t, this.uid = 0; var c = n / e * t; this.min = -c, this.max = t + c } Rr.prototype.insert = function (t, e, n, r, i) { this._forEachCell(e, n, r, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(n), this.bboxes.push(r), this.bboxes.push(i) }, Rr.prototype._insertReadonly = function () { throw "Cannot insert into a GridIndex created from an ArrayBuffer." }, Rr.prototype._insertCell = function (t, e, n, r, i, o) { this.cells[i].push(o) }, Rr.prototype.query = function (t, e, n, r, i) { var o = this.min, a = this.max; if (t <= o && e <= o && a <= n && a <= r && !i) return Array.prototype.slice.call(this.keys); var s = []; return this._forEachCell(t, e, n, r, this._queryCell, s, {}, i), s }, Rr.prototype._queryCell = function (t, e, n, r, i, o, a, s) { var l = this.cells[i]; if (null !== l) for (var u = this.keys, c = this.bboxes, p = 0; p < l.length; p++) { var h = l[p]; if (void 0 === a[h]) { var f = 4 * h; (s ? s(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && n >= c[f + 0] && r >= c[f + 1]) ? (a[h] = !0, o.push(u[h])) : a[h] = !1 } } }, Rr.prototype._forEachCell = function (t, e, n, r, i, o, a, s) { for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(n), p = this._convertToCellCoord(r), h = l; h <= c; h++)for (var f = u; f <= p; f++) { var d = this.d * f + h; if ((!s || s(this._convertFromCellCoord(h), this._convertFromCellCoord(f), this._convertFromCellCoord(h + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, n, r, d, o, a, s)) return } }, Rr.prototype._convertFromCellCoord = function (t) { return (t - this.padding) / this.scale }, Rr.prototype._convertToCellCoord = function (t) { return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)) }, Rr.prototype.toArrayBuffer = function () { if (this.arrayBuffer) return this.arrayBuffer; for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, n = 0, r = 0; r < this.cells.length; r++)n += this.cells[r].length; var i = new Int32Array(e + n + this.keys.length + this.bboxes.length); i[0] = this.extent, i[1] = this.n, i[2] = this.padding; for (var o = e, a = 0; a < t.length; a++) { var s = t[a]; i[3 + a] = o, i.set(s, o), o += s.length } return i[3 + t.length] = o, i.set(this.keys, o), i[3 + t.length + 1] = o += this.keys.length, i.set(this.bboxes, o), o += this.bboxes.length, i.buffer }; var Dr = a.ImageData, Nr = a.ImageBitmap, zr = {}; function Fr(t, e, n) { void 0 === n && (n = {}), Object.defineProperty(e, "_classRegistryKey", { value: t, writeable: !1 }), zr[t] = { klass: e, omit: n.omit || [], shallow: n.shallow || [] } } for (var Br in Fr("Object", Object), Lr.serialize = function (t, e) { var n = t.toArrayBuffer(); return e && e.push(n), { buffer: n } }, Lr.deserialize = function (t) { return new Lr(t.buffer) }, Fr("Grid", Lr), Fr("Color", te), Fr("Error", Error), Fr("ResolvedImage", ie), Fr("StylePropertyFunction", Qn), Fr("StyleExpression", Wn, { omit: ["_evaluator"] }), Fr("ZoomDependentExpression", Yn), Fr("ZoomConstantExpression", Zn), Fr("CompoundExpression", _e, { omit: ["_evaluate"] }), An) An[Br]._classRegistryKey || Fr("Expression_" + Br, An[Br]); function jr(t) { return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name) } function Ur(t) { return Nr && t instanceof Nr } function Vr(t, e) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t; if (jr(t) || Ur(t)) return e && e.push(t), t; if (ArrayBuffer.isView(t)) { var n = t; return e && e.push(n.buffer), n } if (t instanceof Dr) return e && e.push(t.data.buffer), t; if (Array.isArray(t)) { for (var r = [], i = 0, o = t; i < o.length; i += 1)r.push(Vr(o[i], e)); return r } if ("object" == typeof t) { var a = t.constructor, s = a._classRegistryKey; if (!s) throw new Error("can't serialize object of unregistered class"); var l = a.serialize ? a.serialize(t, e) : {}; if (!a.serialize) { for (var u in t) if (t.hasOwnProperty(u) && !(zr[s].omit.indexOf(u) >= 0)) { var c = t[u]; l[u] = zr[s].shallow.indexOf(u) >= 0 ? c : Vr(c, e) } t instanceof Error && (l.message = t.message) } if (l.$name) throw new Error("$name property is reserved for worker serialization logic."); return "Object" !== s && (l.$name = s), l } throw new Error("can't serialize object of type " + typeof t) } function Gr(t) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || jr(t) || Ur(t) || ArrayBuffer.isView(t) || t instanceof Dr) return t; if (Array.isArray(t)) return t.map(Gr); if ("object" == typeof t) { var e = t.$name || "Object", n = zr[e].klass; if (!n) throw new Error("can't deserialize unregistered class " + e); if (n.deserialize) return n.deserialize(t); for (var r = Object.create(n.prototype), i = 0, o = Object.keys(t); i < o.length; i += 1) { var a = o[i]; if ("$name" !== a) { var s = t[a]; r[a] = zr[e].shallow.indexOf(a) >= 0 ? s : Gr(s) } } return r } throw new Error("can't deserialize object of type " + typeof t) } var Hr = function () { this.first = !0 }; Hr.prototype.update = function (t, e) { var n = Math.floor(t); return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0)) }; var Wr = { "Latin-1 Supplement": function (t) { return t >= 128 && t <= 255 }, Arabic: function (t) { return t >= 1536 && t <= 1791 }, "Arabic Supplement": function (t) { return t >= 1872 && t <= 1919 }, "Arabic Extended-A": function (t) { return t >= 2208 && t <= 2303 }, "Hangul Jamo": function (t) { return t >= 4352 && t <= 4607 }, "Unified Canadian Aboriginal Syllabics": function (t) { return t >= 5120 && t <= 5759 }, Khmer: function (t) { return t >= 6016 && t <= 6143 }, "Unified Canadian Aboriginal Syllabics Extended": function (t) { return t >= 6320 && t <= 6399 }, "General Punctuation": function (t) { return t >= 8192 && t <= 8303 }, "Letterlike Symbols": function (t) { return t >= 8448 && t <= 8527 }, "Number Forms": function (t) { return t >= 8528 && t <= 8591 }, "Miscellaneous Technical": function (t) { return t >= 8960 && t <= 9215 }, "Control Pictures": function (t) { return t >= 9216 && t <= 9279 }, "Optical Character Recognition": function (t) { return t >= 9280 && t <= 9311 }, "Enclosed Alphanumerics": function (t) { return t >= 9312 && t <= 9471 }, "Geometric Shapes": function (t) { return t >= 9632 && t <= 9727 }, "Miscellaneous Symbols": function (t) { return t >= 9728 && t <= 9983 }, "Miscellaneous Symbols and Arrows": function (t) { return t >= 11008 && t <= 11263 }, "CJK Radicals Supplement": function (t) { return t >= 11904 && t <= 12031 }, "Kangxi Radicals": function (t) { return t >= 12032 && t <= 12255 }, "Ideographic Description Characters": function (t) { return t >= 12272 && t <= 12287 }, "CJK Symbols and Punctuation": function (t) { return t >= 12288 && t <= 12351 }, Hiragana: function (t) { return t >= 12352 && t <= 12447 }, Katakana: function (t) { return t >= 12448 && t <= 12543 }, Bopomofo: function (t) { return t >= 12544 && t <= 12591 }, "Hangul Compatibility Jamo": function (t) { return t >= 12592 && t <= 12687 }, Kanbun: function (t) { return t >= 12688 && t <= 12703 }, "Bopomofo Extended": function (t) { return t >= 12704 && t <= 12735 }, "CJK Strokes": function (t) { return t >= 12736 && t <= 12783 }, "Katakana Phonetic Extensions": function (t) { return t >= 12784 && t <= 12799 }, "Enclosed CJK Letters and Months": function (t) { return t >= 12800 && t <= 13055 }, "CJK Compatibility": function (t) { return t >= 13056 && t <= 13311 }, "CJK Unified Ideographs Extension A": function (t) { return t >= 13312 && t <= 19903 }, "Yijing Hexagram Symbols": function (t) { return t >= 19904 && t <= 19967 }, "CJK Unified Ideographs": function (t) { return t >= 19968 && t <= 40959 }, "Yi Syllables": function (t) { return t >= 40960 && t <= 42127 }, "Yi Radicals": function (t) { return t >= 42128 && t <= 42191 }, "Hangul Jamo Extended-A": function (t) { return t >= 43360 && t <= 43391 }, "Hangul Syllables": function (t) { return t >= 44032 && t <= 55215 }, "Hangul Jamo Extended-B": function (t) { return t >= 55216 && t <= 55295 }, "Private Use Area": function (t) { return t >= 57344 && t <= 63743 }, "CJK Compatibility Ideographs": function (t) { return t >= 63744 && t <= 64255 }, "Arabic Presentation Forms-A": function (t) { return t >= 64336 && t <= 65023 }, "Vertical Forms": function (t) { return t >= 65040 && t <= 65055 }, "CJK Compatibility Forms": function (t) { return t >= 65072 && t <= 65103 }, "Small Form Variants": function (t) { return t >= 65104 && t <= 65135 }, "Arabic Presentation Forms-B": function (t) { return t >= 65136 && t <= 65279 }, "Halfwidth and Fullwidth Forms": function (t) { return t >= 65280 && t <= 65519 } }; function Xr(t) { for (var e = 0, n = t; e < n.length; e += 1)if (qr(n[e].charCodeAt(0))) return !0; return !1 } function qr(t) { return !(746 !== t && 747 !== t && (t < 4352 || !(Wr["Bopomofo Extended"](t) || Wr.Bopomofo(t) || Wr["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Wr["CJK Compatibility Ideographs"](t) || Wr["CJK Compatibility"](t) || Wr["CJK Radicals Supplement"](t) || Wr["CJK Strokes"](t) || !(!Wr["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Wr["CJK Unified Ideographs Extension A"](t) || Wr["CJK Unified Ideographs"](t) || Wr["Enclosed CJK Letters and Months"](t) || Wr["Hangul Compatibility Jamo"](t) || Wr["Hangul Jamo Extended-A"](t) || Wr["Hangul Jamo Extended-B"](t) || Wr["Hangul Jamo"](t) || Wr["Hangul Syllables"](t) || Wr.Hiragana(t) || Wr["Ideographic Description Characters"](t) || Wr.Kanbun(t) || Wr["Kangxi Radicals"](t) || Wr["Katakana Phonetic Extensions"](t) || Wr.Katakana(t) && 12540 !== t || !(!Wr["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Wr["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Wr["Unified Canadian Aboriginal Syllabics"](t) || Wr["Unified Canadian Aboriginal Syllabics Extended"](t) || Wr["Vertical Forms"](t) || Wr["Yijing Hexagram Symbols"](t) || Wr["Yi Syllables"](t) || Wr["Yi Radicals"](t)))) } function Zr(t) { return !(qr(t) || function (t) { return !!(Wr["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Wr["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Wr["Letterlike Symbols"](t) || Wr["Number Forms"](t) || Wr["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Wr["Control Pictures"](t) && 9251 !== t || Wr["Optical Character Recognition"](t) || Wr["Enclosed Alphanumerics"](t) || Wr["Geometric Shapes"](t) || Wr["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Wr["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Wr["CJK Symbols and Punctuation"](t) || Wr.Katakana(t) || Wr["Private Use Area"](t) || Wr["CJK Compatibility Forms"](t) || Wr["Small Form Variants"](t) || Wr["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t) }(t)) } function Yr(t) { return t >= 1424 && t <= 2303 || Wr["Arabic Presentation Forms-A"](t) || Wr["Arabic Presentation Forms-B"](t) } function Kr(t, e) { return !(!e && Yr(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Wr.Khmer(t)) } function Qr(t) { for (var e = 0, n = t; e < n.length; e += 1)if (Yr(n[e].charCodeAt(0))) return !0; return !1 } var Jr = null, $r = "unavailable", ti = null, ei = function (t) { t && "string" == typeof t && t.indexOf("NetworkError") > -1 && ($r = "error"), Jr && Jr(t) }; function ni() { ri.fire(new Tt("pluginStateChange", { pluginStatus: $r, pluginURL: ti })) } var ri = new Mt, ii = function () { return $r }, oi = function () { if ("deferred" !== $r || !ti) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified"); $r = "loading", ni(), ti && xt({ url: ti }, (function (t) { t ? ei(t) : ($r = "loaded", ni()) })) }, ai = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function () { return "loaded" === $r || null != ai.applyArabicShaping }, isLoading: function () { return "loading" === $r }, setState: function (t) { $r = t.pluginStatus, ti = t.pluginURL }, isParsed: function () { return null != ai.applyArabicShaping && null != ai.processBidirectionalText && null != ai.processStyledBidirectionalText }, getPluginURL: function () { return ti } }, si = function (t, e) { this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Hr, this.transition = {}) }; si.prototype.isSupportedScript = function (t) { return function (t, e) { for (var n = 0, r = t; n < r.length; n += 1)if (!Kr(r[n].charCodeAt(0), e)) return !1; return !0 }(t, ai.isLoaded()) }, si.prototype.crossFadingFactor = function () { return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) }, si.prototype.getCrossfadeParameters = function () { var t = this.zoom, e = t - Math.floor(t), n = this.crossFadingFactor(); return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e + (1 - e) * n } : { fromScale: .5, toScale: 1, t: 1 - (1 - n) * e } }; var li = function (t, e) { this.property = t, this.value = e, this.expression = function (t, e) { if (Fn(t)) return new Qn(t, e); if (Xn(t)) { var n = Kn(t, e); if ("error" === n.result) throw new Error(n.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); return n.value } var r = t; return "string" == typeof t && "color" === e.type && (r = te.parse(t)), { kind: "constant", evaluate: function () { return r } } }(void 0 === e ? t.specification.default : e, t.specification) }; li.prototype.isDataDriven = function () { return "source" === this.expression.kind || "composite" === this.expression.kind }, li.prototype.possiblyEvaluate = function (t, e, n) { return this.property.possiblyEvaluate(this, t, e, n) }; var ui = function (t) { this.property = t, this.value = new li(t, void 0) }; ui.prototype.transitioned = function (t, e) { return new pi(this.property, this.value, e, h({}, t.transition, this.transition), t.now) }, ui.prototype.untransitioned = function () { return new pi(this.property, this.value, null, {}, 0) }; var ci = function (t) { this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues) }; ci.prototype.getValue = function (t) { return b(this._values[t].value.value) }, ci.prototype.setValue = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new ui(this._values[t].property)), this._values[t].value = new li(this._values[t].property, null === e ? void 0 : b(e)) }, ci.prototype.getTransition = function (t) { return b(this._values[t].transition) }, ci.prototype.setTransition = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new ui(this._values[t].property)), this._values[t].transition = b(e) || void 0 }, ci.prototype.serialize = function () { for (var t = {}, e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var r = n[e], i = this.getValue(r); void 0 !== i && (t[r] = i); var o = this.getTransition(r); void 0 !== o && (t[r + "-transition"] = o) } return t }, ci.prototype.transitioned = function (t, e) { for (var n = new hi(this._properties), r = 0, i = Object.keys(this._values); r < i.length; r += 1) { var o = i[r]; n._values[o] = this._values[o].transitioned(t, e._values[o]) } return n }, ci.prototype.untransitioned = function () { for (var t = new hi(this._properties), e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var r = n[e]; t._values[r] = this._values[r].untransitioned() } return t }; var pi = function (t, e, n, r, i) { this.property = t, this.value = e, this.begin = i + r.delay || 0, this.end = this.begin + r.duration || 0, t.specification.transition && (r.delay || r.duration) && (this.prior = n) }; pi.prototype.possiblyEvaluate = function (t, e, n) { var r = t.now || 0, i = this.value.possiblyEvaluate(t, e, n), o = this.prior; if (o) { if (r > this.end) return this.prior = null, i; if (this.value.isDataDriven()) return this.prior = null, i; if (r < this.begin) return o.possiblyEvaluate(t, e, n); var a = (r - this.begin) / (this.end - this.begin); return this.property.interpolate(o.possiblyEvaluate(t, e, n), i, function (t) { if (t <= 0) return 0; if (t >= 1) return 1; var e = t * t, n = e * t; return 4 * (t < .5 ? n : 3 * (t - e) + n - .75) }(a)) } return i }; var hi = function (t) { this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues) }; hi.prototype.possiblyEvaluate = function (t, e, n) { for (var r = new mi(this._properties), i = 0, o = Object.keys(this._values); i < o.length; i += 1) { var a = o[i]; r._values[a] = this._values[a].possiblyEvaluate(t, e, n) } return r }, hi.prototype.hasTransition = function () { for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1)if (this._values[e[t]].prior) return !0; return !1 }; var fi = function (t) { this._properties = t, this._values = Object.create(t.defaultPropertyValues) }; fi.prototype.getValue = function (t) { return b(this._values[t].value) }, fi.prototype.setValue = function (t, e) { this._values[t] = new li(this._values[t].property, null === e ? void 0 : b(e)) }, fi.prototype.serialize = function () { for (var t = {}, e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var r = n[e], i = this.getValue(r); void 0 !== i && (t[r] = i) } return t }, fi.prototype.possiblyEvaluate = function (t, e, n) { for (var r = new mi(this._properties), i = 0, o = Object.keys(this._values); i < o.length; i += 1) { var a = o[i]; r._values[a] = this._values[a].possiblyEvaluate(t, e, n) } return r }; var di = function (t, e, n) { this.property = t, this.value = e, this.parameters = n }; di.prototype.isConstant = function () { return "constant" === this.value.kind }, di.prototype.constantOr = function (t) { return "constant" === this.value.kind ? this.value.value : t }, di.prototype.evaluate = function (t, e, n, r) { return this.property.evaluate(this.value, this.parameters, t, e, n, r) }; var mi = function (t) { this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues) }; mi.prototype.get = function (t) { return this._values[t] }; var vi = function (t) { this.specification = t }; vi.prototype.possiblyEvaluate = function (t, e) { return t.expression.evaluate(e) }, vi.prototype.interpolate = function (t, e, n) { var r = We[this.specification.type]; return r ? r(t, e, n) : t }; var yi = function (t, e) { this.specification = t, this.overrides = e }; yi.prototype.possiblyEvaluate = function (t, e, n, r) { return new di(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? { kind: "constant", value: t.expression.evaluate(e, null, {}, n, r) } : t.expression, e) }, yi.prototype.interpolate = function (t, e, n) { if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t; if (void 0 === t.value.value || void 0 === e.value.value) return new di(this, { kind: "constant", value: void 0 }, t.parameters); var r = We[this.specification.type]; return r ? new di(this, { kind: "constant", value: r(t.value.value, e.value.value, n) }, t.parameters) : t }, yi.prototype.evaluate = function (t, e, n, r, i, o) { return "constant" === t.kind ? t.value : t.evaluate(e, n, r, i, o) }; var gi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (t, e, n, r) { if (void 0 === t.value) return new di(this, { kind: "constant", value: void 0 }, e); if ("constant" === t.expression.kind) { var i = t.expression.evaluate(e, null, {}, n, r), o = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i, a = this._calculate(o, o, o, e); return new di(this, { kind: "constant", value: a }, e) } if ("camera" === t.expression.kind) { var s = this._calculate(t.expression.evaluate({ zoom: e.zoom - 1 }), t.expression.evaluate({ zoom: e.zoom }), t.expression.evaluate({ zoom: e.zoom + 1 }), e); return new di(this, { kind: "constant", value: s }, e) } return new di(this, t.expression, e) }, e.prototype.evaluate = function (t, e, n, r, i, o) { if ("source" === t.kind) { var a = t.evaluate(e, n, r, i, o); return this._calculate(a, a, a, e) } return "composite" === t.kind ? this._calculate(t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, n, r), t.evaluate({ zoom: Math.floor(e.zoom) }, n, r), t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, n, r), e) : t.value }, e.prototype._calculate = function (t, e, n, r) { return r.zoom > r.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: n, to: e } }, e.prototype.interpolate = function (t) { return t }, e }(yi), _i = function (t) { this.specification = t }; _i.prototype.possiblyEvaluate = function (t, e, n, r) { if (void 0 !== t.value) { if ("constant" === t.expression.kind) { var i = t.expression.evaluate(e, null, {}, n, r); return this._calculate(i, i, i, e) } return this._calculate(t.expression.evaluate(new si(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new si(Math.floor(e.zoom), e)), t.expression.evaluate(new si(Math.floor(e.zoom + 1), e)), e) } }, _i.prototype._calculate = function (t, e, n, r) { return r.zoom > r.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: n, to: e } }, _i.prototype.interpolate = function (t) { return t }; var xi = function (t) { this.specification = t }; xi.prototype.possiblyEvaluate = function (t, e, n, r) { return !!t.expression.evaluate(e, null, {}, n, r) }, xi.prototype.interpolate = function () { return !1 }; var bi = function (t) { for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t) { var n = t[e]; n.specification.overridable && this.overridableProperties.push(e); var r = this.defaultPropertyValues[e] = new li(n, void 0), i = this.defaultTransitionablePropertyValues[e] = new ui(n); this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = r.possiblyEvaluate({}) } }; Fr("DataDrivenProperty", yi), Fr("DataConstantProperty", vi), Fr("CrossFadedDataDrivenProperty", gi), Fr("CrossFadedProperty", _i), Fr("ColorRampProperty", xi); var wi = function (t) { function e(e, n) { if (t.call(this), this.id = e.id, this.type = e.type, this._featureFilter = { filter: function () { return !0 }, needGeometry: !1 }, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), n.layout && (this._unevaluatedLayout = new fi(n.layout)), n.paint)) { for (var r in this._transitionablePaint = new ci(n.paint), e.paint) this.setPaintProperty(r, e.paint[r], { validate: !1 }); for (var i in e.layout) this.setLayoutProperty(i, e.layout[i], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(n.paint) } } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getCrossfadeParameters = function () { return this._crossfadeParameters }, e.prototype.getLayoutProperty = function (t) { return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t) }, e.prototype.setLayoutProperty = function (t, e, n) { void 0 === n && (n = {}), null != e && this._validate(Ir, "layers." + this.id + ".layout." + t, t, e, n) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e) }, e.prototype.getPaintProperty = function (t) { return g(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t) }, e.prototype.setPaintProperty = function (t, e, n) { if (void 0 === n && (n = {}), null != e && this._validate(kr, "layers." + this.id + ".paint." + t, t, e, n)) return !1; if (g(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1; var r = this._transitionablePaint._values[t], i = "cross-faded-data-driven" === r.property.specification["property-type"], o = r.value.isDataDriven(), a = r.value; this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t); var s = this._transitionablePaint._values[t].value; return s.isDataDriven() || o || i || this._handleOverridablePaintPropertyUpdate(t, a, s) }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, e, n) { return !1 }, e.prototype.isHidden = function (t) { return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility }, e.prototype.updateTransitions = function (t) { this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint) }, e.prototype.hasTransition = function () { return this._transitioningPaint.hasTransition() }, e.prototype.recalculate = function (t, e) { t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e) }, e.prototype.serialize = function () { var t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), x(t, (function (t, e) { return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length) })) }, e.prototype._validate = function (t, e, n, r, i) { return void 0 === i && (i = {}), (!i || !1 !== i.validate) && Pr(this, t.call(Mr, { key: e, layerType: this.type, objectKey: n, value: r, styleSpec: Ot, style: { glyphs: !0, sprite: !0 } })) }, e.prototype.is3D = function () { return !1 }, e.prototype.isTileClipped = function () { return !1 }, e.prototype.hasOffscreenPass = function () { return !1 }, e.prototype.resize = function () { }, e.prototype.isStateDependent = function () { for (var t in this.paint._values) { var e = this.paint.get(t); if (e instanceof di && Rn(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0 } return !1 }, e }(Mt), Si = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Ei = function (t, e) { this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 }, Ci = function () { this.isTransferred = !1, this.capacity = -1, this.resize(0) }; function Ti(t, e) { void 0 === e && (e = 1); var n = 0, r = 0; return { members: t.map((function (t) { var i = Si[t.type].BYTES_PER_ELEMENT, o = n = Ai(n, Math.max(e, i)), a = t.components || 1; return r = Math.max(r, i), n += i * a, { name: t.name, type: t.type, components: a, offset: o } })), size: Ai(n, Math.max(r, e)), alignment: e } } function Ai(t, e) { return Math.ceil(t / e) * e } Ci.serialize = function (t, e) { return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer } }, Ci.deserialize = function (t) { var e = Object.create(this.prototype); return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e }, Ci.prototype._trim = function () { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) }, Ci.prototype.clear = function () { this.length = 0 }, Ci.prototype.resize = function (t) { this.reserve(t), this.length = t }, Ci.prototype.reserve = function (t) { if (t > this.capacity) { this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); var e = this.uint8; this._refreshViews(), e && this.uint8.set(e) } }, Ci.prototype._refreshViews = function () { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") }; var Mi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e) }, e.prototype.emplace = function (t, e, n) { var r = 2 * t; return this.int16[r + 0] = e, this.int16[r + 1] = n, t }, e }(Ci); Mi.prototype.bytesPerElement = 4, Fr("StructArrayLayout2i4", Mi); var Oi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e, n, r) }, e.prototype.emplace = function (t, e, n, r, i) { var o = 4 * t; return this.int16[o + 0] = e, this.int16[o + 1] = n, this.int16[o + 2] = r, this.int16[o + 3] = i, t }, e }(Ci); Oi.prototype.bytesPerElement = 8, Fr("StructArrayLayout4i8", Oi); var ki = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o) { var a = this.length; return this.resize(a + 1), this.emplace(a, t, e, n, r, i, o) }, e.prototype.emplace = function (t, e, n, r, i, o, a) { var s = 6 * t; return this.int16[s + 0] = e, this.int16[s + 1] = n, this.int16[s + 2] = r, this.int16[s + 3] = i, this.int16[s + 4] = o, this.int16[s + 5] = a, t }, e }(Ci); ki.prototype.bytesPerElement = 12, Fr("StructArrayLayout2i4i12", ki); var Ii = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o) { var a = this.length; return this.resize(a + 1), this.emplace(a, t, e, n, r, i, o) }, e.prototype.emplace = function (t, e, n, r, i, o, a) { var s = 4 * t, l = 8 * t; return this.int16[s + 0] = e, this.int16[s + 1] = n, this.uint8[l + 4] = r, this.uint8[l + 5] = i, this.uint8[l + 6] = o, this.uint8[l + 7] = a, t }, e }(Ci); Ii.prototype.bytesPerElement = 8, Fr("StructArrayLayout2i4ub8", Ii); var Pi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e) }, e.prototype.emplace = function (t, e, n) { var r = 2 * t; return this.float32[r + 0] = e, this.float32[r + 1] = n, t }, e }(Ci); Pi.prototype.bytesPerElement = 8, Fr("StructArrayLayout2f8", Pi); var Li = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o, a, s, l, u) { var c = this.length; return this.resize(c + 1), this.emplace(c, t, e, n, r, i, o, a, s, l, u) }, e.prototype.emplace = function (t, e, n, r, i, o, a, s, l, u, c) { var p = 10 * t; return this.uint16[p + 0] = e, this.uint16[p + 1] = n, this.uint16[p + 2] = r, this.uint16[p + 3] = i, this.uint16[p + 4] = o, this.uint16[p + 5] = a, this.uint16[p + 6] = s, this.uint16[p + 7] = l, this.uint16[p + 8] = u, this.uint16[p + 9] = c, t }, e }(Ci); Li.prototype.bytesPerElement = 20, Fr("StructArrayLayout10ui20", Li); var Ri = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o, a, s, l, u, c, p) { var h = this.length; return this.resize(h + 1), this.emplace(h, t, e, n, r, i, o, a, s, l, u, c, p) }, e.prototype.emplace = function (t, e, n, r, i, o, a, s, l, u, c, p, h) { var f = 12 * t; return this.int16[f + 0] = e, this.int16[f + 1] = n, this.int16[f + 2] = r, this.int16[f + 3] = i, this.uint16[f + 4] = o, this.uint16[f + 5] = a, this.uint16[f + 6] = s, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = p, this.int16[f + 11] = h, t }, e }(Ci); Ri.prototype.bytesPerElement = 24, Fr("StructArrayLayout4i4ui4i24", Ri); var Di = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, n) }, e.prototype.emplace = function (t, e, n, r) { var i = 3 * t; return this.float32[i + 0] = e, this.float32[i + 1] = n, this.float32[i + 2] = r, t }, e }(Ci); Di.prototype.bytesPerElement = 12, Fr("StructArrayLayout3f12", Di); var Ni = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.uint32[1 * t + 0] = e, t }, e }(Ci); Ni.prototype.bytesPerElement = 4, Fr("StructArrayLayout1ul4", Ni); var zi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o, a, s, l) { var u = this.length; return this.resize(u + 1), this.emplace(u, t, e, n, r, i, o, a, s, l) }, e.prototype.emplace = function (t, e, n, r, i, o, a, s, l, u) { var c = 10 * t, p = 5 * t; return this.int16[c + 0] = e, this.int16[c + 1] = n, this.int16[c + 2] = r, this.int16[c + 3] = i, this.int16[c + 4] = o, this.int16[c + 5] = a, this.uint32[p + 3] = s, this.uint16[c + 8] = l, this.uint16[c + 9] = u, t }, e }(Ci); zi.prototype.bytesPerElement = 20, Fr("StructArrayLayout6i1ul2ui20", zi); var Fi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o) { var a = this.length; return this.resize(a + 1), this.emplace(a, t, e, n, r, i, o) }, e.prototype.emplace = function (t, e, n, r, i, o, a) { var s = 6 * t; return this.int16[s + 0] = e, this.int16[s + 1] = n, this.int16[s + 2] = r, this.int16[s + 3] = i, this.int16[s + 4] = o, this.int16[s + 5] = a, t }, e }(Ci); Fi.prototype.bytesPerElement = 12, Fr("StructArrayLayout2i2i2i12", Fi); var Bi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i) { var o = this.length; return this.resize(o + 1), this.emplace(o, t, e, n, r, i) }, e.prototype.emplace = function (t, e, n, r, i, o) { var a = 4 * t, s = 8 * t; return this.float32[a + 0] = e, this.float32[a + 1] = n, this.float32[a + 2] = r, this.int16[s + 6] = i, this.int16[s + 7] = o, t }, e }(Ci); Bi.prototype.bytesPerElement = 16, Fr("StructArrayLayout2f1f2i16", Bi); var ji = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e, n, r) }, e.prototype.emplace = function (t, e, n, r, i) { var o = 12 * t, a = 3 * t; return this.uint8[o + 0] = e, this.uint8[o + 1] = n, this.float32[a + 1] = r, this.float32[a + 2] = i, t }, e }(Ci); ji.prototype.bytesPerElement = 12, Fr("StructArrayLayout2ub2f12", ji); var Ui = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, n) }, e.prototype.emplace = function (t, e, n, r) { var i = 3 * t; return this.uint16[i + 0] = e, this.uint16[i + 1] = n, this.uint16[i + 2] = r, t }, e }(Ci); Ui.prototype.bytesPerElement = 6, Fr("StructArrayLayout3ui6", Ui); var Vi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v) { var y = this.length; return this.resize(y + 1), this.emplace(y, t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v) }, e.prototype.emplace = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v, y) { var g = 24 * t, _ = 12 * t, x = 48 * t; return this.int16[g + 0] = e, this.int16[g + 1] = n, this.uint16[g + 2] = r, this.uint16[g + 3] = i, this.uint32[_ + 2] = o, this.uint32[_ + 3] = a, this.uint32[_ + 4] = s, this.uint16[g + 10] = l, this.uint16[g + 11] = u, this.uint16[g + 12] = c, this.float32[_ + 7] = p, this.float32[_ + 8] = h, this.uint8[x + 36] = f, this.uint8[x + 37] = d, this.uint8[x + 38] = m, this.uint32[_ + 10] = v, this.int16[g + 22] = y, t }, e }(Ci); Vi.prototype.bytesPerElement = 48, Fr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Vi); var Gi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v, y, g, _, x, b, w, S, E, C, T, A) { var M = this.length; return this.resize(M + 1), this.emplace(M, t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v, y, g, _, x, b, w, S, E, C, T, A) }, e.prototype.emplace = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v, y, g, _, x, b, w, S, E, C, T, A, M) { var O = 34 * t, k = 17 * t; return this.int16[O + 0] = e, this.int16[O + 1] = n, this.int16[O + 2] = r, this.int16[O + 3] = i, this.int16[O + 4] = o, this.int16[O + 5] = a, this.int16[O + 6] = s, this.int16[O + 7] = l, this.uint16[O + 8] = u, this.uint16[O + 9] = c, this.uint16[O + 10] = p, this.uint16[O + 11] = h, this.uint16[O + 12] = f, this.uint16[O + 13] = d, this.uint16[O + 14] = m, this.uint16[O + 15] = v, this.uint16[O + 16] = y, this.uint16[O + 17] = g, this.uint16[O + 18] = _, this.uint16[O + 19] = x, this.uint16[O + 20] = b, this.uint16[O + 21] = w, this.uint16[O + 22] = S, this.uint32[k + 12] = E, this.float32[k + 13] = C, this.float32[k + 14] = T, this.float32[k + 15] = A, this.float32[k + 16] = M, t }, e }(Ci); Gi.prototype.bytesPerElement = 68, Fr("StructArrayLayout8i15ui1ul4f68", Gi); var Hi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.float32[1 * t + 0] = e, t }, e }(Ci); Hi.prototype.bytesPerElement = 4, Fr("StructArrayLayout1f4", Hi); var Wi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, n) }, e.prototype.emplace = function (t, e, n, r) { var i = 3 * t; return this.int16[i + 0] = e, this.int16[i + 1] = n, this.int16[i + 2] = r, t }, e }(Ci); Wi.prototype.bytesPerElement = 6, Fr("StructArrayLayout3i6", Wi); var Xi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, n) }, e.prototype.emplace = function (t, e, n, r) { var i = 4 * t; return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = n, this.uint16[i + 3] = r, t }, e }(Ci); Xi.prototype.bytesPerElement = 8, Fr("StructArrayLayout1ul2ui8", Xi); var qi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e) }, e.prototype.emplace = function (t, e, n) { var r = 2 * t; return this.uint16[r + 0] = e, this.uint16[r + 1] = n, t }, e }(Ci); qi.prototype.bytesPerElement = 4, Fr("StructArrayLayout2ui4", qi); var Zi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.uint16[1 * t + 0] = e, t }, e }(Ci); Zi.prototype.bytesPerElement = 2, Fr("StructArrayLayout1ui2", Zi); var Yi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, n, r) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e, n, r) }, e.prototype.emplace = function (t, e, n, r, i) { var o = 4 * t; return this.float32[o + 0] = e, this.float32[o + 1] = n, this.float32[o + 2] = r, this.float32[o + 3] = i, t }, e }(Ci); Yi.prototype.bytesPerElement = 16, Fr("StructArrayLayout4f16", Yi); var Ki = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } }; return n.anchorPointX.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.anchorPointY.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.x1.get = function () { return this._structArray.int16[this._pos2 + 2] }, n.y1.get = function () { return this._structArray.int16[this._pos2 + 3] }, n.x2.get = function () { return this._structArray.int16[this._pos2 + 4] }, n.y2.get = function () { return this._structArray.int16[this._pos2 + 5] }, n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 8] }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 9] }, n.anchorPoint.get = function () { return new i(this.anchorPointX, this.anchorPointY) }, Object.defineProperties(e.prototype, n), e }(Ei); Ki.prototype.size = 20; var Qi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new Ki(this, t) }, e }(zi); Fr("CollisionBoxArray", Qi); var Ji = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } }; return n.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.glyphStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, n.numGlyphs.get = function () { return this._structArray.uint16[this._pos2 + 3] }, n.vertexStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 2] }, n.lineStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, n.lineLength.get = function () { return this._structArray.uint32[this._pos4 + 4] }, n.segment.get = function () { return this._structArray.uint16[this._pos2 + 10] }, n.lowerSize.get = function () { return this._structArray.uint16[this._pos2 + 11] }, n.upperSize.get = function () { return this._structArray.uint16[this._pos2 + 12] }, n.lineOffsetX.get = function () { return this._structArray.float32[this._pos4 + 7] }, n.lineOffsetY.get = function () { return this._structArray.float32[this._pos4 + 8] }, n.writingMode.get = function () { return this._structArray.uint8[this._pos1 + 36] }, n.placedOrientation.get = function () { return this._structArray.uint8[this._pos1 + 37] }, n.placedOrientation.set = function (t) { this._structArray.uint8[this._pos1 + 37] = t }, n.hidden.get = function () { return this._structArray.uint8[this._pos1 + 38] }, n.hidden.set = function (t) { this._structArray.uint8[this._pos1 + 38] = t }, n.crossTileID.get = function () { return this._structArray.uint32[this._pos4 + 10] }, n.crossTileID.set = function (t) { this._structArray.uint32[this._pos4 + 10] = t }, n.associatedIconIndex.get = function () { return this._structArray.int16[this._pos2 + 22] }, Object.defineProperties(e.prototype, n), e }(Ei); Ji.prototype.size = 48; var $i = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new Ji(this, t) }, e }(Vi); Fr("PlacedSymbolArray", $i); var to = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } }; return n.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.rightJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 2] }, n.centerJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 3] }, n.leftJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 4] }, n.verticalPlacedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 5] }, n.placedIconSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 6] }, n.verticalPlacedIconSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 7] }, n.key.get = function () { return this._structArray.uint16[this._pos2 + 8] }, n.textBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 9] }, n.textBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 10] }, n.verticalTextBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 11] }, n.verticalTextBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 12] }, n.iconBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 13] }, n.iconBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 14] }, n.verticalIconBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 15] }, n.verticalIconBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 16] }, n.featureIndex.get = function () { return this._structArray.uint16[this._pos2 + 17] }, n.numHorizontalGlyphVertices.get = function () { return this._structArray.uint16[this._pos2 + 18] }, n.numVerticalGlyphVertices.get = function () { return this._structArray.uint16[this._pos2 + 19] }, n.numIconVertices.get = function () { return this._structArray.uint16[this._pos2 + 20] }, n.numVerticalIconVertices.get = function () { return this._structArray.uint16[this._pos2 + 21] }, n.useRuntimeCollisionCircles.get = function () { return this._structArray.uint16[this._pos2 + 22] }, n.crossTileID.get = function () { return this._structArray.uint32[this._pos4 + 12] }, n.crossTileID.set = function (t) { this._structArray.uint32[this._pos4 + 12] = t }, n.textBoxScale.get = function () { return this._structArray.float32[this._pos4 + 13] }, n.textOffset0.get = function () { return this._structArray.float32[this._pos4 + 14] }, n.textOffset1.get = function () { return this._structArray.float32[this._pos4 + 15] }, n.collisionCircleDiameter.get = function () { return this._structArray.float32[this._pos4 + 16] }, Object.defineProperties(e.prototype, n), e }(Ei); to.prototype.size = 68; var eo = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new to(this, t) }, e }(Gi); Fr("SymbolInstanceArray", eo); var no = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getoffsetX = function (t) { return this.float32[1 * t + 0] }, e }(Hi); Fr("GlyphOffsetArray", no); var ro = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getx = function (t) { return this.int16[3 * t + 0] }, e.prototype.gety = function (t) { return this.int16[3 * t + 1] }, e.prototype.gettileUnitDistanceFromAnchor = function (t) { return this.int16[3 * t + 2] }, e }(Wi); Fr("SymbolLineVertexArray", ro); var io = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } }; return n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 0] }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 3] }, Object.defineProperties(e.prototype, n), e }(Ei); io.prototype.size = 8; var oo = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new io(this, t) }, e }(Xi); Fr("FeatureIndexArray", oo); var ao = Ti([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, so = function (t) { void 0 === t && (t = []), this.segments = t }; function lo(t, e) { return 256 * (t = c(Math.floor(t), 0, 255)) + c(Math.floor(e), 0, 255) } so.prototype.prepareSegment = function (t, e, n, r) { var i = this.segments[this.segments.length - 1]; return t > so.MAX_VERTEX_ARRAY_LENGTH && S("Max vertices per segment is " + so.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!i || i.vertexLength + t > so.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== r) && (i = { vertexOffset: e.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== r && (i.sortKey = r), this.segments.push(i)), i }, so.prototype.get = function () { return this.segments }, so.prototype.destroy = function () { for (var t = 0, e = this.segments; t < e.length; t += 1) { var n = e[t]; for (var r in n.vaos) n.vaos[r].destroy() } }, so.simpleSegment = function (t, e, n, r) { return new so([{ vertexOffset: t, primitiveOffset: e, vertexLength: n, primitiveLength: r, vaos: {}, sortKey: 0 }]) }, so.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Fr("SegmentVector", so); var uo = Ti([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), co = e((function (t) { t.exports = function (t, e) { var n, r, i, o, a, s, l, u; for (r = t.length - (n = 3 & t.length), i = e, a = 3432918353, s = 461845907, u = 0; u < r;)l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (o = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16); switch (l = 0, n) { case 3: l ^= (255 & t.charCodeAt(u + 2)) << 16; case 2: l ^= (255 & t.charCodeAt(u + 1)) << 8; case 1: i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295 }return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0 } })), po = e((function (t) { t.exports = function (t, e) { for (var n, r = t.length, i = e ^ r, o = 0; r >= 4;)n = 1540483477 * (65535 & (n = 255 & t.charCodeAt(o) | (255 & t.charCodeAt(++o)) << 8 | (255 & t.charCodeAt(++o)) << 16 | (255 & t.charCodeAt(++o)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), r -= 4, ++o; switch (r) { case 3: i ^= (255 & t.charCodeAt(o + 2)) << 16; case 2: i ^= (255 & t.charCodeAt(o + 1)) << 8; case 1: i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(o))) + ((1540483477 * (i >>> 16) & 65535) << 16) }return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0 } })), ho = co, fo = po; ho.murmur3 = co, ho.murmur2 = fo; var mo = function () { this.ids = [], this.positions = [], this.indexed = !1 }; mo.prototype.add = function (t, e, n, r) { this.ids.push(yo(t)), this.positions.push(e, n, r) }, mo.prototype.getPositions = function (t) { for (var e = yo(t), n = 0, r = this.ids.length - 1; n < r;) { var i = n + r >> 1; this.ids[i] >= e ? r = i : n = i + 1 } for (var o = []; this.ids[n] === e;)o.push({ index: this.positions[3 * n], start: this.positions[3 * n + 1], end: this.positions[3 * n + 2] }), n++; return o }, mo.serialize = function (t, e) { var n = new Float64Array(t.ids), r = new Uint32Array(t.positions); return function t(e, n, r, i) { for (; r < i;) { for (var o = e[r + i >> 1], a = r - 1, s = i + 1; ;) { do { a++ } while (e[a] < o); do { s-- } while (e[s] > o); if (a >= s) break; go(e, a, s), go(n, 3 * a, 3 * s), go(n, 3 * a + 1, 3 * s + 1), go(n, 3 * a + 2, 3 * s + 2) } s - r < i - s ? (t(e, n, r, s), r = s + 1) : (t(e, n, s + 1, i), i = s) } }(n, r, 0, n.length - 1), e && e.push(n.buffer, r.buffer), { ids: n, positions: r } }, mo.deserialize = function (t) { var e = new mo; return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e }; var vo = Math.pow(2, 53) - 1; function yo(t) { var e = +t; return !isNaN(e) && e <= vo ? e : ho(String(t)) } function go(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } Fr("FeaturePositionMap", mo); var _o = function (t, e) { this.gl = t.gl, this.location = e }, xo = function (t) { function e(e, n) { t.call(this, e, n), this.current = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t)) }, e }(_o), bo = function (t) { function e(e, n) { t.call(this, e, n), this.current = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t)) }, e }(_o), wo = function (t) { function e(e, n) { t.call(this, e, n), this.current = [0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1])) }, e }(_o), So = function (t) { function e(e, n) { t.call(this, e, n), this.current = [0, 0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2])) }, e }(_o), Eo = function (t) { function e(e, n) { t.call(this, e, n), this.current = [0, 0, 0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3])) }, e }(_o), Co = function (t) { function e(e, n) { t.call(this, e, n), this.current = te.transparent } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a)) }, e }(_o), To = new Float32Array(16), Ao = function (t) { function e(e, n) { t.call(this, e, n), this.current = To } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t); for (var e = 1; e < 16; e++)if (t[e] !== this.current[e]) { this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t); break } }, e }(_o); function Mo(t) { return [lo(255 * t.r, 255 * t.g), lo(255 * t.b, 255 * t.a)] } var Oo = function (t, e, n) { this.value = t, this.uniformNames = e.map((function (t) { return "u_" + t })), this.type = n }; Oo.prototype.setUniform = function (t, e, n) { t.set(n.constantOr(this.value)) }, Oo.prototype.getBinding = function (t, e, n) { return "color" === this.type ? new Co(t, e) : new bo(t, e) }; var ko = function (t, e) { this.uniformNames = e.map((function (t) { return "u_" + t })), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1 }; ko.prototype.setConstantPatternPositions = function (t, e) { this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr }, ko.prototype.setUniform = function (t, e, n, r) { var i = "u_pattern_to" === r ? this.patternTo : "u_pattern_from" === r ? this.patternFrom : "u_pixel_ratio_to" === r ? this.pixelRatioTo : "u_pixel_ratio_from" === r ? this.pixelRatioFrom : null; i && t.set(i) }, ko.prototype.getBinding = function (t, e, n) { return "u_pattern" === n.substr(0, 9) ? new Eo(t, e) : new bo(t, e) }; var Io = function (t, e, n, r) { this.expression = t, this.type = n, this.maxValue = 0, this.paintVertexAttributes = e.map((function (t) { return { name: "a_" + t, type: "Float32", components: "color" === n ? 2 : 1, offset: 0 } })), this.paintVertexArray = new r }; Io.prototype.populatePaintArray = function (t, e, n, r, i) { var o = this.paintVertexArray.length, a = this.expression.evaluate(new si(0), e, {}, r, [], i); this.paintVertexArray.resize(t), this._setPaintValue(o, t, a) }, Io.prototype.updatePaintArray = function (t, e, n, r) { var i = this.expression.evaluate({ zoom: 0 }, n, r); this._setPaintValue(t, e, i) }, Io.prototype._setPaintValue = function (t, e, n) { if ("color" === this.type) for (var r = Mo(n), i = t; i < e; i++)this.paintVertexArray.emplace(i, r[0], r[1]); else { for (var o = t; o < e; o++)this.paintVertexArray.emplace(o, n); this.maxValue = Math.max(this.maxValue, Math.abs(n)) } }, Io.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, Io.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }; var Po = function (t, e, n, r, i, o) { this.expression = t, this.uniformNames = e.map((function (t) { return "u_" + t + "_t" })), this.type = n, this.useIntegerZoom = r, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map((function (t) { return { name: "a_" + t, type: "Float32", components: "color" === n ? 4 : 2, offset: 0 } })), this.paintVertexArray = new o }; Po.prototype.populatePaintArray = function (t, e, n, r, i) { var o = this.expression.evaluate(new si(this.zoom), e, {}, r, [], i), a = this.expression.evaluate(new si(this.zoom + 1), e, {}, r, [], i), s = this.paintVertexArray.length; this.paintVertexArray.resize(t), this._setPaintValue(s, t, o, a) }, Po.prototype.updatePaintArray = function (t, e, n, r) { var i = this.expression.evaluate({ zoom: this.zoom }, n, r), o = this.expression.evaluate({ zoom: this.zoom + 1 }, n, r); this._setPaintValue(t, e, i, o) }, Po.prototype._setPaintValue = function (t, e, n, r) { if ("color" === this.type) for (var i = Mo(n), o = Mo(r), a = t; a < e; a++)this.paintVertexArray.emplace(a, i[0], i[1], o[0], o[1]); else { for (var s = t; s < e; s++)this.paintVertexArray.emplace(s, n, r); this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(r)) } }, Po.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, Po.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }, Po.prototype.setUniform = function (t, e) { var n = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom, r = c(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1); t.set(r) }, Po.prototype.getBinding = function (t, e, n) { return new bo(t, e) }; var Lo = function (t, e, n, r, i, o) { this.expression = t, this.type = e, this.useIntegerZoom = n, this.zoom = r, this.layerId = o, this.zoomInPaintVertexArray = new i, this.zoomOutPaintVertexArray = new i }; Lo.prototype.populatePaintArray = function (t, e, n) { var r = this.zoomInPaintVertexArray.length; this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(r, t, e.patterns && e.patterns[this.layerId], n) }, Lo.prototype.updatePaintArray = function (t, e, n, r, i) { this._setPaintValues(t, e, n.patterns && n.patterns[this.layerId], i) }, Lo.prototype._setPaintValues = function (t, e, n, r) { if (r && n) { var i = r[n.min], o = r[n.mid], a = r[n.max]; if (i && o && a) for (var s = t; s < e; s++)this.zoomInPaintVertexArray.emplace(s, o.tl[0], o.tl[1], o.br[0], o.br[1], i.tl[0], i.tl[1], i.br[0], i.br[1], o.pixelRatio, i.pixelRatio), this.zoomOutPaintVertexArray.emplace(s, o.tl[0], o.tl[1], o.br[0], o.br[1], a.tl[0], a.tl[1], a.br[0], a.br[1], o.pixelRatio, a.pixelRatio) } }, Lo.prototype.upload = function (t) { this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, uo.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, uo.members, this.expression.isStateDependent)) }, Lo.prototype.destroy = function () { this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy() }; var Ro = function (t, e, n) { this.binders = {}, this._buffers = []; var r = []; for (var i in t.paint._values) if (n(i)) { var o = t.paint.get(i); if (o instanceof di && Rn(o.property.specification)) { var a = No(i, t.type), s = o.value, l = o.property.specification.type, u = o.property.useIntegerZoom, c = o.property.specification["property-type"], p = "cross-faded" === c || "cross-faded-data-driven" === c; if ("constant" === s.kind) this.binders[i] = p ? new ko(s.value, a) : new Oo(s.value, a, l), r.push("/u_" + i); else if ("source" === s.kind || p) { var h = zo(i, l, "source"); this.binders[i] = p ? new Lo(s, l, u, e, h, t.id) : new Io(s, a, l, h), r.push("/a_" + i) } else { var f = zo(i, l, "composite"); this.binders[i] = new Po(s, a, l, u, e, f), r.push("/z_" + i) } } } this.cacheKey = r.sort().join("") }; Ro.prototype.getMaxValue = function (t) { var e = this.binders[t]; return e instanceof Io || e instanceof Po ? e.maxValue : 0 }, Ro.prototype.populatePaintArrays = function (t, e, n, r, i) { for (var o in this.binders) { var a = this.binders[o]; (a instanceof Io || a instanceof Po || a instanceof Lo) && a.populatePaintArray(t, e, n, r, i) } }, Ro.prototype.setConstantPatternPositions = function (t, e) { for (var n in this.binders) { var r = this.binders[n]; r instanceof ko && r.setConstantPatternPositions(t, e) } }, Ro.prototype.updatePaintArrays = function (t, e, n, r, i) { var o = !1; for (var a in t) for (var s = 0, l = e.getPositions(a); s < l.length; s += 1) { var u = l[s], c = n.feature(u.index); for (var p in this.binders) { var h = this.binders[p]; if ((h instanceof Io || h instanceof Po || h instanceof Lo) && !0 === h.expression.isStateDependent) { var f = r.paint.get(p); h.expression = f.value, h.updatePaintArray(u.start, u.end, c, t[a], i), o = !0 } } } return o }, Ro.prototype.defines = function () { var t = []; for (var e in this.binders) { var n = this.binders[e]; (n instanceof Oo || n instanceof ko) && t.push.apply(t, n.uniformNames.map((function (t) { return "#define HAS_UNIFORM_" + t }))) } return t }, Ro.prototype.getBinderAttributes = function () { var t = []; for (var e in this.binders) { var n = this.binders[e]; if (n instanceof Io || n instanceof Po) for (var r = 0; r < n.paintVertexAttributes.length; r++)t.push(n.paintVertexAttributes[r].name); else if (n instanceof Lo) for (var i = 0; i < uo.members.length; i++)t.push(uo.members[i].name) } return t }, Ro.prototype.getBinderUniforms = function () { var t = []; for (var e in this.binders) { var n = this.binders[e]; if (n instanceof Oo || n instanceof ko || n instanceof Po) for (var r = 0, i = n.uniformNames; r < i.length; r += 1)t.push(i[r]) } return t }, Ro.prototype.getPaintVertexBuffers = function () { return this._buffers }, Ro.prototype.getUniforms = function (t, e) { var n = []; for (var r in this.binders) { var i = this.binders[r]; if (i instanceof Oo || i instanceof ko || i instanceof Po) for (var o = 0, a = i.uniformNames; o < a.length; o += 1) { var s = a[o]; if (e[s]) { var l = i.getBinding(t, e[s], s); n.push({ name: s, property: r, binding: l }) } } } return n }, Ro.prototype.setUniforms = function (t, e, n, r) { for (var i = 0, o = e; i < o.length; i += 1) { var a = o[i], s = a.name, l = a.property; this.binders[l].setUniform(a.binding, r, n.get(l), s) } }, Ro.prototype.updatePaintBuffers = function (t) { for (var e in this._buffers = [], this.binders) { var n = this.binders[e]; if (t && n instanceof Lo) { var r = 2 === t.fromScale ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer; r && this._buffers.push(r) } else (n instanceof Io || n instanceof Po) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer) } }, Ro.prototype.upload = function (t) { for (var e in this.binders) { var n = this.binders[e]; (n instanceof Io || n instanceof Po || n instanceof Lo) && n.upload(t) } this.updatePaintBuffers() }, Ro.prototype.destroy = function () { for (var t in this.binders) { var e = this.binders[t]; (e instanceof Io || e instanceof Po || e instanceof Lo) && e.destroy() } }; var Do = function (t, e, n) { void 0 === n && (n = function () { return !0 }), this.programConfigurations = {}; for (var r = 0, i = t; r < i.length; r += 1) { var o = i[r]; this.programConfigurations[o.id] = new Ro(o, e, n) } this.needsUpload = !1, this._featureMap = new mo, this._bufferOffset = 0 }; function No(t, e) { return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t] || [t.replace(e + "-", "").replace(/-/g, "_")] } function zo(t, e, n) { var r = { color: { source: Pi, composite: Yi }, number: { source: Hi, composite: Pi } }, i = function (t) { return { "line-pattern": { source: Li, composite: Li }, "fill-pattern": { source: Li, composite: Li }, "fill-extrusion-pattern": { source: Li, composite: Li } }[t] }(t); return i && i[n] || r[e][n] } Do.prototype.populatePaintArrays = function (t, e, n, r, i, o) { for (var a in this.programConfigurations) this.programConfigurations[a].populatePaintArrays(t, e, r, i, o); void 0 !== e.id && this._featureMap.add(e.id, n, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0 }, Do.prototype.updatePaintArrays = function (t, e, n, r) { for (var i = 0, o = n; i < o.length; i += 1) { var a = o[i]; this.needsUpload = this.programConfigurations[a.id].updatePaintArrays(t, this._featureMap, e, a, r) || this.needsUpload } }, Do.prototype.get = function (t) { return this.programConfigurations[t] }, Do.prototype.upload = function (t) { if (this.needsUpload) { for (var e in this.programConfigurations) this.programConfigurations[e].upload(t); this.needsUpload = !1 } }, Do.prototype.destroy = function () { for (var t in this.programConfigurations) this.programConfigurations[t].destroy() }, Fr("ConstantBinder", Oo), Fr("CrossFadedConstantBinder", ko), Fr("SourceExpressionBinder", Io), Fr("CrossFadedCompositeBinder", Lo), Fr("CompositeExpressionBinder", Po), Fr("ProgramConfiguration", Ro, { omit: ["_buffers"] }), Fr("ProgramConfigurationSet", Do); var Fo = Math.pow(2, 14) - 1, Bo = -Fo - 1; function jo(t) { for (var e = 8192 / t.extent, n = t.loadGeometry(), r = 0; r < n.length; r++)for (var i = n[r], o = 0; o < i.length; o++) { var a = i[o], s = Math.round(a.x * e), l = Math.round(a.y * e); a.x = c(s, Bo, Fo), a.y = c(l, Bo, Fo), (s < a.x || s > a.x + 1 || l < a.y || l > a.y + 1) && S("Geometry exceeds allowed extent, reduce your vector tile buffer size") } return n } function Uo(t, e) { return { type: t.type, id: t.id, properties: t.properties, geometry: e ? jo(t) : [] } } function Vo(t, e, n, r, i) { t.emplaceBack(2 * e + (r + 1) / 2, 2 * n + (i + 1) / 2) } var Go = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Mi, this.indexArray = new Ui, this.segments = new so, this.programConfigurations = new Do(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; function Ho(t, e) { for (var n = 0; n < t.length; n++)if ($o(e, t[n])) return !0; for (var r = 0; r < e.length; r++)if ($o(t, e[r])) return !0; return !!Zo(t, e) } function Wo(t, e, n) { return !!$o(t, e) || !!Ko(e, t, n) } function Xo(t, e) { if (1 === t.length) return Jo(e, t[0]); for (var n = 0; n < e.length; n++)for (var r = e[n], i = 0; i < r.length; i++)if ($o(t, r[i])) return !0; for (var o = 0; o < t.length; o++)if (Jo(e, t[o])) return !0; for (var a = 0; a < e.length; a++)if (Zo(t, e[a])) return !0; return !1 } function qo(t, e, n) { if (t.length > 1) { if (Zo(t, e)) return !0; for (var r = 0; r < e.length; r++)if (Ko(e[r], t, n)) return !0 } for (var i = 0; i < t.length; i++)if (Ko(t[i], e, n)) return !0; return !1 } function Zo(t, e) { if (0 === t.length || 0 === e.length) return !1; for (var n = 0; n < t.length - 1; n++)for (var r = t[n], i = t[n + 1], o = 0; o < e.length - 1; o++)if (Yo(r, i, e[o], e[o + 1])) return !0; return !1 } function Yo(t, e, n, r) { return E(t, n, r) !== E(e, n, r) && E(t, e, n) !== E(t, e, r) } function Ko(t, e, n) { var r = n * n; if (1 === e.length) return t.distSqr(e[0]) < r; for (var i = 1; i < e.length; i++)if (Qo(t, e[i - 1], e[i]) < r) return !0; return !1 } function Qo(t, e, n) { var r = e.distSqr(n); if (0 === r) return t.distSqr(e); var i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / r; return t.distSqr(i < 0 ? e : i > 1 ? n : n.sub(e)._mult(i)._add(e)) } function Jo(t, e) { for (var n, r, i, o = !1, a = 0; a < t.length; a++)for (var s = 0, l = (n = t[a]).length - 1; s < n.length; l = s++)(r = n[s]).y > e.y != (i = n[l]).y > e.y && e.x < (i.x - r.x) * (e.y - r.y) / (i.y - r.y) + r.x && (o = !o); return o } function $o(t, e) { for (var n = !1, r = 0, i = t.length - 1; r < t.length; i = r++) { var o = t[r], a = t[i]; o.y > e.y != a.y > e.y && e.x < (a.x - o.x) * (e.y - o.y) / (a.y - o.y) + o.x && (n = !n) } return n } function ta(t, e, n) { var r = n[0], i = n[2]; if (t.x < r.x && e.x < r.x || t.x > i.x && e.x > i.x || t.y < r.y && e.y < r.y || t.y > i.y && e.y > i.y) return !1; var o = E(t, e, n[0]); return o !== E(t, e, n[1]) || o !== E(t, e, n[2]) || o !== E(t, e, n[3]) } function ea(t, e, n) { var r = e.paint.get(t).value; return "constant" === r.kind ? r.value : n.programConfigurations.get(e.id).getMaxValue(t) } function na(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function ra(t, e, n, r, o) { if (!e[0] && !e[1]) return t; var a = i.convert(e)._mult(o); "viewport" === n && a._rotate(-r); for (var s = [], l = 0; l < t.length; l++)s.push(t[l].sub(a)); return s } Go.prototype.populate = function (t, e, n) { var r = this.layers[0], i = [], o = null; "circle" === r.type && (o = r.layout.get("circle-sort-key")); for (var a = 0, s = t; a < s.length; a += 1) { var l = s[a], u = l.feature, c = l.id, p = l.index, h = l.sourceLayerIndex, f = this.layers[0]._featureFilter.needGeometry, d = Uo(u, f); if (this.layers[0]._featureFilter.filter(new si(this.zoom), d, n)) { var m = o ? o.evaluate(d, {}, n) : void 0, v = { id: c, properties: u.properties, type: u.type, sourceLayerIndex: h, index: p, geometry: f ? d.geometry : jo(u), patterns: {}, sortKey: m }; i.push(v) } } o && i.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var y = 0, g = i; y < g.length; y += 1) { var _ = g[y], x = _.geometry, b = _.index, w = _.sourceLayerIndex, S = t[b].feature; this.addFeature(_, x, b, n), e.featureIndex.insert(S, x, b, w, this.index) } }, Go.prototype.update = function (t, e, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, n) }, Go.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Go.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Go.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ao), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Go.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Go.prototype.addFeature = function (t, e, n, r) { for (var i = 0, o = e; i < o.length; i += 1)for (var a = 0, s = o[i]; a < s.length; a += 1) { var l = s[a], u = l.x, c = l.y; if (!(u < 0 || u >= 8192 || c < 0 || c >= 8192)) { var p = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), h = p.vertexLength; Vo(this.layoutVertexArray, u, c, -1, -1), Vo(this.layoutVertexArray, u, c, 1, -1), Vo(this.layoutVertexArray, u, c, 1, 1), Vo(this.layoutVertexArray, u, c, -1, 1), this.indexArray.emplaceBack(h, h + 1, h + 2), this.indexArray.emplaceBack(h, h + 3, h + 2), p.vertexLength += 4, p.primitiveLength += 2 } } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {}, r) }, Fr("CircleBucket", Go, { omit: ["layers"] }); var ia = new bi({ "circle-sort-key": new yi(Ot.layout_circle["circle-sort-key"]) }), oa = { paint: new bi({ "circle-radius": new yi(Ot.paint_circle["circle-radius"]), "circle-color": new yi(Ot.paint_circle["circle-color"]), "circle-blur": new yi(Ot.paint_circle["circle-blur"]), "circle-opacity": new yi(Ot.paint_circle["circle-opacity"]), "circle-translate": new vi(Ot.paint_circle["circle-translate"]), "circle-translate-anchor": new vi(Ot.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new vi(Ot.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new vi(Ot.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new yi(Ot.paint_circle["circle-stroke-width"]), "circle-stroke-color": new yi(Ot.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new yi(Ot.paint_circle["circle-stroke-opacity"]) }), layout: ia }, aa = "undefined" != typeof Float32Array ? Float32Array : Array; function sa(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function la(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], h = e[9], f = e[10], d = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = n[0], x = n[1], b = n[2], w = n[3]; return t[0] = _ * r + x * s + b * p + w * m, t[1] = _ * i + x * l + b * h + w * v, t[2] = _ * o + x * u + b * f + w * y, t[3] = _ * a + x * c + b * d + w * g, t[4] = (_ = n[4]) * r + (x = n[5]) * s + (b = n[6]) * p + (w = n[7]) * m, t[5] = _ * i + x * l + b * h + w * v, t[6] = _ * o + x * u + b * f + w * y, t[7] = _ * a + x * c + b * d + w * g, t[8] = (_ = n[8]) * r + (x = n[9]) * s + (b = n[10]) * p + (w = n[11]) * m, t[9] = _ * i + x * l + b * h + w * v, t[10] = _ * o + x * u + b * f + w * y, t[11] = _ * a + x * c + b * d + w * g, t[12] = (_ = n[12]) * r + (x = n[13]) * s + (b = n[14]) * p + (w = n[15]) * m, t[13] = _ * i + x * l + b * h + w * v, t[14] = _ * o + x * u + b * f + w * y, t[15] = _ * a + x * c + b * d + w * g, t } Math.hypot || (Math.hypot = function () { for (var t = arguments, e = 0, n = arguments.length; n--;)e += t[n] * t[n]; return Math.sqrt(e) }); var ua, ca = la; function pa(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3]; return t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, t } ua = new aa(3), aa != Float32Array && (ua[0] = 0, ua[1] = 0, ua[2] = 0), function () { var t = new aa(4); aa != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0) }(); var ha = (function () { var t = new aa(2); aa != Float32Array && (t[0] = 0, t[1] = 0) }(), function (t) { function e(e) { t.call(this, e, oa) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new Go(t) }, e.prototype.queryRadius = function (t) { var e = t; return ea("circle-radius", this, e) + ea("circle-stroke-width", this, e) + na(this.paint.get("circle-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, n, r, i, o, a, s) { for (var l = ra(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, a), u = this.paint.get("circle-radius").evaluate(e, n) + this.paint.get("circle-stroke-width").evaluate(e, n), c = "map" === this.paint.get("circle-pitch-alignment"), p = c ? l : function (t, e) { return t.map((function (t) { return fa(t, e) })) }(l, s), h = c ? u * a : u, f = 0, d = r; f < d.length; f += 1)for (var m = 0, v = d[f]; m < v.length; m += 1) { var y = v[m], g = c ? y : fa(y, s), _ = h, x = pa([], [y.x, y.y, 0, 1], s); if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? _ *= x[3] / o.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (_ *= o.cameraToCenterDistance / x[3]), Wo(p, g, _)) return !0 } return !1 }, e }(wi)); function fa(t, e) { var n = pa([], [t.x, t.y, 0, 1], e); return new i(n[0] / n[3], n[1] / n[3]) } var da = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(Go); function ma(t, e, n, r) { var i = e.width, o = e.height; if (r) { if (r instanceof Uint8ClampedArray) r = new Uint8Array(r.buffer); else if (r.length !== i * o * n) throw new RangeError("mismatched image size") } else r = new Uint8Array(i * o * n); return t.width = i, t.height = o, t.data = r, t } function va(t, e, n) { var r = e.width, i = e.height; if (r !== t.width || i !== t.height) { var o = ma({}, { width: r, height: i }, n); ya(t, o, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, r), height: Math.min(t.height, i) }, n), t.width = r, t.height = i, t.data = o.data } } function ya(t, e, n, r, i, o) { if (0 === i.width || 0 === i.height) return e; if (i.width > t.width || i.height > t.height || n.x > t.width - i.width || n.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy"); if (i.width > e.width || i.height > e.height || r.x > e.width - i.width || r.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy"); for (var a = t.data, s = e.data, l = 0; l < i.height; l++)for (var u = ((n.y + l) * t.width + n.x) * o, c = ((r.y + l) * e.width + r.x) * o, p = 0; p < i.width * o; p++)s[c + p] = a[u + p]; return e } Fr("HeatmapBucket", da, { omit: ["layers"] }); var ga = function (t, e) { ma(this, t, 1, e) }; ga.prototype.resize = function (t) { va(this, t, 1) }, ga.prototype.clone = function () { return new ga({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, ga.copy = function (t, e, n, r, i) { ya(t, e, n, r, i, 1) }; var _a = function (t, e) { ma(this, t, 4, e) }; _a.prototype.resize = function (t) { va(this, t, 4) }, _a.prototype.replace = function (t, e) { e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t }, _a.prototype.clone = function () { return new _a({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, _a.copy = function (t, e, n, r, i) { ya(t, e, n, r, i, 4) }, Fr("AlphaImage", ga), Fr("RGBAImage", _a); var xa = { paint: new bi({ "heatmap-radius": new yi(Ot.paint_heatmap["heatmap-radius"]), "heatmap-weight": new yi(Ot.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new vi(Ot.paint_heatmap["heatmap-intensity"]), "heatmap-color": new xi(Ot.paint_heatmap["heatmap-color"]), "heatmap-opacity": new vi(Ot.paint_heatmap["heatmap-opacity"]) }) }; function ba(t) { var e = {}, n = t.resolution || 256, r = t.clips ? t.clips.length : 1, i = t.image || new _a({ width: n, height: r }), o = function (n, r, o) { e[t.evaluationKey] = o; var a = t.expression.evaluate(e); i.data[n + r + 0] = Math.floor(255 * a.r / a.a), i.data[n + r + 1] = Math.floor(255 * a.g / a.a), i.data[n + r + 2] = Math.floor(255 * a.b / a.a), i.data[n + r + 3] = Math.floor(255 * a.a) }; if (t.clips) for (var a = 0, s = 0; a < r; ++a, s += 4 * n)for (var l = 0, u = 0; l < n; l++, u += 4) { var c = l / (n - 1), p = t.clips[a]; o(s, u, p.start * (1 - c) + p.end * c) } else for (var h = 0, f = 0; h < n; h++, f += 4)o(0, f, h / (n - 1)); return i } var wa = function (t) { function e(e) { t.call(this, e, xa), this._updateColorRamp() } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new da(t) }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { "heatmap-color" === t && this._updateColorRamp() }, e.prototype._updateColorRamp = function () { this.colorRamp = ba({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null }, e.prototype.resize = function () { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null) }, e.prototype.queryRadius = function () { return 0 }, e.prototype.queryIntersectsFeature = function () { return !1 }, e.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility }, e }(wi), Sa = { paint: new bi({ "hillshade-illumination-direction": new vi(Ot.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new vi(Ot.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new vi(Ot.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new vi(Ot.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new vi(Ot.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new vi(Ot.paint_hillshade["hillshade-accent-color"]) }) }, Ea = function (t) { function e(e) { t.call(this, e, Sa) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility }, e }(wi), Ca = Ti([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Ta = Ma, Aa = Ma; function Ma(t, e, n) { n = n || 2; var r, i, o, a, s, l, u, c = e && e.length, p = c ? e[0] * n : t.length, h = Oa(t, 0, p, n, !0), f = []; if (!h || h.next === h.prev) return f; if (c && (h = function (t, e, n, r) { var i, o, a, s = []; for (i = 0, o = e.length; i < o; i++)(a = Oa(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0), s.push(ja(a)); for (s.sort(Na), i = 0; i < s.length; i++)za(s[i], n), n = ka(n, n.next); return n }(t, e, h, n)), t.length > 80 * n) { r = o = t[0], i = a = t[1]; for (var d = n; d < p; d += n)(s = t[d]) < r && (r = s), (l = t[d + 1]) < i && (i = l), s > o && (o = s), l > a && (a = l); u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0 } return Ia(h, f, n, r, i, u), f } function Oa(t, e, n, r, i) { var o, a; if (i === $a(t, e, n, r) > 0) for (o = e; o < n; o += r)a = Ka(o, t[o], t[o + 1], a); else for (o = n - r; o >= e; o -= r)a = Ka(o, t[o], t[o + 1], a); return a && Ha(a, a.next) && (Qa(a), a = a.next), a } function ka(t, e) { if (!t) return t; e || (e = t); var n, r = t; do { if (n = !1, r.steiner || !Ha(r, r.next) && 0 !== Ga(r.prev, r, r.next)) r = r.next; else { if (Qa(r), (r = e = r.prev) === r.next) break; n = !0 } } while (n || r !== e); return e } function Ia(t, e, n, r, i, o, a) { if (t) { !a && o && function (t, e, n, r) { var i = t; do { null === i.z && (i.z = Ba(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { var e, n, r, i, o, a, s, l, u = 1; do { for (n = t, t = null, o = null, a = 0; n;) { for (a++, r = n, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++); for (l = u; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; n = r } o.nextZ = null, u *= 2 } while (a > 1) }(i) }(t, r, i, o); for (var s, l, u = t; t.prev !== t.next;)if (s = t.prev, l = t.next, o ? La(t, r, i, o) : Pa(t)) e.push(s.i / n), e.push(t.i / n), e.push(l.i / n), Qa(t), t = l.next, u = l.next; else if ((t = l) === u) { a ? 1 === a ? Ia(t = Ra(ka(t), e, n), e, n, r, i, o, 2) : 2 === a && Da(t, e, n, r, i, o) : Ia(ka(t), e, n, r, i, o, 1); break } } } function Pa(t) { var e = t.prev, n = t, r = t.next; if (Ga(e, n, r) >= 0) return !1; for (var i = t.next.next; i !== t.prev;) { if (Ua(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Ga(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function La(t, e, n, r) { var i = t.prev, o = t, a = t.next; if (Ga(i, o, a) >= 0) return !1; for (var s = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, u = Ba(i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, e, n, r), c = Ba(s, l, e, n, r), p = t.prevZ, h = t.nextZ; p && p.z >= u && h && h.z <= c;) { if (p !== t.prev && p !== t.next && Ua(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && Ga(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, h !== t.prev && h !== t.next && Ua(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Ga(h.prev, h, h.next) >= 0) return !1; h = h.nextZ } for (; p && p.z >= u;) { if (p !== t.prev && p !== t.next && Ua(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && Ga(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; h && h.z <= c;) { if (h !== t.prev && h !== t.next && Ua(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Ga(h.prev, h, h.next) >= 0) return !1; h = h.nextZ } return !0 } function Ra(t, e, n) { var r = t; do { var i = r.prev, o = r.next.next; !Ha(i, o) && Wa(i, r, r.next, o) && Za(i, o) && Za(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Qa(r), Qa(r.next), r = t = o), r = r.next } while (r !== t); return ka(r) } function Da(t, e, n, r, i, o) { var a = t; do { for (var s = a.next.next; s !== a.prev;) { if (a.i !== s.i && Va(a, s)) { var l = Ya(a, s); return a = ka(a, a.next), l = ka(l, l.next), Ia(a, e, n, r, i, o), void Ia(l, e, n, r, i, o) } s = s.next } a = a.next } while (a !== t) } function Na(t, e) { return t.x - e.x } function za(t, e) { if (e = function (t, e) { var n, r = e, i = t.x, o = t.y, a = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= i && s > a) { if (a = s, s === i) { if (o === r.y) return r; if (o === r.next.y) return r.next } n = r.x < r.next.x ? r : r.next } } r = r.next } while (r !== e); if (!n) return null; if (i === a) return n; var l, u = n, c = n.x, p = n.y, h = 1 / 0; r = n; do { i >= r.x && r.x >= c && i !== r.x && Ua(o < p ? i : a, o, c, p, o < p ? a : i, o, r.x, r.y) && (l = Math.abs(o - r.y) / (i - r.x), Za(r, t) && (l < h || l === h && (r.x > n.x || r.x === n.x && Fa(n, r))) && (n = r, h = l)), r = r.next } while (r !== u); return n }(t, e)) { var n = Ya(e, t); ka(e, e.next), ka(n, n.next) } } function Fa(t, e) { return Ga(t.prev, t, e.prev) < 0 && Ga(e.next, t, t.next) < 0 } function Ba(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function ja(t) { var e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function Ua(t, e, n, r, i, o, a, s) { return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0 } function Va(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Wa(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (Za(t, e) && Za(e, t) && function (t, e) { var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e) && (Ga(t.prev, t, e.prev) || Ga(t, e.prev, e)) || Ha(t, e) && Ga(t.prev, t, t.next) > 0 && Ga(e.prev, e, e.next) > 0) } function Ga(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Ha(t, e) { return t.x === e.x && t.y === e.y } function Wa(t, e, n, r) { var i = qa(Ga(t, e, n)), o = qa(Ga(t, e, r)), a = qa(Ga(n, r, t)), s = qa(Ga(n, r, e)); return i !== o && a !== s || !(0 !== i || !Xa(t, n, e)) || !(0 !== o || !Xa(t, r, e)) || !(0 !== a || !Xa(n, t, r)) || !(0 !== s || !Xa(n, e, r)) } function Xa(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function qa(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Za(t, e) { return Ga(t.prev, t, t.next) < 0 ? Ga(t, e, t.next) >= 0 && Ga(t, t.prev, e) >= 0 : Ga(t, e, t.prev) < 0 || Ga(t, t.next, e) < 0 } function Ya(t, e) { var n = new Ja(t.i, t.x, t.y), r = new Ja(e.i, e.x, e.y), i = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r } function Ka(t, e, n, r) { var i = new Ja(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function Qa(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Ja(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function $a(t, e, n, r) { for (var i = 0, o = e, a = n - r; o < n; o += r)i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return i } function ts(t, e, n, r, i) { !function t(e, n, r, i, o) { for (; i > r;) { if (i - r > 600) { var a = i - r + 1, s = n - r + 1, l = Math.log(a), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1); t(e, n, Math.max(r, Math.floor(n - s * u / a + c)), Math.min(i, Math.floor(n + (a - s) * u / a + c)), o) } var p = e[n], h = r, f = i; for (es(e, r, n), o(e[i], p) > 0 && es(e, r, i); h < f;) { for (es(e, h, f), h++, f--; o(e[h], p) < 0;)h++; for (; o(e[f], p) > 0;)f-- } 0 === o(e[r], p) ? es(e, r, f) : es(e, ++f, i), f <= n && (r = f + 1), n <= f && (i = f - 1) } }(t, e, n || 0, r || t.length - 1, i || ns) } function es(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function ns(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function rs(t, e) { var n = t.length; if (n <= 1) return [t]; for (var r, i, o = [], a = 0; a < n; a++) { var s = C(t[a]); 0 !== s && (t[a].area = Math.abs(s), void 0 === i && (i = s < 0), i === s < 0 ? (r && o.push(r), r = [t[a]]) : r.push(t[a])) } if (r && o.push(r), e > 1) for (var l = 0; l < o.length; l++)o[l].length <= e || (ts(o[l], e, 1, o[l].length - 1, is), o[l] = o[l].slice(0, e)); return o } function is(t, e) { return e.area - t.area } function os(t, e, n) { for (var r = n.patternDependencies, i = !1, o = 0, a = e; o < a.length; o += 1) { var s = a[o].paint.get(t + "-pattern"); s.isConstant() || (i = !0); var l = s.constantOr(null); l && (i = !0, r[l.to] = !0, r[l.from] = !0) } return i } function as(t, e, n, r, i) { for (var o = i.patternDependencies, a = 0, s = e; a < s.length; a += 1) { var l = s[a], u = l.paint.get(t + "-pattern").value; if ("constant" !== u.kind) { var c = u.evaluate({ zoom: r - 1 }, n, {}, i.availableImages), p = u.evaluate({ zoom: r }, n, {}, i.availableImages), h = u.evaluate({ zoom: r + 1 }, n, {}, i.availableImages); p = p && p.name ? p.name : p, h = h && h.name ? h.name : h, o[c = c && c.name ? c.name : c] = !0, o[p] = !0, o[h] = !0, n.patterns[l.id] = { min: c, mid: p, max: h } } } return n } Ma.deviation = function (t, e, n, r) { var i = e && e.length, o = Math.abs($a(t, 0, i ? e[0] * n : t.length, n)); if (i) for (var a = 0, s = e.length; a < s; a++)o -= Math.abs($a(t, e[a] * n, a < s - 1 ? e[a + 1] * n : t.length, n)); var l = 0; for (a = 0; a < r.length; a += 3) { var u = r[a] * n, c = r[a + 1] * n, p = r[a + 2] * n; l += Math.abs((t[u] - t[p]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[p + 1] - t[u + 1])) } return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o) }, Ma.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var a = 0; a < e; a++)n.vertices.push(t[i][o][a]); i > 0 && n.holes.push(r += t[i - 1].length) } return n }, Ta.default = Aa; var ss = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Mi, this.indexArray = new Ui, this.indexArray2 = new qi, this.programConfigurations = new Do(t.layers, t.zoom), this.segments = new so, this.segments2 = new so, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; ss.prototype.populate = function (t, e, n) { this.hasPattern = os("fill", this.layers, e); for (var r = this.layers[0].layout.get("fill-sort-key"), i = [], o = 0, a = t; o < a.length; o += 1) { var s = a[o], l = s.feature, u = s.id, c = s.index, p = s.sourceLayerIndex, h = this.layers[0]._featureFilter.needGeometry, f = Uo(l, h); if (this.layers[0]._featureFilter.filter(new si(this.zoom), f, n)) { var d = r ? r.evaluate(f, {}, n, e.availableImages) : void 0, m = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: p, index: c, geometry: h ? f.geometry : jo(l), patterns: {}, sortKey: d }; i.push(m) } } r && i.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var v = 0, y = i; v < y.length; v += 1) { var g = y[v], _ = g.geometry, x = g.index, b = g.sourceLayerIndex; if (this.hasPattern) { var w = as("fill", this.layers, g, this.zoom, e); this.patternFeatures.push(w) } else this.addFeature(g, _, x, n, {}); e.featureIndex.insert(t[x].feature, _, x, b, this.index) } }, ss.prototype.update = function (t, e, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, n) }, ss.prototype.addFeatures = function (t, e, n) { for (var r = 0, i = this.patternFeatures; r < i.length; r += 1) { var o = i[r]; this.addFeature(o, o.geometry, o.index, e, n) } }, ss.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, ss.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, ss.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ca), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0 }, ss.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) }, ss.prototype.addFeature = function (t, e, n, r, i) { for (var o = 0, a = rs(e, 500); o < a.length; o += 1) { for (var s = a[o], l = 0, u = 0, c = s; u < c.length; u += 1)l += c[u].length; for (var p = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray), h = p.vertexLength, f = [], d = [], m = 0, v = s; m < v.length; m += 1) { var y = v[m]; if (0 !== y.length) { y !== s[0] && d.push(f.length / 2); var g = this.segments2.prepareSegment(y.length, this.layoutVertexArray, this.indexArray2), _ = g.vertexLength; this.layoutVertexArray.emplaceBack(y[0].x, y[0].y), this.indexArray2.emplaceBack(_ + y.length - 1, _), f.push(y[0].x), f.push(y[0].y); for (var x = 1; x < y.length; x++)this.layoutVertexArray.emplaceBack(y[x].x, y[x].y), this.indexArray2.emplaceBack(_ + x - 1, _ + x), f.push(y[x].x), f.push(y[x].y); g.vertexLength += y.length, g.primitiveLength += y.length } } for (var b = Ta(f, d), w = 0; w < b.length; w += 3)this.indexArray.emplaceBack(h + b[w], h + b[w + 1], h + b[w + 2]); p.vertexLength += l, p.primitiveLength += b.length / 3 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, i, r) }, Fr("FillBucket", ss, { omit: ["layers", "patternFeatures"] }); var ls = new bi({ "fill-sort-key": new yi(Ot.layout_fill["fill-sort-key"]) }), us = { paint: new bi({ "fill-antialias": new vi(Ot.paint_fill["fill-antialias"]), "fill-opacity": new yi(Ot.paint_fill["fill-opacity"]), "fill-color": new yi(Ot.paint_fill["fill-color"]), "fill-outline-color": new yi(Ot.paint_fill["fill-outline-color"]), "fill-translate": new vi(Ot.paint_fill["fill-translate"]), "fill-translate-anchor": new vi(Ot.paint_fill["fill-translate-anchor"]), "fill-pattern": new gi(Ot.paint_fill["fill-pattern"]) }), layout: ls }, cs = function (t) { function e(e) { t.call(this, e, us) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, n) { t.prototype.recalculate.call(this, e, n); var r = this.paint._values["fill-outline-color"]; "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) }, e.prototype.createBucket = function (t) { return new ss(t) }, e.prototype.queryRadius = function () { return na(this.paint.get("fill-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, n, r, i, o, a) { return Xo(ra(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, a), r) }, e.prototype.isTileClipped = function () { return !0 }, e }(wi), ps = Ti([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, hs = fs; function fs(t, e, n, r, i) { this.properties = {}, this.extent = n, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = r, this._values = i, t.readFields(ds, this, e) } function ds(t, e, n) { 1 == t ? e.id = n.readVarint() : 2 == t ? function (t, e) { for (var n = t.readVarint() + t.pos; t.pos < n;) { var r = e._keys[t.readVarint()], i = e._values[t.readVarint()]; e.properties[r] = i } }(n, e) : 3 == t ? e.type = n.readVarint() : 4 == t && (e._geometry = n.pos) } function ms(t) { for (var e, n, r = 0, i = 0, o = t.length, a = o - 1; i < o; a = i++)r += ((n = t[a]).x - (e = t[i]).x) * (e.y + n.y); return r } fs.types = ["Unknown", "Point", "LineString", "Polygon"], fs.prototype.loadGeometry = function () { var t = this._pbf; t.pos = this._geometry; for (var e, n = t.readVarint() + t.pos, r = 1, o = 0, a = 0, s = 0, l = []; t.pos < n;) { if (o <= 0) { var u = t.readVarint(); r = 7 & u, o = u >> 3 } if (o--, 1 === r || 2 === r) a += t.readSVarint(), s += t.readSVarint(), 1 === r && (e && l.push(e), e = []), e.push(new i(a, s)); else { if (7 !== r) throw new Error("unknown command " + r); e && e.push(e[0].clone()) } } return e && l.push(e), l }, fs.prototype.bbox = function () { var t = this._pbf; t.pos = this._geometry; for (var e = t.readVarint() + t.pos, n = 1, r = 0, i = 0, o = 0, a = 1 / 0, s = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) { if (r <= 0) { var c = t.readVarint(); n = 7 & c, r = c >> 3 } if (r--, 1 === n || 2 === n) (i += t.readSVarint()) < a && (a = i), i > s && (s = i), (o += t.readSVarint()) < l && (l = o), o > u && (u = o); else if (7 !== n) throw new Error("unknown command " + n) } return [a, l, s, u] }, fs.prototype.toGeoJSON = function (t, e, n) { var r, i, o = this.extent * Math.pow(2, n), a = this.extent * t, s = this.extent * e, l = this.loadGeometry(), u = fs.types[this.type]; function c(t) { for (var e = 0; e < t.length; e++) { var n = t[e]; t[e] = [360 * (n.x + a) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (n.y + s) / o) * Math.PI / 180)) - 90] } } switch (this.type) { case 1: var p = []; for (r = 0; r < l.length; r++)p[r] = l[r][0]; c(l = p); break; case 2: for (r = 0; r < l.length; r++)c(l[r]); break; case 3: for (l = function (t) { var e = t.length; if (e <= 1) return [t]; for (var n, r, i = [], o = 0; o < e; o++) { var a = ms(t[o]); 0 !== a && (void 0 === r && (r = a < 0), r === a < 0 ? (n && i.push(n), n = [t[o]]) : n.push(t[o])) } return n && i.push(n), i }(l), r = 0; r < l.length; r++)for (i = 0; i < l[r].length; i++)c(l[r][i]) }1 === l.length ? l = l[0] : u = "Multi" + u; var h = { type: "Feature", geometry: { type: u, coordinates: l }, properties: this.properties }; return "id" in this && (h.id = this.id), h }; var vs = ys; function ys(t, e) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(gs, this, e), this.length = this._features.length } function gs(t, e, n) { 15 === t ? e.version = n.readVarint() : 1 === t ? e.name = n.readString() : 5 === t ? e.extent = n.readVarint() : 2 === t ? e._features.push(n.pos) : 3 === t ? e._keys.push(n.readString()) : 4 === t && e._values.push(function (t) { for (var e = null, n = t.readVarint() + t.pos; t.pos < n;) { var r = t.readVarint() >> 3; e = 1 === r ? t.readString() : 2 === r ? t.readFloat() : 3 === r ? t.readDouble() : 4 === r ? t.readVarint64() : 5 === r ? t.readVarint() : 6 === r ? t.readSVarint() : 7 === r ? t.readBoolean() : null } return e }(n)) } function _s(t, e, n) { if (3 === t) { var r = new vs(n, n.readVarint() + n.pos); r.length && (e[r.name] = r) } } ys.prototype.feature = function (t) { if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[t]; var e = this._pbf.readVarint() + this._pbf.pos; return new hs(this._pbf, e, this.extent, this._keys, this._values) }; var xs = { VectorTile: function (t, e) { this.layers = t.readFields(_s, {}, e) }, VectorTileFeature: hs, VectorTileLayer: vs }, bs = xs.VectorTileFeature.types, ws = Math.pow(2, 13); function Ss(t, e, n, r, i, o, a, s) { t.emplaceBack(e, n, 2 * Math.floor(r * ws) + a, i * ws * 2, o * ws * 2, Math.round(s)) } var Es = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ki, this.indexArray = new Ui, this.programConfigurations = new Do(t.layers, t.zoom), this.segments = new so, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; function Cs(t, e) { return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192) } Es.prototype.populate = function (t, e, n) { this.features = [], this.hasPattern = os("fill-extrusion", this.layers, e); for (var r = 0, i = t; r < i.length; r += 1) { var o = i[r], a = o.feature, s = o.id, l = o.index, u = o.sourceLayerIndex, c = this.layers[0]._featureFilter.needGeometry, p = Uo(a, c); if (this.layers[0]._featureFilter.filter(new si(this.zoom), p, n)) { var h = { id: s, sourceLayerIndex: u, index: l, geometry: c ? p.geometry : jo(a), properties: a.properties, type: a.type, patterns: {} }; this.hasPattern ? this.features.push(as("fill-extrusion", this.layers, h, this.zoom, e)) : this.addFeature(h, h.geometry, l, n, {}), e.featureIndex.insert(a, h.geometry, l, u, this.index, !0) } } }, Es.prototype.addFeatures = function (t, e, n) { for (var r = 0, i = this.features; r < i.length; r += 1) { var o = i[r]; this.addFeature(o, o.geometry, o.index, e, n) } }, Es.prototype.update = function (t, e, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, n) }, Es.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Es.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Es.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ps), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Es.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Es.prototype.addFeature = function (t, e, n, r, i) { for (var o = 0, a = rs(e, 500); o < a.length; o += 1) { for (var s = a[o], l = 0, u = 0, c = s; u < c.length; u += 1)l += c[u].length; for (var p = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h = 0, f = s; h < f.length; h += 1) { var d = f[h]; if (0 !== d.length && !((P = d).every((function (t) { return t.x < 0 })) || P.every((function (t) { return t.x > 8192 })) || P.every((function (t) { return t.y < 0 })) || P.every((function (t) { return t.y > 8192 })))) for (var m = 0, v = 0; v < d.length; v++) { var y = d[v]; if (v >= 1) { var g = d[v - 1]; if (!Cs(y, g)) { p.vertexLength + 4 > so.MAX_VERTEX_ARRAY_LENGTH && (p = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); var _ = y.sub(g)._perp()._unit(), x = g.dist(y); m + x > 32768 && (m = 0), Ss(this.layoutVertexArray, y.x, y.y, _.x, _.y, 0, 0, m), Ss(this.layoutVertexArray, y.x, y.y, _.x, _.y, 0, 1, m), Ss(this.layoutVertexArray, g.x, g.y, _.x, _.y, 0, 0, m += x), Ss(this.layoutVertexArray, g.x, g.y, _.x, _.y, 0, 1, m); var b = p.vertexLength; this.indexArray.emplaceBack(b, b + 2, b + 1), this.indexArray.emplaceBack(b + 1, b + 2, b + 3), p.vertexLength += 4, p.primitiveLength += 2 } } } } if (p.vertexLength + l > so.MAX_VERTEX_ARRAY_LENGTH && (p = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray)), "Polygon" === bs[t.type]) { for (var w = [], S = [], E = p.vertexLength, C = 0, T = s; C < T.length; C += 1) { var A = T[C]; if (0 !== A.length) { A !== s[0] && S.push(w.length / 2); for (var M = 0; M < A.length; M++) { var O = A[M]; Ss(this.layoutVertexArray, O.x, O.y, 0, 0, 1, 1, 0), w.push(O.x), w.push(O.y) } } } for (var k = Ta(w, S), I = 0; I < k.length; I += 3)this.indexArray.emplaceBack(E + k[I], E + k[I + 2], E + k[I + 1]); p.primitiveLength += k.length / 3, p.vertexLength += l } } var P; this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, i, r) }, Fr("FillExtrusionBucket", Es, { omit: ["layers", "features"] }); var Ts = { paint: new bi({ "fill-extrusion-opacity": new vi(Ot["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new yi(Ot["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new vi(Ot["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new vi(Ot["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gi(Ot["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new yi(Ot["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new yi(Ot["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new vi(Ot["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, As = function (t) { function e(e) { t.call(this, e, Ts) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new Es(t) }, e.prototype.queryRadius = function () { return na(this.paint.get("fill-extrusion-translate")) }, e.prototype.is3D = function () { return !0 }, e.prototype.queryIntersectsFeature = function (t, e, n, r, o, a, s, l) { var u = ra(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, s), c = this.paint.get("fill-extrusion-height").evaluate(e, n), p = this.paint.get("fill-extrusion-base").evaluate(e, n), h = function (t, e, n, r) { for (var o = [], a = 0, s = t; a < s.length; a += 1) { var l = s[a], u = [l.x, l.y, 0, 1]; pa(u, u, e), o.push(new i(u[0] / u[3], u[1] / u[3])) } return o }(u, l), f = function (t, e, n, r) { for (var o = [], a = [], s = r[8] * e, l = r[9] * e, u = r[10] * e, c = r[11] * e, p = r[8] * n, h = r[9] * n, f = r[10] * n, d = r[11] * n, m = 0, v = t; m < v.length; m += 1) { for (var y = [], g = [], _ = 0, x = v[m]; _ < x.length; _ += 1) { var b = x[_], w = b.x, S = b.y, E = r[0] * w + r[4] * S + r[12], C = r[1] * w + r[5] * S + r[13], T = r[2] * w + r[6] * S + r[14], A = r[3] * w + r[7] * S + r[15], M = T + u, O = A + c, k = E + p, I = C + h, P = T + f, L = A + d, R = new i((E + s) / O, (C + l) / O); R.z = M / O, y.push(R); var D = new i(k / L, I / L); D.z = P / L, g.push(D) } o.push(y), a.push(g) } return [o, a] }(r, p, c, l); return function (t, e, n) { var r = 1 / 0; Xo(n, e) && (r = Os(n, e[0])); for (var i = 0; i < e.length; i++)for (var o = e[i], a = t[i], s = 0; s < o.length - 1; s++) { var l = o[s], u = [l, o[s + 1], a[s + 1], a[s], l]; Ho(n, u) && (r = Math.min(r, Os(n, u))) } return r !== 1 / 0 && r }(f[0], f[1], h) }, e }(wi); function Ms(t, e) { return t.x * e.x + t.y * e.y } function Os(t, e) { if (1 === t.length) { for (var n, r = 0, i = e[r++]; !n || i.equals(n);)if (!(n = e[r++])) return 1 / 0; for (; r < e.length; r++) { var o = e[r], a = t[0], s = n.sub(i), l = o.sub(i), u = a.sub(i), c = Ms(s, s), p = Ms(s, l), h = Ms(l, l), f = Ms(u, s), d = Ms(u, l), m = c * h - p * p, v = (h * f - p * d) / m, y = (c * d - p * f) / m, g = i.z * (1 - v - y) + n.z * v + o.z * y; if (isFinite(g)) return g } return 1 / 0 } for (var _ = 1 / 0, x = 0, b = e; x < b.length; x += 1)_ = Math.min(_, b[x].z); return _ } var ks = Ti([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, Is = Ti([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, Ps = xs.VectorTileFeature.types, Ls = Math.cos(Math.PI / 180 * 37.5), Rs = Math.pow(2, 14) / .5, Ds = function (t) { var e = this; this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((function (t) { e.gradients[t.id] = {} })), this.layoutVertexArray = new Ii, this.layoutVertexArray2 = new Pi, this.indexArray = new Ui, this.programConfigurations = new Do(t.layers, t.zoom), this.segments = new so, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; Ds.prototype.populate = function (t, e, n) { this.hasPattern = os("line", this.layers, e); for (var r = this.layers[0].layout.get("line-sort-key"), i = [], o = 0, a = t; o < a.length; o += 1) { var s = a[o], l = s.feature, u = s.id, c = s.index, p = s.sourceLayerIndex, h = this.layers[0]._featureFilter.needGeometry, f = Uo(l, h); if (this.layers[0]._featureFilter.filter(new si(this.zoom), f, n)) { var d = r ? r.evaluate(f, {}, n) : void 0, m = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: p, index: c, geometry: h ? f.geometry : jo(l), patterns: {}, sortKey: d }; i.push(m) } } r && i.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var v = 0, y = i; v < y.length; v += 1) { var g = y[v], _ = g.geometry, x = g.index, b = g.sourceLayerIndex; if (this.hasPattern) { var w = as("line", this.layers, g, this.zoom, e); this.patternFeatures.push(w) } else this.addFeature(g, _, x, n, {}); e.featureIndex.insert(t[x].feature, _, x, b, this.index) } }, Ds.prototype.update = function (t, e, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, n) }, Ds.prototype.addFeatures = function (t, e, n) { for (var r = 0, i = this.patternFeatures; r < i.length; r += 1) { var o = i[r]; this.addFeature(o, o.geometry, o.index, e, n) } }, Ds.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Ds.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Ds.prototype.upload = function (t) { this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Is)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ks), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Ds.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Ds.prototype.lineFeatureClips = function (t) { if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end } }, Ds.prototype.addFeature = function (t, e, n, r, i) { var o = this.layers[0].layout, a = o.get("line-join").evaluate(t, {}), s = o.get("line-cap"), l = o.get("line-miter-limit"), u = o.get("line-round-limit"); this.lineClips = this.lineFeatureClips(t); for (var c = 0, p = e; c < p.length; c += 1)this.addLine(p[c], t, a, s, l, u); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, i, r) }, Ds.prototype.addLine = function (t, e, n, r, i, o) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) { this.lineClipsArray.push(this.lineClips); for (var a = 0; a < t.length - 1; a++)this.totalDistance += t[a].dist(t[a + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance) } for (var s = "Polygon" === Ps[e.type], l = t.length; l >= 2 && t[l - 1].equals(t[l - 2]);)l--; for (var u = 0; u < l - 1 && t[u].equals(t[u + 1]);)u++; if (!(l < (s ? 3 : 2))) { "bevel" === n && (i = 1.05); var c, p = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, h = this.segments.prepareSegment(10 * l, this.layoutVertexArray, this.indexArray), f = void 0, d = void 0, m = void 0, v = void 0; this.e1 = this.e2 = -1, s && (v = t[u].sub(c = t[l - 2])._unit()._perp()); for (var y = u; y < l; y++)if (!(d = y === l - 1 ? s ? t[u + 1] : void 0 : t[y + 1]) || !t[y].equals(d)) { v && (m = v), c && (f = c), c = t[y], v = d ? d.sub(c)._unit()._perp() : m; var g = (m = m || v).add(v); 0 === g.x && 0 === g.y || g._unit(); var _ = m.x * v.x + m.y * v.y, x = g.x * v.x + g.y * v.y, b = 0 !== x ? 1 / x : 1 / 0, w = 2 * Math.sqrt(2 - 2 * x), S = x < Ls && f && d, E = m.x * v.y - m.y * v.x > 0; if (S && y > u) { var C = c.dist(f); if (C > 2 * p) { var T = c.sub(c.sub(f)._mult(p / C)._round()); this.updateDistance(f, T), this.addCurrentVertex(T, m, 0, 0, h), f = T } } var A = f && d, M = A ? n : s ? "butt" : r; if (A && "round" === M && (b < o ? M = "miter" : b <= 2 && (M = "fakeround")), "miter" === M && b > i && (M = "bevel"), "bevel" === M && (b > 2 && (M = "flipbevel"), b < i && (M = "miter")), f && this.updateDistance(f, c), "miter" === M) g._mult(b), this.addCurrentVertex(c, g, 0, 0, h); else if ("flipbevel" === M) { if (b > 100) g = v.mult(-1); else { var O = b * m.add(v).mag() / m.sub(v).mag(); g._perp()._mult(O * (E ? -1 : 1)) } this.addCurrentVertex(c, g, 0, 0, h), this.addCurrentVertex(c, g.mult(-1), 0, 0, h) } else if ("bevel" === M || "fakeround" === M) { var k = -Math.sqrt(b * b - 1), I = E ? k : 0, P = E ? 0 : k; if (f && this.addCurrentVertex(c, m, I, P, h), "fakeround" === M) for (var L = Math.round(180 * w / Math.PI / 20), R = 1; R < L; R++) { var D = R / L; if (.5 !== D) { var N = D - .5; D += D * N * (D - 1) * ((1.0904 + _ * (_ * (3.55645 - 1.43519 * _) - 3.2452)) * N * N + (.848013 + _ * (.215638 * _ - 1.06021))) } var z = v.sub(m)._mult(D)._add(m)._unit()._mult(E ? -1 : 1); this.addHalfVertex(c, z.x, z.y, !1, E, 0, h) } d && this.addCurrentVertex(c, v, -I, -P, h) } else if ("butt" === M) this.addCurrentVertex(c, g, 0, 0, h); else if ("square" === M) { var F = f ? 1 : -1; this.addCurrentVertex(c, g, F, F, h) } else "round" === M && (f && (this.addCurrentVertex(c, m, 0, 0, h), this.addCurrentVertex(c, m, 1, 1, h, !0)), d && (this.addCurrentVertex(c, v, -1, -1, h, !0), this.addCurrentVertex(c, v, 0, 0, h))); if (S && y < l - 1) { var B = c.dist(d); if (B > 2 * p) { var j = c.add(d.sub(c)._mult(p / B)._round()); this.updateDistance(c, j), this.addCurrentVertex(j, v, 0, 0, h), c = j } } } } }, Ds.prototype.addCurrentVertex = function (t, e, n, r, i, o) { void 0 === o && (o = !1); var a = e.y * r - e.x, s = -e.y - e.x * r; this.addHalfVertex(t, e.x + e.y * n, e.y - e.x * n, o, !1, n, i), this.addHalfVertex(t, a, s, o, !0, -r, i), this.distance > Rs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, n, r, i, o)) }, Ds.prototype.addHalfVertex = function (t, e, n, r, i, o, a) { var s = .5 * (this.lineClips ? this.scaledDistance * (Rs - 1) : this.scaledDistance); this.layoutVertexArray.emplaceBack((t.x << 1) + (r ? 1 : 0), (t.y << 1) + (i ? 1 : 0), Math.round(63 * e) + 128, Math.round(63 * n) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1) | (63 & s) << 2, s >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length); var l = a.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), a.primitiveLength++), i ? this.e2 = l : this.e1 = l }, Ds.prototype.updateScaledDistance = function () { this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance }, Ds.prototype.updateDistance = function (t, e) { this.distance += t.dist(e), this.updateScaledDistance() }, Fr("LineBucket", Ds, { omit: ["layers", "patternFeatures"] }); var Ns = new bi({ "line-cap": new vi(Ot.layout_line["line-cap"]), "line-join": new yi(Ot.layout_line["line-join"]), "line-miter-limit": new vi(Ot.layout_line["line-miter-limit"]), "line-round-limit": new vi(Ot.layout_line["line-round-limit"]), "line-sort-key": new yi(Ot.layout_line["line-sort-key"]) }), zs = { paint: new bi({ "line-opacity": new yi(Ot.paint_line["line-opacity"]), "line-color": new yi(Ot.paint_line["line-color"]), "line-translate": new vi(Ot.paint_line["line-translate"]), "line-translate-anchor": new vi(Ot.paint_line["line-translate-anchor"]), "line-width": new yi(Ot.paint_line["line-width"]), "line-gap-width": new yi(Ot.paint_line["line-gap-width"]), "line-offset": new yi(Ot.paint_line["line-offset"]), "line-blur": new yi(Ot.paint_line["line-blur"]), "line-dasharray": new _i(Ot.paint_line["line-dasharray"]), "line-pattern": new gi(Ot.paint_line["line-pattern"]), "line-gradient": new xi(Ot.paint_line["line-gradient"]) }), layout: Ns }, Fs = new (function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (e, n) { return n = new si(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), t.prototype.possiblyEvaluate.call(this, e, n) }, e.prototype.evaluate = function (e, n, r, i) { return n = h({}, n, { zoom: Math.floor(n.zoom) }), t.prototype.evaluate.call(this, e, n, r, i) }, e }(yi))(zs.paint.properties["line-width"].specification); Fs.useIntegerZoom = !0; var Bs = function (t) { function e(e) { t.call(this, e, zs), this.gradientVersion = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { "line-gradient" === t && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ge, this.gradientVersion = (this.gradientVersion + 1) % s) }, e.prototype.gradientExpression = function () { return this._transitionablePaint._values["line-gradient"].value.expression }, e.prototype.recalculate = function (e, n) { t.prototype.recalculate.call(this, e, n), this.paint._values["line-floorwidth"] = Fs.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e) }, e.prototype.createBucket = function (t) { return new Ds(t) }, e.prototype.queryRadius = function (t) { var e = t, n = js(ea("line-width", this, e), ea("line-gap-width", this, e)), r = ea("line-offset", this, e); return n / 2 + Math.abs(r) + na(this.paint.get("line-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, n, r, o, a, s) { var l = ra(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, s), u = s / 2 * js(this.paint.get("line-width").evaluate(e, n), this.paint.get("line-gap-width").evaluate(e, n)), c = this.paint.get("line-offset").evaluate(e, n); return c && (r = function (t, e) { for (var n = [], r = new i(0, 0), o = 0; o < t.length; o++) { for (var a = t[o], s = [], l = 0; l < a.length; l++) { var u = a[l], c = a[l + 1], p = 0 === l ? r : u.sub(a[l - 1])._unit()._perp(), h = l === a.length - 1 ? r : c.sub(u)._unit()._perp(), f = p._add(h)._unit(); f._mult(1 / (f.x * h.x + f.y * h.y)), s.push(f._mult(e)._add(u)) } n.push(s) } return n }(r, c * s)), function (t, e, n) { for (var r = 0; r < e.length; r++) { var i = e[r]; if (t.length >= 3) for (var o = 0; o < i.length; o++)if ($o(t, i[o])) return !0; if (qo(t, i, n)) return !0 } return !1 }(l, r, u) }, e.prototype.isTileClipped = function () { return !0 }, e }(wi); function js(t, e) { return e > 0 ? e + 2 * t : t } var Us = Ti([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Vs = Ti([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Gs = (Ti([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), Ti([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Hs = (Ti([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), Ti([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Ws = Ti([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); function Xs(t, e, n) { return t.sections.forEach((function (t) { t.text = function (t, e, n) { var r = e.layout.get("text-transform").evaluate(n, {}); return "uppercase" === r ? t = t.toLocaleUpperCase() : "lowercase" === r && (t = t.toLocaleLowerCase()), ai.applyArabicShaping && (t = ai.applyArabicShaping(t)), t }(t.text, e, n) })), t } Ti([{ name: "triangle", components: 3, type: "Uint16" }]), Ti([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ti([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ti([{ type: "Float32", name: "offsetX" }]), Ti([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]); var qs = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }, Zs = function (t, e, n, r, i) { var o, a, s = 8 * i - r - 1, l = (1 << s) - 1, u = l >> 1, c = -7, p = n ? i - 1 : 0, h = n ? -1 : 1, f = t[e + p]; for (p += h, o = f & (1 << -c) - 1, f >>= -c, c += s; c > 0; o = 256 * o + t[e + p], p += h, c -= 8); for (a = o & (1 << -c) - 1, o >>= -c, c += r; c > 0; a = 256 * a + t[e + p], p += h, c -= 8); if (0 === o) o = 1 - u; else { if (o === l) return a ? NaN : 1 / 0 * (f ? -1 : 1); a += Math.pow(2, r), o -= u } return (f ? -1 : 1) * a * Math.pow(2, o - r) }, Ys = function (t, e, n, r, i, o) { var a, s, l, u = 8 * o - i - 1, c = (1 << u) - 1, p = c >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : o - 1, d = r ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + p >= 1 ? h / l : h * Math.pow(2, 1 - p)) * l >= 2 && (a++, l /= 2), a + p >= c ? (s = 0, a = c) : a + p >= 1 ? (s = (e * l - 1) * Math.pow(2, i), a += p) : (s = e * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; t[n + f] = 255 & s, f += d, s /= 256, i -= 8); for (a = a << i | s, u += i; u > 0; t[n + f] = 255 & a, f += d, a /= 256, u -= 8); t[n + f - d] |= 128 * m }, Ks = Qs; function Qs(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } Qs.Varint = 0, Qs.Fixed64 = 1, Qs.Bytes = 2, Qs.Fixed32 = 5; var Js = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8"); function $s(t) { return t.type === Qs.Bytes ? t.readVarint() + t.pos : t.pos + 1 } function tl(t, e, n) { return n ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0) } function el(t, e, n) { var r = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2)); n.realloc(r); for (var i = n.pos - 1; i >= t; i--)n.buf[i + r] = n.buf[i] } function nl(t, e) { for (var n = 0; n < t.length; n++)e.writeVarint(t[n]) } function rl(t, e) { for (var n = 0; n < t.length; n++)e.writeSVarint(t[n]) } function il(t, e) { for (var n = 0; n < t.length; n++)e.writeFloat(t[n]) } function ol(t, e) { for (var n = 0; n < t.length; n++)e.writeDouble(t[n]) } function al(t, e) { for (var n = 0; n < t.length; n++)e.writeBoolean(t[n]) } function sl(t, e) { for (var n = 0; n < t.length; n++)e.writeFixed32(t[n]) } function ll(t, e) { for (var n = 0; n < t.length; n++)e.writeSFixed32(t[n]) } function ul(t, e) { for (var n = 0; n < t.length; n++)e.writeFixed64(t[n]) } function cl(t, e) { for (var n = 0; n < t.length; n++)e.writeSFixed64(t[n]) } function pl(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3] } function hl(t, e, n) { t[n] = e, t[n + 1] = e >>> 8, t[n + 2] = e >>> 16, t[n + 3] = e >>> 24 } function fl(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24) } function dl(t, e, n) { 1 === t && n.readMessage(ml, e) } function ml(t, e, n) { if (3 === t) { var r = n.readMessage(vl, {}), i = r.width, o = r.height, a = r.left, s = r.top, l = r.advance; e.push({ id: r.id, bitmap: new ga({ width: i + 6, height: o + 6 }, r.bitmap), metrics: { width: i, height: o, left: a, top: s, advance: l } }) } } function vl(t, e, n) { 1 === t ? e.id = n.readVarint() : 2 === t ? e.bitmap = n.readBytes() : 3 === t ? e.width = n.readVarint() : 4 === t ? e.height = n.readVarint() : 5 === t ? e.left = n.readSVarint() : 6 === t ? e.top = n.readSVarint() : 7 === t && (e.advance = n.readVarint()) } function yl(t) { for (var e = 0, n = 0, r = 0, i = t; r < i.length; r += 1) { var o = i[r]; e += o.w * o.h, n = Math.max(n, o.w) } t.sort((function (t, e) { return e.h - t.h })); for (var a = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), n), h: 1 / 0 }], s = 0, l = 0, u = 0, c = t; u < c.length; u += 1)for (var p = c[u], h = a.length - 1; h >= 0; h--) { var f = a[h]; if (!(p.w > f.w || p.h > f.h)) { if (p.x = f.x, p.y = f.y, l = Math.max(l, p.y + p.h), s = Math.max(s, p.x + p.w), p.w === f.w && p.h === f.h) { var d = a.pop(); h < a.length && (a[h] = d) } else p.h === f.h ? (f.x += p.w, f.w -= p.w) : p.w === f.w ? (f.y += p.h, f.h -= p.h) : (a.push({ x: f.x + p.w, y: f.y, w: f.w - p.w, h: p.h }), f.y += p.h, f.h -= p.h); break } } return { w: s, h: l, fill: e / (s * l) || 0 } } Qs.prototype = { destroy: function () { this.buf = null }, readFields: function (t, e, n) { for (n = n || this.length; this.pos < n;) { var r = this.readVarint(), i = r >> 3, o = this.pos; this.type = 7 & r, t(i, e, this), this.pos === o && this.skip(r) } return e }, readMessage: function (t, e) { return this.readFields(t, e, this.readVarint() + this.pos) }, readFixed32: function () { var t = pl(this.buf, this.pos); return this.pos += 4, t }, readSFixed32: function () { var t = fl(this.buf, this.pos); return this.pos += 4, t }, readFixed64: function () { var t = pl(this.buf, this.pos) + 4294967296 * pl(this.buf, this.pos + 4); return this.pos += 8, t }, readSFixed64: function () { var t = pl(this.buf, this.pos) + 4294967296 * fl(this.buf, this.pos + 4); return this.pos += 8, t }, readFloat: function () { var t = Zs(this.buf, this.pos, !0, 23, 4); return this.pos += 4, t }, readDouble: function () { var t = Zs(this.buf, this.pos, !0, 52, 8); return this.pos += 8, t }, readVarint: function (t) { var e, n, r = this.buf; return e = 127 & (n = r[this.pos++]), n < 128 ? e : (e |= (127 & (n = r[this.pos++])) << 7, n < 128 ? e : (e |= (127 & (n = r[this.pos++])) << 14, n < 128 ? e : (e |= (127 & (n = r[this.pos++])) << 21, n < 128 ? e : function (t, e, n) { var r, i, o = n.buf; if (r = (112 & (i = o[n.pos++])) >> 4, i < 128) return tl(t, r, e); if (r |= (127 & (i = o[n.pos++])) << 3, i < 128) return tl(t, r, e); if (r |= (127 & (i = o[n.pos++])) << 10, i < 128) return tl(t, r, e); if (r |= (127 & (i = o[n.pos++])) << 17, i < 128) return tl(t, r, e); if (r |= (127 & (i = o[n.pos++])) << 24, i < 128) return tl(t, r, e); if (r |= (1 & (i = o[n.pos++])) << 31, i < 128) return tl(t, r, e); throw new Error("Expected varint not more than 10 bytes") }(e |= (15 & (n = r[this.pos])) << 28, t, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var t = this.readVarint(); return t % 2 == 1 ? (t + 1) / -2 : t / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var t = this.readVarint() + this.pos, e = this.pos; return this.pos = t, t - e >= 12 && Js ? function (t, e, n) { return Js.decode(t.subarray(e, n)) }(this.buf, e, t) : function (t, e, n) { for (var r = "", i = e; i < n;) { var o, a, s, l = t[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (i + c > n) break; 1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (o = t[i + 1])) && (u = (31 & l) << 6 | 63 & o) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (o = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & o) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], s = t[i + 3], 128 == (192 & (o = t[i + 1])) && 128 == (192 & a) && 128 == (192 & s) && ((u = (15 & l) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, r += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), r += String.fromCharCode(u), i += c } return r }(this.buf, e, t) }, readBytes: function () { var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e }, readPackedVarint: function (t, e) { if (this.type !== Qs.Bytes) return t.push(this.readVarint(e)); var n = $s(this); for (t = t || []; this.pos < n;)t.push(this.readVarint(e)); return t }, readPackedSVarint: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readSVarint()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readSVarint()); return t }, readPackedBoolean: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readBoolean()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readBoolean()); return t }, readPackedFloat: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readFloat()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readFloat()); return t }, readPackedDouble: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readDouble()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readDouble()); return t }, readPackedFixed32: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readFixed32()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readFixed32()); return t }, readPackedSFixed32: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readSFixed32()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed32()); return t }, readPackedFixed64: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readFixed64()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readFixed64()); return t }, readPackedSFixed64: function (t) { if (this.type !== Qs.Bytes) return t.push(this.readSFixed64()); var e = $s(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed64()); return t }, skip: function (t) { var e = 7 & t; if (e === Qs.Varint) for (; this.buf[this.pos++] > 127;); else if (e === Qs.Bytes) this.pos = this.readVarint() + this.pos; else if (e === Qs.Fixed32) this.pos += 4; else { if (e !== Qs.Fixed64) throw new Error("Unimplemented type: " + e); this.pos += 8 } }, writeTag: function (t, e) { this.writeVarint(t << 3 | e) }, realloc: function (t) { for (var e = this.length || 16; e < this.pos + t;)e *= 2; if (e !== this.length) { var n = new Uint8Array(e); n.set(this.buf), this.buf = n, this.length = e } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (t) { this.realloc(4), hl(this.buf, t, this.pos), this.pos += 4 }, writeSFixed32: function (t) { this.realloc(4), hl(this.buf, t, this.pos), this.pos += 4 }, writeFixed64: function (t) { this.realloc(8), hl(this.buf, -1 & t, this.pos), hl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeSFixed64: function (t) { this.realloc(8), hl(this.buf, -1 & t, this.pos), hl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeVarint: function (t) { (t = +t || 0) > 268435455 || t < 0 ? function (t, e) { var n, r; if (t >= 0 ? (n = t % 4294967296 | 0, r = t / 4294967296 | 0) : (r = ~(-t / 4294967296), 4294967295 ^ (n = ~(-t % 4294967296)) ? n = n + 1 | 0 : (n = 0, r = r + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); e.realloc(10), function (t, e, n) { n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, n.buf[n.pos] = 127 & (t >>>= 7) }(n, 0, e), function (t, e) { var n = (7 & t) << 4; e.buf[e.pos++] |= n | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t))))) }(r, e) }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)))) }, writeSVarint: function (t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t) }, writeBoolean: function (t) { this.writeVarint(Boolean(t)) }, writeString: function (t) { t = String(t), this.realloc(4 * t.length), this.pos++; var e = this.pos; this.pos = function (t, e, n) { for (var r, i, o = 0; o < e.length; o++) { if ((r = e.charCodeAt(o)) > 55295 && r < 57344) { if (!i) { r > 56319 || o + 1 === e.length ? (t[n++] = 239, t[n++] = 191, t[n++] = 189) : i = r; continue } if (r < 56320) { t[n++] = 239, t[n++] = 191, t[n++] = 189, i = r; continue } r = i - 55296 << 10 | r - 56320 | 65536, i = null } else i && (t[n++] = 239, t[n++] = 191, t[n++] = 189, i = null); r < 128 ? t[n++] = r : (r < 2048 ? t[n++] = r >> 6 | 192 : (r < 65536 ? t[n++] = r >> 12 | 224 : (t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128), t[n++] = r >> 6 & 63 | 128), t[n++] = 63 & r | 128) } return n }(this.buf, t, this.pos); var n = this.pos - e; n >= 128 && el(e, n, this), this.pos = e - 1, this.writeVarint(n), this.pos += n }, writeFloat: function (t) { this.realloc(4), Ys(this.buf, t, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (t) { this.realloc(8), Ys(this.buf, t, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (t) { var e = t.length; this.writeVarint(e), this.realloc(e); for (var n = 0; n < e; n++)this.buf[this.pos++] = t[n] }, writeRawMessage: function (t, e) { this.pos++; var n = this.pos; t(e, this); var r = this.pos - n; r >= 128 && el(n, r, this), this.pos = n - 1, this.writeVarint(r), this.pos += r }, writeMessage: function (t, e, n) { this.writeTag(t, Qs.Bytes), this.writeRawMessage(e, n) }, writePackedVarint: function (t, e) { e.length && this.writeMessage(t, nl, e) }, writePackedSVarint: function (t, e) { e.length && this.writeMessage(t, rl, e) }, writePackedBoolean: function (t, e) { e.length && this.writeMessage(t, al, e) }, writePackedFloat: function (t, e) { e.length && this.writeMessage(t, il, e) }, writePackedDouble: function (t, e) { e.length && this.writeMessage(t, ol, e) }, writePackedFixed32: function (t, e) { e.length && this.writeMessage(t, sl, e) }, writePackedSFixed32: function (t, e) { e.length && this.writeMessage(t, ll, e) }, writePackedFixed64: function (t, e) { e.length && this.writeMessage(t, ul, e) }, writePackedSFixed64: function (t, e) { e.length && this.writeMessage(t, cl, e) }, writeBytesField: function (t, e) { this.writeTag(t, Qs.Bytes), this.writeBytes(e) }, writeFixed32Field: function (t, e) { this.writeTag(t, Qs.Fixed32), this.writeFixed32(e) }, writeSFixed32Field: function (t, e) { this.writeTag(t, Qs.Fixed32), this.writeSFixed32(e) }, writeFixed64Field: function (t, e) { this.writeTag(t, Qs.Fixed64), this.writeFixed64(e) }, writeSFixed64Field: function (t, e) { this.writeTag(t, Qs.Fixed64), this.writeSFixed64(e) }, writeVarintField: function (t, e) { this.writeTag(t, Qs.Varint), this.writeVarint(e) }, writeSVarintField: function (t, e) { this.writeTag(t, Qs.Varint), this.writeSVarint(e) }, writeStringField: function (t, e) { this.writeTag(t, Qs.Bytes), this.writeString(e) }, writeFloatField: function (t, e) { this.writeTag(t, Qs.Fixed32), this.writeFloat(e) }, writeDoubleField: function (t, e) { this.writeTag(t, Qs.Fixed64), this.writeDouble(e) }, writeBooleanField: function (t, e) { this.writeVarintField(t, Boolean(e)) } }; var gl = function (t, e) { var n = e.pixelRatio, r = e.version, i = e.stretchX, o = e.stretchY, a = e.content; this.paddedRect = t, this.pixelRatio = n, this.stretchX = i, this.stretchY = o, this.content = a, this.version = r }, _l = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } }; _l.tl.get = function () { return [this.paddedRect.x + 1, this.paddedRect.y + 1] }, _l.br.get = function () { return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1] }, _l.tlbr.get = function () { return this.tl.concat(this.br) }, _l.displaySize.get = function () { return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio] }, Object.defineProperties(gl.prototype, _l); var xl = function (t, e) { var n = {}, r = {}; this.haveRenderCallbacks = []; var i = []; this.addImages(t, n, i), this.addImages(e, r, i); var o = yl(i), a = new _a({ width: o.w || 1, height: o.h || 1 }); for (var s in t) { var l = t[s], u = n[s].paddedRect; _a.copy(l.data, a, { x: 0, y: 0 }, { x: u.x + 1, y: u.y + 1 }, l.data) } for (var c in e) { var p = e[c], h = r[c].paddedRect, f = h.x + 1, d = h.y + 1, m = p.data.width, v = p.data.height; _a.copy(p.data, a, { x: 0, y: 0 }, { x: f, y: d }, p.data), _a.copy(p.data, a, { x: 0, y: v - 1 }, { x: f, y: d - 1 }, { width: m, height: 1 }), _a.copy(p.data, a, { x: 0, y: 0 }, { x: f, y: d + v }, { width: m, height: 1 }), _a.copy(p.data, a, { x: m - 1, y: 0 }, { x: f - 1, y: d }, { width: 1, height: v }), _a.copy(p.data, a, { x: 0, y: 0 }, { x: f + m, y: d }, { width: 1, height: v }) } this.image = a, this.iconPositions = n, this.patternPositions = r }; xl.prototype.addImages = function (t, e, n) { for (var r in t) { var i = t[r], o = { x: 0, y: 0, w: i.data.width + 2, h: i.data.height + 2 }; n.push(o), e[r] = new gl(o, i), i.hasRenderCallback && this.haveRenderCallbacks.push(r) } }, xl.prototype.patchUpdatedImages = function (t, e) { for (var n in t.dispatchRenderCallbacks(this.haveRenderCallbacks), t.updatedImages) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n), e), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n), e) }, xl.prototype.patchUpdatedImage = function (t, e, n) { if (t && e && t.version !== e.version) { t.version = e.version; var r = t.tl; n.update(e.data, void 0, { x: r[0], y: r[1] }) } }, Fr("ImagePosition", gl), Fr("ImageAtlas", xl); var bl = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, wl = function () { this.scale = 1, this.fontStack = "", this.imageName = null }; wl.forText = function (t, e) { var n = new wl; return n.scale = t || 1, n.fontStack = e, n }, wl.forImage = function (t) { var e = new wl; return e.imageName = t, e }; var Sl = function () { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null }; function El(t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m) { var v, y = Sl.fromFeature(t, i); p === bl.vertical && y.verticalizePunctuation(); var g = ai.processBidirectionalText, _ = ai.processStyledBidirectionalText; if (g && 1 === y.sections.length) { v = []; for (var x = 0, b = g(y.toString(), Il(y, u, o, e, r, f, d)); x < b.length; x += 1) { var w = b[x], S = new Sl; S.text = w, S.sections = y.sections; for (var E = 0; E < w.length; E++)S.sectionIndex.push(0); v.push(S) } } else if (_) { v = []; for (var C = 0, T = _(y.text, y.sectionIndex, Il(y, u, o, e, r, f, d)); C < T.length; C += 1) { var A = T[C], M = new Sl; M.text = A[0], M.sectionIndex = A[1], M.sections = y.sections, v.push(M) } } else v = function (t, e) { for (var n = [], r = t.text, i = 0, o = 0, a = e; o < a.length; o += 1) { var s = a[o]; n.push(t.substring(i, s)), i = s } return i < r.length && n.push(t.substring(i, r.length)), n }(y, Il(y, u, o, e, r, f, d)); var O = [], k = { positionedLines: O, text: y.toString(), top: c[1], bottom: c[1], left: c[0], right: c[0], writingMode: p, iconsInText: !1, verticalizable: !1 }; return function (t, e, n, r, i, o, a, s, l, u, c, p) { for (var h = 0, f = -17, d = 0, m = 0, v = "right" === s ? 1 : "left" === s ? 0 : .5, y = 0, g = 0, _ = i; g < _.length; g += 1) { var x = _[g]; x.trim(); var b = x.getMaxScale(), w = 24 * (b - 1), S = { positionedGlyphs: [], lineOffset: 0 }; t.positionedLines[y] = S; var E = S.positionedGlyphs, C = 0; if (x.length()) { for (var T = 0; T < x.length(); T++) { var A = x.getSection(T), M = x.getSectionIndex(T), O = x.getCharCode(T), k = 0, I = null, P = null, L = null, R = 24, D = !(l === bl.horizontal || !c && !qr(O) || c && (Cl[O] || (H = O, Wr.Arabic(H) || Wr["Arabic Supplement"](H) || Wr["Arabic Extended-A"](H) || Wr["Arabic Presentation Forms-A"](H) || Wr["Arabic Presentation Forms-B"](H)))); if (A.imageName) { var N = r[A.imageName]; if (!N) continue; L = A.imageName, t.iconsInText = t.iconsInText || !0, P = N.paddedRect; var z = N.displaySize; A.scale = 24 * A.scale / p, k = w + (24 - z[1] * A.scale), R = (I = { width: z[0], height: z[1], left: 1, top: -3, advance: D ? z[1] : z[0] }).advance; var F = D ? z[0] * A.scale - 24 * b : z[1] * A.scale - 24 * b; F > 0 && F > C && (C = F) } else { var B = n[A.fontStack], j = B && B[O]; if (j && j.rect) P = j.rect, I = j.metrics; else { var U = e[A.fontStack], V = U && U[O]; if (!V) continue; I = V.metrics } k = 24 * (b - A.scale) } D ? (t.verticalizable = !0, E.push({ glyph: O, imageName: L, x: h, y: f + k, vertical: D, scale: A.scale, fontStack: A.fontStack, sectionIndex: M, metrics: I, rect: P }), h += R * A.scale + u) : (E.push({ glyph: O, imageName: L, x: h, y: f + k, vertical: D, scale: A.scale, fontStack: A.fontStack, sectionIndex: M, metrics: I, rect: P }), h += I.advance * A.scale + u) } 0 !== E.length && (d = Math.max(h - u, d), Ll(E, 0, E.length - 1, v, C)), h = 0; var G = o * b + C; S.lineOffset = Math.max(C, w), f += G, m = Math.max(G, m), ++y } else f += o, ++y } var H, W = f - -17, X = Pl(a), q = X.horizontalAlign, Z = X.verticalAlign; (function (t, e, n, r, i, o, a, s, l) { var u, c = (e - n) * i; u = o !== a ? -s * r - -17 : (-r * l + .5) * a; for (var p = 0, h = t; p < h.length; p += 1)for (var f = 0, d = h[p].positionedGlyphs; f < d.length; f += 1) { var m = d[f]; m.x += c, m.y += u } })(t.positionedLines, v, q, Z, d, m, o, W, i.length), t.top += -Z * W, t.bottom = t.top + W, t.left += -q * d, t.right = t.left + d }(k, e, n, r, v, a, s, l, p, u, h, m), !function (t) { for (var e = 0, n = t; e < n.length; e += 1)if (0 !== n[e].positionedGlyphs.length) return !1; return !0 }(O) && k } Sl.fromFeature = function (t, e) { for (var n = new Sl, r = 0; r < t.sections.length; r++) { var i = t.sections[r]; i.image ? n.addImageSection(i) : n.addTextSection(i, e) } return n }, Sl.prototype.length = function () { return this.text.length }, Sl.prototype.getSection = function (t) { return this.sections[this.sectionIndex[t]] }, Sl.prototype.getSectionIndex = function (t) { return this.sectionIndex[t] }, Sl.prototype.getCharCode = function (t) { return this.text.charCodeAt(t) }, Sl.prototype.verticalizePunctuation = function () { this.text = function (t) { for (var e = "", n = 0; n < t.length; n++) { var r = t.charCodeAt(n + 1) || null, i = t.charCodeAt(n - 1) || null; e += r && Zr(r) && !qs[t[n + 1]] || i && Zr(i) && !qs[t[n - 1]] || !qs[t[n]] ? t[n] : qs[t[n]] } return e }(this.text) }, Sl.prototype.trim = function () { for (var t = 0, e = 0; e < this.text.length && Cl[this.text.charCodeAt(e)]; e++)t++; for (var n = this.text.length, r = this.text.length - 1; r >= 0 && r >= t && Cl[this.text.charCodeAt(r)]; r--)n--; this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n) }, Sl.prototype.substring = function (t, e) { var n = new Sl; return n.text = this.text.substring(t, e), n.sectionIndex = this.sectionIndex.slice(t, e), n.sections = this.sections, n }, Sl.prototype.toString = function () { return this.text }, Sl.prototype.getMaxScale = function () { var t = this; return this.sectionIndex.reduce((function (e, n) { return Math.max(e, t.sections[n].scale) }), 0) }, Sl.prototype.addTextSection = function (t, e) { this.text += t.text, this.sections.push(wl.forText(t.scale, t.fontStack || e)); for (var n = this.sections.length - 1, r = 0; r < t.text.length; ++r)this.sectionIndex.push(n) }, Sl.prototype.addImageSection = function (t) { var e = t.image ? t.image.name : ""; if (0 !== e.length) { var n = this.getNextImageSectionCharCode(); n ? (this.text += String.fromCharCode(n), this.sections.push(wl.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : S("Reached maximum number of images 6401") } else S("Can't add FormattedSection with an empty image.") }, Sl.prototype.getNextImageSectionCharCode = function () { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) }; var Cl = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Tl = {}; function Al(t, e, n, r, i, o) { if (e.imageName) { var a = r[e.imageName]; return a ? a.displaySize[0] * e.scale * 24 / o + i : 0 } var s = n[e.fontStack], l = s && s[t]; return l ? l.metrics.advance * e.scale + i : 0 } function Ml(t, e, n, r) { var i = Math.pow(t - e, 2); return r ? t < e ? i / 2 : 2 * i : i + Math.abs(n) * n } function Ol(t, e, n) { var r = 0; return 10 === t && (r -= 1e4), n && (r += 150), 40 !== t && 65288 !== t || (r += 50), 41 !== e && 65289 !== e || (r += 50), r } function kl(t, e, n, r, i, o) { for (var a = null, s = Ml(e, n, i, o), l = 0, u = r; l < u.length; l += 1) { var c = u[l], p = Ml(e - c.x, n, i, o) + c.badness; p <= s && (a = c, s = p) } return { index: t, x: e, priorBreak: a, badness: s } } function Il(t, e, n, r, i, o, a) { if ("point" !== o) return []; if (!t) return []; for (var s, l = [], u = function (t, e, n, r, i, o) { for (var a = 0, s = 0; s < t.length(); s++) { var l = t.getSection(s); a += Al(t.getCharCode(s), l, r, i, e, o) } return a / Math.max(1, Math.ceil(a / n)) }(t, e, n, r, i, a), c = t.text.indexOf("​") >= 0, p = 0, h = 0; h < t.length(); h++) { var f = t.getSection(h), d = t.getCharCode(h); if (Cl[d] || (p += Al(d, f, r, i, e, a)), h < t.length() - 1) { var m = !((s = d) < 11904 || !(Wr["Bopomofo Extended"](s) || Wr.Bopomofo(s) || Wr["CJK Compatibility Forms"](s) || Wr["CJK Compatibility Ideographs"](s) || Wr["CJK Compatibility"](s) || Wr["CJK Radicals Supplement"](s) || Wr["CJK Strokes"](s) || Wr["CJK Symbols and Punctuation"](s) || Wr["CJK Unified Ideographs Extension A"](s) || Wr["CJK Unified Ideographs"](s) || Wr["Enclosed CJK Letters and Months"](s) || Wr["Halfwidth and Fullwidth Forms"](s) || Wr.Hiragana(s) || Wr["Ideographic Description Characters"](s) || Wr["Kangxi Radicals"](s) || Wr["Katakana Phonetic Extensions"](s) || Wr.Katakana(s) || Wr["Vertical Forms"](s) || Wr["Yi Radicals"](s) || Wr["Yi Syllables"](s))); (Tl[d] || m || f.imageName) && l.push(kl(h + 1, p, u, l, Ol(d, t.getCharCode(h + 1), m && c), !1)) } } return function t(e) { return e ? t(e.priorBreak).concat(e.index) : [] }(kl(t.length(), p, u, l, 0, !0)) } function Pl(t) { var e = .5, n = .5; switch (t) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0 }switch (t) { case "bottom": case "bottom-right": case "bottom-left": n = 1; break; case "top": case "top-right": case "top-left": n = 0 }return { horizontalAlign: e, verticalAlign: n } } function Ll(t, e, n, r, i) { if (r || i) for (var o = t[n], a = (t[n].x + o.metrics.advance * o.scale) * r, s = e; s <= n; s++)t[s].x -= a, t[s].y += i } function Rl(t, e, n, r, i, o) { var a, s = t.image; if (s.content) { var l = s.content, u = s.pixelRatio || 1; a = [l[0] / u, l[1] / u, s.displaySize[0] - l[2] / u, s.displaySize[1] - l[3] / u] } var c, p, h, f, d = e.left * o, m = e.right * o; "width" === n || "both" === n ? (f = i[0] + d - r[3], p = i[0] + m + r[1]) : p = (f = i[0] + (d + m - s.displaySize[0]) / 2) + s.displaySize[0]; var v = e.top * o, y = e.bottom * o; return "height" === n || "both" === n ? (c = i[1] + v - r[0], h = i[1] + y + r[2]) : h = (c = i[1] + (v + y - s.displaySize[1]) / 2) + s.displaySize[1], { image: s, top: c, right: p, bottom: h, left: f, collisionPadding: a } } Tl[10] = !0, Tl[32] = !0, Tl[38] = !0, Tl[40] = !0, Tl[41] = !0, Tl[43] = !0, Tl[45] = !0, Tl[47] = !0, Tl[173] = !0, Tl[183] = !0, Tl[8203] = !0, Tl[8208] = !0, Tl[8211] = !0, Tl[8231] = !0; var Dl = function (t) { function e(e, n, r, i) { t.call(this, e, n), this.angle = r, void 0 !== i && (this.segment = i) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.clone = function () { return new e(this.x, this.y, this.angle, this.segment) }, e }(i); function Nl(t, e) { var n = e.expression; if ("constant" === n.kind) return { kind: "constant", layoutSize: n.evaluate(new si(t + 1)) }; if ("source" === n.kind) return { kind: "source" }; for (var r = n.zoomStops, i = n.interpolationType, o = 0; o < r.length && r[o] <= t;)o++; for (var a = o = Math.max(0, o - 1); a < r.length && r[a] < t + 1;)a++; a = Math.min(r.length - 1, a); var s = r[o], l = r[a]; return "composite" === n.kind ? { kind: "composite", minZoom: s, maxZoom: l, interpolationType: i } : { kind: "camera", minZoom: s, maxZoom: l, minSize: n.evaluate(new si(s)), maxSize: n.evaluate(new si(l)), interpolationType: i } } function zl(t, e, n) { var r = e.uSize, i = n.lowerSize; return "source" === t.kind ? i / 128 : "composite" === t.kind ? He(i / 128, n.upperSize / 128, e.uSizeT) : r } function Fl(t, e) { var n = 0, r = 0; if ("constant" === t.kind) r = t.layoutSize; else if ("source" !== t.kind) { var i = t.interpolationType, o = i ? c(an.interpolationFactor(i, e, t.minZoom, t.maxZoom), 0, 1) : 0; "camera" === t.kind ? r = He(t.minSize, t.maxSize, o) : n = o } return { uSizeT: n, uSize: r } } Fr("Anchor", Dl); var Bl = Object.freeze({ __proto__: null, getSizeData: Nl, evaluateSizeForFeature: zl, evaluateSizeForZoom: Fl, SIZE_PACK_FACTOR: 128 }); function jl(t, e, n, r, i) { if (void 0 === e.segment) return !0; for (var o = e, a = e.segment + 1, s = 0; s > -n / 2;) { if (--a < 0) return !1; s -= t[a].dist(o), o = t[a] } s += t[a].dist(t[a + 1]), a++; for (var l = [], u = 0; s < n / 2;) { var c = t[a], p = t[a + 1]; if (!p) return !1; var h = t[a - 1].angleTo(c) - c.angleTo(p); for (h = Math.abs((h + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({ distance: s, angleDelta: h }), u += h; s - l[0].distance > r;)u -= l.shift().angleDelta; if (u > i) return !1; a++, s += c.dist(p) } return !0 } function Ul(t) { for (var e = 0, n = 0; n < t.length - 1; n++)e += t[n].dist(t[n + 1]); return e } function Vl(t, e, n) { return t ? .6 * e * n : 0 } function Gl(t, e) { return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0) } function Hl(t, e, n, r, i, o) { for (var a = Vl(n, i, o), s = Gl(n, r) * o, l = 0, u = Ul(t) / 2, c = 0; c < t.length - 1; c++) { var p = t[c], h = t[c + 1], f = p.dist(h); if (l + f > u) { var d = (u - l) / f, m = He(p.x, h.x, d), v = He(p.y, h.y, d), y = new Dl(m, v, h.angleTo(p), c); return y._round(), !a || jl(t, y, s, a, e) ? y : void 0 } l += f } } function Wl(t, e, n, r, i, o, a, s, l) { var u = Vl(r, o, a), c = Gl(r, i), p = c * a, h = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l; return e - p < e / 4 && (e = p + e / 4), function t(e, n, r, i, o, a, s, l, u) { for (var c = a / 2, p = Ul(e), h = 0, f = n - r, d = [], m = 0; m < e.length - 1; m++) { for (var v = e[m], y = e[m + 1], g = v.dist(y), _ = y.angleTo(v); f + r < h + g;) { var x = ((f += r) - h) / g, b = He(v.x, y.x, x), w = He(v.y, y.y, x); if (b >= 0 && b < u && w >= 0 && w < u && f - c >= 0 && f + c <= p) { var S = new Dl(b, w, _, m); S._round(), i && !jl(e, S, a, i, o) || d.push(S) } } h += g } return l || d.length || s || (d = t(e, h / 2, r, i, o, a, s, !0, u)), d }(t, h ? e / 2 * s % e : (c / 2 + 2 * o) * a * s % e, e, u, n, p, h, !1, l) } function Xl(t, e, n, r, o) { for (var a = [], s = 0; s < t.length; s++)for (var l = t[s], u = void 0, c = 0; c < l.length - 1; c++) { var p = l[c], h = l[c + 1]; p.x < e && h.x < e || (p.x < e ? p = new i(e, p.y + (e - p.x) / (h.x - p.x) * (h.y - p.y))._round() : h.x < e && (h = new i(e, p.y + (e - p.x) / (h.x - p.x) * (h.y - p.y))._round()), p.y < n && h.y < n || (p.y < n ? p = new i(p.x + (n - p.y) / (h.y - p.y) * (h.x - p.x), n)._round() : h.y < n && (h = new i(p.x + (n - p.y) / (h.y - p.y) * (h.x - p.x), n)._round()), p.x >= r && h.x >= r || (p.x >= r ? p = new i(r, p.y + (r - p.x) / (h.x - p.x) * (h.y - p.y))._round() : h.x >= r && (h = new i(r, p.y + (r - p.x) / (h.x - p.x) * (h.y - p.y))._round()), p.y >= o && h.y >= o || (p.y >= o ? p = new i(p.x + (o - p.y) / (h.y - p.y) * (h.x - p.x), o)._round() : h.y >= o && (h = new i(p.x + (o - p.y) / (h.y - p.y) * (h.x - p.x), o)._round()), u && p.equals(u[u.length - 1]) || a.push(u = [p]), u.push(h))))) } return a } function ql(t, e, n, r) { var o = [], a = t.image, s = a.pixelRatio, l = a.paddedRect.w - 2, u = a.paddedRect.h - 2, c = t.right - t.left, p = t.bottom - t.top, h = a.stretchX || [[0, l]], f = a.stretchY || [[0, u]], d = function (t, e) { return t + e[1] - e[0] }, m = h.reduce(d, 0), v = f.reduce(d, 0), y = l - m, g = u - v, _ = 0, x = m, b = 0, w = v, S = 0, E = y, C = 0, T = g; if (a.content && r) { var A = a.content; _ = Zl(h, 0, A[0]), b = Zl(f, 0, A[1]), x = Zl(h, A[0], A[2]), w = Zl(f, A[1], A[3]), S = A[0] - _, C = A[1] - b, E = A[2] - A[0] - x, T = A[3] - A[1] - w } var M = function (r, o, l, u) { var h = Kl(r.stretch - _, x, c, t.left), f = Ql(r.fixed - S, E, r.stretch, m), d = Kl(o.stretch - b, w, p, t.top), y = Ql(o.fixed - C, T, o.stretch, v), g = Kl(l.stretch - _, x, c, t.left), A = Ql(l.fixed - S, E, l.stretch, m), M = Kl(u.stretch - b, w, p, t.top), O = Ql(u.fixed - C, T, u.stretch, v), k = new i(h, d), I = new i(g, d), P = new i(g, M), L = new i(h, M), R = new i(f / s, y / s), D = new i(A / s, O / s), N = e * Math.PI / 180; if (N) { var z = Math.sin(N), F = Math.cos(N), B = [F, -z, z, F]; k._matMult(B), I._matMult(B), L._matMult(B), P._matMult(B) } var j = r.stretch + r.fixed, U = o.stretch + o.fixed; return { tl: k, tr: I, bl: L, br: P, tex: { x: a.paddedRect.x + 1 + j, y: a.paddedRect.y + 1 + U, w: l.stretch + l.fixed - j, h: u.stretch + u.fixed - U }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: R, pixelOffsetBR: D, minFontScaleX: E / s / c, minFontScaleY: T / s / p, isSDF: n } }; if (r && (a.stretchX || a.stretchY)) for (var O = Yl(h, y, m), k = Yl(f, g, v), I = 0; I < O.length - 1; I++)for (var P = O[I], L = O[I + 1], R = 0; R < k.length - 1; R++)o.push(M(P, k[R], L, k[R + 1])); else o.push(M({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l + 1 }, { fixed: 0, stretch: u + 1 })); return o } function Zl(t, e, n) { for (var r = 0, i = 0, o = t; i < o.length; i += 1) { var a = o[i]; r += Math.max(e, Math.min(n, a[1])) - Math.max(e, Math.min(n, a[0])) } return r } function Yl(t, e, n) { for (var r = [{ fixed: -1, stretch: 0 }], i = 0, o = t; i < o.length; i += 1) { var a = o[i], s = a[0], l = a[1], u = r[r.length - 1]; r.push({ fixed: s - u.stretch, stretch: u.stretch }), r.push({ fixed: s - u.stretch, stretch: u.stretch + (l - s) }) } return r.push({ fixed: e + 1, stretch: n }), r } function Kl(t, e, n, r) { return t / e * n + r } function Ql(t, e, n, r) { return t - e * n / r } var Jl = function (t, e, n, r, o, a, s, l, u, c) { if (this.boxStartIndex = t.length, u) { var p = a.top, h = a.bottom, f = a.collisionPadding; f && (p -= f[1], h += f[3]); var d = h - p; d > 0 && (d = Math.max(10, d), this.circleDiameter = d) } else { var m = a.top * s - l, v = a.bottom * s + l, y = a.left * s - l, g = a.right * s + l, _ = a.collisionPadding; if (_ && (y -= _[0] * s, m -= _[1] * s, g += _[2] * s, v += _[3] * s), c) { var x = new i(y, m), b = new i(g, m), w = new i(y, v), S = new i(g, v), E = c * Math.PI / 180; x._rotate(E), b._rotate(E), w._rotate(E), S._rotate(E), y = Math.min(x.x, b.x, w.x, S.x), g = Math.max(x.x, b.x, w.x, S.x), m = Math.min(x.y, b.y, w.y, S.y), v = Math.max(x.y, b.y, w.y, S.y) } t.emplaceBack(e.x, e.y, y, m, g, v, n, r, o) } this.boxEndIndex = t.length }, $l = function (t, e) { if (void 0 === t && (t = []), void 0 === e && (e = tu), this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (var n = (this.length >> 1) - 1; n >= 0; n--)this._down(n) }; function tu(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function eu(t, e, n) { void 0 === e && (e = 1), void 0 === n && (n = !1); for (var r = 1 / 0, o = 1 / 0, a = -1 / 0, s = -1 / 0, l = t[0], u = 0; u < l.length; u++) { var c = l[u]; (!u || c.x < r) && (r = c.x), (!u || c.y < o) && (o = c.y), (!u || c.x > a) && (a = c.x), (!u || c.y > s) && (s = c.y) } var p = Math.min(a - r, s - o), h = p / 2, f = new $l([], nu); if (0 === p) return new i(r, o); for (var d = r; d < a; d += p)for (var m = o; m < s; m += p)f.push(new ru(d + h, m + h, h, t)); for (var v = function (t) { for (var e = 0, n = 0, r = 0, i = t[0], o = 0, a = i.length, s = a - 1; o < a; s = o++) { var l = i[o], u = i[s], c = l.x * u.y - u.x * l.y; n += (l.x + u.x) * c, r += (l.y + u.y) * c, e += 3 * c } return new ru(n / e, r / e, 0, t) }(t), y = f.length; f.length;) { var g = f.pop(); (g.d > v.d || !v.d) && (v = g, n && console.log("found best %d after %d probes", Math.round(1e4 * g.d) / 1e4, y)), g.max - v.d <= e || (f.push(new ru(g.p.x - (h = g.h / 2), g.p.y - h, h, t)), f.push(new ru(g.p.x + h, g.p.y - h, h, t)), f.push(new ru(g.p.x - h, g.p.y + h, h, t)), f.push(new ru(g.p.x + h, g.p.y + h, h, t)), y += 4) } return n && (console.log("num probes: " + y), console.log("best distance: " + v.d)), v.p } function nu(t, e) { return e.max - t.max } function ru(t, e, n, r) { this.p = new i(t, e), this.h = n, this.d = function (t, e) { for (var n = !1, r = 1 / 0, i = 0; i < e.length; i++)for (var o = e[i], a = 0, s = o.length, l = s - 1; a < s; l = a++) { var u = o[a], c = o[l]; u.y > t.y != c.y > t.y && t.x < (c.x - u.x) * (t.y - u.y) / (c.y - u.y) + u.x && (n = !n), r = Math.min(r, Qo(t, u, c)) } return (n ? 1 : -1) * Math.sqrt(r) }(this.p, r), this.max = this.d + this.h * Math.SQRT2 } $l.prototype.push = function (t) { this.data.push(t), this.length++, this._up(this.length - 1) }, $l.prototype.pop = function () { if (0 !== this.length) { var t = this.data[0], e = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t } }, $l.prototype.peek = function () { return this.data[0] }, $l.prototype._up = function (t) { for (var e = this.data, n = this.compare, r = e[t]; t > 0;) { var i = t - 1 >> 1, o = e[i]; if (n(r, o) >= 0) break; e[t] = o, t = i } e[t] = r }, $l.prototype._down = function (t) { for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) { var o = 1 + (t << 1), a = e[o], s = o + 1; if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0) break; e[t] = a, t = o } e[t] = i }; var iu = Number.POSITIVE_INFINITY; function ou(t, e) { return e[1] !== iu ? function (t, e, n) { var r = 0, i = 0; switch (e = Math.abs(e), n = Math.abs(n), t) { case "top-right": case "top-left": case "top": i = n - 7; break; case "bottom-right": case "bottom-left": case "bottom": i = 7 - n }switch (t) { case "top-right": case "bottom-right": case "right": r = -e; break; case "top-left": case "bottom-left": case "left": r = e }return [r, i] }(t, e[0], e[1]) : function (t, e) { var n = 0, r = 0; e < 0 && (e = 0); var i = e / Math.sqrt(2); switch (t) { case "top-right": case "top-left": r = i - 7; break; case "bottom-right": case "bottom-left": r = 7 - i; break; case "bottom": r = 7 - e; break; case "top": r = e - 7 }switch (t) { case "top-right": case "bottom-right": n = -i; break; case "top-left": case "bottom-left": n = i; break; case "left": n = e; break; case "right": n = -e }return [n, r] }(t, e[0]) } function au(t) { switch (t) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function su(t, e, n, r, o, a, s, l, u, c, p, h, f, d, m) { var v = function (t, e, n, r, o, a, s, l) { for (var u = r.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180, c = [], p = 0, h = e.positionedLines; p < h.length; p += 1)for (var f = h[p], d = 0, m = f.positionedGlyphs; d < m.length; d += 1) { var v = m[d]; if (v.rect) { var y = v.rect || {}, g = 4, _ = !0, x = 1, b = 0, w = (o || l) && v.vertical, S = v.metrics.advance * v.scale / 2; if (l && e.verticalizable && (b = f.lineOffset / 2 - (v.imageName ? -(24 - v.metrics.width * v.scale) / 2 : 24 * (v.scale - 1))), v.imageName) { var E = s[v.imageName]; _ = E.sdf, g = 1 / (x = E.pixelRatio) } var C = o ? [v.x + S, v.y] : [0, 0], T = o ? [0, 0] : [v.x + S + n[0], v.y + n[1] - b], A = [0, 0]; w && (A = T, T = [0, 0]); var M = (v.metrics.left - g) * v.scale - S + T[0], O = (-v.metrics.top - g) * v.scale + T[1], k = M + y.w * v.scale / x, I = O + y.h * v.scale / x, P = new i(M, O), L = new i(k, O), R = new i(M, I), D = new i(k, I); if (w) { var N = new i(-S, S - -17), z = -Math.PI / 2, F = 12 - S, B = new i(22 - F, -(v.imageName ? F : 0)), j = new (Function.prototype.bind.apply(i, [null].concat(A))); P._rotateAround(z, N)._add(B)._add(j), L._rotateAround(z, N)._add(B)._add(j), R._rotateAround(z, N)._add(B)._add(j), D._rotateAround(z, N)._add(B)._add(j) } if (u) { var U = Math.sin(u), V = Math.cos(u), G = [V, -U, U, V]; P._matMult(G), L._matMult(G), R._matMult(G), D._matMult(G) } var H = new i(0, 0), W = new i(0, 0); c.push({ tl: P, tr: L, bl: R, br: D, tex: y, writingMode: e.writingMode, glyphOffset: C, sectionIndex: v.sectionIndex, isSDF: _, pixelOffsetTL: H, pixelOffsetBR: W, minFontScaleX: 0, minFontScaleY: 0 }) } } return c }(0, n, l, o, a, s, r, t.allowVerticalPlacement), y = t.textSizeData, g = null; "source" === y.kind ? (g = [128 * o.layout.get("text-size").evaluate(s, {})])[0] > 32640 && S(t.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === y.kind && ((g = [128 * d.compositeTextSizes[0].evaluate(s, {}, m), 128 * d.compositeTextSizes[1].evaluate(s, {}, m)])[0] > 32640 || g[1] > 32640) && S(t.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t.addSymbols(t.text, v, g, l, a, s, c, e, u.lineStartIndex, u.lineLength, f, m); for (var _ = 0, x = p; _ < x.length; _ += 1)h[x[_]] = t.text.placedSymbolArray.length - 1; return 4 * v.length } function lu(t) { for (var e in t) return t[e]; return null } function uu(t, e, n, r) { var i = t.compareText; if (e in i) { for (var o = i[e], a = o.length - 1; a >= 0; a--)if (r.dist(o[a]) < n) return !0 } else i[e] = []; return i[e].push(r), !1 } var cu = xs.VectorTileFeature.types, pu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function hu(t, e, n, r, i, o, a, s, l, u, c, p, h) { var f = s ? Math.min(32640, Math.round(s[0])) : 0, d = s ? Math.min(32640, Math.round(s[1])) : 0; t.emplaceBack(e, n, Math.round(32 * r), Math.round(32 * i), o, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * p, 256 * h) } function fu(t, e, n) { t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n) } function du(t) { for (var e = 0, n = t.sections; e < n.length; e += 1)if (Qr(n[e].text)) return !0; return !1 } var mu = function (t) { this.layoutVertexArray = new Ri, this.indexArray = new Ui, this.programConfigurations = t, this.segments = new so, this.dynamicLayoutVertexArray = new Di, this.opacityVertexArray = new Ni, this.placedSymbolArray = new $i }; mu.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length }, mu.prototype.upload = function (t, e, n, r) { this.isEmpty() || (n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Us.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Vs.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, pu, !0), this.opacityVertexBuffer.itemSize = 1), (n || r) && this.programConfigurations.upload(t)) }, mu.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()) }, Fr("SymbolBuffers", mu); var vu = function (t, e, n) { this.layoutVertexArray = new t, this.layoutAttributes = e, this.indexArray = new n, this.segments = new so, this.collisionVertexArray = new ji }; vu.prototype.upload = function (t) { this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Gs.members, !0) }, vu.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()) }, Fr("CollisionBuffers", vu); var yu = function (t) { this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = sa([]), this.placementViewportMatrix = sa([]); var e = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Nl(this.zoom, e["text-size"]), this.iconSizeData = Nl(this.zoom, e["icon-size"]); var n = this.layers[0].layout, r = n.get("symbol-sort-key"), i = n.get("symbol-z-order"); this.canOverlap = n.get("text-allow-overlap") || n.get("icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== r.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, "point" === n.get("symbol-placement") && (this.writingModes = n.get("text-writing-mode").map((function (t) { return bl[t] }))), this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })), this.sourceID = t.sourceID }; yu.prototype.createArrays = function () { this.text = new mu(new Do(this.layers, this.zoom, (function (t) { return /^text/.test(t) }))), this.icon = new mu(new Do(this.layers, this.zoom, (function (t) { return /^icon/.test(t) }))), this.glyphOffsetArray = new no, this.lineVertexArray = new ro, this.symbolInstances = new eo }, yu.prototype.calculateGlyphDependencies = function (t, e, n, r, i) { for (var o = 0; o < t.length; o++)if (e[t.charCodeAt(o)] = !0, (n || r) && i) { var a = qs[t.charAt(o)]; a && (e[a.charCodeAt(0)] = !0) } }, yu.prototype.populate = function (t, e, n) { var r = this.layers[0], i = r.layout, o = i.get("text-font"), a = i.get("text-field"), s = i.get("icon-image"), l = ("constant" !== a.value.kind || a.value.value instanceof re && !a.value.value.isEmpty() || a.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), u = "constant" !== s.value.kind || !!s.value.value || Object.keys(s.parameters).length > 0, c = i.get("symbol-sort-key"); if (this.features = [], l || u) { for (var p = e.iconDependencies, h = e.glyphDependencies, f = e.availableImages, d = new si(this.zoom), m = 0, v = t; m < v.length; m += 1) { var y = v[m], g = y.feature, _ = y.id, x = y.index, b = y.sourceLayerIndex, w = r._featureFilter.needGeometry, S = Uo(g, w); if (r._featureFilter.filter(d, S, n)) { w || (S.geometry = jo(g)); var E = void 0; if (l) { var C = r.getValueAndResolveTokens("text-field", S, n, f), T = re.factory(C); du(T) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === ii() || this.hasRTLText && ai.isParsed()) && (E = Xs(T, r, S)) } var A = void 0; if (u) { var M = r.getValueAndResolveTokens("icon-image", S, n, f); A = M instanceof ie ? M : ie.fromString(M) } if (E || A) { var O = this.sortFeaturesByKey ? c.evaluate(S, {}, n) : void 0; if (this.features.push({ id: _, text: E, icon: A, index: x, sourceLayerIndex: b, geometry: S.geometry, properties: g.properties, type: cu[g.type], sortKey: O }), A && (p[A.name] = !0), E) { var k = o.evaluate(S, {}, n).join(","), I = "map" === i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement"); this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(bl.vertical) >= 0; for (var P = 0, L = E.sections; P < L.length; P += 1) { var R = L[P]; if (R.image) p[R.image.name] = !0; else { var D = Xr(E.toString()), N = R.fontStack || k, z = h[N] = h[N] || {}; this.calculateGlyphDependencies(R.text, z, I, this.allowVerticalPlacement, D) } } } } } } "line" === i.get("symbol-placement") && (this.features = function (t) { var e = {}, n = {}, r = [], i = 0; function o(e) { r.push(t[e]), i++ } function a(t, e, i) { var o = n[t]; return delete n[t], n[e] = o, r[o].geometry[0].pop(), r[o].geometry[0] = r[o].geometry[0].concat(i[0]), o } function s(t, n, i) { var o = e[n]; return delete e[n], e[t] = o, r[o].geometry[0].shift(), r[o].geometry[0] = i[0].concat(r[o].geometry[0]), o } function l(t, e, n) { var r = n ? e[0][e[0].length - 1] : e[0][0]; return t + ":" + r.x + ":" + r.y } for (var u = 0; u < t.length; u++) { var c = t[u], p = c.geometry, h = c.text ? c.text.toString() : null; if (h) { var f = l(h, p), d = l(h, p, !0); if (f in n && d in e && n[f] !== e[d]) { var m = s(f, d, p), v = a(f, d, r[m].geometry); delete e[f], delete n[d], n[l(h, r[v].geometry, !0)] = v, r[m].geometry = null } else f in n ? a(f, d, p) : d in e ? s(f, d, p) : (o(u), e[f] = i - 1, n[d] = i - 1) } else o(u) } return r.filter((function (t) { return t.geometry })) }(this.features)), this.sortFeaturesByKey && this.features.sort((function (t, e) { return t.sortKey - e.sortKey })) } }, yu.prototype.update = function (t, e, n) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, n)) }, yu.prototype.isEmpty = function () { return 0 === this.symbolInstances.length && !this.hasRTLText }, yu.prototype.uploadPending = function () { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload }, yu.prototype.upload = function (t) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 }, yu.prototype.destroyDebugData = function () { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy() }, yu.prototype.destroy = function () { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData() }, yu.prototype.addToLineVertexArray = function (t, e) { var n = this.lineVertexArray.length; if (void 0 !== t.segment) { for (var r = t.dist(e[t.segment + 1]), i = t.dist(e[t.segment]), o = {}, a = t.segment + 1; a < e.length; a++)o[a] = { x: e[a].x, y: e[a].y, tileUnitDistanceFromAnchor: r }, a < e.length - 1 && (r += e[a + 1].dist(e[a])); for (var s = t.segment || 0; s >= 0; s--)o[s] = { x: e[s].x, y: e[s].y, tileUnitDistanceFromAnchor: i }, s > 0 && (i += e[s - 1].dist(e[s])); for (var l = 0; l < e.length; l++) { var u = o[l]; this.lineVertexArray.emplaceBack(u.x, u.y, u.tileUnitDistanceFromAnchor) } } return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n } }, yu.prototype.addSymbols = function (t, e, n, r, i, o, a, s, l, u, c, p) { for (var h = t.indexArray, f = t.layoutVertexArray, d = t.segments.prepareSegment(4 * e.length, f, h, this.canOverlap ? o.sortKey : void 0), m = this.glyphOffsetArray.length, v = d.vertexLength, y = this.allowVerticalPlacement && a === bl.vertical ? Math.PI / 2 : 0, g = o.text && o.text.sections, _ = 0; _ < e.length; _++) { var x = e[_], b = x.tl, w = x.tr, S = x.bl, E = x.br, C = x.tex, T = x.pixelOffsetTL, A = x.pixelOffsetBR, M = x.minFontScaleX, O = x.minFontScaleY, k = x.glyphOffset, I = x.isSDF, P = x.sectionIndex, L = d.vertexLength, R = k[1]; hu(f, s.x, s.y, b.x, R + b.y, C.x, C.y, n, I, T.x, T.y, M, O), hu(f, s.x, s.y, w.x, R + w.y, C.x + C.w, C.y, n, I, A.x, T.y, M, O), hu(f, s.x, s.y, S.x, R + S.y, C.x, C.y + C.h, n, I, T.x, A.y, M, O), hu(f, s.x, s.y, E.x, R + E.y, C.x + C.w, C.y + C.h, n, I, A.x, A.y, M, O), fu(t.dynamicLayoutVertexArray, s, y), h.emplaceBack(L, L + 1, L + 2), h.emplaceBack(L + 1, L + 2, L + 3), d.vertexLength += 4, d.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k[0]), _ !== e.length - 1 && P === e[_ + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, o, o.index, {}, p, g && g[P]) } t.placedSymbolArray.emplaceBack(s.x, s.y, m, this.glyphOffsetArray.length - m, v, l, u, s.segment, n ? n[0] : 0, n ? n[1] : 0, r[0], r[1], a, 0, !1, 0, c) }, yu.prototype._addCollisionDebugVertex = function (t, e, n, r, i, o) { return e.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, r, i, Math.round(o.x), Math.round(o.y)) }, yu.prototype.addCollisionDebugVertices = function (t, e, n, r, o, a, s) { var l = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), u = l.vertexLength, c = o.layoutVertexArray, p = o.collisionVertexArray, h = s.anchorX, f = s.anchorY; this._addCollisionDebugVertex(c, p, a, h, f, new i(t, e)), this._addCollisionDebugVertex(c, p, a, h, f, new i(n, e)), this._addCollisionDebugVertex(c, p, a, h, f, new i(n, r)), this._addCollisionDebugVertex(c, p, a, h, f, new i(t, r)), l.vertexLength += 4; var d = o.indexArray; d.emplaceBack(u, u + 1), d.emplaceBack(u + 1, u + 2), d.emplaceBack(u + 2, u + 3), d.emplaceBack(u + 3, u), l.primitiveLength += 4 }, yu.prototype.addDebugCollisionBoxes = function (t, e, n, r) { for (var i = t; i < e; i++) { var o = this.collisionBoxArray.get(i); this.addCollisionDebugVertices(o.x1, o.y1, o.x2, o.y2, r ? this.textCollisionBox : this.iconCollisionBox, o.anchorPoint, n) } }, yu.prototype.generateCollisionDebugBuffers = function () { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new vu(Fi, Hs.members, qi), this.iconCollisionBox = new vu(Fi, Hs.members, qi); for (var t = 0; t < this.symbolInstances.length; t++) { var e = this.symbolInstances.get(t); this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1) } }, yu.prototype._deserializeCollisionBoxesForSymbol = function (t, e, n, r, i, o, a, s, l) { for (var u = {}, c = e; c < n; c++) { var p = t.get(c); u.textBox = { x1: p.x1, y1: p.y1, x2: p.x2, y2: p.y2, anchorPointX: p.anchorPointX, anchorPointY: p.anchorPointY }, u.textFeatureIndex = p.featureIndex; break } for (var h = r; h < i; h++) { var f = t.get(h); u.verticalTextBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, u.verticalTextFeatureIndex = f.featureIndex; break } for (var d = o; d < a; d++) { var m = t.get(d); u.iconBox = { x1: m.x1, y1: m.y1, x2: m.x2, y2: m.y2, anchorPointX: m.anchorPointX, anchorPointY: m.anchorPointY }, u.iconFeatureIndex = m.featureIndex; break } for (var v = s; v < l; v++) { var y = t.get(v); u.verticalIconBox = { x1: y.x1, y1: y.y1, x2: y.x2, y2: y.y2, anchorPointX: y.anchorPointX, anchorPointY: y.anchorPointY }, u.verticalIconFeatureIndex = y.featureIndex; break } return u }, yu.prototype.deserializeCollisionBoxes = function (t) { this.collisionArrays = []; for (var e = 0; e < this.symbolInstances.length; e++) { var n = this.symbolInstances.get(e); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex)) } }, yu.prototype.hasTextData = function () { return this.text.segments.get().length > 0 }, yu.prototype.hasIconData = function () { return this.icon.segments.get().length > 0 }, yu.prototype.hasDebugData = function () { return this.textCollisionBox && this.iconCollisionBox }, yu.prototype.hasTextCollisionBoxData = function () { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 }, yu.prototype.hasIconCollisionBoxData = function () { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 }, yu.prototype.addIndicesForPlacedSymbol = function (t, e) { for (var n = t.placedSymbolArray.get(e), r = n.vertexStartIndex + 4 * n.numGlyphs, i = n.vertexStartIndex; i < r; i += 4)t.indexArray.emplaceBack(i, i + 1, i + 2), t.indexArray.emplaceBack(i + 1, i + 2, i + 3) }, yu.prototype.getSortedSymbolIndexes = function (t) { if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes; for (var e = Math.sin(t), n = Math.cos(t), r = [], i = [], o = [], a = 0; a < this.symbolInstances.length; ++a) { o.push(a); var s = this.symbolInstances.get(a); r.push(0 | Math.round(e * s.anchorX + n * s.anchorY)), i.push(s.featureIndex) } return o.sort((function (t, e) { return r[t] - r[e] || i[e] - i[t] })), o }, yu.prototype.addToSortKeyRanges = function (t, e) { var n = this.sortKeyRanges[this.sortKeyRanges.length - 1]; n && n.sortKey === e ? n.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: e, symbolInstanceStart: t, symbolInstanceEnd: t + 1 }) }, yu.prototype.sortFeatures = function (t) { var e = this; if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (var n = 0, r = this.symbolInstanceIndexes; n < r.length; n += 1) { var i = this.symbolInstances.get(r[n]); this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach((function (t, n, r) { t >= 0 && r.indexOf(t) === n && e.addIndicesForPlacedSymbol(e.text, t) })), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } }, Fr("SymbolBucket", yu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), yu.MAX_GLYPHS = 65535, yu.addDynamicAttributes = fu; var gu = new bi({ "symbol-placement": new vi(Ot.layout_symbol["symbol-placement"]), "symbol-spacing": new vi(Ot.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new vi(Ot.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new yi(Ot.layout_symbol["symbol-sort-key"]), "symbol-z-order": new vi(Ot.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new vi(Ot.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new vi(Ot.layout_symbol["icon-ignore-placement"]), "icon-optional": new vi(Ot.layout_symbol["icon-optional"]), "icon-rotation-alignment": new vi(Ot.layout_symbol["icon-rotation-alignment"]), "icon-size": new yi(Ot.layout_symbol["icon-size"]), "icon-text-fit": new vi(Ot.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new vi(Ot.layout_symbol["icon-text-fit-padding"]), "icon-image": new yi(Ot.layout_symbol["icon-image"]), "icon-rotate": new yi(Ot.layout_symbol["icon-rotate"]), "icon-padding": new vi(Ot.layout_symbol["icon-padding"]), "icon-keep-upright": new vi(Ot.layout_symbol["icon-keep-upright"]), "icon-offset": new yi(Ot.layout_symbol["icon-offset"]), "icon-anchor": new yi(Ot.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new vi(Ot.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new vi(Ot.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new vi(Ot.layout_symbol["text-rotation-alignment"]), "text-field": new yi(Ot.layout_symbol["text-field"]), "text-font": new yi(Ot.layout_symbol["text-font"]), "text-size": new yi(Ot.layout_symbol["text-size"]), "text-max-width": new yi(Ot.layout_symbol["text-max-width"]), "text-line-height": new vi(Ot.layout_symbol["text-line-height"]), "text-letter-spacing": new yi(Ot.layout_symbol["text-letter-spacing"]), "text-justify": new yi(Ot.layout_symbol["text-justify"]), "text-radial-offset": new yi(Ot.layout_symbol["text-radial-offset"]), "text-variable-anchor": new vi(Ot.layout_symbol["text-variable-anchor"]), "text-anchor": new yi(Ot.layout_symbol["text-anchor"]), "text-max-angle": new vi(Ot.layout_symbol["text-max-angle"]), "text-writing-mode": new vi(Ot.layout_symbol["text-writing-mode"]), "text-rotate": new yi(Ot.layout_symbol["text-rotate"]), "text-padding": new vi(Ot.layout_symbol["text-padding"]), "text-keep-upright": new vi(Ot.layout_symbol["text-keep-upright"]), "text-transform": new yi(Ot.layout_symbol["text-transform"]), "text-offset": new yi(Ot.layout_symbol["text-offset"]), "text-allow-overlap": new vi(Ot.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new vi(Ot.layout_symbol["text-ignore-placement"]), "text-optional": new vi(Ot.layout_symbol["text-optional"]) }), _u = { paint: new bi({ "icon-opacity": new yi(Ot.paint_symbol["icon-opacity"]), "icon-color": new yi(Ot.paint_symbol["icon-color"]), "icon-halo-color": new yi(Ot.paint_symbol["icon-halo-color"]), "icon-halo-width": new yi(Ot.paint_symbol["icon-halo-width"]), "icon-halo-blur": new yi(Ot.paint_symbol["icon-halo-blur"]), "icon-translate": new vi(Ot.paint_symbol["icon-translate"]), "icon-translate-anchor": new vi(Ot.paint_symbol["icon-translate-anchor"]), "text-opacity": new yi(Ot.paint_symbol["text-opacity"]), "text-color": new yi(Ot.paint_symbol["text-color"], { runtimeType: Ut, getOverride: function (t) { return t.textColor }, hasOverride: function (t) { return !!t.textColor } }), "text-halo-color": new yi(Ot.paint_symbol["text-halo-color"]), "text-halo-width": new yi(Ot.paint_symbol["text-halo-width"]), "text-halo-blur": new yi(Ot.paint_symbol["text-halo-blur"]), "text-translate": new vi(Ot.paint_symbol["text-translate"]), "text-translate-anchor": new vi(Ot.paint_symbol["text-translate-anchor"]) }), layout: gu }, xu = function (t) { this.type = t.property.overrides ? t.property.overrides.runtimeType : zt, this.defaultValue = t }; xu.prototype.evaluate = function (t) { if (t.formattedSection) { var e = this.defaultValue.property.overrides; if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection) } return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default }, xu.prototype.eachChild = function (t) { this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression) }, xu.prototype.outputDefined = function () { return !1 }, xu.prototype.serialize = function () { return null }, Fr("FormatSectionOverride", xu, { omit: ["defaultValue"] }); var bu = function (t) { function e(e) { t.call(this, e, _u) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, n) { if (t.prototype.recalculate.call(this, e, n), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) { var r = this.layout.get("text-writing-mode"); if (r) { for (var i = [], o = 0, a = r; o < a.length; o += 1) { var s = a[o]; i.indexOf(s) < 0 && i.push(s) } this.layout._values["text-writing-mode"] = i } else this.layout._values["text-writing-mode"] = ["horizontal"] } this._setPaintOverrides() }, e.prototype.getValueAndResolveTokens = function (t, e, n, r) { var i = this.layout.get(t).evaluate(e, {}, n, r), o = this._unevaluatedLayout._values[t]; return o.isDataDriven() || Xn(o.value) || !i ? i : function (t, e) { return e.replace(/{([^{}]+)}/g, (function (e, n) { return n in t ? String(t[n]) : "" })) }(e.properties, i) }, e.prototype.createBucket = function (t) { return new yu(t) }, e.prototype.queryRadius = function () { return 0 }, e.prototype.queryIntersectsFeature = function () { return !1 }, e.prototype._setPaintOverrides = function () { for (var t = 0, n = _u.paint.overridableProperties; t < n.length; t += 1) { var r = n[t]; if (e.hasPaintOverride(this.layout, r)) { var i, o = this.paint.get(r), a = new xu(o), s = new Wn(a, o.property.specification); i = "constant" === o.value.kind || "source" === o.value.kind ? new Zn("source", s) : new Yn("composite", s, o.value.zoomStops, o.value._interpolationType), this.paint._values[r] = new di(o.property, i, o.parameters) } } }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, n, r) { return !(!this.layout || n.isDataDriven() || r.isDataDriven()) && e.hasPaintOverride(this.layout, t) }, e.hasPaintOverride = function (t, e) { var n = t.get("text-field"), r = _u.paint.properties[e], i = !1, o = function (t) { for (var e = 0, n = t; e < n.length; e += 1)if (r.overrides && r.overrides.hasOverride(n[e])) return void (i = !0) }; if ("constant" === n.value.kind && n.value.value instanceof re) o(n.value.value.sections); else if ("source" === n.value.kind) { var a = function (t) { i || (t instanceof ue && se(t.value) === Wt ? o(t.value.sections) : t instanceof fe ? o(t.sections) : t.eachChild(a)) }, s = n.value; s._styleExpression && a(s._styleExpression.expression) } return i }, e }(wi), wu = { paint: new bi({ "background-color": new vi(Ot.paint_background["background-color"]), "background-pattern": new _i(Ot.paint_background["background-pattern"]), "background-opacity": new vi(Ot.paint_background["background-opacity"]) }) }, Su = function (t) { function e(e) { t.call(this, e, wu) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(wi), Eu = { paint: new bi({ "raster-opacity": new vi(Ot.paint_raster["raster-opacity"]), "raster-hue-rotate": new vi(Ot.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new vi(Ot.paint_raster["raster-brightness-min"]), "raster-brightness-max": new vi(Ot.paint_raster["raster-brightness-max"]), "raster-saturation": new vi(Ot.paint_raster["raster-saturation"]), "raster-contrast": new vi(Ot.paint_raster["raster-contrast"]), "raster-resampling": new vi(Ot.paint_raster["raster-resampling"]), "raster-fade-duration": new vi(Ot.paint_raster["raster-fade-duration"]) }) }, Cu = function (t) { function e(e) { t.call(this, e, Eu) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(wi), Tu = function (t) { function e(e) { t.call(this, e, {}), this.implementation = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.is3D = function () { return "3d" === this.implementation.renderingMode }, e.prototype.hasOffscreenPass = function () { return void 0 !== this.implementation.prerender }, e.prototype.recalculate = function () { }, e.prototype.updateTransitions = function () { }, e.prototype.hasTransition = function () { }, e.prototype.serialize = function () { }, e.prototype.onAdd = function (t) { this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl) }, e.prototype.onRemove = function (t) { this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl) }, e }(wi), Au = { circle: ha, heatmap: wa, hillshade: Ea, fill: cs, "fill-extrusion": As, line: Bs, symbol: bu, background: Su, raster: Cu }, Mu = a.HTMLImageElement, Ou = a.HTMLCanvasElement, ku = a.HTMLVideoElement, Iu = a.ImageData, Pu = a.ImageBitmap, Lu = function (t, e, n, r) { this.context = t, this.format = n, this.texture = t.gl.createTexture(), this.update(e, r) }; Lu.prototype.update = function (t, e, n) { var r = t.width, i = t.height, o = !(this.size && this.size[0] === r && this.size[1] === i || n), a = this.context, s = a.gl; if (this.useMipmap = Boolean(e && e.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), o) this.size = [r, i], t instanceof Mu || t instanceof Ou || t instanceof ku || t instanceof Iu || Pu && t instanceof Pu ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, t) : s.texImage2D(s.TEXTURE_2D, 0, this.format, r, i, 0, this.format, s.UNSIGNED_BYTE, t.data); else { var l = n || { x: 0, y: 0 }, u = l.x, c = l.y; t instanceof Mu || t instanceof Ou || t instanceof ku || t instanceof Iu || Pu && t instanceof Pu ? s.texSubImage2D(s.TEXTURE_2D, 0, u, c, s.RGBA, s.UNSIGNED_BYTE, t) : s.texSubImage2D(s.TEXTURE_2D, 0, u, c, r, i, s.RGBA, s.UNSIGNED_BYTE, t.data) } this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D) }, Lu.prototype.bind = function (t, e, n) { var r = this.context.gl; r.bindTexture(r.TEXTURE_2D, this.texture), n !== r.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = r.LINEAR), t !== this.filter && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, n || t), this.filter = t), e !== this.wrap && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, e), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, e), this.wrap = e) }, Lu.prototype.isSizePowerOfTwo = function () { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 }, Lu.prototype.destroy = function () { this.context.gl.deleteTexture(this.texture), this.texture = null }; var Ru = function (t) { var e = this; this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = function () { e._triggered = !1, e._callback() }) }; Ru.prototype.trigger = function () { var t = this; this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((function () { t._triggered = !1, t._callback() }), 0)) }, Ru.prototype.remove = function () { delete this._channel, this._callback = function () { } }; var Du = function (t, e, n) { this.target = t, this.parent = e, this.mapId = n, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, y(["receive", "process"], this), this.invoker = new Ru(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = T() ? t : a }; function Nu(t, e, n) { var r = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n); return [t * r - 2 * Math.PI * 6378137 / 2, e * r - 2 * Math.PI * 6378137 / 2] } Du.prototype.send = function (t, e, n, r, i) { var o = this; void 0 === i && (i = !1); var a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10); n && (this.callbacks[a] = n); var s = O(this.globalScope) ? void 0 : []; return this.target.postMessage({ id: a, type: t, hasCallback: !!n, targetMapId: r, mustQueue: i, sourceMapId: this.mapId, data: Vr(e, s) }, s), { cancel: function () { n && delete o.callbacks[a], o.target.postMessage({ id: a, type: "<cancel>", targetMapId: r, sourceMapId: o.mapId }) } } }, Du.prototype.receive = function (t) { var e = t.data, n = e.id; if (n && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) { delete this.tasks[n]; var r = this.cancelCallbacks[n]; delete this.cancelCallbacks[n], r && r() } else T() || e.mustQueue ? (this.tasks[n] = e, this.taskQueue.push(n), this.invoker.trigger()) : this.processTask(n, e) }, Du.prototype.process = function () { if (this.taskQueue.length) { var t = this.taskQueue.shift(), e = this.tasks[t]; delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e) } }, Du.prototype.processTask = function (t, e) { var n = this; if ("<response>" === e.type) { var r = this.callbacks[t]; delete this.callbacks[t], r && (e.error ? r(Gr(e.error)) : r(null, Gr(e.data))) } else { var i = !1, o = O(this.globalScope) ? void 0 : [], a = e.hasCallback ? function (e, r) { i = !0, delete n.cancelCallbacks[t], n.target.postMessage({ id: t, type: "<response>", sourceMapId: n.mapId, error: e ? Vr(e) : null, data: Vr(r, o) }, o) } : function (t) { i = !0 }, s = null, l = Gr(e.data); if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, l, a); else if (this.parent.getWorkerSource) { var u = e.type.split("."); s = this.parent.getWorkerSource(e.sourceMapId, u[0], l.source)[u[1]](l, a) } else a(new Error("Could not find function " + e.type)); !i && s && s.cancel && (this.cancelCallbacks[t] = s.cancel) } }, Du.prototype.remove = function () { this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1) }; var zu = function (t, e) { t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])) }; zu.prototype.setNorthEast = function (t) { return this._ne = t instanceof Fu ? new Fu(t.lng, t.lat) : Fu.convert(t), this }, zu.prototype.setSouthWest = function (t) { return this._sw = t instanceof Fu ? new Fu(t.lng, t.lat) : Fu.convert(t), this }, zu.prototype.extend = function (t) { var e, n, r = this._sw, i = this._ne; if (t instanceof Fu) e = t, n = t; else { if (!(t instanceof zu)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(zu.convert(t)) : this.extend(Fu.convert(t)) : this; if (n = t._ne, !(e = t._sw) || !n) return this } return r || i ? (r.lng = Math.min(e.lng, r.lng), r.lat = Math.min(e.lat, r.lat), i.lng = Math.max(n.lng, i.lng), i.lat = Math.max(n.lat, i.lat)) : (this._sw = new Fu(e.lng, e.lat), this._ne = new Fu(n.lng, n.lat)), this }, zu.prototype.getCenter = function () { return new Fu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) }, zu.prototype.getSouthWest = function () { return this._sw }, zu.prototype.getNorthEast = function () { return this._ne }, zu.prototype.getNorthWest = function () { return new Fu(this.getWest(), this.getNorth()) }, zu.prototype.getSouthEast = function () { return new Fu(this.getEast(), this.getSouth()) }, zu.prototype.getWest = function () { return this._sw.lng }, zu.prototype.getSouth = function () { return this._sw.lat }, zu.prototype.getEast = function () { return this._ne.lng }, zu.prototype.getNorth = function () { return this._ne.lat }, zu.prototype.toArray = function () { return [this._sw.toArray(), this._ne.toArray()] }, zu.prototype.toString = function () { return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")" }, zu.prototype.isEmpty = function () { return !(this._sw && this._ne) }, zu.prototype.contains = function (t) { var e = Fu.convert(t), n = e.lng, r = e.lat, i = this._sw.lng <= n && n <= this._ne.lng; return this._sw.lng > this._ne.lng && (i = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && i }, zu.convert = function (t) { return !t || t instanceof zu ? t : new zu(t) }; var Fu = function (t, e) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")"); if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") }; Fu.prototype.wrap = function () { return new Fu(p(this.lng, -180, 180), this.lat) }, Fu.prototype.toArray = function () { return [this.lng, this.lat] }, Fu.prototype.toString = function () { return "LngLat(" + this.lng + ", " + this.lat + ")" }, Fu.prototype.distanceTo = function (t) { var e = Math.PI / 180, n = this.lat * e, r = t.lat * e, i = Math.sin(n) * Math.sin(r) + Math.cos(n) * Math.cos(r) * Math.cos((t.lng - this.lng) * e); return 6371008.8 * Math.acos(Math.min(i, 1)) }, Fu.prototype.toBounds = function (t) { void 0 === t && (t = 0); var e = 360 * t / 40075017, n = e / Math.cos(Math.PI / 180 * this.lat); return new zu(new Fu(this.lng - n, this.lat - e), new Fu(this.lng + n, this.lat + e)) }, Fu.convert = function (t) { if (t instanceof Fu) return t; if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Fu(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Fu(Number("lng" in t ? t.lng : t.lon), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") }; var Bu = 2 * Math.PI * 6371008.8; function ju(t) { return Bu * Math.cos(t * Math.PI / 180) } function Uu(t) { return (180 + t) / 360 } function Vu(t) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360 } function Gu(t, e) { return t / ju(e) } function Hu(t) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90 } var Wu = function (t, e, n) { void 0 === n && (n = 0), this.x = +t, this.y = +e, this.z = +n }; Wu.fromLngLat = function (t, e) { void 0 === e && (e = 0); var n = Fu.convert(t); return new Wu(Uu(n.lng), Vu(n.lat), Gu(e, n.lat)) }, Wu.prototype.toLngLat = function () { return new Fu(360 * this.x - 180, Hu(this.y)) }, Wu.prototype.toAltitude = function () { return this.z * ju(Hu(this.y)) }, Wu.prototype.meterInMercatorCoordinateUnits = function () { return 1 / Bu * (t = Hu(this.y), 1 / Math.cos(t * Math.PI / 180)); var t }; var Xu = function (t, e, n) { this.z = t, this.x = e, this.y = n, this.key = Yu(0, t, t, e, n) }; Xu.prototype.equals = function (t) { return this.z === t.z && this.x === t.x && this.y === t.y }, Xu.prototype.url = function (t, e) { var n, r, i, o, a, s = (r = this.y, i = this.z, o = Nu(256 * (n = this.x), 256 * (r = Math.pow(2, i) - r - 1), i), a = Nu(256 * (n + 1), 256 * (r + 1), i), o[0] + "," + o[1] + "," + a[0] + "," + a[1]), l = function (t, e, n) { for (var r, i = "", o = t; o > 0; o--)i += (e & (r = 1 << o - 1) ? 1 : 0) + (n & r ? 2 : 0); return i }(this.z, this.x, this.y); return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", l).replace("{bbox-epsg-3857}", s) }, Xu.prototype.getTilePoint = function (t) { var e = Math.pow(2, this.z); return new i(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y)) }, Xu.prototype.toString = function () { return this.z + "/" + this.x + "/" + this.y }; var qu = function (t, e) { this.wrap = t, this.canonical = e, this.key = Yu(t, e.z, e.z, e.x, e.y) }, Zu = function (t, e, n, r, i) { this.overscaledZ = t, this.wrap = e, this.canonical = new Xu(n, +r, +i), this.key = Yu(e, t, n, r, i) }; function Yu(t, e, n, r, i) { (t *= 2) < 0 && (t = -1 * t - 1); var o = 1 << n; return (o * o * t + o * i + r).toString(36) + n.toString(36) + e.toString(36) } Zu.prototype.equals = function (t) { return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical) }, Zu.prototype.scaledTo = function (t) { var e = this.canonical.z - t; return t > this.canonical.z ? new Zu(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Zu(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e) }, Zu.prototype.calculateScaledKey = function (t, e) { var n = this.canonical.z - t; return t > this.canonical.z ? Yu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : Yu(this.wrap * +e, t, t, this.canonical.x >> n, this.canonical.y >> n) }, Zu.prototype.isChildOf = function (t) { if (t.wrap !== this.wrap) return !1; var e = this.canonical.z - t.canonical.z; return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e }, Zu.prototype.children = function (t) { if (this.overscaledZ >= t) return [new Zu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; var e = this.canonical.z + 1, n = 2 * this.canonical.x, r = 2 * this.canonical.y; return [new Zu(e, this.wrap, e, n, r), new Zu(e, this.wrap, e, n + 1, r), new Zu(e, this.wrap, e, n, r + 1), new Zu(e, this.wrap, e, n + 1, r + 1)] }, Zu.prototype.isLessThan = function (t) { return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)) }, Zu.prototype.wrapped = function () { return new Zu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) }, Zu.prototype.unwrapTo = function (t) { return new Zu(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y) }, Zu.prototype.overscaleFactor = function () { return Math.pow(2, this.overscaledZ - this.canonical.z) }, Zu.prototype.toUnwrapped = function () { return new qu(this.wrap, this.canonical) }, Zu.prototype.toString = function () { return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y }, Zu.prototype.getTilePoint = function (t) { return this.canonical.getTilePoint(new Wu(t.x - this.wrap, t.y)) }, Fr("CanonicalTileID", Xu), Fr("OverscaledTileID", Zu, { omit: ["posMatrix"] }); var Ku = function (t, e, n) { if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square"); if (n && "mapbox" !== n && "terrarium" !== n) return S('"' + n + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'); this.stride = e.height; var r = this.dim = e.height - 2; this.data = new Uint32Array(e.data.buffer), this.encoding = n || "mapbox"; for (var i = 0; i < r; i++)this.data[this._idx(-1, i)] = this.data[this._idx(0, i)], this.data[this._idx(r, i)] = this.data[this._idx(r - 1, i)], this.data[this._idx(i, -1)] = this.data[this._idx(i, 0)], this.data[this._idx(i, r)] = this.data[this._idx(i, r - 1)]; this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(r, -1)] = this.data[this._idx(r - 1, 0)], this.data[this._idx(-1, r)] = this.data[this._idx(0, r - 1)], this.data[this._idx(r, r)] = this.data[this._idx(r - 1, r - 1)] }; Ku.prototype.get = function (t, e) { var n = new Uint8Array(this.data.buffer), r = 4 * this._idx(t, e); return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(n[r], n[r + 1], n[r + 2]) }, Ku.prototype.getUnpackVector = function () { return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4] }, Ku.prototype._idx = function (t, e) { if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data"); return (e + 1) * this.stride + (t + 1) }, Ku.prototype._unpackMapbox = function (t, e, n) { return (256 * t * 256 + 256 * e + n) / 10 - 1e4 }, Ku.prototype._unpackTerrarium = function (t, e, n) { return 256 * t + e + n / 256 - 32768 }, Ku.prototype.getPixels = function () { return new _a({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer)) }, Ku.prototype.backfillBorder = function (t, e, n) { if (this.dim !== t.dim) throw new Error("dem dimension mismatch"); var r = e * this.dim, i = e * this.dim + this.dim, o = n * this.dim, a = n * this.dim + this.dim; switch (e) { case -1: r = i - 1; break; case 1: i = r + 1 }switch (n) { case -1: o = a - 1; break; case 1: a = o + 1 }for (var s = -e * this.dim, l = -n * this.dim, u = o; u < a; u++)for (var c = r; c < i; c++)this.data[this._idx(c, u)] = t.data[this._idx(c + s, u + l)] }, Fr("DEMData", Ku); var Qu = function (t) { this._stringToNumber = {}, this._numberToString = []; for (var e = 0; e < t.length; e++) { var n = t[e]; this._stringToNumber[n] = e, this._numberToString[e] = n } }; Qu.prototype.encode = function (t) { return this._stringToNumber[t] }, Qu.prototype.decode = function (t) { return this._numberToString[t] }; var Ju = function (t, e, n, r, i) { this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = n, t._y = r, this.properties = t.properties, this.id = i }, $u = { geometry: { configurable: !0 } }; $u.geometry.get = function () { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry }, $u.geometry.set = function (t) { this._geometry = t }, Ju.prototype.toJSON = function () { var t = { geometry: this.geometry }; for (var e in this) "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]); return t }, Object.defineProperties(Ju.prototype, $u); var tc = function () { this.state = {}, this.stateChanges = {}, this.deletedStates = {} }; tc.prototype.updateState = function (t, e, n) { var r = String(e); if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][r] = this.stateChanges[t][r] || {}, h(this.stateChanges[t][r], n), null === this.deletedStates[t]) for (var i in this.deletedStates[t] = {}, this.state[t]) i !== r && (this.deletedStates[t][i] = null); else if (this.deletedStates[t] && null === this.deletedStates[t][r]) for (var o in this.deletedStates[t][r] = {}, this.state[t][r]) n[o] || (this.deletedStates[t][r][o] = null); else for (var a in n) this.deletedStates[t] && this.deletedStates[t][r] && null === this.deletedStates[t][r][a] && delete this.deletedStates[t][r][a] }, tc.prototype.removeFeatureState = function (t, e, n) { if (null !== this.deletedStates[t]) { var r = String(e); if (this.deletedStates[t] = this.deletedStates[t] || {}, n && void 0 !== e) null !== this.deletedStates[t][r] && (this.deletedStates[t][r] = this.deletedStates[t][r] || {}, this.deletedStates[t][r][n] = null); else if (void 0 !== e) if (this.stateChanges[t] && this.stateChanges[t][r]) for (n in this.deletedStates[t][r] = {}, this.stateChanges[t][r]) this.deletedStates[t][r][n] = null; else this.deletedStates[t][r] = null; else this.deletedStates[t] = null } }, tc.prototype.getState = function (t, e) { var n = String(e), r = h({}, (this.state[t] || {})[n], (this.stateChanges[t] || {})[n]); if (null === this.deletedStates[t]) return {}; if (this.deletedStates[t]) { var i = this.deletedStates[t][e]; if (null === i) return {}; for (var o in i) delete r[o] } return r }, tc.prototype.initializeTileState = function (t, e) { t.setFeatureState(this.state, e) }, tc.prototype.coalesceChanges = function (t, e) { var n = {}; for (var r in this.stateChanges) { this.state[r] = this.state[r] || {}; var i = {}; for (var o in this.stateChanges[r]) this.state[r][o] || (this.state[r][o] = {}), h(this.state[r][o], this.stateChanges[r][o]), i[o] = this.state[r][o]; n[r] = i } for (var a in this.deletedStates) { this.state[a] = this.state[a] || {}; var s = {}; if (null === this.deletedStates[a]) for (var l in this.state[a]) s[l] = {}, this.state[a][l] = {}; else for (var u in this.deletedStates[a]) { if (null === this.deletedStates[a][u]) this.state[a][u] = {}; else for (var c = 0, p = Object.keys(this.deletedStates[a][u]); c < p.length; c += 1)delete this.state[a][u][p[c]]; s[u] = this.state[a][u] } n[a] = n[a] || {}, h(n[a], s) } if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(n).length) for (var f in t) t[f].setFeatureState(n, e) }; var ec = function (t, e) { this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Lr(8192, 16, 0), this.grid3D = new Lr(8192, 16, 0), this.featureIndexArray = new oo, this.promoteId = e }; function nc(t, e, n, r, i) { return _(t, (function (t, o) { var a = e instanceof mi ? e.get(o) : null; return a && a.evaluate ? a.evaluate(n, r, i) : a })) } function rc(t) { for (var e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0, o = 0, a = t; o < a.length; o += 1) { var s = a[o]; e = Math.min(e, s.x), n = Math.min(n, s.y), r = Math.max(r, s.x), i = Math.max(i, s.y) } return { minX: e, minY: n, maxX: r, maxY: i } } function ic(t, e) { return e - t } ec.prototype.insert = function (t, e, n, r, i, o) { var a = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(n, r, i); for (var s = o ? this.grid3D : this.grid, l = 0; l < e.length; l++) { for (var u = e[l], c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = 0; p < u.length; p++) { var h = u[p]; c[0] = Math.min(c[0], h.x), c[1] = Math.min(c[1], h.y), c[2] = Math.max(c[2], h.x), c[3] = Math.max(c[3], h.y) } c[0] < 8192 && c[1] < 8192 && c[2] >= 0 && c[3] >= 0 && s.insert(a, c[0], c[1], c[2], c[3]) } }, ec.prototype.loadVTLayers = function () { return this.vtLayers || (this.vtLayers = new xs.VectorTile(new Ks(this.rawTileData)).layers, this.sourceLayerCoder = new Qu(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers }, ec.prototype.query = function (t, e, n, r) { var o = this; this.loadVTLayers(); for (var a = t.params || {}, s = 8192 / t.tileSize / t.scale, l = ar(a.filter), u = t.queryGeometry, c = t.queryPadding * s, p = rc(u), h = this.grid.query(p.minX - c, p.minY - c, p.maxX + c, p.maxY + c), f = rc(t.cameraQueryGeometry), d = this.grid3D.query(f.minX - c, f.minY - c, f.maxX + c, f.maxY + c, (function (e, n, r, o) { return function (t, e, n, r, o) { for (var a = 0, s = t; a < s.length; a += 1) { var l = s[a]; if (e <= l.x && n <= l.y && r >= l.x && o >= l.y) return !0 } var u = [new i(e, n), new i(e, o), new i(r, o), new i(r, n)]; if (t.length > 2) for (var c = 0, p = u; c < p.length; c += 1)if ($o(t, p[c])) return !0; for (var h = 0; h < t.length - 1; h++)if (ta(t[h], t[h + 1], u)) return !0; return !1 }(t.cameraQueryGeometry, e - c, n - c, r + c, o + c) })), m = 0, v = d; m < v.length; m += 1)h.push(v[m]); h.sort(ic); for (var y, g = {}, _ = function (i) { var c = h[i]; if (c !== y) { y = c; var p = o.featureIndexArray.get(c), f = null; o.loadMatchingFeature(g, p.bucketIndex, p.sourceLayerIndex, p.featureIndex, l, a.layers, a.availableImages, e, n, r, (function (e, n, r) { return f || (f = jo(e)), n.queryIntersectsFeature(u, e, r, f, o.z, t.transform, s, t.pixelPosMatrix) })) } }, x = 0; x < h.length; x++)_(x); return g }, ec.prototype.loadMatchingFeature = function (t, e, n, r, i, o, a, s, l, u, c) { var p = this.bucketLayerIDs[e]; if (!o || function (t, e) { for (var n = 0; n < t.length; n++)if (e.indexOf(t[n]) >= 0) return !0; return !1 }(o, p)) { var f = this.sourceLayerCoder.decode(n), d = this.vtLayers[f].feature(r); if (i.needGeometry) { var m = Uo(d, !0); if (!i.filter(new si(this.tileID.overscaledZ), m, this.tileID.canonical)) return } else if (!i.filter(new si(this.tileID.overscaledZ), d)) return; for (var v = this.getId(d, f), y = 0; y < p.length; y++) { var g = p[y]; if (!(o && o.indexOf(g) < 0)) { var _ = s[g]; if (_) { var x = {}; void 0 !== v && u && (x = u.getState(_.sourceLayer || "_geojsonTileLayer", v)); var b = h({}, l[g]); b.paint = nc(b.paint, _.paint, d, x, a), b.layout = nc(b.layout, _.layout, d, x, a); var w = !c || c(d, _, x); if (w) { var S = new Ju(d, this.z, this.x, this.y, v); S.layer = b; var E = t[g]; void 0 === E && (E = t[g] = []), E.push({ featureIndex: r, feature: S, intersectionZ: w }) } } } } } }, ec.prototype.lookupSymbolFeatures = function (t, e, n, r, i, o, a, s) { var l = {}; this.loadVTLayers(); for (var u = ar(i), c = 0, p = t; c < p.length; c += 1)this.loadMatchingFeature(l, n, r, p[c], u, o, a, s, e); return l }, ec.prototype.hasLayer = function (t) { for (var e = 0, n = this.bucketLayerIDs; e < n.length; e += 1)for (var r = 0, i = n[e]; r < i.length; r += 1)if (t === i[r]) return !0; return !1 }, ec.prototype.getId = function (t, e) { var n = t.id; return this.promoteId && "boolean" == typeof (n = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]]) && (n = Number(n)), n }, Fr("FeatureIndex", ec, { omit: ["rawTileData", "sourceLayerCoder"] }); var oc = function (t, e) { this.tileID = t, this.uid = d(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading" }; oc.prototype.registerFadeDuration = function (t) { var e = t + this.timeAdded; e < F.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e) }, oc.prototype.wasRequested = function () { return "errored" === this.state || "loaded" === this.state || "reloading" === this.state }, oc.prototype.loadVectorData = function (t, e, n) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) { for (var r in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) { var n = {}; if (!e) return n; for (var r = function () { var t = o[i], r = t.layerIds.map((function (t) { return e.getLayer(t) })).filter(Boolean); if (0 !== r.length) { t.layers = r, t.stateDependentLayerIds && (t.stateDependentLayers = t.stateDependentLayerIds.map((function (t) { return r.filter((function (e) { return e.id === t }))[0] }))); for (var a = 0, s = r; a < s.length; a += 1)n[s[a].id] = t } }, i = 0, o = t; i < o.length; i += 1)r(); return n }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) { var i = this.buckets[r]; if (i instanceof yu) { if (this.hasSymbolBuckets = !0, !n) break; i.justReloaded = !0 } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var o in this.buckets) { var a = this.buckets[o]; if (a instanceof yu && a.hasRTLText) { this.hasRTLText = !0, ai.isLoading() || ai.isLoaded() || "deferred" !== ii() || oi(); break } } for (var s in this.queryPadding = 0, this.buckets) { var l = this.buckets[s]; this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(s).queryRadius(l)) } t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage) } else this.collisionBoxArray = new Qi }, oc.prototype.unloadVectorData = function () { for (var t in this.buckets) this.buckets[t].destroy(); this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded" }, oc.prototype.getBucket = function (t) { return this.buckets[t.id] }, oc.prototype.upload = function (t) { for (var e in this.buckets) { var n = this.buckets[e]; n.uploadPending() && n.upload(t) } var r = t.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Lu(t, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Lu(t, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null) }, oc.prototype.prepare = function (t) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture) }, oc.prototype.queryRenderedFeatures = function (t, e, n, r, i, o, a, s, l, u) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r, cameraQueryGeometry: i, scale: o, tileSize: this.tileSize, pixelPosMatrix: u, transform: s, params: a, queryPadding: this.queryPadding * l }, t, e, n) : {} }, oc.prototype.querySourceFeatures = function (t, e) { var n = this.latestFeatureIndex; if (n && n.rawTileData) { var r = n.loadVTLayers(), i = e ? e.sourceLayer : "", o = r._geojsonTileLayer || r[i]; if (o) for (var a = ar(e && e.filter), s = this.tileID.canonical, l = s.z, u = s.x, c = s.y, p = { z: l, x: u, y: c }, h = 0; h < o.length; h++) { var f = o.feature(h); if (a.needGeometry) { var d = Uo(f, !0); if (!a.filter(new si(this.tileID.overscaledZ), d, this.tileID.canonical)) continue } else if (!a.filter(new si(this.tileID.overscaledZ), f)) continue; var m = n.getId(f, i), v = new Ju(f, l, u, c, m); v.tile = p, t.push(v) } } }, oc.prototype.hasData = function () { return "loaded" === this.state || "reloading" === this.state || "expired" === this.state }, oc.prototype.patternsLoaded = function () { return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length }, oc.prototype.setExpiryData = function (t) { var e = this.expirationTime; if (t.cacheControl) { var n = A(t.cacheControl); n["max-age"] && (this.expirationTime = Date.now() + 1e3 * n["max-age"]) } else t.expires && (this.expirationTime = new Date(t.expires).getTime()); if (this.expirationTime) { var r = Date.now(), i = !1; if (this.expirationTime > r) i = !1; else if (e) if (this.expirationTime < e) i = !0; else { var o = this.expirationTime - e; o ? this.expirationTime = r + Math.max(o, 3e4) : i = !0 } else i = !0; i ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0 } }, oc.prototype.getExpiryTimeout = function () { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1) }, oc.prototype.setFeatureState = function (t, e) { if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) { var n = this.latestFeatureIndex.loadVTLayers(); for (var r in this.buckets) if (e.style.hasLayer(r)) { var i = this.buckets[r], o = i.layers[0].sourceLayer || "_geojsonTileLayer", a = n[o], s = t[o]; if (a && s && 0 !== Object.keys(s).length) { i.update(s, a, this.imageAtlas && this.imageAtlas.patternPositions || {}); var l = e && e.style && e.style.getLayer(r); l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(i))) } } } }, oc.prototype.holdingForFade = function () { return void 0 !== this.symbolFadeHoldUntil }, oc.prototype.symbolFadeFinished = function () { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < F.now() }, oc.prototype.clearFadeHold = function () { this.symbolFadeHoldUntil = void 0 }, oc.prototype.setHoldDuration = function (t) { this.symbolFadeHoldUntil = F.now() + t }, oc.prototype.setDependencies = function (t, e) { for (var n = {}, r = 0, i = e; r < i.length; r += 1)n[i[r]] = !0; this.dependencies[t] = n }, oc.prototype.hasDependency = function (t, e) { for (var n = 0, r = t; n < r.length; n += 1) { var i = this.dependencies[r[n]]; if (i) for (var o = 0, a = e; o < a.length; o += 1)if (i[a[o]]) return !0 } return !1 }; var ac = a.performance, sc = function (t) { this._marks = { start: [t.url, "start"].join("#"), end: [t.url, "end"].join("#"), measure: t.url.toString() }, ac.mark(this._marks.start) }; sc.prototype.finish = function () { ac.mark(this._marks.end); var t = ac.getEntriesByName(this._marks.measure); return 0 === t.length && (ac.measure(this._marks.measure, this._marks.start, this._marks.end), t = ac.getEntriesByName(this._marks.measure), ac.clearMarks(this._marks.start), ac.clearMarks(this._marks.end), ac.clearMeasures(this._marks.measure)), t }, t.Actor = Du, t.AlphaImage = ga, t.CanonicalTileID = Xu, t.CollisionBoxArray = Qi, t.Color = te, t.DEMData = Ku, t.DataConstantProperty = vi, t.DictionaryCoder = Qu, t.EXTENT = 8192, t.ErrorEvent = At, t.EvaluationParameters = si, t.Event = Tt, t.Evented = Mt, t.FeatureIndex = ec, t.FillBucket = ss, t.FillExtrusionBucket = Es, t.ImageAtlas = xl, t.ImagePosition = gl, t.LineBucket = Ds, t.LngLat = Fu, t.LngLatBounds = zu, t.MercatorCoordinate = Wu, t.ONE_EM = 24, t.OverscaledTileID = Zu, t.Point = i, t.Point$1 = i, t.Properties = bi, t.Protobuf = Ks, t.RGBAImage = _a, t.RequestManager = W, t.RequestPerformance = sc, t.ResourceType = dt, t.SegmentVector = so, t.SourceFeatureState = tc, t.StructArrayLayout1ui2 = Zi, t.StructArrayLayout2f1f2i16 = Bi, t.StructArrayLayout2i4 = Mi, t.StructArrayLayout3ui6 = Ui, t.StructArrayLayout4i8 = Oi, t.SymbolBucket = yu, t.Texture = Lu, t.Tile = oc, t.Transitionable = ci, t.Uniform1f = bo, t.Uniform1i = xo, t.Uniform2f = wo, t.Uniform3f = So, t.Uniform4f = Eo, t.UniformColor = Co, t.UniformMatrix4f = Ao, t.UnwrappedTileID = qu, t.ValidationError = kt, t.WritingMode = bl, t.ZoomHistory = Hr, t.add = function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t }, t.addDynamicAttributes = fu, t.asyncAll = function (t, e, n) { if (!t.length) return n(null, []); var r = t.length, i = new Array(t.length), o = null; t.forEach((function (t, a) { e(t, (function (t, e) { t && (o = t), i[a] = e, 0 == --r && n(o, i) })) })) }, t.bezier = l, t.bindAll = y, t.browser = F, t.cacheEntryPossiblyAdded = function (t) { ++ht > lt && (t.getActor().send("enforceCacheSizeLimit", st), ht = 0) }, t.clamp = c, t.clearTileCache = function (t) { var e = a.caches.delete("mapbox-tiles"); t && e.catch(t).then((function () { return t() })) }, t.clipLine = Xl, t.clone = function (t) { var e = new aa(16); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e }, t.clone$1 = b, t.clone$2 = function (t) { var e = new aa(3); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e }, t.collisionCircleLayout = Ws, t.config = B, t.create = function () { var t = new aa(16); return aa != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t }, t.create$1 = function () { var t = new aa(9); return aa != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t }, t.create$2 = function () { var t = new aa(4); return aa != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t }, t.createCommonjsModule = e, t.createExpression = qn, t.createLayout = Ti, t.createStyleLayer = function (t) { return "custom" === t.type ? new Tu(t) : new Au[t.type](t) }, t.cross = function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[0], s = n[1], l = n[2]; return t[0] = i * l - o * s, t[1] = o * a - r * l, t[2] = r * s - i * a, t }, t.deepEqual = function t(e, n) { if (Array.isArray(e)) { if (!Array.isArray(n) || e.length !== n.length) return !1; for (var r = 0; r < e.length; r++)if (!t(e[r], n[r])) return !1; return !0 } if ("object" == typeof e && null !== e && null !== n) { if ("object" != typeof n) return !1; if (Object.keys(e).length !== Object.keys(n).length) return !1; for (var i in e) if (!t(e[i], n[i])) return !1; return !0 } return e === n }, t.dot = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] }, t.dot$1 = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3] }, t.ease = u, t.emitValidationErrors = Pr, t.endsWith = g, t.enforceCacheSizeLimit = function (t) { ut(), tt && tt.then((function (e) { e.keys().then((function (n) { for (var r = 0; r < n.length - t; r++)e.delete(n[r]) })) })) }, t.evaluateSizeForFeature = zl, t.evaluateSizeForZoom = Fl, t.evaluateVariableOffset = ou, t.evented = ri, t.extend = h, t.featureFilter = ar, t.filterObject = x, t.fromRotation = function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, t.getAnchorAlignment = Pl, t.getAnchorJustification = au, t.getArrayBuffer = xt, t.getImage = St, t.getJSON = function (t, e) { return _t(h(t, { type: "json" }), e) }, t.getRTLTextPluginStatus = ii, t.getReferrer = gt, t.getVideo = function (t, e) { var n, r, i = a.document.createElement("video"); i.muted = !0, i.onloadstart = function () { e(null, i) }; for (var o = 0; o < t.length; o++) { var s = a.document.createElement("source"); n = t[o], r = void 0, (r = a.document.createElement("a")).href = n, (r.protocol !== a.document.location.protocol || r.host !== a.document.location.host) && (i.crossOrigin = "Anonymous"), s.src = t[o], i.appendChild(s) } return { cancel: function () { } } }, t.identity = sa, t.invert = function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], l = e[6], u = e[7], c = e[8], p = e[9], h = e[10], f = e[11], d = e[12], m = e[13], v = e[14], y = e[15], g = n * s - r * a, _ = n * l - i * a, x = n * u - o * a, b = r * l - i * s, w = r * u - o * s, S = i * u - o * l, E = c * m - p * d, C = c * v - h * d, T = c * y - f * d, A = p * v - h * m, M = p * y - f * m, O = h * y - f * v, k = g * O - _ * M + x * A + b * T - w * C + S * E; return k ? (t[0] = (s * O - l * M + u * A) * (k = 1 / k), t[1] = (i * M - r * O - o * A) * k, t[2] = (m * S - v * w + y * b) * k, t[3] = (h * w - p * S - f * b) * k, t[4] = (l * T - a * O - u * C) * k, t[5] = (n * O - i * T + o * C) * k, t[6] = (v * x - d * S - y * _) * k, t[7] = (c * S - h * x + f * _) * k, t[8] = (a * M - s * T + u * E) * k, t[9] = (r * T - n * M - o * E) * k, t[10] = (d * w - m * x + y * g) * k, t[11] = (p * x - c * w - f * g) * k, t[12] = (s * C - a * A - l * E) * k, t[13] = (n * A - r * C + i * E) * k, t[14] = (m * _ - d * b - v * g) * k, t[15] = (c * b - p * _ + h * g) * k, t) : null }, t.isChar = Wr, t.isMapboxURL = X, t.keysDifference = function (t, e) { var n = []; for (var r in t) r in e || n.push(r); return n }, t.makeRequest = _t, t.mapObject = _, t.mercatorXfromLng = Uu, t.mercatorYfromLat = Vu, t.mercatorZfromAltitude = Gu, t.mul = ca, t.multiply = la, t.mvt = xs, t.nextPowerOfTwo = function (t) { return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, t.normalize = function (t, e) { var n = e[0], r = e[1], i = e[2], o = n * n + r * r + i * i; return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o, t }, t.number = He, t.offscreenCanvasSupported = ft, t.ortho = function (t, e, n, r, i, o, a) { var s = 1 / (e - n), l = 1 / (r - i), u = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * l, t[14] = (a + o) * u, t[15] = 1, t }, t.parseGlyphPBF = function (t) { return new Ks(t).readFields(dl, []) }, t.pbf = Ks, t.performSymbolLayout = function (t, e, n, r, i, o, a) { t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1; var s = t.layers[0].layout, l = t.layers[0]._unevaluatedLayout._values, u = {}; if ("composite" === t.textSizeData.kind) { var c = t.textSizeData, p = c.maxZoom; u.compositeTextSizes = [l["text-size"].possiblyEvaluate(new si(c.minZoom), a), l["text-size"].possiblyEvaluate(new si(p), a)] } if ("composite" === t.iconSizeData.kind) { var h = t.iconSizeData, f = h.maxZoom; u.compositeIconSizes = [l["icon-size"].possiblyEvaluate(new si(h.minZoom), a), l["icon-size"].possiblyEvaluate(new si(f), a)] } u.layoutTextSize = l["text-size"].possiblyEvaluate(new si(t.zoom + 1), a), u.layoutIconSize = l["icon-size"].possiblyEvaluate(new si(t.zoom + 1), a), u.textMaxSize = l["text-size"].possiblyEvaluate(new si(18)); for (var d = 24 * s.get("text-line-height"), m = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"), v = s.get("text-keep-upright"), y = s.get("text-size"), g = function () { var o = x[_], l = s.get("text-font").evaluate(o, {}, a).join(","), c = y.evaluate(o, {}, a), p = u.layoutTextSize.evaluate(o, {}, a), h = u.layoutIconSize.evaluate(o, {}, a), f = { horizontal: {}, vertical: void 0 }, g = o.text, b = [0, 0]; if (g) { var w = g.toString(), E = 24 * s.get("text-letter-spacing").evaluate(o, {}, a), C = function (t) { for (var e = 0, n = t; e < n.length; e += 1)if (r = n[e].charCodeAt(0), Wr.Arabic(r) || Wr["Arabic Supplement"](r) || Wr["Arabic Extended-A"](r) || Wr["Arabic Presentation Forms-A"](r) || Wr["Arabic Presentation Forms-B"](r)) return !1; var r; return !0 }(w) ? E : 0, T = s.get("text-anchor").evaluate(o, {}, a), A = s.get("text-variable-anchor"); if (!A) { var M = s.get("text-radial-offset").evaluate(o, {}, a); b = M ? ou(T, [24 * M, iu]) : s.get("text-offset").evaluate(o, {}, a).map((function (t) { return 24 * t })) } var O = m ? "center" : s.get("text-justify").evaluate(o, {}, a), k = s.get("symbol-placement"), I = "point" === k ? 24 * s.get("text-max-width").evaluate(o, {}, a) : 0, P = function () { t.allowVerticalPlacement && Xr(w) && (f.vertical = El(g, e, n, i, l, I, d, T, "left", C, b, bl.vertical, !0, k, p, c)) }; if (!m && A) { for (var L = "auto" === O ? A.map((function (t) { return au(t) })) : [O], R = !1, D = 0; D < L.length; D++) { var N = L[D]; if (!f.horizontal[N]) if (R) f.horizontal[N] = f.horizontal[0]; else { var z = El(g, e, n, i, l, I, d, "center", N, C, b, bl.horizontal, !1, k, p, c); z && (f.horizontal[N] = z, R = 1 === z.positionedLines.length) } } P() } else { "auto" === O && (O = au(T)); var F = El(g, e, n, i, l, I, d, T, O, C, b, bl.horizontal, !1, k, p, c); F && (f.horizontal[O] = F), P(), Xr(w) && m && v && (f.vertical = El(g, e, n, i, l, I, d, T, O, C, b, bl.vertical, !1, k, p, c)) } } var B = void 0, j = !1; if (o.icon && o.icon.name) { var U = r[o.icon.name]; U && (B = function (t, e, n) { var r = Pl(n), i = e[0] - t.displaySize[0] * r.horizontalAlign, o = e[1] - t.displaySize[1] * r.verticalAlign; return { image: t, top: o, bottom: o + t.displaySize[1], left: i, right: i + t.displaySize[0] } }(i[o.icon.name], s.get("icon-offset").evaluate(o, {}, a), s.get("icon-anchor").evaluate(o, {}, a)), j = U.sdf, void 0 === t.sdfIcons ? t.sdfIcons = U.sdf : t.sdfIcons !== U.sdf && S("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (U.pixelRatio !== t.pixelRatio || 0 !== s.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0)) } var V = lu(f.horizontal) || f.vertical; t.iconsInText = !!V && V.iconsInText, (V || B) && function (t, e, n, r, i, o, a, s, l, u, c) { var p = o.textMaxSize.evaluate(e, {}); void 0 === p && (p = a); var h, f = t.layers[0].layout, d = f.get("icon-offset").evaluate(e, {}, c), m = lu(n.horizontal), v = a / 24, y = t.tilePixelRatio * v, g = t.tilePixelRatio * p / 24, _ = t.tilePixelRatio * s, x = t.tilePixelRatio * f.get("symbol-spacing"), b = f.get("text-padding") * t.tilePixelRatio, w = f.get("icon-padding") * t.tilePixelRatio, E = f.get("text-max-angle") / 180 * Math.PI, C = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), T = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"), A = f.get("symbol-placement"), M = x / 2, O = f.get("icon-text-fit"); r && "none" !== O && (t.allowVerticalPlacement && n.vertical && (h = Rl(r, n.vertical, O, f.get("icon-text-fit-padding"), d, v)), m && (r = Rl(r, m, O, f.get("icon-text-fit-padding"), d, v))); var k = function (s, p) { p.x < 0 || p.x >= 8192 || p.y < 0 || p.y >= 8192 || function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m, v, y, g, _, x, b, w, E, C) { var T, A, M, O, k, I = t.addToLineVertexArray(e, n), P = 0, L = 0, R = 0, D = 0, N = -1, z = -1, F = {}, B = ho(""), j = 0, U = 0; if (void 0 === s._unevaluatedLayout.getValue("text-radial-offset") ? (j = (T = s.layout.get("text-offset").evaluate(x, {}, E).map((function (t) { return 24 * t })))[0], U = T[1]) : (j = 24 * s.layout.get("text-radial-offset").evaluate(x, {}, E), U = iu), t.allowVerticalPlacement && r.vertical) { var V = s.layout.get("text-rotate").evaluate(x, {}, E) + 90; O = new Jl(l, e, u, c, p, r.vertical, h, f, d, V), a && (k = new Jl(l, e, u, c, p, a, v, y, d, V)) } if (i) { var G = s.layout.get("icon-rotate").evaluate(x, {}), H = "none" !== s.layout.get("icon-text-fit"), W = ql(i, G, w, H), X = a ? ql(a, G, w, H) : void 0; M = new Jl(l, e, u, c, p, i, v, y, !1, G), P = 4 * W.length; var q = t.iconSizeData, Z = null; "source" === q.kind ? (Z = [128 * s.layout.get("icon-size").evaluate(x, {})])[0] > 32640 && S(t.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === q.kind && ((Z = [128 * b.compositeIconSizes[0].evaluate(x, {}, E), 128 * b.compositeIconSizes[1].evaluate(x, {}, E)])[0] > 32640 || Z[1] > 32640) && S(t.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t.addSymbols(t.icon, W, Z, _, g, x, !1, e, I.lineStartIndex, I.lineLength, -1, E), N = t.icon.placedSymbolArray.length - 1, X && (L = 4 * X.length, t.addSymbols(t.icon, X, Z, _, g, x, bl.vertical, e, I.lineStartIndex, I.lineLength, -1, E), z = t.icon.placedSymbolArray.length - 1) } for (var Y in r.horizontal) { var K = r.horizontal[Y]; if (!A) { B = ho(K.text); var Q = s.layout.get("text-rotate").evaluate(x, {}, E); A = new Jl(l, e, u, c, p, K, h, f, d, Q) } var J = 1 === K.positionedLines.length; if (R += su(t, e, K, o, s, d, x, m, I, r.vertical ? bl.horizontal : bl.horizontalOnly, J ? Object.keys(r.horizontal) : [Y], F, N, b, E), J) break } r.vertical && (D += su(t, e, r.vertical, o, s, d, x, m, I, bl.vertical, ["vertical"], F, z, b, E)); var $ = A ? A.boxStartIndex : t.collisionBoxArray.length, tt = A ? A.boxEndIndex : t.collisionBoxArray.length, et = O ? O.boxStartIndex : t.collisionBoxArray.length, nt = O ? O.boxEndIndex : t.collisionBoxArray.length, rt = M ? M.boxStartIndex : t.collisionBoxArray.length, it = M ? M.boxEndIndex : t.collisionBoxArray.length, ot = k ? k.boxStartIndex : t.collisionBoxArray.length, at = k ? k.boxEndIndex : t.collisionBoxArray.length, st = -1, lt = function (t, e) { return t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e }; st = lt(A, st), st = lt(O, st), st = lt(M, st); var ut = (st = lt(k, st)) > -1 ? 1 : 0; ut && (st *= C / 24), t.glyphOffsetArray.length >= yu.MAX_GLYPHS && S("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== x.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, x.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, F.right >= 0 ? F.right : -1, F.center >= 0 ? F.center : -1, F.left >= 0 ? F.left : -1, F.vertical || -1, N, z, B, $, tt, et, nt, rt, it, ot, at, u, R, D, P, L, ut, 0, h, j, U, st) }(t, p, s, n, r, i, h, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, y, b, C, l, _, w, T, d, e, o, u, c, a) }; if ("line" === A) for (var I = 0, P = Xl(e.geometry, 0, 0, 8192, 8192); I < P.length; I += 1)for (var L = P[I], R = 0, D = Wl(L, x, E, n.vertical || m, r, 24, g, t.overscaling, 8192); R < D.length; R += 1) { var N = D[R]; m && uu(t, m.text, M, N) || k(L, N) } else if ("line-center" === A) for (var z = 0, F = e.geometry; z < F.length; z += 1) { var B = F[z]; if (B.length > 1) { var j = Hl(B, E, n.vertical || m, r, 24, g); j && k(B, j) } } else if ("Polygon" === e.type) for (var U = 0, V = rs(e.geometry, 0); U < V.length; U += 1) { var G = V[U], H = eu(G, 16); k(G[0], new Dl(H.x, H.y, 0)) } else if ("LineString" === e.type) for (var W = 0, X = e.geometry; W < X.length; W += 1) { var q = X[W]; k(q, new Dl(q[0].x, q[0].y, 0)) } else if ("Point" === e.type) for (var Z = 0, Y = e.geometry; Z < Y.length; Z += 1)for (var K = 0, Q = Y[Z]; K < Q.length; K += 1) { var J = Q[K]; k([J], new Dl(J.x, J.y, 0)) } }(t, o, f, B, r, u, p, h, b, j, a) }, _ = 0, x = t.features; _ < x.length; _ += 1)g(); o && t.generateCollisionDebugBuffers() }, t.perspective = function (t, e, n, r, i) { var o, a = 1 / Math.tan(e / 2); return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + r) * (o = 1 / (r - i)), t[14] = 2 * i * r * o) : (t[10] = -1, t[14] = -2 * r), t }, t.pick = function (t, e) { for (var n = {}, r = 0; r < e.length; r++) { var i = e[r]; i in t && (n[i] = t[i]) } return n }, t.plugin = ai, t.polygonIntersectsPolygon = Ho, t.postMapLoadEvent = at, t.postTurnstileEvent = it, t.potpack = yl, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = Fr, t.registerForPluginStateChange = function (t) { return t({ pluginStatus: $r, pluginURL: ti }), ri.on("pluginStateChange", t), t }, t.renderColorRamp = ba, t.rotate = function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = Math.sin(n), l = Math.cos(n); return t[0] = r * l + o * s, t[1] = i * l + a * s, t[2] = r * -s + o * l, t[3] = i * -s + a * l, t }, t.rotateX = function (t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[4], a = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], h = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * i + u * r, t[5] = a * i + c * r, t[6] = s * i + p * r, t[7] = l * i + h * r, t[8] = u * i - o * r, t[9] = c * i - a * r, t[10] = p * i - s * r, t[11] = h * i - l * r, t }, t.rotateZ = function (t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[0], a = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], h = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i + u * r, t[1] = a * i + c * r, t[2] = s * i + p * r, t[3] = l * i + h * r, t[4] = u * i - o * r, t[5] = c * i - a * r, t[6] = p * i - s * r, t[7] = h * i - l * r, t }, t.scale = function (t, e, n) { var r = n[0], i = n[1], o = n[2]; return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * o, t[9] = e[9] * o, t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, t.scale$1 = function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t }, t.scale$2 = function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t }, t.setCacheLimits = function (t, e) { st = t, lt = e }, t.setRTLTextPlugin = function (t, e, n) { if (void 0 === n && (n = !1), "deferred" === $r || "loading" === $r || "loaded" === $r) throw new Error("setRTLTextPlugin cannot be called multiple times."); ti = F.resolveURL(t), $r = "deferred", Jr = e, ni(), n || oi() }, t.sphericalToCartesian = function (t) { var e = t[0], n = t[1], r = t[2]; return n += 90, n *= Math.PI / 180, r *= Math.PI / 180, { x: e * Math.cos(n) * Math.sin(r), y: e * Math.sin(n) * Math.sin(r), z: e * Math.cos(r) } }, t.sqrLen = function (t) { var e = t[0], n = t[1]; return e * e + n * n }, t.styleSpec = Ot, t.sub = function (t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t }, t.symbolSize = Bl, t.transformMat3 = function (t, e, n) { var r = e[0], i = e[1], o = e[2]; return t[0] = r * n[0] + i * n[3] + o * n[6], t[1] = r * n[1] + i * n[4] + o * n[7], t[2] = r * n[2] + i * n[5] + o * n[8], t }, t.transformMat4 = pa, t.translate = function (t, e, n) { var r, i, o, a, s, l, u, c, p, h, f, d, m = n[0], v = n[1], y = n[2]; return e === t ? (t[12] = e[0] * m + e[4] * v + e[8] * y + e[12], t[13] = e[1] * m + e[5] * v + e[9] * y + e[13], t[14] = e[2] * m + e[6] * v + e[10] * y + e[14], t[15] = e[3] * m + e[7] * v + e[11] * y + e[15]) : (i = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], h = e[9], f = e[10], d = e[11], t[0] = r = e[0], t[1] = i, t[2] = o, t[3] = a, t[4] = s, t[5] = l, t[6] = u, t[7] = c, t[8] = p, t[9] = h, t[10] = f, t[11] = d, t[12] = r * m + s * v + p * y + e[12], t[13] = i * m + l * v + h * y + e[13], t[14] = o * m + u * v + f * y + e[14], t[15] = a * m + c * v + d * y + e[15]), t }, t.triggerPluginCompletionEvent = ei, t.uniqueId = d, t.validateCustomStyleLayer = function (t) { var e = [], n = t.id; return void 0 === n && e.push({ message: "layers." + n + ': missing required property "id"' }), void 0 === t.render && e.push({ message: "layers." + n + ': missing required method "render"' }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({ message: "layers." + n + ': property "renderingMode" must be either "2d" or "3d"' }), e }, t.validateLight = Or, t.validateStyle = Mr, t.values = function (t) { var e = []; for (var n in t) e.push(t[n]); return e }, t.vectorTile = xs, t.version = "1.13.2", t.warnOnce = S, t.webpSupported = j, t.window = a, t.wrap = p })), r(["./shared"], (function (t) { function e(t) { var n = typeof t; if ("number" === n || "boolean" === n || "string" === n || null == t) return JSON.stringify(t); if (Array.isArray(t)) { for (var r = "[", i = 0, o = t; i < o.length; i += 1)r += e(o[i]) + ","; return r + "]" } for (var a = Object.keys(t).sort(), s = "{", l = 0; l < a.length; l++)s += JSON.stringify(a[l]) + ":" + e(t[a[l]]) + ","; return s + "}" } function n(n) { for (var r = "", i = 0, o = t.refProperties; i < o.length; i += 1)r += "/" + e(n[o[i]]); return r } var r = function (t) { this.keyCache = {}, t && this.replace(t) }; r.prototype.replace = function (t) { this._layerConfigs = {}, this._layers = {}, this.update(t, []) }, r.prototype.update = function (e, r) { for (var i = this, o = 0, a = e; o < a.length; o += 1) { var s = a[o]; this._layerConfigs[s.id] = s; var l = this._layers[s.id] = t.createStyleLayer(s); l._featureFilter = t.featureFilter(l.filter), this.keyCache[s.id] && delete this.keyCache[s.id] } for (var u = 0, c = r; u < c.length; u += 1) { var p = c[u]; delete this.keyCache[p], delete this._layerConfigs[p], delete this._layers[p] } this.familiesBySource = {}; for (var h = 0, f = function (t, e) { for (var r = {}, i = 0; i < t.length; i++) { var o = e && e[t[i].id] || n(t[i]); e && (e[t[i].id] = o); var a = r[o]; a || (a = r[o] = []), a.push(t[i]) } var s = []; for (var l in r) s.push(r[l]); return s }(t.values(this._layerConfigs), this.keyCache); h < f.length; h += 1) { var d = f[h].map((function (t) { return i._layers[t.id] })), m = d[0]; if ("none" !== m.visibility) { var v = m.source || "", y = this.familiesBySource[v]; y || (y = this.familiesBySource[v] = {}); var g = m.sourceLayer || "_geojsonTileLayer", _ = y[g]; _ || (_ = y[g] = []), _.push(d) } } }; var i = function (e) { var n = {}, r = []; for (var i in e) { var o = e[i], a = n[i] = {}; for (var s in o) { var l = o[+s]; if (l && 0 !== l.bitmap.width && 0 !== l.bitmap.height) { var u = { x: 0, y: 0, w: l.bitmap.width + 2, h: l.bitmap.height + 2 }; r.push(u), a[s] = { rect: u, metrics: l.metrics } } } } var c = t.potpack(r), p = new t.AlphaImage({ width: c.w || 1, height: c.h || 1 }); for (var h in e) { var f = e[h]; for (var d in f) { var m = f[+d]; if (m && 0 !== m.bitmap.width && 0 !== m.bitmap.height) { var v = n[h][d].rect; t.AlphaImage.copy(m.bitmap, p, { x: 0, y: 0 }, { x: v.x + 1, y: v.y + 1 }, m.bitmap) } } } this.image = p, this.positions = n }; t.register("GlyphAtlas", i); var o = function (e) { this.tileID = new t.OverscaledTileID(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.uid = e.uid, this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId }; function a(e, n, r) { for (var i = new t.EvaluationParameters(n), o = 0, a = e; o < a.length; o += 1)a[o].recalculate(i, r) } function s(e, n) { var r = t.getArrayBuffer(e.request, (function (e, r, i, o) { e ? n(e) : r && n(null, { vectorTile: new t.vectorTile.VectorTile(new t.pbf(r)), rawData: r, cacheControl: i, expires: o }) })); return function () { r.cancel(), n() } } o.prototype.parse = function (e, n, r, o, s) { var l = this; this.status = "parsing", this.data = e, this.collisionBoxArray = new t.CollisionBoxArray; var u = new t.DictionaryCoder(Object.keys(e.layers).sort()), c = new t.FeatureIndex(this.tileID, this.promoteId); c.bucketLayerIDs = []; var p, h, f, d, m = {}, v = { featureIndex: c, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: r }, y = n.familiesBySource[this.source]; for (var g in y) { var _ = e.layers[g]; if (_) { 1 === _.version && t.warnOnce('Vector tile source "' + this.source + '" layer "' + g + '" does not use vector tile spec v2 and therefore may have some rendering errors.'); for (var x = u.encode(g), b = [], w = 0; w < _.length; w++) { var S = _.feature(w), E = c.getId(S, g); b.push({ feature: S, id: E, index: w, sourceLayerIndex: x }) } for (var C = 0, T = y[g]; C < T.length; C += 1) { var A = T[C], M = A[0]; M.minzoom && this.zoom < Math.floor(M.minzoom) || M.maxzoom && this.zoom >= M.maxzoom || "none" !== M.visibility && (a(A, this.zoom, r), (m[M.id] = M.createBucket({ index: c.bucketLayerIDs.length, layers: A, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: x, sourceID: this.source })).populate(b, v, this.tileID.canonical), c.bucketLayerIDs.push(A.map((function (t) { return t.id })))) } } } var O = t.mapObject(v.glyphDependencies, (function (t) { return Object.keys(t).map(Number) })); Object.keys(O).length ? o.send("getGlyphs", { uid: this.uid, stacks: O }, (function (t, e) { p || (p = t, h = e, P.call(l)) })) : h = {}; var k = Object.keys(v.iconDependencies); k.length ? o.send("getImages", { icons: k, source: this.source, tileID: this.tileID, type: "icons" }, (function (t, e) { p || (p = t, f = e, P.call(l)) })) : f = {}; var I = Object.keys(v.patternDependencies); function P() { if (p) return s(p); if (h && f && d) { var e = new i(h), n = new t.ImageAtlas(f, d); for (var o in m) { var l = m[o]; l instanceof t.SymbolBucket ? (a(l.layers, this.zoom, r), t.performSymbolLayout(l, h, e.positions, f, n.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l.hasPattern && (l instanceof t.LineBucket || l instanceof t.FillBucket || l instanceof t.FillExtrusionBucket) && (a(l.layers, this.zoom, r), l.addFeatures(v, this.tileID.canonical, n.patternPositions)) } this.status = "done", s(null, { buckets: t.values(m).filter((function (t) { return !t.isEmpty() })), featureIndex: c, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: e.image, imageAtlas: n, glyphMap: this.returnDependencies ? h : null, iconMap: this.returnDependencies ? f : null, glyphPositions: this.returnDependencies ? e.positions : null }) } } I.length ? o.send("getImages", { icons: I, source: this.source, tileID: this.tileID, type: "patterns" }, (function (t, e) { p || (p = t, d = e, P.call(l)) })) : d = {}, P.call(this) }; var l = function (t, e, n, r) { this.actor = t, this.layerIndex = e, this.availableImages = n, this.loadVectorData = r || s, this.loading = {}, this.loaded = {} }; l.prototype.loadTile = function (e, n) { var r = this, i = e.uid; this.loading || (this.loading = {}); var a = !!(e && e.request && e.request.collectResourceTiming) && new t.RequestPerformance(e.request), s = this.loading[i] = new o(e); s.abort = this.loadVectorData(e, (function (e, o) { if (delete r.loading[i], e || !o) return s.status = "done", r.loaded[i] = s, n(e); var l = o.rawData, u = {}; o.expires && (u.expires = o.expires), o.cacheControl && (u.cacheControl = o.cacheControl); var c = {}; if (a) { var p = a.finish(); p && (c.resourceTiming = JSON.parse(JSON.stringify(p))) } s.vectorTile = o.vectorTile, s.parse(o.vectorTile, r.layerIndex, r.availableImages, r.actor, (function (e, r) { if (e || !r) return n(e); n(null, t.extend({ rawTileData: l.slice(0) }, r, u, c)) })), r.loaded = r.loaded || {}, r.loaded[i] = s })) }, l.prototype.reloadTile = function (t, e) { var n = this, r = this.loaded, i = t.uid, o = this; if (r && r[i]) { var a = r[i]; a.showCollisionBoxes = t.showCollisionBoxes; var s = function (t, r) { var i = a.reloadCallback; i && (delete a.reloadCallback, a.parse(a.vectorTile, o.layerIndex, n.availableImages, o.actor, i)), e(t, r) }; "parsing" === a.status ? a.reloadCallback = s : "done" === a.status && (a.vectorTile ? a.parse(a.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s()) } }, l.prototype.abortTile = function (t, e) { var n = this.loading, r = t.uid; n && n[r] && n[r].abort && (n[r].abort(), delete n[r]), e() }, l.prototype.removeTile = function (t, e) { var n = this.loaded, r = t.uid; n && n[r] && delete n[r], e() }; var u = t.window.ImageBitmap, c = function () { this.loaded = {} }; function p(t, e) { if (0 !== t.length) { h(t[0], e); for (var n = 1; n < t.length; n++)h(t[n], !e) } } function h(t, e) { for (var n = 0, r = 0, i = t.length, o = i - 1; r < i; o = r++)n += (t[r][0] - t[o][0]) * (t[o][1] + t[r][1]); n >= 0 != !!e && t.reverse() } c.prototype.loadTile = function (e, n) { var r = e.uid, i = e.encoding, o = e.rawImageData, a = u && o instanceof u ? this.getImageData(o) : o, s = new t.DEMData(r, a, i); this.loaded = this.loaded || {}, this.loaded[r] = s, n(null, s) }, c.prototype.getImageData = function (e) { this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height); var n = this.offscreenCanvasContext.getImageData(-1, -1, e.width + 2, e.height + 2); return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new t.RGBAImage({ width: n.width, height: n.height }, n.data) }, c.prototype.removeTile = function (t) { var e = this.loaded, n = t.uid; e && e[n] && delete e[n] }; var f = t.vectorTile.VectorTileFeature.prototype.toGeoJSON, d = function (e) { this._feature = e, this.extent = t.EXTENT, this.type = e.type, this.properties = e.tags, "id" in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10)) }; d.prototype.loadGeometry = function () { if (1 === this._feature.type) { for (var e = [], n = 0, r = this._feature.geometry; n < r.length; n += 1) { var i = r[n]; e.push([new t.Point$1(i[0], i[1])]) } return e } for (var o = [], a = 0, s = this._feature.geometry; a < s.length; a += 1) { for (var l = [], u = 0, c = s[a]; u < c.length; u += 1) { var p = c[u]; l.push(new t.Point$1(p[0], p[1])) } o.push(l) } return o }, d.prototype.toGeoJSON = function (t, e, n) { return f.call(this, t, e, n) }; var m = function (e) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = t.EXTENT, this.length = e.length, this._features = e }; m.prototype.feature = function (t) { return new d(this._features[t]) }; var v = t.vectorTile.VectorTileFeature, y = g; function g(t, e) { this.options = e || {}, this.features = t, this.length = t.length } function _(t, e) { this.id = "number" == typeof t.id ? t.id : void 0, this.type = t.type, this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry, this.properties = t.tags, this.extent = e || 4096 } g.prototype.feature = function (t) { return new _(this.features[t], this.options.extent) }, _.prototype.loadGeometry = function () { var e = this.rawGeometry; this.geometry = []; for (var n = 0; n < e.length; n++) { for (var r = e[n], i = [], o = 0; o < r.length; o++)i.push(new t.Point$1(r[o][0], r[o][1])); this.geometry.push(i) } return this.geometry }, _.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var t = this.geometry, e = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0, o = 0; o < t.length; o++)for (var a = t[o], s = 0; s < a.length; s++) { var l = a[s]; e = Math.min(e, l.x), n = Math.max(n, l.x), r = Math.min(r, l.y), i = Math.max(i, l.y) } return [e, r, n, i] }, _.prototype.toGeoJSON = v.prototype.toGeoJSON; var x = w, b = y; function w(e) { var n = new t.pbf; return function (t, e) { for (var n in t.layers) e.writeMessage(3, S, t.layers[n]) }(e, n), n.finish() } function S(t, e) { var n; e.writeVarintField(15, t.version || 1), e.writeStringField(1, t.name || ""), e.writeVarintField(5, t.extent || 4096); var r = { keys: [], values: [], keycache: {}, valuecache: {} }; for (n = 0; n < t.length; n++)r.feature = t.feature(n), e.writeMessage(2, E, r); var i = r.keys; for (n = 0; n < i.length; n++)e.writeStringField(3, i[n]); var o = r.values; for (n = 0; n < o.length; n++)e.writeMessage(4, O, o[n]) } function E(t, e) { var n = t.feature; void 0 !== n.id && e.writeVarintField(1, n.id), e.writeMessage(2, C, t), e.writeVarintField(3, n.type), e.writeMessage(4, M, n) } function C(t, e) { var n = t.feature, r = t.keys, i = t.values, o = t.keycache, a = t.valuecache; for (var s in n.properties) { var l = o[s]; void 0 === l && (r.push(s), o[s] = l = r.length - 1), e.writeVarint(l); var u = n.properties[s], c = typeof u; "string" !== c && "boolean" !== c && "number" !== c && (u = JSON.stringify(u)); var p = c + ":" + u, h = a[p]; void 0 === h && (i.push(u), a[p] = h = i.length - 1), e.writeVarint(h) } } function T(t, e) { return (e << 3) + (7 & t) } function A(t) { return t << 1 ^ t >> 31 } function M(t, e) { for (var n = t.loadGeometry(), r = t.type, i = 0, o = 0, a = n.length, s = 0; s < a; s++) { var l = n[s], u = 1; 1 === r && (u = l.length), e.writeVarint(T(1, u)); for (var c = 3 === r ? l.length - 1 : l.length, p = 0; p < c; p++) { 1 === p && 1 !== r && e.writeVarint(T(2, c - 1)); var h = l[p].x - i, f = l[p].y - o; e.writeVarint(A(h)), e.writeVarint(A(f)), i += h, o += f } 3 === r && e.writeVarint(T(7, 1)) } } function O(t, e) { var n = typeof t; "string" === n ? e.writeStringField(1, t) : "boolean" === n ? e.writeBooleanField(7, t) : "number" === n && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t)) } function k(t, e, n, r) { I(t, n, r), I(e, 2 * n, 2 * r), I(e, 2 * n + 1, 2 * r + 1) } function I(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function P(t, e, n, r) { var i = t - n, o = e - r; return i * i + o * o } x.fromVectorTileJs = w, x.fromGeojsonVt = function (t, e) { e = e || {}; var n = {}; for (var r in t) n[r] = new y(t[r].features, e), n[r].name = r, n[r].version = e.version, n[r].extent = e.extent; return w({ layers: n }) }, x.GeoJSONWrapper = b; var L = function (t) { return t[0] }, R = function (t) { return t[1] }, D = function (t, e, n, r, i) { void 0 === e && (e = L), void 0 === n && (n = R), void 0 === r && (r = 64), void 0 === i && (i = Float64Array), this.nodeSize = r, this.points = t; for (var o = t.length < 65536 ? Uint16Array : Uint32Array, a = this.ids = new o(t.length), s = this.coords = new i(2 * t.length), l = 0; l < t.length; l++)a[l] = l, s[2 * l] = e(t[l]), s[2 * l + 1] = n(t[l]); !function t(e, n, r, i, o, a) { if (!(o - i <= r)) { var s = i + o >> 1; !function t(e, n, r, i, o, a) { for (; o > i;) { if (o - i > 600) { var s = o - i + 1, l = r - i + 1, u = Math.log(s), c = .5 * Math.exp(2 * u / 3), p = .5 * Math.sqrt(u * c * (s - c) / s) * (l - s / 2 < 0 ? -1 : 1); t(e, n, r, Math.max(i, Math.floor(r - l * c / s + p)), Math.min(o, Math.floor(r + (s - l) * c / s + p)), a) } var h = n[2 * r + a], f = i, d = o; for (k(e, n, i, r), n[2 * o + a] > h && k(e, n, i, o); f < d;) { for (k(e, n, f, d), f++, d--; n[2 * f + a] < h;)f++; for (; n[2 * d + a] > h;)d-- } n[2 * i + a] === h ? k(e, n, i, d) : k(e, n, ++d, o), d <= r && (i = d + 1), r <= d && (o = d - 1) } }(e, n, s, i, o, a % 2), t(e, n, r, i, s - 1, a + 1), t(e, n, r, s + 1, o, a + 1) } }(a, s, r, 0, a.length - 1, 0) }; D.prototype.range = function (t, e, n, r) { return function (t, e, n, r, i, o, a) { for (var s, l, u = [0, t.length - 1, 0], c = []; u.length;) { var p = u.pop(), h = u.pop(), f = u.pop(); if (h - f <= a) for (var d = f; d <= h; d++)l = e[2 * d + 1], (s = e[2 * d]) >= n && s <= i && l >= r && l <= o && c.push(t[d]); else { var m = Math.floor((f + h) / 2); l = e[2 * m + 1], (s = e[2 * m]) >= n && s <= i && l >= r && l <= o && c.push(t[m]); var v = (p + 1) % 2; (0 === p ? n <= s : r <= l) && (u.push(f), u.push(m - 1), u.push(v)), (0 === p ? i >= s : o >= l) && (u.push(m + 1), u.push(h), u.push(v)) } } return c }(this.ids, this.coords, t, e, n, r, this.nodeSize) }, D.prototype.within = function (t, e, n) { return function (t, e, n, r, i, o) { for (var a = [0, t.length - 1, 0], s = [], l = i * i; a.length;) { var u = a.pop(), c = a.pop(), p = a.pop(); if (c - p <= o) for (var h = p; h <= c; h++)P(e[2 * h], e[2 * h + 1], n, r) <= l && s.push(t[h]); else { var f = Math.floor((p + c) / 2), d = e[2 * f], m = e[2 * f + 1]; P(d, m, n, r) <= l && s.push(t[f]); var v = (u + 1) % 2; (0 === u ? n - i <= d : r - i <= m) && (a.push(p), a.push(f - 1), a.push(v)), (0 === u ? n + i >= d : r + i >= m) && (a.push(f + 1), a.push(c), a.push(v)) } } return s }(this.ids, this.coords, t, e, n, this.nodeSize) }; var N = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function (t) { return t } }, z = function (t) { this.options = H(Object.create(N), t), this.trees = new Array(this.options.maxZoom + 1) }; function F(t, e, n, r, i) { return { x: t, y: e, zoom: 1 / 0, id: n, parentId: -1, numPoints: r, properties: i } } function B(t, e) { var n = t.geometry.coordinates, r = n[1]; return { x: V(n[0]), y: G(r), zoom: 1 / 0, index: e, parentId: -1 } } function j(t) { return { type: "Feature", id: t.id, properties: U(t), geometry: { type: "Point", coordinates: [(r = t.x, 360 * (r - .5)), (e = t.y, n = (180 - 360 * e) * Math.PI / 180, 360 * Math.atan(Math.exp(n)) / Math.PI - 90)] } }; var e, n, r } function U(t) { var e = t.numPoints, n = e >= 1e4 ? Math.round(e / 1e3) + "k" : e >= 1e3 ? Math.round(e / 100) / 10 + "k" : e; return H(H({}, t.properties), { cluster: !0, cluster_id: t.id, point_count: e, point_count_abbreviated: n }) } function V(t) { return t / 360 + .5 } function G(t) { var e = Math.sin(t * Math.PI / 180), n = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI; return n < 0 ? 0 : n > 1 ? 1 : n } function H(t, e) { for (var n in e) t[n] = e[n]; return t } function W(t) { return t.x } function X(t) { return t.y } function q(t, e, n, r, i, o) { var a = i - n, s = o - r; if (0 !== a || 0 !== s) { var l = ((t - n) * a + (e - r) * s) / (a * a + s * s); l > 1 ? (n = i, r = o) : l > 0 && (n += a * l, r += s * l) } return (a = t - n) * a + (s = e - r) * s } function Z(t, e, n, r) { var i = { id: void 0 === t ? null : t, type: e, geometry: n, tags: r, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; return function (t) { var e = t.geometry, n = t.type; if ("Point" === n || "MultiPoint" === n || "LineString" === n) Y(t, e); else if ("Polygon" === n || "MultiLineString" === n) for (var r = 0; r < e.length; r++)Y(t, e[r]); else if ("MultiPolygon" === n) for (r = 0; r < e.length; r++)for (var i = 0; i < e[r].length; i++)Y(t, e[r][i]) }(i), i } function Y(t, e) { for (var n = 0; n < e.length; n += 3)t.minX = Math.min(t.minX, e[n]), t.minY = Math.min(t.minY, e[n + 1]), t.maxX = Math.max(t.maxX, e[n]), t.maxY = Math.max(t.maxY, e[n + 1]) } function K(t, e, n, r) { if (e.geometry) { var i = e.geometry.coordinates, o = e.geometry.type, a = Math.pow(n.tolerance / ((1 << n.maxZoom) * n.extent), 2), s = [], l = e.id; if (n.promoteId ? l = e.properties[n.promoteId] : n.generateId && (l = r || 0), "Point" === o) Q(i, s); else if ("MultiPoint" === o) for (var u = 0; u < i.length; u++)Q(i[u], s); else if ("LineString" === o) J(i, s, a, !1); else if ("MultiLineString" === o) { if (n.lineMetrics) { for (u = 0; u < i.length; u++)J(i[u], s = [], a, !1), t.push(Z(l, "LineString", s, e.properties)); return } $(i, s, a, !1) } else if ("Polygon" === o) $(i, s, a, !0); else { if ("MultiPolygon" !== o) { if ("GeometryCollection" === o) { for (u = 0; u < e.geometry.geometries.length; u++)K(t, { id: l, geometry: e.geometry.geometries[u], properties: e.properties }, n, r); return } throw new Error("Input data is not a valid GeoJSON object.") } for (u = 0; u < i.length; u++) { var c = []; $(i[u], c, a, !0), s.push(c) } } t.push(Z(l, o, s, e.properties)) } } function Q(t, e) { e.push(tt(t[0])), e.push(et(t[1])), e.push(0) } function J(t, e, n, r) { for (var i, o, a = 0, s = 0; s < t.length; s++) { var l = tt(t[s][0]), u = et(t[s][1]); e.push(l), e.push(u), e.push(0), s > 0 && (a += r ? (i * u - l * o) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(u - o, 2))), i = l, o = u } var c = e.length - 3; e[2] = 1, function t(e, n, r, i) { for (var o, a = i, s = r - n >> 1, l = r - n, u = e[n], c = e[n + 1], p = e[r], h = e[r + 1], f = n + 3; f < r; f += 3) { var d = q(e[f], e[f + 1], u, c, p, h); if (d > a) o = f, a = d; else if (d === a) { var m = Math.abs(f - s); m < l && (o = f, l = m) } } a > i && (o - n > 3 && t(e, n, o, i), e[o + 2] = a, r - o > 3 && t(e, o, r, i)) }(e, 0, c, n), e[c + 2] = 1, e.size = Math.abs(a), e.start = 0, e.end = e.size } function $(t, e, n, r) { for (var i = 0; i < t.length; i++) { var o = []; J(t[i], o, n, r), e.push(o) } } function tt(t) { return t / 360 + .5 } function et(t) { var e = Math.sin(t * Math.PI / 180), n = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI; return n < 0 ? 0 : n > 1 ? 1 : n } function nt(t, e, n, r, i, o, a, s) { if (r /= e, o >= (n /= e) && a < r) return t; if (a < n || o >= r) return null; for (var l = [], u = 0; u < t.length; u++) { var c = t[u], p = c.geometry, h = c.type, f = 0 === i ? c.minX : c.minY, d = 0 === i ? c.maxX : c.maxY; if (f >= n && d < r) l.push(c); else if (!(d < n || f >= r)) { var m = []; if ("Point" === h || "MultiPoint" === h) rt(p, m, n, r, i); else if ("LineString" === h) it(p, m, n, r, i, !1, s.lineMetrics); else if ("MultiLineString" === h) at(p, m, n, r, i, !1); else if ("Polygon" === h) at(p, m, n, r, i, !0); else if ("MultiPolygon" === h) for (var v = 0; v < p.length; v++) { var y = []; at(p[v], y, n, r, i, !0), y.length && m.push(y) } if (m.length) { if (s.lineMetrics && "LineString" === h) { for (v = 0; v < m.length; v++)l.push(Z(c.id, h, m[v], c.tags)); continue } "LineString" !== h && "MultiLineString" !== h || (1 === m.length ? (h = "LineString", m = m[0]) : h = "MultiLineString"), "Point" !== h && "MultiPoint" !== h || (h = 3 === m.length ? "Point" : "MultiPoint"), l.push(Z(c.id, h, m, c.tags)) } } } return l.length ? l : null } function rt(t, e, n, r, i) { for (var o = 0; o < t.length; o += 3) { var a = t[o + i]; a >= n && a <= r && (e.push(t[o]), e.push(t[o + 1]), e.push(t[o + 2])) } } function it(t, e, n, r, i, o, a) { for (var s, l, u = ot(t), c = 0 === i ? lt : ut, p = t.start, h = 0; h < t.length - 3; h += 3) { var f = t[h], d = t[h + 1], m = t[h + 2], v = t[h + 3], y = t[h + 4], g = 0 === i ? f : d, _ = 0 === i ? v : y, x = !1; a && (s = Math.sqrt(Math.pow(f - v, 2) + Math.pow(d - y, 2))), g < n ? _ > n && (l = c(u, f, d, v, y, n), a && (u.start = p + s * l)) : g > r ? _ < r && (l = c(u, f, d, v, y, r), a && (u.start = p + s * l)) : st(u, f, d, m), _ < n && g >= n && (l = c(u, f, d, v, y, n), x = !0), _ > r && g <= r && (l = c(u, f, d, v, y, r), x = !0), !o && x && (a && (u.end = p + s * l), e.push(u), u = ot(t)), a && (p += s) } var b = t.length - 3; f = t[b], d = t[b + 1], m = t[b + 2], (g = 0 === i ? f : d) >= n && g <= r && st(u, f, d, m), b = u.length - 3, o && b >= 3 && (u[b] !== u[0] || u[b + 1] !== u[1]) && st(u, u[0], u[1], u[2]), u.length && e.push(u) } function ot(t) { var e = []; return e.size = t.size, e.start = t.start, e.end = t.end, e } function at(t, e, n, r, i, o) { for (var a = 0; a < t.length; a++)it(t[a], e, n, r, i, o, !1) } function st(t, e, n, r) { t.push(e), t.push(n), t.push(r) } function lt(t, e, n, r, i, o) { var a = (o - e) / (r - e); return t.push(o), t.push(n + (i - n) * a), t.push(1), a } function ut(t, e, n, r, i, o) { var a = (o - n) / (i - n); return t.push(e + (r - e) * a), t.push(o), t.push(1), a } function ct(t, e) { for (var n = [], r = 0; r < t.length; r++) { var i, o = t[r], a = o.type; if ("Point" === a || "MultiPoint" === a || "LineString" === a) i = pt(o.geometry, e); else if ("MultiLineString" === a || "Polygon" === a) { i = []; for (var s = 0; s < o.geometry.length; s++)i.push(pt(o.geometry[s], e)) } else if ("MultiPolygon" === a) for (i = [], s = 0; s < o.geometry.length; s++) { for (var l = [], u = 0; u < o.geometry[s].length; u++)l.push(pt(o.geometry[s][u], e)); i.push(l) } n.push(Z(o.id, a, i, o.tags)) } return n } function pt(t, e) { var n = []; n.size = t.size, void 0 !== t.start && (n.start = t.start, n.end = t.end); for (var r = 0; r < t.length; r += 3)n.push(t[r] + e, t[r + 1], t[r + 2]); return n } function ht(t, e) { if (t.transformed) return t; var n, r, i, o = 1 << t.z, a = t.x, s = t.y; for (n = 0; n < t.features.length; n++) { var l = t.features[n], u = l.geometry, c = l.type; if (l.geometry = [], 1 === c) for (r = 0; r < u.length; r += 2)l.geometry.push(ft(u[r], u[r + 1], e, o, a, s)); else for (r = 0; r < u.length; r++) { var p = []; for (i = 0; i < u[r].length; i += 2)p.push(ft(u[r][i], u[r][i + 1], e, o, a, s)); l.geometry.push(p) } } return t.transformed = !0, t } function ft(t, e, n, r, i, o) { return [Math.round(n * (t * r - i)), Math.round(n * (e * r - o))] } function dt(t, e, n, r, i) { for (var o = e === i.maxZoom ? 0 : i.tolerance / ((1 << e) * i.extent), a = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: n, y: r, z: e, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s = 0; s < t.length; s++) { a.numFeatures++, mt(a, t[s], o, i); var l = t[s].minX, u = t[s].minY, c = t[s].maxX, p = t[s].maxY; l < a.minX && (a.minX = l), u < a.minY && (a.minY = u), c > a.maxX && (a.maxX = c), p > a.maxY && (a.maxY = p) } return a } function mt(t, e, n, r) { var i = e.geometry, o = e.type, a = []; if ("Point" === o || "MultiPoint" === o) for (var s = 0; s < i.length; s += 3)a.push(i[s]), a.push(i[s + 1]), t.numPoints++, t.numSimplified++; else if ("LineString" === o) vt(a, i, t, n, !1, !1); else if ("MultiLineString" === o || "Polygon" === o) for (s = 0; s < i.length; s++)vt(a, i[s], t, n, "Polygon" === o, 0 === s); else if ("MultiPolygon" === o) for (var l = 0; l < i.length; l++) { var u = i[l]; for (s = 0; s < u.length; s++)vt(a, u[s], t, n, !0, 0 === s) } if (a.length) { var c = e.tags || null; if ("LineString" === o && r.lineMetrics) { for (var p in c = {}, e.tags) c[p] = e.tags[p]; c.mapbox_clip_start = i.start / i.size, c.mapbox_clip_end = i.end / i.size } var h = { geometry: a, type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1, tags: c }; null !== e.id && (h.id = e.id), t.features.push(h) } } function vt(t, e, n, r, i, o) { var a = r * r; if (r > 0 && e.size < (i ? a : r)) n.numPoints += e.length / 3; else { for (var s = [], l = 0; l < e.length; l += 3)(0 === r || e[l + 2] > a) && (n.numSimplified++, s.push(e[l]), s.push(e[l + 1])), n.numPoints++; i && function (t, e) { for (var n = 0, r = 0, i = t.length, o = i - 2; r < i; o = r, r += 2)n += (t[r] - t[o]) * (t[r + 1] + t[o + 1]); if (n > 0 === e) for (r = 0, i = t.length; r < i / 2; r += 2) { var a = t[r], s = t[r + 1]; t[r] = t[i - 2 - r], t[r + 1] = t[i - 1 - r], t[i - 2 - r] = a, t[i - 1 - r] = s } }(s, o), t.push(s) } } function yt(t, e) { var n = (e = this.options = function (t, e) { for (var n in e) t[n] = e[n]; return t }(Object.create(this.options), e)).debug; if (n && console.time("preprocess data"), e.maxZoom < 0 || e.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (e.promoteId && e.generateId) throw new Error("promoteId and generateId cannot be used together."); var r = function (t, e) { var n = []; if ("FeatureCollection" === t.type) for (var r = 0; r < t.features.length; r++)K(n, t.features[r], e, r); else K(n, "Feature" === t.type ? t : { geometry: t }, e); return n }(t, e); this.tiles = {}, this.tileCoords = [], n && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", e.indexMaxZoom, e.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (r = function (t, e) { var n = e.buffer / e.extent, r = t, i = nt(t, 1, -1 - n, n, 0, -1, 2, e), o = nt(t, 1, 1 - n, 2 + n, 0, -1, 2, e); return (i || o) && (r = nt(t, 1, -n, 1 + n, 0, -1, 2, e) || [], i && (r = ct(i, 1).concat(r)), o && (r = r.concat(ct(o, -1)))), r }(r, e)).length && this.splitTile(r, 0, 0, 0), n && (r.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } function gt(t, e, n) { return 32 * ((1 << t) * n + e) + t } function _t(t, e) { var n = t.tileID.canonical; if (!this._geoJSONIndex) return e(null, null); var r = this._geoJSONIndex.getTile(n.z, n.x, n.y); if (!r) return e(null, null); var i = new m(r.features), o = x(i); 0 === o.byteOffset && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)), e(null, { vectorTile: i, rawData: o.buffer }) } z.prototype.load = function (t) { var e = this.options, n = e.log, r = e.minZoom, i = e.maxZoom, o = e.nodeSize; n && console.time("total time"); var a = "prepare " + t.length + " points"; n && console.time(a), this.points = t; for (var s = [], l = 0; l < t.length; l++)t[l].geometry && s.push(B(t[l], l)); this.trees[i + 1] = new D(s, W, X, o, Float32Array), n && console.timeEnd(a); for (var u = i; u >= r; u--) { var c = +Date.now(); s = this._cluster(s, u), this.trees[u] = new D(s, W, X, o, Float32Array), n && console.log("z%d: %d clusters in %dms", u, s.length, +Date.now() - c) } return n && console.timeEnd("total time"), this }, z.prototype.getClusters = function (t, e) { var n = ((t[0] + 180) % 360 + 360) % 360 - 180, r = Math.max(-90, Math.min(90, t[1])), i = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[3])); if (t[2] - t[0] >= 360) n = -180, i = 180; else if (n > i) { var a = this.getClusters([n, r, 180, o], e), s = this.getClusters([-180, r, i, o], e); return a.concat(s) } for (var l = this.trees[this._limitZoom(e)], u = [], c = 0, p = l.range(V(n), G(o), V(i), G(r)); c < p.length; c += 1) { var h = l.points[p[c]]; u.push(h.numPoints ? j(h) : this.points[h.index]) } return u }, z.prototype.getChildren = function (t) { var e = this._getOriginId(t), n = this._getOriginZoom(t), r = "No cluster with the specified id.", i = this.trees[n]; if (!i) throw new Error(r); var o = i.points[e]; if (!o) throw new Error(r); for (var a = this.options.radius / (this.options.extent * Math.pow(2, n - 1)), s = [], l = 0, u = i.within(o.x, o.y, a); l < u.length; l += 1) { var c = i.points[u[l]]; c.parentId === t && s.push(c.numPoints ? j(c) : this.points[c.index]) } if (0 === s.length) throw new Error(r); return s }, z.prototype.getLeaves = function (t, e, n) { var r = []; return this._appendLeaves(r, t, e = e || 10, n = n || 0, 0), r }, z.prototype.getTile = function (t, e, n) { var r = this.trees[this._limitZoom(t)], i = Math.pow(2, t), o = this.options, a = o.radius / o.extent, s = (n - a) / i, l = (n + 1 + a) / i, u = { features: [] }; return this._addTileFeatures(r.range((e - a) / i, s, (e + 1 + a) / i, l), r.points, e, n, i, u), 0 === e && this._addTileFeatures(r.range(1 - a / i, s, 1, l), r.points, i, n, i, u), e === i - 1 && this._addTileFeatures(r.range(0, s, a / i, l), r.points, -1, n, i, u), u.features.length ? u : null }, z.prototype.getClusterExpansionZoom = function (t) { for (var e = this._getOriginZoom(t) - 1; e <= this.options.maxZoom;) { var n = this.getChildren(t); if (e++, 1 !== n.length) break; t = n[0].properties.cluster_id } return e }, z.prototype._appendLeaves = function (t, e, n, r, i) { for (var o = 0, a = this.getChildren(e); o < a.length; o += 1) { var s = a[o], l = s.properties; if (l && l.cluster ? i + l.point_count <= r ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, n, r, i) : i < r ? i++ : t.push(s), t.length === n) break } return i }, z.prototype._addTileFeatures = function (t, e, n, r, i, o) { for (var a = 0, s = t; a < s.length; a += 1) { var l = e[s[a]], u = l.numPoints, c = { type: 1, geometry: [[Math.round(this.options.extent * (l.x * i - n)), Math.round(this.options.extent * (l.y * i - r))]], tags: u ? U(l) : this.points[l.index].properties }, p = void 0; u ? p = l.id : this.options.generateId ? p = l.index : this.points[l.index].id && (p = this.points[l.index].id), void 0 !== p && (c.id = p), o.features.push(c) } }, z.prototype._limitZoom = function (t) { return Math.max(this.options.minZoom, Math.min(+t, this.options.maxZoom + 1)) }, z.prototype._cluster = function (t, e) { for (var n = [], r = this.options, i = r.reduce, o = r.minPoints, a = r.radius / (r.extent * Math.pow(2, e)), s = 0; s < t.length; s++) { var l = t[s]; if (!(l.zoom <= e)) { l.zoom = e; for (var u = this.trees[e + 1], c = u.within(l.x, l.y, a), p = l.numPoints || 1, h = p, f = 0, d = c; f < d.length; f += 1) { var m = u.points[d[f]]; m.zoom > e && (h += m.numPoints || 1) } if (h >= o) { for (var v = l.x * p, y = l.y * p, g = i && p > 1 ? this._map(l, !0) : null, _ = (s << 5) + (e + 1) + this.points.length, x = 0, b = c; x < b.length; x += 1) { var w = u.points[b[x]]; if (!(w.zoom <= e)) { w.zoom = e; var S = w.numPoints || 1; v += w.x * S, y += w.y * S, w.parentId = _, i && (g || (g = this._map(l, !0)), i(g, this._map(w))) } } l.parentId = _, n.push(F(v / h, y / h, _, h, g)) } else if (n.push(l), h > 1) for (var E = 0, C = c; E < C.length; E += 1) { var T = u.points[C[E]]; T.zoom <= e || (T.zoom = e, n.push(T)) } } } return n }, z.prototype._getOriginId = function (t) { return t - this.points.length >> 5 }, z.prototype._getOriginZoom = function (t) { return (t - this.points.length) % 32 }, z.prototype._map = function (t, e) { if (t.numPoints) return e ? H({}, t.properties) : t.properties; var n = this.points[t.index].properties, r = this.options.map(n); return e && r === n ? H({}, r) : r }, yt.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, yt.prototype.splitTile = function (t, e, n, r, i, o, a) { for (var s = [t, e, n, r], l = this.options, u = l.debug; s.length;) { r = s.pop(), n = s.pop(), e = s.pop(), t = s.pop(); var c = 1 << e, p = gt(e, n, r), h = this.tiles[p]; if (!h && (u > 1 && console.time("creation"), h = this.tiles[p] = dt(t, e, n, r, l), this.tileCoords.push({ z: e, x: n, y: r }), u)) { u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", e, n, r, h.numFeatures, h.numPoints, h.numSimplified), console.timeEnd("creation")); var f = "z" + e; this.stats[f] = (this.stats[f] || 0) + 1, this.total++ } if (h.source = t, i) { if (e === l.maxZoom || e === i) continue; var d = 1 << i - e; if (n !== Math.floor(o / d) || r !== Math.floor(a / d)) continue } else if (e === l.indexMaxZoom || h.numPoints <= l.indexMaxPoints) continue; if (h.source = null, 0 !== t.length) { u > 1 && console.time("clipping"); var m, v, y, g, _, x, b = .5 * l.buffer / l.extent, w = .5 - b, S = .5 + b, E = 1 + b; m = v = y = g = null, _ = nt(t, c, n - b, n + S, 0, h.minX, h.maxX, l), x = nt(t, c, n + w, n + E, 0, h.minX, h.maxX, l), t = null, _ && (m = nt(_, c, r - b, r + S, 1, h.minY, h.maxY, l), v = nt(_, c, r + w, r + E, 1, h.minY, h.maxY, l), _ = null), x && (y = nt(x, c, r - b, r + S, 1, h.minY, h.maxY, l), g = nt(x, c, r + w, r + E, 1, h.minY, h.maxY, l), x = null), u > 1 && console.timeEnd("clipping"), s.push(m || [], e + 1, 2 * n, 2 * r), s.push(v || [], e + 1, 2 * n, 2 * r + 1), s.push(y || [], e + 1, 2 * n + 1, 2 * r), s.push(g || [], e + 1, 2 * n + 1, 2 * r + 1) } } }, yt.prototype.getTile = function (t, e, n) { var r = this.options, i = r.extent, o = r.debug; if (t < 0 || t > 24) return null; var a = 1 << t, s = gt(t, e = (e % a + a) % a, n); if (this.tiles[s]) return ht(this.tiles[s], i); o > 1 && console.log("drilling down to z%d-%d-%d", t, e, n); for (var l, u = t, c = e, p = n; !l && u > 0;)u--, c = Math.floor(c / 2), p = Math.floor(p / 2), l = this.tiles[gt(u, c, p)]; return l && l.source ? (o > 1 && console.log("found parent tile z%d-%d-%d", u, c, p), o > 1 && console.time("drilling down"), this.splitTile(l.source, u, c, p, t, e, n), o > 1 && console.timeEnd("drilling down"), this.tiles[s] ? ht(this.tiles[s], i) : null) : null }; var xt = function (e) { function n(t, n, r, i) { e.call(this, t, n, r, _t), i && (this.loadGeoJSON = i) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.loadData = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = e, this._pendingLoadDataParams = t, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData()) }, n.prototype._loadData = function () { var e = this; if (this._pendingCallback && this._pendingLoadDataParams) { var n = this._pendingCallback, r = this._pendingLoadDataParams; delete this._pendingCallback, delete this._pendingLoadDataParams; var i = !!(r && r.request && r.request.collectResourceTiming) && new t.RequestPerformance(r.request); this.loadGeoJSON(r, (function (o, a) { if (o || !a) return n(o); if ("object" != typeof a) return n(new Error("Input data given to '" + r.source + "' is not a valid GeoJSON object.")); !function t(e, n) { var r, i = e && e.type; if ("FeatureCollection" === i) for (r = 0; r < e.features.length; r++)t(e.features[r], n); else if ("GeometryCollection" === i) for (r = 0; r < e.geometries.length; r++)t(e.geometries[r], n); else if ("Feature" === i) t(e.geometry, n); else if ("Polygon" === i) p(e.coordinates, n); else if ("MultiPolygon" === i) for (r = 0; r < e.coordinates.length; r++)p(e.coordinates[r], n); return e }(a, !0); try { if (r.filter) { var s = t.createExpression(r.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if ("error" === s.result) throw new Error(s.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); var l = a.features.filter((function (t) { return s.value.evaluate({ zoom: 0 }, t) })); a = { type: "FeatureCollection", features: l } } e._geoJSONIndex = r.cluster ? new z(function (e) { var n = e.superclusterOptions, r = e.clusterProperties; if (!r || !n) return n; for (var i = {}, o = {}, a = { accumulated: null, zoom: 0 }, s = { properties: null }, l = Object.keys(r), u = 0, c = l; u < c.length; u += 1) { var p = c[u], h = r[p], f = h[0], d = t.createExpression(h[1]), m = t.createExpression("string" == typeof f ? [f, ["accumulated"], ["get", p]] : f); i[p] = d.value, o[p] = m.value } return n.map = function (t) { s.properties = t; for (var e = {}, n = 0, r = l; n < r.length; n += 1) { var o = r[n]; e[o] = i[o].evaluate(a, s) } return e }, n.reduce = function (t, e) { s.properties = e; for (var n = 0, r = l; n < r.length; n += 1) { var i = r[n]; a.accumulated = t[i], t[i] = o[i].evaluate(a, s) } }, n }(r)).load(a.features) : function (t, e) { return new yt(t, e) }(a, r.geojsonVtOptions) } catch (o) { return n(o) } e.loaded = {}; var u = {}; if (i) { var c = i.finish(); c && (u.resourceTiming = {}, u.resourceTiming[r.source] = JSON.parse(JSON.stringify(c))) } n(null, u) })) } }, n.prototype.coalesce = function () { "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData()) }, n.prototype.reloadTile = function (t, n) { var r = this.loaded; return r && r[t.uid] ? e.prototype.reloadTile.call(this, t, n) : this.loadTile(t, n) }, n.prototype.loadGeoJSON = function (e, n) { if (e.request) t.getJSON(e.request, n); else { if ("string" != typeof e.data) return n(new Error("Input data given to '" + e.source + "' is not a valid GeoJSON object.")); try { return n(null, JSON.parse(e.data)) } catch (t) { return n(new Error("Input data given to '" + e.source + "' is not a valid GeoJSON object.")) } } }, n.prototype.removeSource = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), e() }, n.prototype.getClusterExpansionZoom = function (t, e) { try { e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId)) } catch (t) { e(t) } }, n.prototype.getClusterChildren = function (t, e) { try { e(null, this._geoJSONIndex.getChildren(t.clusterId)) } catch (t) { e(t) } }, n.prototype.getClusterLeaves = function (t, e) { try { e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset)) } catch (t) { e(t) } }, n }(l), bt = function (e) { var n = this; this.self = e, this.actor = new t.Actor(e, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: xt }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (t, e) { if (n.workerSourceTypes[t]) throw new Error('Worker source with name "' + t + '" already registered.'); n.workerSourceTypes[t] = e }, this.self.registerRTLTextPlugin = function (e) { if (t.plugin.isParsed()) throw new Error("RTL text plugin already registered."); t.plugin.applyArabicShaping = e.applyArabicShaping, t.plugin.processBidirectionalText = e.processBidirectionalText, t.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText } }; return bt.prototype.setReferrer = function (t, e) { this.referrer = e }, bt.prototype.setImages = function (t, e, n) { for (var r in this.availableImages[t] = e, this.workerSources[t]) { var i = this.workerSources[t][r]; for (var o in i) i[o].availableImages = e } n() }, bt.prototype.setLayers = function (t, e, n) { this.getLayerIndex(t).replace(e), n() }, bt.prototype.updateLayers = function (t, e, n) { this.getLayerIndex(t).update(e.layers, e.removedIds), n() }, bt.prototype.loadTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).loadTile(e, n) }, bt.prototype.loadDEMTile = function (t, e, n) { this.getDEMWorkerSource(t, e.source).loadTile(e, n) }, bt.prototype.reloadTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).reloadTile(e, n) }, bt.prototype.abortTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).abortTile(e, n) }, bt.prototype.removeTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).removeTile(e, n) }, bt.prototype.removeDEMTile = function (t, e) { this.getDEMWorkerSource(t, e.source).removeTile(e) }, bt.prototype.removeSource = function (t, e, n) { if (this.workerSources[t] && this.workerSources[t][e.type] && this.workerSources[t][e.type][e.source]) { var r = this.workerSources[t][e.type][e.source]; delete this.workerSources[t][e.type][e.source], void 0 !== r.removeSource ? r.removeSource(e, n) : n() } }, bt.prototype.loadWorkerSource = function (t, e, n) { try { this.self.importScripts(e.url), n() } catch (t) { n(t.toString()) } }, bt.prototype.syncRTLPluginState = function (e, n, r) { try { t.plugin.setState(n); var i = t.plugin.getPluginURL(); if (t.plugin.isLoaded() && !t.plugin.isParsed() && null != i) { this.self.importScripts(i); var o = t.plugin.isParsed(); r(o ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + i), o) } } catch (t) { r(t.toString()) } }, bt.prototype.getAvailableImages = function (t) { var e = this.availableImages[t]; return e || (e = []), e }, bt.prototype.getLayerIndex = function (t) { var e = this.layerIndexes[t]; return e || (e = this.layerIndexes[t] = new r), e }, bt.prototype.getWorkerSource = function (t, e, n) { var r = this; return this.workerSources[t] || (this.workerSources[t] = {}), this.workerSources[t][e] || (this.workerSources[t][e] = {}), this.workerSources[t][e][n] || (this.workerSources[t][e][n] = new this.workerSourceTypes[e]({ send: function (e, n, i) { r.actor.send(e, n, i, t) } }, this.getLayerIndex(t), this.getAvailableImages(t))), this.workerSources[t][e][n] }, bt.prototype.getDEMWorkerSource = function (t, e) { return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}), this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new c), this.demWorkerSources[t][e] }, bt.prototype.enforceCacheSizeLimit = function (e, n) { t.enforceCacheSizeLimit(n) }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new bt(self)), bt })), r(["./shared"], (function (t) { var e = t.createCommonjsModule((function (t) { function e(t) { return !n(t) } function n(t) { return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () { if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1; var t, e, n = new Blob([""], { type: "text/javascript" }), r = URL.createObjectURL(n); try { e = new Worker(r), t = !0 } catch (e) { t = !1 } return e && e.terminate(), URL.revokeObjectURL(r), t }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () { var t = document.createElement("canvas"); t.width = t.height = 1; var e = t.getContext("2d"); if (!e) return !1; var n = e.getImageData(0, 0, 1, 1); return n && n.width === t.width }() ? (void 0 === r[n = t && t.failIfMajorPerformanceCaveat] && (r[n] = function (t) { var n = function (t) { var n = document.createElement("canvas"), r = Object.create(e.webGLContextAttributes); return r.failIfMajorPerformanceCaveat = t, n.probablySupportsContext ? n.probablySupportsContext("webgl", r) || n.probablySupportsContext("experimental-webgl", r) : n.supportsContext ? n.supportsContext("webgl", r) || n.supportsContext("experimental-webgl", r) : n.getContext("webgl", r) || n.getContext("experimental-webgl", r) }(t); if (!n) return !1; var r = n.createShader(n.VERTEX_SHADER); return !(!r || n.isContextLost()) && (n.shaderSource(r, "void main() {}"), n.compileShader(r), !0 === n.getShaderParameter(r, n.COMPILE_STATUS)) }(n)), r[n] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support"; var n } t.exports ? t.exports = e : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e, window.mapboxgl.notSupportedReason = n); var r = {}; e.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 } })), n = { create: function (e, n, r) { var i = t.window.document.createElement(e); return void 0 !== n && (i.className = n), r && r.appendChild(i), i }, createNS: function (e, n) { return t.window.document.createElementNS(e, n) } }, r = t.window.document && t.window.document.documentElement.style; function i(t) { if (!r) return t[0]; for (var e = 0; e < t.length; e++)if (t[e] in r) return t[e]; return t[0] } var o, a = i(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]); n.disableDrag = function () { r && a && (o = r[a], r[a] = "none") }, n.enableDrag = function () { r && a && (r[a] = o) }; var s = i(["transform", "WebkitTransform"]); n.setTransform = function (t, e) { t.style[s] = e }; var l = !1; try { var u = Object.defineProperty({}, "passive", { get: function () { l = !0 } }); t.window.addEventListener("test", u, u), t.window.removeEventListener("test", u, u) } catch (t) { l = !1 } n.addEventListener = function (t, e, n, r) { void 0 === r && (r = {}), t.addEventListener(e, n, "passive" in r && l ? r : r.capture) }, n.removeEventListener = function (t, e, n, r) { void 0 === r && (r = {}), t.removeEventListener(e, n, "passive" in r && l ? r : r.capture) }; var c = function (e) { e.preventDefault(), e.stopPropagation(), t.window.removeEventListener("click", c, !0) }; function p(t) { var e = t.userImage; return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0) } n.suppressClick = function () { t.window.addEventListener("click", c, !0), t.window.setTimeout((function () { t.window.removeEventListener("click", c, !0) }), 0) }, n.mousePos = function (e, n) { var r = e.getBoundingClientRect(); return new t.Point(n.clientX - r.left - e.clientLeft, n.clientY - r.top - e.clientTop) }, n.touchPos = function (e, n) { for (var r = e.getBoundingClientRect(), i = [], o = 0; o < n.length; o++)i.push(new t.Point(n[o].clientX - r.left - e.clientLeft, n[o].clientY - r.top - e.clientTop)); return i }, n.mouseButton = function (e) { return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button }, n.remove = function (t) { t.parentNode && t.parentNode.removeChild(t) }; var h = function (e) { function n() { e.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = !0 } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.isLoaded = function () { return this.loaded }, n.prototype.setLoaded = function (t) { if (this.loaded !== t && (this.loaded = t, t)) { for (var e = 0, n = this.requestors; e < n.length; e += 1) { var r = n[e]; this._notify(r.ids, r.callback) } this.requestors = [] } }, n.prototype.getImage = function (t) { return this.images[t] }, n.prototype.addImage = function (t, e) { this._validate(t, e) && (this.images[t] = e) }, n.prototype._validate = function (e, n) { var r = !0; return this._validateStretch(n.stretchX, n.data && n.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "stretchX" value'))), r = !1), this._validateStretch(n.stretchY, n.data && n.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "stretchY" value'))), r = !1), this._validateContent(n.content, n) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "content" value'))), r = !1), r }, n.prototype._validateStretch = function (t, e) { if (!t) return !0; for (var n = 0, r = 0, i = t; r < i.length; r += 1) { var o = i[r]; if (o[0] < n || o[1] < o[0] || e < o[1]) return !1; n = o[1] } return !0 }, n.prototype._validateContent = function (t, e) { return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1])) }, n.prototype.updateImage = function (t, e) { e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0 }, n.prototype.removeImage = function (t) { var e = this.images[t]; delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove() }, n.prototype.listImages = function () { return Object.keys(this.images) }, n.prototype.getImages = function (t, e) { var n = !0; if (!this.isLoaded()) for (var r = 0, i = t; r < i.length; r += 1)this.images[i[r]] || (n = !1); this.isLoaded() || n ? this._notify(t, e) : this.requestors.push({ ids: t, callback: e }) }, n.prototype._notify = function (e, n) { for (var r = {}, i = 0, o = e; i < o.length; i += 1) { var a = o[i]; this.images[a] || this.fire(new t.Event("styleimagemissing", { id: a })); var s = this.images[a]; s ? r[a] = { data: s.data.clone(), pixelRatio: s.pixelRatio, sdf: s.sdf, version: s.version, stretchX: s.stretchX, stretchY: s.stretchY, content: s.content, hasRenderCallback: Boolean(s.userImage && s.userImage.render) } : t.warnOnce('Image "' + a + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.') } n(null, r) }, n.prototype.getPixelSize = function () { var t = this.atlasImage; return { width: t.width, height: t.height } }, n.prototype.getPattern = function (e) { var n = this.patterns[e], r = this.getImage(e); if (!r) return null; if (n && n.position.version === r.version) return n.position; if (n) n.position.version = r.version; else { var i = { w: r.data.width + 2, h: r.data.height + 2, x: 0, y: 0 }, o = new t.ImagePosition(i, r); this.patterns[e] = { bin: i, position: o } } return this._updatePatternAtlas(), this.patterns[e].position }, n.prototype.bind = function (e) { var n = e.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.Texture(e, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE) }, n.prototype._updatePatternAtlas = function () { var e = []; for (var n in this.patterns) e.push(this.patterns[n].bin); var r = t.potpack(e), i = r.w, o = r.h, a = this.atlasImage; for (var s in a.resize({ width: i || 1, height: o || 1 }), this.patterns) { var l = this.patterns[s].bin, u = l.x + 1, c = l.y + 1, p = this.images[s].data, h = p.width, f = p.height; t.RGBAImage.copy(p, a, { x: 0, y: 0 }, { x: u, y: c }, { width: h, height: f }), t.RGBAImage.copy(p, a, { x: 0, y: f - 1 }, { x: u, y: c - 1 }, { width: h, height: 1 }), t.RGBAImage.copy(p, a, { x: 0, y: 0 }, { x: u, y: c + f }, { width: h, height: 1 }), t.RGBAImage.copy(p, a, { x: h - 1, y: 0 }, { x: u - 1, y: c }, { width: 1, height: f }), t.RGBAImage.copy(p, a, { x: 0, y: 0 }, { x: u + h, y: c }, { width: 1, height: f }) } this.dirty = !0 }, n.prototype.beginFrame = function () { this.callbackDispatchedThisFrame = {} }, n.prototype.dispatchRenderCallbacks = function (t) { for (var e = 0, n = t; e < n.length; e += 1) { var r = n[e]; if (!this.callbackDispatchedThisFrame[r]) { this.callbackDispatchedThisFrame[r] = !0; var i = this.images[r]; p(i) && this.updateImage(r, i) } } }, n }(t.Evented), f = v, d = v, m = 1e20; function v(t, e, n, r, i, o) { this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = r || .25, this.fontFamily = i || "sans-serif", this.fontWeight = o || "normal", this.radius = n || 8; var a = this.size = this.fontSize + 2 * this.buffer; this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = a, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.d = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Int16Array(a), this.middle = Math.round(a / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)) } function y(t, e, n, r, i, o, a) { for (var s = 0; s < e; s++) { for (var l = 0; l < n; l++)r[l] = t[l * e + s]; for (g(r, i, o, a, n), l = 0; l < n; l++)t[l * e + s] = i[l] } for (l = 0; l < n; l++) { for (s = 0; s < e; s++)r[s] = t[l * e + s]; for (g(r, i, o, a, e), s = 0; s < e; s++)t[l * e + s] = Math.sqrt(i[s]) } } function g(t, e, n, r, i) { n[0] = 0, r[0] = -m, r[1] = +m; for (var o = 1, a = 0; o < i; o++) { for (var s = (t[o] + o * o - (t[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); s <= r[a];)a--, s = (t[o] + o * o - (t[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); n[++a] = o, r[a] = s, r[a + 1] = +m } for (o = 0, a = 0; o < i; o++) { for (; r[a + 1] < o;)a++; e[o] = (o - n[a]) * (o - n[a]) + t[n[a]] } } v.prototype.draw = function (t) { this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle); for (var e = this.ctx.getImageData(0, 0, this.size, this.size), n = new Uint8ClampedArray(this.size * this.size), r = 0; r < this.size * this.size; r++) { var i = e.data[4 * r + 3] / 255; this.gridOuter[r] = 1 === i ? 0 : 0 === i ? m : Math.pow(Math.max(0, .5 - i), 2), this.gridInner[r] = 1 === i ? m : 0 === i ? 0 : Math.pow(Math.max(0, i - .5), 2) } for (y(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), y(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), r = 0; r < this.size * this.size; r++)n[r] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[r] - this.gridInner[r]) / this.radius + this.cutoff)))); return n }, f.default = d; var _ = function (t, e) { this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {} }; _.prototype.setURL = function (t) { this.url = t }, _.prototype.getGlyphs = function (e, n) { var r = this, i = []; for (var o in e) for (var a = 0, s = e[o]; a < s.length; a += 1)i.push({ stack: o, id: s[a] }); t.asyncAll(i, (function (t, e) { var n = t.stack, i = t.id, o = r.entries[n]; o || (o = r.entries[n] = { glyphs: {}, requests: {}, ranges: {} }); var a = o.glyphs[i]; if (void 0 === a) { if (a = r._tinySDF(o, n, i)) return o.glyphs[i] = a, void e(null, { stack: n, id: i, glyph: a }); var s = Math.floor(i / 256); if (256 * s > 65535) e(new Error("glyphs > 65535 not supported")); else if (o.ranges[s]) e(null, { stack: n, id: i, glyph: a }); else { var l = o.requests[s]; l || (l = o.requests[s] = [], _.loadGlyphRange(n, s, r.url, r.requestManager, (function (t, e) { if (e) { for (var n in e) r._doesCharSupportLocalGlyph(+n) || (o.glyphs[+n] = e[+n]); o.ranges[s] = !0 } for (var i = 0, a = l; i < a.length; i += 1)(0, a[i])(t, e); delete o.requests[s] }))), l.push((function (t, r) { t ? e(t) : r && e(null, { stack: n, id: i, glyph: r[i] || null }) })) } } else e(null, { stack: n, id: i, glyph: a }) }), (function (t, e) { if (t) n(t); else if (e) { for (var r = {}, i = 0, o = e; i < o.length; i += 1) { var a = o[i], s = a.stack, l = a.id, u = a.glyph; (r[s] || (r[s] = {}))[l] = u && { id: u.id, bitmap: u.bitmap.clone(), metrics: u.metrics } } n(null, r) } })) }, _.prototype._doesCharSupportLocalGlyph = function (e) { return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e) || t.isChar["Hangul Syllables"](e) || t.isChar.Hiragana(e) || t.isChar.Katakana(e)) }, _.prototype._tinySDF = function (e, n, r) { var i = this.localIdeographFontFamily; if (i && this._doesCharSupportLocalGlyph(r)) { var o = e.tinySDF; if (!o) { var a = "400"; /bold/i.test(n) ? a = "900" : /medium/i.test(n) ? a = "500" : /light/i.test(n) && (a = "200"), o = e.tinySDF = new _.TinySDF(24, 3, 8, .25, i, a) } return { id: r, bitmap: new t.AlphaImage({ width: 30, height: 30 }, o.draw(String.fromCharCode(r))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } } } }, _.loadGlyphRange = function (e, n, r, i, o) { var a = 256 * n, s = a + 255, l = i.transformRequest(i.normalizeGlyphsURL(r).replace("{fontstack}", e).replace("{range}", a + "-" + s), t.ResourceType.Glyphs); t.getArrayBuffer(l, (function (e, n) { if (e) o(e); else if (n) { for (var r = {}, i = 0, a = t.parseGlyphPBF(n); i < a.length; i += 1) { var s = a[i]; r[s.id] = s } o(null, r) } })) }, _.TinySDF = f; var x = function () { this.specification = t.styleSpec.light.position }; x.prototype.possiblyEvaluate = function (e, n) { return t.sphericalToCartesian(e.expression.evaluate(n)) }, x.prototype.interpolate = function (e, n, r) { return { x: t.number(e.x, n.x, r), y: t.number(e.y, n.y, r), z: t.number(e.z, n.z, r) } }; var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x, color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function (e) { function n(n) { e.call(this), this._transitionable = new t.Transitionable(b), this.setLight(n), this._transitioning = this._transitionable.untransitioned() } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.getLight = function () { return this._transitionable.serialize() }, n.prototype.setLight = function (e, n) { if (void 0 === n && (n = {}), !this._validate(t.validateLight, e, n)) for (var r in e) { var i = e[r]; t.endsWith(r, "-transition") ? this._transitionable.setTransition(r.slice(0, -"-transition".length), i) : this._transitionable.setValue(r, i) } }, n.prototype.updateTransitions = function (t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) }, n.prototype.hasTransition = function () { return this._transitioning.hasTransition() }, n.prototype.recalculate = function (t) { this.properties = this._transitioning.possiblyEvaluate(t) }, n.prototype._validate = function (e, n, r) { return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: t.styleSpec }))) }, n }(t.Evented), S = function (t, e) { this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {} }; S.prototype.getDash = function (t, e) { var n = t.join(",") + String(e); return this.dashEntry[n] || (this.dashEntry[n] = this.addDash(t, e)), this.dashEntry[n] }, S.prototype.getDashRanges = function (t, e, n) { var r = [], i = t.length % 2 == 1 ? -t[t.length - 1] * n : 0, o = t[0] * n, a = !0; r.push({ left: i, right: o, isDash: a, zeroLength: 0 === t[0] }); for (var s = t[0], l = 1; l < t.length; l++) { var u = t[l]; r.push({ left: i = s * n, right: o = (s += u) * n, isDash: a = !a, zeroLength: 0 === u }) } return r }, S.prototype.addRoundDash = function (t, e, n) { for (var r = e / 2, i = -n; i <= n; i++)for (var o = this.width * (this.nextRow + n + i), a = 0, s = t[a], l = 0; l < this.width; l++) { l / s.right > 1 && (s = t[++a]); var u = Math.abs(l - s.left), c = Math.abs(l - s.right), p = Math.min(u, c), h = void 0, f = i / n * (r + 1); if (s.isDash) { var d = r - Math.abs(f); h = Math.sqrt(p * p + d * d) } else h = r - Math.sqrt(p * p + f * f); this.data[o + l] = Math.max(0, Math.min(255, h + 128)) } }, S.prototype.addRegularDash = function (t) { for (var e = t.length - 1; e >= 0; --e) { var n = t[e], r = t[e + 1]; n.zeroLength ? t.splice(e, 1) : r && r.isDash === n.isDash && (r.left = n.left, t.splice(e, 1)) } var i = t[0], o = t[t.length - 1]; i.isDash === o.isDash && (i.left = o.left - this.width, o.right = i.right + this.width); for (var a = this.width * this.nextRow, s = 0, l = t[s], u = 0; u < this.width; u++) { u / l.right > 1 && (l = t[++s]); var c = Math.abs(u - l.left), p = Math.abs(u - l.right), h = Math.min(c, p); this.data[a + u] = Math.max(0, Math.min(255, (l.isDash ? h : -h) + 128)) } }, S.prototype.addDash = function (e, n) { var r = n ? 7 : 0, i = 2 * r + 1; if (this.nextRow + i > this.height) return t.warnOnce("LineAtlas out of space"), null; for (var o = 0, a = 0; a < e.length; a++)o += e[a]; if (0 !== o) { var s = this.width / o, l = this.getDashRanges(e, this.width, s); n ? this.addRoundDash(l, s, r) : this.addRegularDash(l) } var u = { y: (this.nextRow + r + .5) / this.height, height: 2 * r / this.height, width: o }; return this.nextRow += i, this.dirty = !0, u }, S.prototype.bind = function (t) { var e = t.gl; this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data)) }; var E = function e(n, r) { this.workerPool = n, this.actors = [], this.currentActor = 0, this.id = t.uniqueId(); for (var i = this.workerPool.acquire(this.id), o = 0; o < i.length; o++) { var a = new e.Actor(i[o], r, this.id); a.name = "Worker " + o, this.actors.push(a) } }; function C(e, n, r) { var i = function (i, o) { if (i) return r(i); if (o) { var a = t.pick(t.extend(o, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]); o.vector_layers && (a.vectorLayers = o.vector_layers, a.vectorLayerIds = a.vectorLayers.map((function (t) { return t.id }))), a.tiles = n.canonicalizeTileset(a, e.url), r(null, a) } }; return e.url ? t.getJSON(n.transformRequest(n.normalizeSourceURL(e.url), t.ResourceType.Source), i) : t.browser.frame((function () { return i(null, e) })) } E.prototype.broadcast = function (e, n, r) { t.asyncAll(this.actors, (function (t, r) { t.send(e, n, r) }), r = r || function () { }) }, E.prototype.getActor = function () { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] }, E.prototype.remove = function () { this.actors.forEach((function (t) { t.remove() })), this.actors = [], this.workerPool.release(this.id) }, E.Actor = t.Actor; var T = function (e, n, r) { this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = n || 0, this.maxzoom = r || 24 }; T.prototype.validateBounds = function (t) { return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90] }, T.prototype.contains = function (e) { var n = Math.pow(2, e.z), r = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * n), i = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * n), o = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * n), a = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * n); return e.x >= r && e.x < o && e.y >= i && e.y < a }; var A = function (e) { function n(n, r, i, o) { if (e.call(this), this.id = n, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(o) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function () { var e = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = C(this._options, this.map._requestManager, (function (n, r) { e._tileJSONRequest = null, e._loaded = !0, n ? e.fire(new t.ErrorEvent(n)) : r && (t.extend(e, r), r.bounds && (e.tileBounds = new T(r.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(r.tiles, e.map._requestManager._customAccessToken), t.postMapLoadEvent(r.tiles, e.map._getMapId(), e.map._requestManager._skuToken, e.map._requestManager._customAccessToken), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" }))) })) }, n.prototype.loaded = function () { return this._loaded }, n.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, n.prototype.onAdd = function (t) { this.map = t, this.load() }, n.prototype.setSourceProperty = function (t) { this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.map.style.sourceCaches[this.id].clearTiles(), this.load() }, n.prototype.setTiles = function (t) { var e = this; return this.setSourceProperty((function () { e._options.tiles = t })), this }, n.prototype.setUrl = function (t) { var e = this; return this.setSourceProperty((function () { e.url = t, e._options.url = t })), this }, n.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, n.prototype.serialize = function () { return t.extend({}, this._options) }, n.prototype.loadTile = function (e, n) { var r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)), i = { request: this.map._requestManager.transformRequest(r, t.ResourceType.Tile), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }; function o(r, i) { return delete e.request, e.aborted ? n(null) : r && 404 !== r.status ? n(r) : (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), this.map._refreshExpiredTiles && i && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), n(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null))) } i.request.collectResourceTiming = this._collectResourceTiming, e.actor && "expired" !== e.state ? "loading" === e.state ? e.reloadCallback = n : e.request = e.actor.send("reloadTile", i, o.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send("loadTile", i, o.bind(this))) }, n.prototype.abortTile = function (t) { t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id }, void 0) }, n.prototype.unloadTile = function (t) { t.unloadVectorData(), t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id }, void 0) }, n.prototype.hasTransition = function () { return !1 }, n }(t.Evented), M = function (e) { function n(n, r, i, o) { e.call(this), this.id = n, this.dispatcher = i, this.setEventedParent(o), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({ type: "raster" }, r), t.extend(this, t.pick(r, ["url", "scheme", "tileSize"])) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function () { var e = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = C(this._options, this.map._requestManager, (function (n, r) { e._tileJSONRequest = null, e._loaded = !0, n ? e.fire(new t.ErrorEvent(n)) : r && (t.extend(e, r), r.bounds && (e.tileBounds = new T(r.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(r.tiles), t.postMapLoadEvent(r.tiles, e.map._getMapId(), e.map._requestManager._skuToken), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" }))) })) }, n.prototype.loaded = function () { return this._loaded }, n.prototype.onAdd = function (t) { this.map = t, this.load() }, n.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, n.prototype.serialize = function () { return t.extend({}, this._options) }, n.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, n.prototype.loadTile = function (e, n) { var r = this, i = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize); e.request = t.getImage(this.map._requestManager.transformRequest(i, t.ResourceType.Tile), (function (i, o) { if (delete e.request, e.aborted) e.state = "unloaded", n(null); else if (i) e.state = "errored", n(i); else if (o) { r.map._refreshExpiredTiles && e.setExpiryData(o), delete o.cacheControl, delete o.expires; var a = r.map.painter.context, s = a.gl; e.texture = r.map.painter.getTileTexture(o.width), e.texture ? e.texture.update(o, { useMipmap: !0 }) : (e.texture = new t.Texture(a, o, s.RGBA, { useMipmap: !0 }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), a.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a.extTextureFilterAnisotropicMax)), e.state = "loaded", t.cacheEntryPossiblyAdded(r.dispatcher), n(null) } })) }, n.prototype.abortTile = function (t, e) { t.request && (t.request.cancel(), delete t.request), e() }, n.prototype.unloadTile = function (t, e) { t.texture && this.map.painter.saveTileTexture(t.texture), e() }, n.prototype.hasTransition = function () { return !1 }, n }(t.Evented), O = function (e) { function n(n, r, i, o) { e.call(this, n, r, i, o), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox" } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.serialize = function () { return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding } }, n.prototype.loadTile = function (e, n) { var r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize); function i(t, r) { t && (e.state = "errored", n(t)), r && (e.dem = r, e.needsHillshadePrepare = !0, e.state = "loaded", n(null)) } e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function (r, o) { if (delete e.request, e.aborted) e.state = "unloaded", n(null); else if (r) e.state = "errored", n(r); else if (o) { this.map._refreshExpiredTiles && e.setExpiryData(o), delete o.cacheControl, delete o.expires; var a = t.window.ImageBitmap && o instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? o : t.browser.getImageData(o, 1), s = { uid: e.uid, coord: e.tileID, source: this.id, rawImageData: a, encoding: this.encoding }; e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send("loadDEMTile", s, i.bind(this))) } }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID) }, n.prototype._getNeighboringTiles = function (e) { var n = e.canonical, r = Math.pow(2, n.z), i = (n.x - 1 + r) % r, o = 0 === n.x ? e.wrap - 1 : e.wrap, a = (n.x + 1 + r) % r, s = n.x + 1 === r ? e.wrap + 1 : e.wrap, l = {}; return l[new t.OverscaledTileID(e.overscaledZ, o, n.z, i, n.y).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, n.z, a, n.y).key] = { backfilled: !1 }, n.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, o, n.z, i, n.y - 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, n.z, a, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < r && (l[new t.OverscaledTileID(e.overscaledZ, o, n.z, i, n.y + 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, n.z, a, n.y + 1).key] = { backfilled: !1 }), l }, n.prototype.unloadTile = function (t) { t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && t.actor.send("removeDEMTile", { uid: t.uid, source: this.id }) }, n }(M), k = function (e) { function n(n, r, i, o) { e.call(this), this.id = n, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = i.getActor(), this.setEventedParent(o), this._data = r.data, this._options = t.extend({}, r), this._collectResourceTiming = r.collectResourceTiming, this._resourceTiming = [], void 0 !== r.maxzoom && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId; var a = t.EXTENT / this.tileSize; this.workerOptions = t.extend({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (void 0 !== r.buffer ? r.buffer : 128) * a, tolerance: (void 0 !== r.tolerance ? r.tolerance : .375) * a, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== r.clusterMaxZoom ? Math.min(r.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: t.EXTENT, radius: (r.clusterRadius || 50) * a, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function () { var e = this; this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function (n) { if (n) e.fire(new t.ErrorEvent(n)); else { var r = { dataType: "source", sourceDataType: "metadata" }; e._collectResourceTiming && e._resourceTiming && e._resourceTiming.length > 0 && (r.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new t.Event("data", r)) } })) }, n.prototype.onAdd = function (t) { this.map = t, this.load() }, n.prototype.setData = function (e) { var n = this; return this._data = e, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function (e) { if (e) n.fire(new t.ErrorEvent(e)); else { var r = { dataType: "source", sourceDataType: "content" }; n._collectResourceTiming && n._resourceTiming && n._resourceTiming.length > 0 && (r.resourceTiming = n._resourceTiming, n._resourceTiming = []), n.fire(new t.Event("data", r)) } })), this }, n.prototype.getClusterExpansionZoom = function (t, e) { return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t, source: this.id }, e), this }, n.prototype.getClusterChildren = function (t, e) { return this.actor.send("geojson.getClusterChildren", { clusterId: t, source: this.id }, e), this }, n.prototype.getClusterLeaves = function (t, e, n, r) { return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t, limit: e, offset: n }, r), this }, n.prototype._updateWorkerData = function (e) { var n = this; this._loaded = !1; var r = t.extend({}, this.workerOptions), i = this._data; "string" == typeof i ? (r.request = this.map._requestManager.transformRequest(t.browser.resolveURL(i), t.ResourceType.Source), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(i), this.actor.send(this.type + ".loadData", r, (function (t, i) { n._removed || i && i.abandoned || (n._loaded = !0, i && i.resourceTiming && i.resourceTiming[n.id] && (n._resourceTiming = i.resourceTiming[n.id].slice(0)), n.actor.send(n.type + ".coalesce", { source: r.source }, null), e(t)) })) }, n.prototype.loaded = function () { return this._loaded }, n.prototype.loadTile = function (e, n) { var r = this, i = e.actor ? "reloadTile" : "loadTile"; e.actor = this.actor, e.request = this.actor.send(i, { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (function (t, o) { return delete e.request, e.unloadVectorData(), e.aborted ? n(null) : t ? n(t) : (e.loadVectorData(o, r.map.painter, "reloadTile" === i), n(null)) })) }, n.prototype.abortTile = function (t) { t.request && (t.request.cancel(), delete t.request), t.aborted = !0 }, n.prototype.unloadTile = function (t) { t.unloadVectorData(), this.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id }) }, n.prototype.onRemove = function () { this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id }) }, n.prototype.serialize = function () { return t.extend({}, this._options, { type: this.type, data: this._data }) }, n.prototype.hasTransition = function () { return !1 }, n }(t.Evented), I = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), P = function (e) { function n(t, n, r, i) { e.call(this), this.id = t, this.dispatcher = r, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(i), this.options = n } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function (e, n) { var r = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (function (i, o) { r._loaded = !0, i ? r.fire(new t.ErrorEvent(i)) : o && (r.image = o, e && (r.coordinates = e), n && n(), r._finishLoading()) })) }, n.prototype.loaded = function () { return this._loaded }, n.prototype.updateImage = function (t) { var e = this; return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, (function () { e.texture = null })), this) : this }, n.prototype._finishLoading = function () { this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" }))) }, n.prototype.onAdd = function (t) { this.map = t, this.load() }, n.prototype.setCoordinates = function (e) { var n = this; this.coordinates = e; var r = e.map(t.MercatorCoordinate.fromLngLat); this.tileID = function (e) { for (var n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = 0, s = e; a < s.length; a += 1) { var l = s[a]; n = Math.min(n, l.x), r = Math.min(r, l.y), i = Math.max(i, l.x), o = Math.max(o, l.y) } var u = Math.max(i - n, o - r), c = Math.max(0, Math.floor(-Math.log(u) / Math.LN2)), p = Math.pow(2, c); return new t.CanonicalTileID(c, Math.floor((n + i) / 2 * p), Math.floor((r + o) / 2 * p)) }(r), this.minzoom = this.maxzoom = this.tileID.z; var i = r.map((function (t) { return n.tileID.getTilePoint(t)._round() })); return this._boundsArray = new t.StructArrayLayout4i8, this._boundsArray.emplaceBack(i[0].x, i[0].y, 0, 0), this._boundsArray.emplaceBack(i[1].x, i[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(i[3].x, i[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(i[2].x, i[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this }, n.prototype.prepare = function () { if (0 !== Object.keys(this.tiles).length && this.image) { var e = this.map.painter.context, n = e.gl; for (var r in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, I.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)), this.tiles) { var i = this.tiles[r]; "loaded" !== i.state && (i.state = "loaded", i.texture = this.texture) } } }, n.prototype.loadTile = function (t, e) { this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = "errored", e(null)) }, n.prototype.serialize = function () { return { type: "image", url: this.options.url, coordinates: this.coordinates } }, n.prototype.hasTransition = function () { return !1 }, n }(t.Evented), L = function (e) { function n(t, n, r, i) { e.call(this, t, n, r, i), this.roundZoom = !0, this.type = "video", this.options = n } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function () { var e = this; this._loaded = !1; var n = this.options; this.urls = []; for (var r = 0, i = n.urls; r < i.length; r += 1)this.urls.push(this.map._requestManager.transformRequest(i[r], t.ResourceType.Source).url); t.getVideo(this.urls, (function (n, r) { e._loaded = !0, n ? e.fire(new t.ErrorEvent(n)) : r && (e.video = r, e.video.loop = !0, e.video.addEventListener("playing", (function () { e.map.triggerRepaint() })), e.map && e.video.play(), e._finishLoading()) })) }, n.prototype.pause = function () { this.video && this.video.pause() }, n.prototype.play = function () { this.video && this.video.play() }, n.prototype.seek = function (e) { if (this.video) { var n = this.video.seekable; e < n.start(0) || e > n.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + n.start(0) + " and " + n.end(0) + "-second mark."))) : this.video.currentTime = e } }, n.prototype.getVideo = function () { return this.video }, n.prototype.onAdd = function (t) { this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) }, n.prototype.prepare = function () { if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) { var e = this.map.painter.context, n = e.gl; for (var r in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, I.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)), this.tiles) { var i = this.tiles[r]; "loaded" !== i.state && (i.state = "loaded", i.texture = this.texture) } } }, n.prototype.serialize = function () { return { type: "video", urls: this.urls, coordinates: this.coordinates } }, n.prototype.hasTransition = function () { return this.video && !this.video.paused }, n }(P), R = function (e) { function n(n, r, i, o) { e.call(this, n, r, i, o), r.coordinates ? Array.isArray(r.coordinates) && 4 === r.coordinates.length && !r.coordinates.some((function (t) { return !Array.isArray(t) || 2 !== t.length || t.some((function (t) { return "number" != typeof t })) })) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + n, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + n, null, 'missing required property "coordinates"'))), r.animate && "boolean" != typeof r.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + n, null, 'optional "animate" property must be a boolean value'))), r.canvas ? "string" == typeof r.canvas || r.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + n, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + n, null, 'missing required property "canvas"'))), this.options = r, this.animate = void 0 === r.animate || r.animate } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.load = function () { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint() }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1) }, this._finishLoading()) }, n.prototype.getCanvas = function () { return this.canvas }, n.prototype.onAdd = function (t) { this.map = t, this.load(), this.canvas && this.animate && this.play() }, n.prototype.onRemove = function () { this.pause() }, n.prototype.prepare = function () { var e = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) { var n = this.map.painter.context, r = n.gl; for (var i in this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, I.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new t.Texture(n, this.canvas, r.RGBA, { premultiply: !0 }), this.tiles) { var o = this.tiles[i]; "loaded" !== o.state && (o.state = "loaded", o.texture = this.texture) } } }, n.prototype.serialize = function () { return { type: "canvas", coordinates: this.coordinates } }, n.prototype.hasTransition = function () { return this._playing }, n.prototype._hasInvalidDimensions = function () { for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) { var n = e[t]; if (isNaN(n) || n <= 0) return !0 } return !1 }, n }(P), D = { vector: A, raster: M, "raster-dem": O, geojson: k, video: L, image: P, canvas: R }; function N(e, n) { var r = t.identity([]); return t.translate(r, r, [1, 1, 0]), t.scale(r, r, [.5 * e.width, .5 * e.height, 1]), t.multiply(r, r, e.calculatePosMatrix(n.toUnwrapped())) } function z(t, e, n, r, i, o) { var a = function (t, e, n) { if (t) for (var r = 0, i = t; r < i.length; r += 1) { var o = e[i[r]]; if (o && o.source === n && "fill-extrusion" === o.type) return !0 } else for (var a in e) { var s = e[a]; if (s.source === n && "fill-extrusion" === s.type) return !0 } return !1 }(i && i.layers, e, t.id), s = o.maxPitchScaleFactor(), l = t.tilesIn(r, s, a); l.sort(F); for (var u = [], c = 0, p = l; c < p.length; c += 1) { var h = p[c]; u.push({ wrappedTileID: h.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(e, n, t._state, h.queryGeometry, h.cameraQueryGeometry, h.scale, i, o, s, N(t.transform, h.tileID)) }) } var f = function (t) { for (var e = {}, n = {}, r = 0, i = t; r < i.length; r += 1) { var o = i[r], a = o.queryResults, s = o.wrappedTileID, l = n[s] = n[s] || {}; for (var u in a) for (var c = a[u], p = l[u] = l[u] || {}, h = e[u] = e[u] || [], f = 0, d = c; f < d.length; f += 1) { var m = d[f]; p[m.featureIndex] || (p[m.featureIndex] = !0, h.push(m)) } } return e }(u); for (var d in f) f[d].forEach((function (e) { var n = e.feature, r = t.getFeatureState(n.layer["source-layer"], n.id); n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = r })); return f } function F(t, e) { var n = t.tileID, r = e.tileID; return n.overscaledZ - r.overscaledZ || n.canonical.y - r.canonical.y || n.wrap - r.wrap || n.canonical.x - r.canonical.x } var B = function (t, e) { this.max = t, this.onRemove = e, this.reset() }; B.prototype.reset = function () { for (var t in this.data) for (var e = 0, n = this.data[t]; e < n.length; e += 1) { var r = n[e]; r.timeout && clearTimeout(r.timeout), this.onRemove(r.value) } return this.data = {}, this.order = [], this }, B.prototype.add = function (t, e, n) { var r = this, i = t.wrapped().key; void 0 === this.data[i] && (this.data[i] = []); var o = { value: e, timeout: void 0 }; if (void 0 !== n && (o.timeout = setTimeout((function () { r.remove(t, o) }), n)), this.data[i].push(o), this.order.push(i), this.order.length > this.max) { var a = this._getAndRemoveByKey(this.order[0]); a && this.onRemove(a) } return this }, B.prototype.has = function (t) { return t.wrapped().key in this.data }, B.prototype.getAndRemove = function (t) { return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null }, B.prototype._getAndRemoveByKey = function (t) { var e = this.data[t].shift(); return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value }, B.prototype.getByKey = function (t) { var e = this.data[t]; return e ? e[0].value : null }, B.prototype.get = function (t) { return this.has(t) ? this.data[t.wrapped().key][0].value : null }, B.prototype.remove = function (t, e) { if (!this.has(t)) return this; var n = t.wrapped().key, r = void 0 === e ? 0 : this.data[n].indexOf(e), i = this.data[n][r]; return this.data[n].splice(r, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[n].length && delete this.data[n], this.onRemove(i.value), this.order.splice(this.order.indexOf(n), 1), this }, B.prototype.setMaxSize = function (t) { for (this.max = t; this.order.length > this.max;) { var e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this }, B.prototype.filter = function (t) { var e = []; for (var n in this.data) for (var r = 0, i = this.data[n]; r < i.length; r += 1) { var o = i[r]; t(o.value) || e.push(o) } for (var a = 0, s = e; a < s.length; a += 1) { var l = s[a]; this.remove(l.value.tileID, l) } }; var j = function (t, e, n) { this.context = t; var r = t.gl; this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(n), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer }; j.prototype.bind = function () { this.context.bindElementBuffer.set(this.buffer) }, j.prototype.updateData = function (t) { var e = this.context.gl; this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer) }, j.prototype.destroy = function () { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) }; var U = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, V = function (t, e, n, r) { this.length = e.length, this.attributes = n, this.itemSize = e.bytesPerElement, this.dynamicDraw = r, this.context = t; var i = t.gl; this.buffer = i.createBuffer(), t.bindVertexBuffer.set(this.buffer), i.bufferData(i.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer }; V.prototype.bind = function () { this.context.bindVertexBuffer.set(this.buffer) }, V.prototype.updateData = function (t) { var e = this.context.gl; this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer) }, V.prototype.enableAttributes = function (t, e) { for (var n = 0; n < this.attributes.length; n++) { var r = e.attributes[this.attributes[n].name]; void 0 !== r && t.enableVertexAttribArray(r) } }, V.prototype.setVertexAttribPointers = function (t, e, n) { for (var r = 0; r < this.attributes.length; r++) { var i = this.attributes[r], o = e.attributes[i.name]; void 0 !== o && t.vertexAttribPointer(o, i.components, t[U[i.type]], !1, this.itemSize, i.offset + this.itemSize * (n || 0)) } }, V.prototype.destroy = function () { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) }; var G = function (t) { this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1 }; G.prototype.get = function () { return this.current }, G.prototype.set = function (t) { }, G.prototype.getDefault = function () { return this.default }, G.prototype.setDefault = function () { this.set(this.default) }; var H = function (e) { function n() { e.apply(this, arguments) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.getDefault = function () { return t.Color.transparent }, n.prototype.set = function (t) { var e = this.current; (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) }, n }(G), W = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 1 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1) }, e }(G), X = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1) }, e }(G), q = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return [!0, !0, !0, !0] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) }, e }(G), Z = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1) }, e }(G), Y = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 255 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1) }, e }(G), K = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } }, e.prototype.set = function (t) { var e = this.current; (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1) }, e }(G), Q = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [t.KEEP, t.KEEP, t.KEEP] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1) }, e }(G), J = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1 } }, e }(G), $ = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return [0, 1] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1) }, e }(G), tt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1 } }, e }(G), et = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.LESS }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1) }, e }(G), nt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1 } }, e }(G), rt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [t.ONE, t.ZERO] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1) }, e }(G), it = function (e) { function n() { e.apply(this, arguments) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.getDefault = function () { return t.Color.transparent }, n.prototype.set = function (t) { var e = this.current; (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) }, n }(G), ot = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.FUNC_ADD }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1) }, e }(G), at = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1 } }, e }(G), st = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.BACK }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1) }, e }(G), lt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.CCW }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1) }, e }(G), ut = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1) }, e }(G), ct = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.TEXTURE0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1) }, e }(G), pt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) }, e }(G), ht = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1 } }, e }(G), ft = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1 } }, e }(G), dt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1 } }, e }(G), mt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1 } }, e }(G), vt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { var e = this.gl; e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1 }, e }(G), yt = function (t) { function e(e) { t.call(this, e), this.vao = e.extVertexArrayObject } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1) }, e }(G), gt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 4 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1 } }, e }(G), _t = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1 } }, e }(G), xt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1 } }, e }(G), bt = function (t) { function e(e, n) { t.call(this, e), this.context = e, this.parent = n } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e }(G), wt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.setDirty = function () { this.dirty = !0 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { this.context.bindFramebuffer.set(this.parent); var e = this.gl; e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1 } }, e }(bt), St = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { this.context.bindFramebuffer.set(this.parent); var e = this.gl; e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1 } }, e }(bt), Et = function (t, e, n, r) { this.context = t, this.width = e, this.height = n; var i = this.framebuffer = t.gl.createFramebuffer(); this.colorAttachment = new wt(t, i), r && (this.depthAttachment = new St(t, i)) }; Et.prototype.destroy = function () { var t = this.context.gl, e = this.colorAttachment.get(); if (e && t.deleteTexture(e), this.depthAttachment) { var n = this.depthAttachment.get(); n && t.deleteRenderbuffer(n) } t.deleteFramebuffer(this.framebuffer) }; var Ct = function (t, e, n) { this.func = t, this.mask = e, this.range = n }; Ct.ReadOnly = !1, Ct.ReadWrite = !0, Ct.disabled = new Ct(519, Ct.ReadOnly, [0, 1]); var Tt = function (t, e, n, r, i, o) { this.test = t, this.ref = e, this.mask = n, this.fail = r, this.depthFail = i, this.pass = o }; Tt.disabled = new Tt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680); var At = function (t, e, n) { this.blendFunction = t, this.blendColor = e, this.mask = n }; At.disabled = new At(At.Replace = [1, 0], t.Color.transparent, [!1, !1, !1, !1]), At.unblended = new At(At.Replace, t.Color.transparent, [!0, !0, !0, !0]), At.alphaBlended = new At([1, 771], t.Color.transparent, [!0, !0, !0, !0]); var Mt = function (t, e, n) { this.enable = t, this.mode = e, this.frontFace = n }; Mt.disabled = new Mt(!1, 1029, 2305), Mt.backCCW = new Mt(!0, 1029, 2305); var Ot = function (t) { this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new H(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new Z(this), this.stencilMask = new Y(this), this.stencilFunc = new K(this), this.stencilOp = new Q(this), this.stencilTest = new J(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new nt(this), this.blendFunc = new rt(this), this.blendColor = new it(this), this.blendEquation = new ot(this), this.cullFace = new at(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ut(this), this.activeTexture = new ct(this), this.viewport = new pt(this), this.bindFramebuffer = new ht(this), this.bindRenderbuffer = new ft(this), this.bindTexture = new dt(this), this.bindVertexBuffer = new mt(this), this.bindElementBuffer = new vt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new yt(this), this.pixelStoreUnpack = new gt(this), this.pixelStoreUnpackPremultiplyAlpha = new _t(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE) }; Ot.prototype.setDefault = function () { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault() }, Ot.prototype.setDirty = function () { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0 }, Ot.prototype.createIndexBuffer = function (t, e) { return new j(this, t, e) }, Ot.prototype.createVertexBuffer = function (t, e, n) { return new V(this, t, e, n) }, Ot.prototype.createRenderbuffer = function (t, e, n) { var r = this.gl, i = r.createRenderbuffer(); return this.bindRenderbuffer.set(i), r.renderbufferStorage(r.RENDERBUFFER, t, e, n), this.bindRenderbuffer.set(null), i }, Ot.prototype.createFramebuffer = function (t, e, n) { return new Et(this, t, e, n) }, Ot.prototype.clear = function (t) { var e = t.color, n = t.depth, r = this.gl, i = 0; e && (i |= r.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== n && (i |= r.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), r.clear(i) }, Ot.prototype.setCullFace = function (t) { !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace)) }, Ot.prototype.setDepthMode = function (t) { t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1) }, Ot.prototype.setStencilMode = function (t) { t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1) }, Ot.prototype.setColorMode = function (e) { t.deepEqual(e.blendFunction, At.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask) }, Ot.prototype.unbindVAO = function () { this.extVertexArrayObject && this.bindVertexArrayOES.set(null) }; var kt = function (e) { function n(n, r, i) { var o = this; e.call(this), this.id = n, this.dispatcher = i, this.on("data", (function (t) { "source" === t.dataType && "metadata" === t.sourceDataType && (o._sourceLoaded = !0), o._sourceLoaded && !o._paused && "source" === t.dataType && "content" === t.sourceDataType && (o.reload(), o.transform && o.update(o.transform)) })), this.on("error", (function () { o._sourceErrored = !0 })), this._source = function (e, n, r, i) { var o = new D[n.type](e, n, r, i); if (o.id !== e) throw new Error("Expected Source id to be " + e + " instead of " + o.id); return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], o), o }(n, r, i, this), this._tiles = {}, this._cache = new B(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.onAdd = function (t) { this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t) }, n.prototype.onRemove = function (t) { this._source && this._source.onRemove && this._source.onRemove(t) }, n.prototype.loaded = function () { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; if (!this._source.loaded()) return !1; for (var t in this._tiles) { var e = this._tiles[t]; if ("loaded" !== e.state && "errored" !== e.state) return !1 } return !0 }, n.prototype.getSource = function () { return this._source }, n.prototype.pause = function () { this._paused = !0 }, n.prototype.resume = function () { if (this._paused) { var t = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform) } }, n.prototype._loadTile = function (t, e) { return this._source.loadTile(t, e) }, n.prototype._unloadTile = function (t) { if (this._source.unloadTile) return this._source.unloadTile(t, (function () { })) }, n.prototype._abortTile = function (t) { if (this._source.abortTile) return this._source.abortTile(t, (function () { })) }, n.prototype.serialize = function () { return this._source.serialize() }, n.prototype.prepare = function (t) { for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) { var n = this._tiles[e]; n.upload(t), n.prepare(this.map.style.imageManager) } }, n.prototype.getIds = function () { return t.values(this._tiles).map((function (t) { return t.tileID })).sort(It).map((function (t) { return t.key })) }, n.prototype.getRenderableIds = function (e) { var n = this, r = []; for (var i in this._tiles) this._isIdRenderable(i, e) && r.push(this._tiles[i]); return e ? r.sort((function (e, r) { var i = e.tileID, o = r.tileID, a = new t.Point(i.canonical.x, i.canonical.y)._rotate(n.transform.angle), s = new t.Point(o.canonical.x, o.canonical.y)._rotate(n.transform.angle); return i.overscaledZ - o.overscaledZ || s.y - a.y || s.x - a.x })).map((function (t) { return t.tileID.key })) : r.map((function (t) { return t.tileID })).sort(It).map((function (t) { return t.key })) }, n.prototype.hasRenderableParent = function (t) { var e = this.findLoadedParent(t, 0); return !!e && this._isIdRenderable(e.tileID.key) }, n.prototype._isIdRenderable = function (t, e) { return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade()) }, n.prototype.reload = function () { if (this._paused) this._shouldReloadOnResume = !0; else for (var t in this._cache.reset(), this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading") }, n.prototype._reloadTile = function (t, e) { var n = this._tiles[t]; n && ("loading" !== n.state && (n.state = e), this._loadTile(n, this._tileLoaded.bind(this, n, t, e))) }, n.prototype._tileLoaded = function (e, n, r, i) { if (i) return e.state = "errored", void (404 !== i.status ? this._source.fire(new t.ErrorEvent(i, { tile: e })) : this.update(this.transform)); e.timeAdded = t.browser.now(), "expired" === r && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(n, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e, coord: e.tileID })) }, n.prototype._backfillDEM = function (t) { for (var e = this.getRenderableIds(), n = 0; n < e.length; n++) { var r = e[n]; if (t.neighboringTiles && t.neighboringTiles[r]) { var i = this.getTileByID(r); o(t, i), o(i, t) } } function o(t, e) { t.needsHillshadePrepare = !0; var n = e.tileID.canonical.x - t.tileID.canonical.x, r = e.tileID.canonical.y - t.tileID.canonical.y, i = Math.pow(2, t.tileID.canonical.z), o = e.tileID.key; 0 === n && 0 === r || Math.abs(r) > 1 || (Math.abs(n) > 1 && (1 === Math.abs(n + i) ? n += i : 1 === Math.abs(n - i) && (n -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, n, r), t.neighboringTiles && t.neighboringTiles[o] && (t.neighboringTiles[o].backfilled = !0))) } }, n.prototype.getTile = function (t) { return this.getTileByID(t.key) }, n.prototype.getTileByID = function (t) { return this._tiles[t] }, n.prototype._retainLoadedChildren = function (t, e, n, r) { for (var i in this._tiles) { var o = this._tiles[i]; if (!(r[i] || !o.hasData() || o.tileID.overscaledZ <= e || o.tileID.overscaledZ > n)) { for (var a = o.tileID; o && o.tileID.overscaledZ > e + 1;) { var s = o.tileID.scaledTo(o.tileID.overscaledZ - 1); (o = this._tiles[s.key]) && o.hasData() && (a = s) } for (var l = a; l.overscaledZ > e;)if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) { r[a.key] = a; break } } } }, n.prototype.findLoadedParent = function (t, e) { if (t.key in this._loadedParentTiles) { var n = this._loadedParentTiles[t.key]; return n && n.tileID.overscaledZ >= e ? n : null } for (var r = t.overscaledZ - 1; r >= e; r--) { var i = t.scaledTo(r), o = this._getLoadedTile(i); if (o) return o } }, n.prototype._getLoadedTile = function (t) { var e = this._tiles[t.key]; return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key) }, n.prototype.updateCacheSize = function (t) { var e = Math.ceil(t.width / this._source.tileSize) + 1, n = Math.ceil(t.height / this._source.tileSize) + 1, r = Math.floor(e * n * 5), i = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r; this._cache.setMaxSize(i) }, n.prototype.handleWrapJump = function (t) { var e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360); if (this._prevLng = t, e) { var n = {}; for (var r in this._tiles) { var i = this._tiles[r]; i.tileID = i.tileID.unwrapTo(i.tileID.wrap + e), n[i.tileID.key] = i } for (var o in this._tiles = n, this._timers) clearTimeout(this._timers[o]), delete this._timers[o]; for (var a in this._tiles) this._setTileReloadTimer(a, this._tiles[a]) } }, n.prototype.update = function (e) { var r = this; if (this.transform = e, this._sourceLoaded && !this._paused) { var i; this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((function (e) { return new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y) })) : (i = e.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (i = i.filter((function (t) { return r._source.hasTile(t) })))) : i = []; var o = e.coveringZoomLevel(this._source), a = Math.max(o - n.maxOverzooming, this._source.minzoom), s = Math.max(o + n.maxUnderzooming, this._source.minzoom), l = this._updateRetainedTiles(i, o); if (Pt(this._source.type)) { for (var u = {}, c = {}, p = 0, h = Object.keys(l); p < h.length; p += 1) { var f = h[p], d = l[f], m = this._tiles[f]; if (m && !(m.fadeEndTime && m.fadeEndTime <= t.browser.now())) { var v = this.findLoadedParent(d, a); v && (this._addTile(v.tileID), u[v.tileID.key] = v.tileID), c[f] = d } } for (var y in this._retainLoadedChildren(c, o, s, l), u) l[y] || (this._coveredTiles[y] = !0, l[y] = u[y]) } for (var g in l) this._tiles[g].clearFadeHold(); for (var _ = 0, x = t.keysDifference(this._tiles, l); _ < x.length; _ += 1) { var b = x[_], w = this._tiles[b]; w.hasSymbolBuckets && !w.holdingForFade() ? w.setHoldDuration(this.map._fadeDuration) : w.hasSymbolBuckets && !w.symbolFadeFinished() || this._removeTile(b) } this._updateLoadedParentTileCache() } }, n.prototype.releaseSymbolFadeTiles = function () { for (var t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t) }, n.prototype._updateRetainedTiles = function (t, e) { for (var r = {}, i = {}, o = Math.max(e - n.maxOverzooming, this._source.minzoom), a = Math.max(e + n.maxUnderzooming, this._source.minzoom), s = {}, l = 0, u = t; l < u.length; l += 1) { var c = u[l], p = this._addTile(c); r[c.key] = c, p.hasData() || e < this._source.maxzoom && (s[c.key] = c) } this._retainLoadedChildren(s, e, a, r); for (var h = 0, f = t; h < f.length; h += 1) { var d = f[h], m = this._tiles[d.key]; if (!m.hasData()) { if (e + 1 > this._source.maxzoom) { var v = d.children(this._source.maxzoom)[0], y = this.getTile(v); if (y && y.hasData()) { r[v.key] = v; continue } } else { var g = d.children(this._source.maxzoom); if (r[g[0].key] && r[g[1].key] && r[g[2].key] && r[g[3].key]) continue } for (var _ = m.wasRequested(), x = d.overscaledZ - 1; x >= o; --x) { var b = d.scaledTo(x); if (i[b.key]) break; if (i[b.key] = !0, !(m = this.getTile(b)) && _ && (m = this._addTile(b)), m && (r[b.key] = b, _ = m.wasRequested(), m.hasData())) break } } } return r }, n.prototype._updateLoadedParentTileCache = function () { for (var t in this._loadedParentTiles = {}, this._tiles) { for (var e = [], n = void 0, r = this._tiles[t].tileID; r.overscaledZ > 0;) { if (r.key in this._loadedParentTiles) { n = this._loadedParentTiles[r.key]; break } e.push(r.key); var i = r.scaledTo(r.overscaledZ - 1); if (n = this._getLoadedTile(i)) break; r = i } for (var o = 0, a = e; o < a.length; o += 1)this._loadedParentTiles[a[o]] = n } }, n.prototype._addTile = function (e) { var n = this._tiles[e.key]; if (n) return n; (n = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, n), n.tileID = e, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, n))); var r = Boolean(n); return r || (n = new t.Tile(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(n, this._tileLoaded.bind(this, n, e.key, n.state))), n ? (n.uses++, this._tiles[e.key] = n, r || this._source.fire(new t.Event("dataloading", { tile: n, coord: n.tileID, dataType: "source" })), n) : null }, n.prototype._setTileReloadTimer = function (t, e) { var n = this; t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]); var r = e.getExpiryTimeout(); r && (this._timers[t] = setTimeout((function () { n._reloadTile(t, "expired"), delete n._timers[t] }), r)) }, n.prototype._removeTile = function (t) { var e = this._tiles[t]; e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e)))) }, n.prototype.clearTiles = function () { for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(t); this._cache.reset() }, n.prototype.tilesIn = function (e, n, r) { var i = this, o = [], a = this.transform; if (!a) return o; for (var s = r ? a.getCameraQueryGeometry(e) : e, l = e.map((function (t) { return a.pointCoordinate(t) })), u = s.map((function (t) { return a.pointCoordinate(t) })), c = this.getIds(), p = 1 / 0, h = 1 / 0, f = -1 / 0, d = -1 / 0, m = 0, v = u; m < v.length; m += 1) { var y = v[m]; p = Math.min(p, y.x), h = Math.min(h, y.y), f = Math.max(f, y.x), d = Math.max(d, y.y) } for (var g = function (e) { var r = i._tiles[c[e]]; if (!r.holdingForFade()) { var s = r.tileID, m = Math.pow(2, a.zoom - r.tileID.overscaledZ), v = n * r.queryPadding * t.EXTENT / r.tileSize / m, y = [s.getTilePoint(new t.MercatorCoordinate(p, h)), s.getTilePoint(new t.MercatorCoordinate(f, d))]; if (y[0].x - v < t.EXTENT && y[0].y - v < t.EXTENT && y[1].x + v >= 0 && y[1].y + v >= 0) { var g = l.map((function (t) { return s.getTilePoint(t) })), _ = u.map((function (t) { return s.getTilePoint(t) })); o.push({ tile: r, tileID: s, queryGeometry: g, cameraQueryGeometry: _, scale: m }) } } }, _ = 0; _ < c.length; _++)g(_); return o }, n.prototype.getVisibleCoordinates = function (t) { for (var e = this, n = this.getRenderableIds(t).map((function (t) { return e._tiles[t].tileID })), r = 0, i = n; r < i.length; r += 1) { var o = i[r]; o.posMatrix = this.transform.calculatePosMatrix(o.toUnwrapped()) } return n }, n.prototype.hasTransition = function () { if (this._source.hasTransition()) return !0; if (Pt(this._source.type)) for (var e in this._tiles) { var n = this._tiles[e]; if (void 0 !== n.fadeEndTime && n.fadeEndTime >= t.browser.now()) return !0 } return !1 }, n.prototype.setFeatureState = function (t, e, n) { this._state.updateState(t = t || "_geojsonTileLayer", e, n) }, n.prototype.removeFeatureState = function (t, e, n) { this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, n) }, n.prototype.getFeatureState = function (t, e) { return this._state.getState(t = t || "_geojsonTileLayer", e) }, n.prototype.setDependencies = function (t, e, n) { var r = this._tiles[t]; r && r.setDependencies(e, n) }, n.prototype.reloadTilesForDependencies = function (t, e) { for (var n in this._tiles) this._tiles[n].hasDependency(t, e) && this._reloadTile(n, "reloading"); this._cache.filter((function (n) { return !n.hasDependency(t, e) })) }, n }(t.Evented); function It(t, e) { var n = Math.abs(2 * t.wrap) - +(t.wrap < 0), r = Math.abs(2 * e.wrap) - +(e.wrap < 0); return t.overscaledZ - e.overscaledZ || r - n || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x } function Pt(t) { return "raster" === t || "image" === t || "video" === t } function Lt() { return new t.window.Worker(Yi.workerUrl) } kt.maxOverzooming = 10, kt.maxUnderzooming = 3; var Rt = "mapboxgl_preloaded_worker_pool", Dt = function () { this.active = {} }; Dt.prototype.acquire = function (t) { if (!this.workers) for (this.workers = []; this.workers.length < Dt.workerCount;)this.workers.push(new Lt); return this.active[t] = !0, this.workers.slice() }, Dt.prototype.release = function (t) { delete this.active[t], 0 === this.numActive() && (this.workers.forEach((function (t) { t.terminate() })), this.workers = null) }, Dt.prototype.isPreloaded = function () { return !!this.active[Rt] }, Dt.prototype.numActive = function () { return Object.keys(this.active).length }; var Nt, zt = Math.floor(t.browser.hardwareConcurrency / 2); function Ft() { return Nt || (Nt = new Dt), Nt } function Bt(e, n) { var r = {}; for (var i in e) "ref" !== i && (r[i] = e[i]); return t.refProperties.forEach((function (t) { t in n && (r[t] = n[t]) })), r } function jt(t) { t = t.slice(); for (var e = Object.create(null), n = 0; n < t.length; n++)e[t[n].id] = t[n]; for (var r = 0; r < t.length; r++)"ref" in t[r] && (t[r] = Bt(t[r], e[t[r].ref])); return t } Dt.workerCount = Math.max(Math.min(zt, 6), 1); var Ut = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" }; function Vt(t, e, n) { n.push({ command: Ut.addSource, args: [t, e[t]] }) } function Gt(t, e, n) { e.push({ command: Ut.removeSource, args: [t] }), n[t] = !0 } function Ht(t, e, n, r) { Gt(t, n, r), Vt(t, e, n) } function Wt(e, n, r) { var i; for (i in e[r]) if (e[r].hasOwnProperty(i) && "data" !== i && !t.deepEqual(e[r][i], n[r][i])) return !1; for (i in n[r]) if (n[r].hasOwnProperty(i) && "data" !== i && !t.deepEqual(e[r][i], n[r][i])) return !1; return !0 } function Xt(e, n, r, i, o, a) { var s; for (s in n = n || {}, e = e || {}) e.hasOwnProperty(s) && (t.deepEqual(e[s], n[s]) || r.push({ command: a, args: [i, s, n[s], o] })); for (s in n) n.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t.deepEqual(e[s], n[s]) || r.push({ command: a, args: [i, s, n[s], o] })) } function qt(t) { return t.id } function Zt(t, e) { return t[e.id] = e, t } var Yt = function (t, e) { this.reset(t, e) }; Yt.prototype.reset = function (t, e) { this.points = t || [], this._distances = [0]; for (var n = 1; n < this.points.length; n++)this._distances[n] = this._distances[n - 1] + this.points[n].dist(this.points[n - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding }, Yt.prototype.lerp = function (e) { if (1 === this.points.length) return this.points[0]; e = t.clamp(e, 0, 1); for (var n = 1, r = this._distances[n], i = e * this.paddedLength + this.padding; r < i && n < this._distances.length;)r = this._distances[++n]; var o = n - 1, a = this._distances[o], s = r - a, l = s > 0 ? (i - a) / s : 0; return this.points[o].mult(1 - l).add(this.points[n].mult(l)) }; var Kt = function (t, e, n) { var r = this.boxCells = [], i = this.circleCells = []; this.xCellCount = Math.ceil(t / n), this.yCellCount = Math.ceil(e / n); for (var o = 0; o < this.xCellCount * this.yCellCount; o++)r.push([]), i.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0 }; function Qt(e, n, r, i, o) { var a = t.create(); return n ? (t.scale(a, a, [1 / o, 1 / o, 1]), r || t.rotateZ(a, a, i.angle)) : t.multiply(a, i.labelPlaneMatrix, e), a } function Jt(e, n, r, i, o) { if (n) { var a = t.clone(e); return t.scale(a, a, [o, o, 1]), r || t.rotateZ(a, a, -i.angle), a } return i.glCoordMatrix } function $t(e, n) { var r = [e.x, e.y, 0, 1]; ce(r, r, n); var i = r[3]; return { point: new t.Point(r[0] / i, r[1] / i), signedDistanceFromCamera: i } } function te(t, e) { return .5 + t / e * .5 } function ee(t, e) { var n = t[0] / t[3], r = t[1] / t[3]; return n >= -e[0] && n <= e[0] && r >= -e[1] && r <= e[1] } function ne(e, n, r, i, o, a, s, l) { var u = i ? e.textSizeData : e.iconSizeData, c = t.evaluateSizeForZoom(u, r.transform.zoom), p = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], h = i ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray; h.clear(); for (var f = e.lineVertexArray, d = i ? e.text.placedSymbolArray : e.icon.placedSymbolArray, m = r.transform.width / r.transform.height, v = !1, y = 0; y < d.length; y++) { var g = d.get(y); if (g.hidden || g.writingMode === t.WritingMode.vertical && !v) ue(g.numGlyphs, h); else { v = !1; var _ = [g.anchorX, g.anchorY, 0, 1]; if (t.transformMat4(_, _, n), ee(_, p)) { var x = te(r.transform.cameraToCenterDistance, _[3]), b = t.evaluateSizeForFeature(u, c, g), w = s ? b / x : b * x, S = new t.Point(g.anchorX, g.anchorY), E = $t(S, o).point, C = {}, T = oe(g, w, !1, l, n, o, a, e.glyphOffsetArray, f, h, E, S, C, m); v = T.useVertical, (T.notEnoughRoom || v || T.needsFlipping && oe(g, w, !0, l, n, o, a, e.glyphOffsetArray, f, h, E, S, C, m).notEnoughRoom) && ue(g.numGlyphs, h) } else ue(g.numGlyphs, h) } } i ? e.text.dynamicLayoutVertexBuffer.updateData(h) : e.icon.dynamicLayoutVertexBuffer.updateData(h) } function re(t, e, n, r, i, o, a, s, l, u, c) { var p = s.glyphStartIndex + s.numGlyphs, h = s.lineStartIndex, f = s.lineStartIndex + s.lineLength, d = e.getoffsetX(s.glyphStartIndex), m = e.getoffsetX(p - 1), v = se(t * d, n, r, i, o, a, s.segment, h, f, l, u, c); if (!v) return null; var y = se(t * m, n, r, i, o, a, s.segment, h, f, l, u, c); return y ? { first: v, last: y } : null } function ie(e, n, r, i) { return e === t.WritingMode.horizontal && Math.abs(r.y - n.y) > Math.abs(r.x - n.x) * i ? { useVertical: !0 } : (e === t.WritingMode.vertical ? n.y < r.y : n.x > r.x) ? { needsFlipping: !0 } : null } function oe(e, n, r, i, o, a, s, l, u, c, p, h, f, d) { var m, v = n / 24, y = e.lineOffsetX * v, g = e.lineOffsetY * v; if (e.numGlyphs > 1) { var _ = e.glyphStartIndex + e.numGlyphs, x = e.lineStartIndex, b = e.lineStartIndex + e.lineLength, w = re(v, l, y, g, r, p, h, e, u, a, f); if (!w) return { notEnoughRoom: !0 }; var S = $t(w.first.point, s).point, E = $t(w.last.point, s).point; if (i && !r) { var C = ie(e.writingMode, S, E, d); if (C) return C } m = [w.first]; for (var T = e.glyphStartIndex + 1; T < _ - 1; T++)m.push(se(v * l.getoffsetX(T), y, g, r, p, h, e.segment, x, b, u, a, f)); m.push(w.last) } else { if (i && !r) { var A = $t(h, o).point, M = e.lineStartIndex + e.segment + 1, O = new t.Point(u.getx(M), u.gety(M)), k = $t(O, o), I = k.signedDistanceFromCamera > 0 ? k.point : ae(h, O, A, 1, o), P = ie(e.writingMode, A, I, d); if (P) return P } var L = se(v * l.getoffsetX(e.glyphStartIndex), y, g, r, p, h, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, u, a, f); if (!L) return { notEnoughRoom: !0 }; m = [L] } for (var R = 0, D = m; R < D.length; R += 1) { var N = D[R]; t.addDynamicAttributes(c, N.point, N.angle) } return {} } function ae(t, e, n, r, i) { var o = $t(t.add(t.sub(e)._unit()), i).point, a = n.sub(o); return n.add(a._mult(r / a.mag())) } function se(e, n, r, i, o, a, s, l, u, c, p, h) { var f = i ? e - n : e + n, d = f > 0 ? 1 : -1, m = 0; i && (d *= -1, m = Math.PI), d < 0 && (m += Math.PI); for (var v = d > 0 ? l + s : l + s + 1, y = o, g = o, _ = 0, x = 0, b = Math.abs(f), w = []; _ + x <= b;) { if ((v += d) < l || v >= u) return null; if (g = y, w.push(y), void 0 === (y = h[v])) { var S = new t.Point(c.getx(v), c.gety(v)), E = $t(S, p); if (E.signedDistanceFromCamera > 0) y = h[v] = E.point; else { var C = v - d; y = ae(0 === _ ? a : new t.Point(c.getx(C), c.gety(C)), S, g, b - _ + 1, p) } } _ += x, x = g.dist(y) } var T = (b - _) / x, A = y.sub(g), M = A.mult(T)._add(g); M._add(A._unit()._perp()._mult(r * d)); var O = m + Math.atan2(y.y - g.y, y.x - g.x); return w.push(M), { point: M, angle: O, path: w } } Kt.prototype.keysLength = function () { return this.boxKeys.length + this.circleKeys.length }, Kt.prototype.insert = function (t, e, n, r, i) { this._forEachCell(e, n, r, i, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(n), this.bboxes.push(r), this.bboxes.push(i) }, Kt.prototype.insertCircle = function (t, e, n, r) { this._forEachCell(e - r, n - r, e + r, n + r, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(n), this.circles.push(r) }, Kt.prototype._insertBoxCell = function (t, e, n, r, i, o) { this.boxCells[i].push(o) }, Kt.prototype._insertCircleCell = function (t, e, n, r, i, o) { this.circleCells[i].push(o) }, Kt.prototype._query = function (t, e, n, r, i, o) { if (n < 0 || t > this.width || r < 0 || e > this.height) return !i && []; var a = []; if (t <= 0 && e <= 0 && this.width <= n && this.height <= r) { if (i) return !0; for (var s = 0; s < this.boxKeys.length; s++)a.push({ key: this.boxKeys[s], x1: this.bboxes[4 * s], y1: this.bboxes[4 * s + 1], x2: this.bboxes[4 * s + 2], y2: this.bboxes[4 * s + 3] }); for (var l = 0; l < this.circleKeys.length; l++) { var u = this.circles[3 * l], c = this.circles[3 * l + 1], p = this.circles[3 * l + 2]; a.push({ key: this.circleKeys[l], x1: u - p, y1: c - p, x2: u + p, y2: c + p }) } return o ? a.filter(o) : a } return this._forEachCell(t, e, n, r, this._queryCell, a, { hitTest: i, seenUids: { box: {}, circle: {} } }, o), i ? a.length > 0 : a }, Kt.prototype._queryCircle = function (t, e, n, r, i) { var o = t - n, a = t + n, s = e - n, l = e + n; if (a < 0 || o > this.width || l < 0 || s > this.height) return !r && []; var u = []; return this._forEachCell(o, s, a, l, this._queryCellCircle, u, { hitTest: r, circle: { x: t, y: e, radius: n }, seenUids: { box: {}, circle: {} } }, i), r ? u.length > 0 : u }, Kt.prototype.query = function (t, e, n, r, i) { return this._query(t, e, n, r, !1, i) }, Kt.prototype.hitTest = function (t, e, n, r, i) { return this._query(t, e, n, r, !0, i) }, Kt.prototype.hitTestCircle = function (t, e, n, r) { return this._queryCircle(t, e, n, !0, r) }, Kt.prototype._queryCell = function (t, e, n, r, i, o, a, s) { var l = a.seenUids, u = this.boxCells[i]; if (null !== u) for (var c = this.bboxes, p = 0, h = u; p < h.length; p += 1) { var f = h[p]; if (!l.box[f]) { l.box[f] = !0; var d = 4 * f; if (t <= c[d + 2] && e <= c[d + 3] && n >= c[d + 0] && r >= c[d + 1] && (!s || s(this.boxKeys[f]))) { if (a.hitTest) return o.push(!0), !0; o.push({ key: this.boxKeys[f], x1: c[d], y1: c[d + 1], x2: c[d + 2], y2: c[d + 3] }) } } } var m = this.circleCells[i]; if (null !== m) for (var v = this.circles, y = 0, g = m; y < g.length; y += 1) { var _ = g[y]; if (!l.circle[_]) { l.circle[_] = !0; var x = 3 * _; if (this._circleAndRectCollide(v[x], v[x + 1], v[x + 2], t, e, n, r) && (!s || s(this.circleKeys[_]))) { if (a.hitTest) return o.push(!0), !0; var b = v[x], w = v[x + 1], S = v[x + 2]; o.push({ key: this.circleKeys[_], x1: b - S, y1: w - S, x2: b + S, y2: w + S }) } } } }, Kt.prototype._queryCellCircle = function (t, e, n, r, i, o, a, s) { var l = a.circle, u = a.seenUids, c = this.boxCells[i]; if (null !== c) for (var p = this.bboxes, h = 0, f = c; h < f.length; h += 1) { var d = f[h]; if (!u.box[d]) { u.box[d] = !0; var m = 4 * d; if (this._circleAndRectCollide(l.x, l.y, l.radius, p[m + 0], p[m + 1], p[m + 2], p[m + 3]) && (!s || s(this.boxKeys[d]))) return o.push(!0), !0 } } var v = this.circleCells[i]; if (null !== v) for (var y = this.circles, g = 0, _ = v; g < _.length; g += 1) { var x = _[g]; if (!u.circle[x]) { u.circle[x] = !0; var b = 3 * x; if (this._circlesCollide(y[b], y[b + 1], y[b + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[x]))) return o.push(!0), !0 } } }, Kt.prototype._forEachCell = function (t, e, n, r, i, o, a, s) { for (var l = this._convertToXCellCoord(t), u = this._convertToYCellCoord(e), c = this._convertToXCellCoord(n), p = this._convertToYCellCoord(r), h = l; h <= c; h++)for (var f = u; f <= p; f++)if (i.call(this, t, e, n, r, this.xCellCount * f + h, o, a, s)) return }, Kt.prototype._convertToXCellCoord = function (t) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))) }, Kt.prototype._convertToYCellCoord = function (t) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))) }, Kt.prototype._circlesCollide = function (t, e, n, r, i, o) { var a = r - t, s = i - e, l = n + o; return l * l > a * a + s * s }, Kt.prototype._circleAndRectCollide = function (t, e, n, r, i, o, a) { var s = (o - r) / 2, l = Math.abs(t - (r + s)); if (l > s + n) return !1; var u = (a - i) / 2, c = Math.abs(e - (i + u)); if (c > u + n) return !1; if (l <= s || c <= u) return !0; var p = l - s, h = c - u; return p * p + h * h <= n * n }; var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function ue(t, e) { for (var n = 0; n < t; n++) { var r = e.length; e.resize(r + 4), e.float32.set(le, 3 * r) } } function ce(t, e, n) { var r = e[0], i = e[1]; return t[0] = n[0] * r + n[4] * i + n[12], t[1] = n[1] * r + n[5] * i + n[13], t[3] = n[3] * r + n[7] * i + n[15], t } var pe = function (t, e, n) { void 0 === e && (e = new Kt(t.width + 200, t.height + 200, 25)), void 0 === n && (n = new Kt(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = n, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200 }; function he(e, n, r) { return n * (t.EXTENT / (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ))) } pe.prototype.placeCollisionBox = function (t, e, n, r, i) { var o = this.projectAndGetPerspectiveRatio(r, t.anchorPointX, t.anchorPointY), a = n * o.perspectiveRatio, s = t.x1 * a + o.point.x, l = t.y1 * a + o.point.y, u = t.x2 * a + o.point.x, c = t.y2 * a + o.point.y; return !this.isInsideGrid(s, l, u, c) || !e && this.grid.hitTest(s, l, u, c, i) ? { box: [], offscreen: !1 } : { box: [s, l, u, c], offscreen: this.isOffscreen(s, l, u, c) } }, pe.prototype.placeCollisionCircles = function (e, n, r, i, o, a, s, l, u, c, p, h, f) { var d = [], m = new t.Point(n.anchorX, n.anchorY), v = $t(m, a), y = te(this.transform.cameraToCenterDistance, v.signedDistanceFromCamera), g = (c ? o / y : o * y) / t.ONE_EM, _ = $t(m, s).point, x = re(g, i, n.lineOffsetX * g, n.lineOffsetY * g, !1, _, m, n, r, s, {}), b = !1, w = !1, S = !0; if (x) { for (var E = .5 * h * y + f, C = new t.Point(-100, -100), T = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), A = new Yt, M = x.first, O = x.last, k = [], I = M.path.length - 1; I >= 1; I--)k.push(M.path[I]); for (var P = 1; P < O.path.length; P++)k.push(O.path[P]); var L = 2.5 * E; if (l) { var R = k.map((function (t) { return $t(t, l) })); k = R.some((function (t) { return t.signedDistanceFromCamera <= 0 })) ? [] : R.map((function (t) { return t.point })) } var D = []; if (k.length > 0) { for (var N = k[0].clone(), z = k[0].clone(), F = 1; F < k.length; F++)N.x = Math.min(N.x, k[F].x), N.y = Math.min(N.y, k[F].y), z.x = Math.max(z.x, k[F].x), z.y = Math.max(z.y, k[F].y); D = N.x >= C.x && z.x <= T.x && N.y >= C.y && z.y <= T.y ? [k] : z.x < C.x || N.x > T.x || z.y < C.y || N.y > T.y ? [] : t.clipLine([k], C.x, C.y, T.x, T.y) } for (var B = 0, j = D; B < j.length; B += 1) { var U; A.reset(j[B], .25 * E), U = A.length <= .5 * E ? 1 : Math.ceil(A.paddedLength / L) + 1; for (var V = 0; V < U; V++) { var G = V / Math.max(U - 1, 1), H = A.lerp(G), W = H.x + 100, X = H.y + 100; d.push(W, X, E, 0); var q = W - E, Z = X - E, Y = W + E, K = X + E; if (S = S && this.isOffscreen(q, Z, Y, K), w = w || this.isInsideGrid(q, Z, Y, K), !e && this.grid.hitTestCircle(W, X, E, p) && (b = !0, !u)) return { circles: [], offscreen: !1, collisionDetected: b } } } } return { circles: !u && b || !w ? [] : d, offscreen: S, collisionDetected: b } }, pe.prototype.queryRenderedSymbols = function (e) { if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {}; for (var n = [], r = 1 / 0, i = 1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e; s < l.length; s += 1) { var u = l[s], c = new t.Point(u.x + 100, u.y + 100); r = Math.min(r, c.x), i = Math.min(i, c.y), o = Math.max(o, c.x), a = Math.max(a, c.y), n.push(c) } for (var p = {}, h = {}, f = 0, d = this.grid.query(r, i, o, a).concat(this.ignoredGrid.query(r, i, o, a)); f < d.length; f += 1) { var m = d[f], v = m.key; if (void 0 === p[v.bucketInstanceId] && (p[v.bucketInstanceId] = {}), !p[v.bucketInstanceId][v.featureIndex]) { var y = [new t.Point(m.x1, m.y1), new t.Point(m.x2, m.y1), new t.Point(m.x2, m.y2), new t.Point(m.x1, m.y2)]; t.polygonIntersectsPolygon(n, y) && (p[v.bucketInstanceId][v.featureIndex] = !0, void 0 === h[v.bucketInstanceId] && (h[v.bucketInstanceId] = []), h[v.bucketInstanceId].push(v.featureIndex)) } } return h }, pe.prototype.insertCollisionBox = function (t, e, n, r, i) { (e ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: n, featureIndex: r, collisionGroupID: i }, t[0], t[1], t[2], t[3]) }, pe.prototype.insertCollisionCircles = function (t, e, n, r, i) { for (var o = e ? this.ignoredGrid : this.grid, a = { bucketInstanceId: n, featureIndex: r, collisionGroupID: i }, s = 0; s < t.length; s += 4)o.insertCircle(a, t[s], t[s + 1], t[s + 2]) }, pe.prototype.projectAndGetPerspectiveRatio = function (e, n, r) { var i = [n, r, 0, 1]; return ce(i, i, e), { point: new t.Point((i[0] / i[3] + 1) / 2 * this.transform.width + 100, (-i[1] / i[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: .5 + this.transform.cameraToCenterDistance / i[3] * .5 } }, pe.prototype.isOffscreen = function (t, e, n, r) { return n < 100 || t >= this.screenRightBoundary || r < 100 || e > this.screenBottomBoundary }, pe.prototype.isInsideGrid = function (t, e, n, r) { return n >= 0 && t < this.gridRightBoundary && r >= 0 && e < this.gridBottomBoundary }, pe.prototype.getViewportMatrix = function () { var e = t.identity([]); return t.translate(e, e, [-100, -100, 0]), e }; var fe = function (t, e, n, r) { this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : r && n ? 1 : 0, this.placed = n }; fe.prototype.isHidden = function () { return 0 === this.opacity && !this.placed }; var de = function (t, e, n, r, i) { this.text = new fe(t ? t.text : null, e, n, i), this.icon = new fe(t ? t.icon : null, e, r, i) }; de.prototype.isHidden = function () { return this.text.isHidden() && this.icon.isHidden() }; var me = function (t, e, n) { this.text = t, this.icon = e, this.skipFade = n }, ve = function () { this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [] }, ye = function (t, e, n, r, i) { this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = n, this.bucketIndex = r, this.tileID = i }, ge = function (t) { this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {} }; function _e(e, n, r, i, o) { var a = t.getAnchorAlignment(e), s = -(a.horizontalAlign - .5) * n, l = -(a.verticalAlign - .5) * r, u = t.evaluateVariableOffset(e, i); return new t.Point(s + u[0] * o, l + u[1] * o) } function xe(e, n, r, i, o, a) { var s = e.x1, l = e.x2, u = e.y1, c = e.y2, p = e.anchorPointX, h = e.anchorPointY, f = new t.Point(n, r); return i && f._rotate(o ? a : -a), { x1: s + f.x, y1: u + f.y, x2: l + f.x, y2: c + f.y, anchorPointX: p, anchorPointY: h } } ge.prototype.get = function (t) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[t]) { var e = ++this.maxGroupID; this.collisionGroups[t] = { ID: e, predicate: function (t) { return t.collisionGroupID === e } } } return this.collisionGroups[t] }; var be = function (t, e, n, r) { this.transform = t.clone(), this.collisionIndex = new pe(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new ge(n), this.collisionCircleArrays = {}, this.prevPlacement = r, r && (r.prevPlacement = void 0), this.placedOrientations = {} }; function we(t, e, n, r, i) { t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0) } be.prototype.getBucketParts = function (e, n, r, i) { var o = r.getBucket(n), a = r.latestFeatureIndex; if (o && a && n.id === o.layerIds[0]) { var s = r.collisionBoxArray, l = o.layers[0].layout, u = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ), c = r.tileSize / t.EXTENT, p = this.transform.calculatePosMatrix(r.tileID.toUnwrapped()), h = "map" === l.get("text-pitch-alignment"), f = "map" === l.get("text-rotation-alignment"), d = he(r, 1, this.transform.zoom), m = Qt(p, h, f, this.transform, d), v = null; if (h) { var y = Jt(p, h, f, this.transform, d); v = t.multiply([], this.transform.labelPlaneMatrix, y) } this.retainedQueryData[o.bucketInstanceId] = new ye(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, r.tileID); var g = { bucket: o, layout: l, posMatrix: p, textLabelPlaneMatrix: m, labelToScreenMatrix: v, scale: u, textPixelRatio: c, holdingForFade: r.holdingForFade(), collisionBoxArray: s, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(o.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) }; if (i) for (var _ = 0, x = o.sortKeyRanges; _ < x.length; _ += 1) { var b = x[_]; e.push({ sortKey: b.sortKey, symbolInstanceStart: b.symbolInstanceStart, symbolInstanceEnd: b.symbolInstanceEnd, parameters: g }) } else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: g }) } }, be.prototype.attemptAnchorPlacement = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d) { var m, v = [p.textOffset0, p.textOffset1], y = _e(t, n, r, v, i), g = this.collisionIndex.placeCollisionBox(xe(e, y.x, y.y, o, a, this.transform.angle), c, s, l, u.predicate); if (!d || 0 !== this.collisionIndex.placeCollisionBox(xe(d, y.x, y.y, o, a, this.transform.angle), c, s, l, u.predicate).box.length) return g.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[p.crossTileID] && this.prevPlacement.placements[p.crossTileID] && this.prevPlacement.placements[p.crossTileID].text && (m = this.prevPlacement.variableOffsets[p.crossTileID].anchor), this.variableOffsets[p.crossTileID] = { textOffset: v, width: n, height: r, anchor: t, textBoxScale: i, prevAnchor: m }, this.markUsedJustification(h, t, p, f), h.allowVerticalPlacement && (this.markUsedOrientation(h, f, p), this.placedOrientations[p.crossTileID] = f), { shift: y, placedGlyphBoxes: g }) : void 0 }, be.prototype.placeLayerBucketPart = function (e, n, r) { var i = this, o = e.parameters, a = o.bucket, s = o.layout, l = o.posMatrix, u = o.textLabelPlaneMatrix, c = o.labelToScreenMatrix, p = o.textPixelRatio, h = o.holdingForFade, f = o.collisionBoxArray, d = o.partiallyEvaluatedTextSize, m = o.collisionGroup, v = s.get("text-optional"), y = s.get("icon-optional"), g = s.get("text-allow-overlap"), _ = s.get("icon-allow-overlap"), x = "map" === s.get("text-rotation-alignment"), b = "map" === s.get("text-pitch-alignment"), w = "none" !== s.get("icon-text-fit"), S = "viewport-y" === s.get("symbol-z-order"), E = g && (_ || !a.hasIconData() || y), C = _ && (g || !a.hasTextData() || v); !a.collisionArrays && f && a.deserializeCollisionBoxes(f); var T = function (e, o) { if (!n[e.crossTileID]) if (h) i.placements[e.crossTileID] = new me(!1, !1, !1); else { var f, S = !1, T = !1, A = !0, M = null, O = { box: null, offscreen: null }, k = { box: null, offscreen: null }, I = null, P = null, L = 0, R = 0, D = 0; o.textFeatureIndex ? L = o.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), o.verticalTextFeatureIndex && (R = o.verticalTextFeatureIndex); var N = o.textBox; if (N) { var z = function (n) { var r = t.WritingMode.horizontal; if (a.allowVerticalPlacement && !n && i.prevPlacement) { var o = i.prevPlacement.placedOrientations[e.crossTileID]; o && (i.placedOrientations[e.crossTileID] = o, i.markUsedOrientation(a, r = o, e)) } return r }, F = function (n, r) { if (a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && o.verticalTextBox) for (var i = 0, s = a.writingModes; i < s.length && (s[i] === t.WritingMode.vertical ? (O = r(), k = O) : O = n(), !(O && O.box && O.box.length)); i += 1); else O = n() }; if (s.get("text-variable-anchor")) { var B = s.get("text-variable-anchor"); if (i.prevPlacement && i.prevPlacement.variableOffsets[e.crossTileID]) { var j = i.prevPlacement.variableOffsets[e.crossTileID]; B.indexOf(j.anchor) > 0 && (B = B.filter((function (t) { return t !== j.anchor }))).unshift(j.anchor) } var U = function (t, n, r) { for (var o = t.x2 - t.x1, s = t.y2 - t.y1, u = e.textBoxScale, c = w && !_ ? n : null, h = { box: [], offscreen: !1 }, f = g ? 2 * B.length : B.length, d = 0; d < f; ++d) { var v = i.attemptAnchorPlacement(B[d % B.length], t, o, s, u, x, b, p, l, m, d >= B.length, e, a, r, c); if (v && (h = v.placedGlyphBoxes) && h.box && h.box.length) { S = !0, M = v.shift; break } } return h }; F((function () { return U(N, o.iconBox, t.WritingMode.horizontal) }), (function () { var n = o.verticalTextBox; return a.allowVerticalPlacement && !(O && O.box && O.box.length) && e.numVerticalGlyphVertices > 0 && n ? U(n, o.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null } })), O && (S = O.box, A = O.offscreen); var V = z(O && O.box); if (!S && i.prevPlacement) { var G = i.prevPlacement.variableOffsets[e.crossTileID]; G && (i.variableOffsets[e.crossTileID] = G, i.markUsedJustification(a, G.anchor, e, V)) } } else { var H = function (t, n) { var r = i.collisionIndex.placeCollisionBox(t, g, p, l, m.predicate); return r && r.box && r.box.length && (i.markUsedOrientation(a, n, e), i.placedOrientations[e.crossTileID] = n), r }; F((function () { return H(N, t.WritingMode.horizontal) }), (function () { var n = o.verticalTextBox; return a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && n ? H(n, t.WritingMode.vertical) : { box: null, offscreen: null } })), z(O && O.box && O.box.length) } } if (S = (f = O) && f.box && f.box.length > 0, A = f && f.offscreen, e.useRuntimeCollisionCircles) { var W = a.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex), X = t.evaluateSizeForFeature(a.textSizeData, d, W), q = s.get("text-padding"); I = i.collisionIndex.placeCollisionCircles(g, W, a.lineVertexArray, a.glyphOffsetArray, X, l, u, c, r, b, m.predicate, e.collisionCircleDiameter, q), S = g || I.circles.length > 0 && !I.collisionDetected, A = A && I.offscreen } if (o.iconFeatureIndex && (D = o.iconFeatureIndex), o.iconBox) { var Z = function (t) { var e = w && M ? xe(t, M.x, M.y, x, b, i.transform.angle) : t; return i.collisionIndex.placeCollisionBox(e, _, p, l, m.predicate) }; T = k && k.box && k.box.length && o.verticalIconBox ? (P = Z(o.verticalIconBox)).box.length > 0 : (P = Z(o.iconBox)).box.length > 0, A = A && P.offscreen } var Y = v || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices, K = y || 0 === e.numIconVertices; if (Y || K ? K ? Y || (T = T && S) : S = T && S : T = S = T && S, S && f && f.box && i.collisionIndex.insertCollisionBox(f.box, s.get("text-ignore-placement"), a.bucketInstanceId, k && k.box && R ? R : L, m.ID), T && P && i.collisionIndex.insertCollisionBox(P.box, s.get("icon-ignore-placement"), a.bucketInstanceId, D, m.ID), I && (S && i.collisionIndex.insertCollisionCircles(I.circles, s.get("text-ignore-placement"), a.bucketInstanceId, L, m.ID), r)) { var Q = a.bucketInstanceId, J = i.collisionCircleArrays[Q]; void 0 === J && (J = i.collisionCircleArrays[Q] = new ve); for (var $ = 0; $ < I.circles.length; $ += 4)J.circles.push(I.circles[$ + 0]), J.circles.push(I.circles[$ + 1]), J.circles.push(I.circles[$ + 2]), J.circles.push(I.collisionDetected ? 1 : 0) } i.placements[e.crossTileID] = new me(S || E, T || C, A || a.justReloaded), n[e.crossTileID] = !0 } }; if (S) for (var A = a.getSortedSymbolIndexes(this.transform.angle), M = A.length - 1; M >= 0; --M) { var O = A[M]; T(a.symbolInstances.get(O), a.collisionArrays[O]) } else for (var k = e.symbolInstanceStart; k < e.symbolInstanceEnd; k++)T(a.symbolInstances.get(k), a.collisionArrays[k]); if (r && a.bucketInstanceId in this.collisionCircleArrays) { var I = this.collisionCircleArrays[a.bucketInstanceId]; t.invert(I.invProjMatrix, l), I.viewportMatrix = this.collisionIndex.getViewportMatrix() } a.justReloaded = !1 }, be.prototype.markUsedJustification = function (e, n, r, i) { var o; o = i === t.WritingMode.vertical ? r.verticalPlacedTextSymbolIndex : { left: r.leftJustifiedTextSymbolIndex, center: r.centerJustifiedTextSymbolIndex, right: r.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(n)]; for (var a = 0, s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex]; a < s.length; a += 1) { var l = s[a]; l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = o >= 0 && l !== o ? 0 : r.crossTileID) } }, be.prototype.markUsedOrientation = function (e, n, r) { for (var i = n === t.WritingMode.horizontal || n === t.WritingMode.horizontalOnly ? n : 0, o = n === t.WritingMode.vertical ? n : 0, a = 0, s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex]; a < s.length; a += 1)e.text.placedSymbolArray.get(s[a]).placedOrientation = i; r.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = o) }, be.prototype.commit = function (t) { this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom; var e = this.prevPlacement, n = !1; this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0; var r = e ? e.symbolFadeChange(t) : 1, i = e ? e.opacities : {}, o = e ? e.variableOffsets : {}, a = e ? e.placedOrientations : {}; for (var s in this.placements) { var l = this.placements[s], u = i[s]; u ? (this.opacities[s] = new de(u, r, l.text, l.icon), n = n || l.text !== u.text.placed || l.icon !== u.icon.placed) : (this.opacities[s] = new de(null, r, l.text, l.icon, l.skipFade), n = n || l.text || l.icon) } for (var c in i) { var p = i[c]; if (!this.opacities[c]) { var h = new de(p, r, !1, !1); h.isHidden() || (this.opacities[c] = h, n = n || p.text.placed || p.icon.placed) } } for (var f in o) this.variableOffsets[f] || !this.opacities[f] || this.opacities[f].isHidden() || (this.variableOffsets[f] = o[f]); for (var d in a) this.placedOrientations[d] || !this.opacities[d] || this.opacities[d].isHidden() || (this.placedOrientations[d] = a[d]); n ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t) }, be.prototype.updateLayerOpacities = function (t, e) { for (var n = {}, r = 0, i = e; r < i.length; r += 1) { var o = i[r], a = o.getBucket(t); a && o.latestFeatureIndex && t.id === a.layerIds[0] && this.updateBucketOpacities(a, n, o.collisionBoxArray) } }, be.prototype.updateBucketOpacities = function (e, n, r) { var i = this; e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear(); var o = e.layers[0].layout, a = new de(null, 0, !1, !1, !0), s = o.get("text-allow-overlap"), l = o.get("icon-allow-overlap"), u = o.get("text-variable-anchor"), c = "map" === o.get("text-rotation-alignment"), p = "map" === o.get("text-pitch-alignment"), h = "none" !== o.get("icon-text-fit"), f = new de(null, 0, s && (l || !e.hasIconData() || o.get("icon-optional")), l && (s || !e.hasTextData() || o.get("text-optional")), !0); !e.collisionArrays && r && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(r); for (var d = function (t, e, n) { for (var r = 0; r < e / 4; r++)t.opacityVertexArray.emplaceBack(n) }, m = function (r) { var o = e.symbolInstances.get(r), s = o.numHorizontalGlyphVertices, l = o.numVerticalGlyphVertices, m = o.crossTileID, v = i.opacities[m]; n[m] ? v = a : v || (i.opacities[m] = v = f), n[m] = !0; var y = o.numIconVertices > 0, g = i.placedOrientations[o.crossTileID], _ = g === t.WritingMode.vertical, x = g === t.WritingMode.horizontal || g === t.WritingMode.horizontalOnly; if (s > 0 || l > 0) { var b = ke(v.text); d(e.text, s, _ ? Ie : b), d(e.text, l, x ? Ie : b); var w = v.text.isHidden();[o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach((function (t) { t >= 0 && (e.text.placedSymbolArray.get(t).hidden = w || _ ? 1 : 0) })), o.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).hidden = w || x ? 1 : 0); var S = i.variableOffsets[o.crossTileID]; S && i.markUsedJustification(e, S.anchor, o, g); var E = i.placedOrientations[o.crossTileID]; E && (i.markUsedJustification(e, "left", o, E), i.markUsedOrientation(e, E, o)) } if (y) { var C = ke(v.icon), T = !(h && o.verticalPlacedIconSymbolIndex && _); o.placedIconSymbolIndex >= 0 && (d(e.icon, o.numIconVertices, T ? C : Ie), e.icon.placedSymbolArray.get(o.placedIconSymbolIndex).hidden = v.icon.isHidden()), o.verticalPlacedIconSymbolIndex >= 0 && (d(e.icon, o.numVerticalIconVertices, T ? Ie : C), e.icon.placedSymbolArray.get(o.verticalPlacedIconSymbolIndex).hidden = v.icon.isHidden()) } if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) { var A = e.collisionArrays[r]; if (A) { var M = new t.Point(0, 0); if (A.textBox || A.verticalTextBox) { var O = !0; if (u) { var k = i.variableOffsets[m]; k ? (M = _e(k.anchor, k.width, k.height, k.textOffset, k.textBoxScale), c && M._rotate(p ? i.transform.angle : -i.transform.angle)) : O = !1 } A.textBox && we(e.textCollisionBox.collisionVertexArray, v.text.placed, !O || _, M.x, M.y), A.verticalTextBox && we(e.textCollisionBox.collisionVertexArray, v.text.placed, !O || x, M.x, M.y) } var I = Boolean(!x && A.verticalIconBox); A.iconBox && we(e.iconCollisionBox.collisionVertexArray, v.icon.placed, I, h ? M.x : 0, h ? M.y : 0), A.verticalIconBox && we(e.iconCollisionBox.collisionVertexArray, v.icon.placed, !I, h ? M.x : 0, h ? M.y : 0) } } }, v = 0; v < e.symbolInstances.length; v++)m(v); if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) { var y = this.collisionCircleArrays[e.bucketInstanceId]; e.placementInvProjMatrix = y.invProjMatrix, e.placementViewportMatrix = y.viewportMatrix, e.collisionCircleArray = y.circles, delete this.collisionCircleArrays[e.bucketInstanceId] } }, be.prototype.symbolFadeChange = function (t) { return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment }, be.prototype.zoomAdjustment = function (t) { return Math.max(0, (this.transform.zoom - t) / 1.5) }, be.prototype.hasTransitions = function (t) { return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration }, be.prototype.stillRecent = function (t, e) { var n = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1; return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * n > t }, be.prototype.setStale = function () { this.stale = !0 }; var Se = Math.pow(2, 25), Ee = Math.pow(2, 24), Ce = Math.pow(2, 17), Te = Math.pow(2, 16), Ae = Math.pow(2, 9), Me = Math.pow(2, 8), Oe = Math.pow(2, 1); function ke(t) { if (0 === t.opacity && !t.placed) return 0; if (1 === t.opacity && t.placed) return 4294967295; var e = t.placed ? 1 : 0, n = Math.floor(127 * t.opacity); return n * Se + e * Ee + n * Ce + e * Te + n * Ae + e * Me + n * Oe + e } var Ie = 0, Pe = function (t) { this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [] }; Pe.prototype.continuePlacement = function (t, e, n, r, i) { for (var o = this._bucketParts; this._currentTileIndex < t.length;)if (e.getBucketParts(o, r, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, i()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o.sort((function (t, e) { return t.sortKey - e.sortKey }))); this._currentPartIndex < o.length;)if (e.placeLayerBucketPart(o[this._currentPartIndex], this._seenCrossTileIDs, n), this._currentPartIndex++, i()) return !0; return !1 }; var Le = function (t, e, n, r, i, o, a) { this.placement = new be(t, i, o, a), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = r, this._done = !1 }; Le.prototype.isDone = function () { return this._done }, Le.prototype.continuePlacement = function (e, n, r) { for (var i = this, o = t.browser.now(), a = function () { var e = t.browser.now() - o; return !i._forceFullPlacement && e > 2 }; this._currentPlacementIndex >= 0;) { var s = n[e[this._currentPlacementIndex]], l = this.placement.collisionIndex.transform.zoom; if ("symbol" === s.type && (!s.minzoom || s.minzoom <= l) && (!s.maxzoom || s.maxzoom > l)) { if (this._inProgressLayer || (this._inProgressLayer = new Pe(s)), this._inProgressLayer.continuePlacement(r[s.source], this.placement, this._showCollisionBoxes, s, a)) return; delete this._inProgressLayer } this._currentPlacementIndex-- } this._done = !0 }, Le.prototype.commit = function (t) { return this.placement.commit(t), this.placement }; var Re = 512 / t.EXTENT / 2, De = function (t, e, n) { this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = n; for (var r = 0; r < e.length; r++) { var i = e.get(r), o = i.key; this.indexedSymbolInstances[o] || (this.indexedSymbolInstances[o] = []), this.indexedSymbolInstances[o].push({ crossTileID: i.crossTileID, coord: this.getScaledCoordinates(i, t) }) } }; De.prototype.getScaledCoordinates = function (e, n) { var r = Re / Math.pow(2, n.canonical.z - this.tileID.canonical.z); return { x: Math.floor((n.canonical.x * t.EXTENT + e.anchorX) * r), y: Math.floor((n.canonical.y * t.EXTENT + e.anchorY) * r) } }, De.prototype.findMatches = function (t, e, n) { for (var r = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), i = 0; i < t.length; i++) { var o = t.get(i); if (!o.crossTileID) { var a = this.indexedSymbolInstances[o.key]; if (a) for (var s = this.getScaledCoordinates(o, e), l = 0, u = a; l < u.length; l += 1) { var c = u[l]; if (Math.abs(c.coord.x - s.x) <= r && Math.abs(c.coord.y - s.y) <= r && !n[c.crossTileID]) { n[c.crossTileID] = !0, o.crossTileID = c.crossTileID; break } } } } }; var Ne = function () { this.maxCrossTileID = 0 }; Ne.prototype.generate = function () { return ++this.maxCrossTileID }; var ze = function () { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 }; ze.prototype.handleWrapJump = function (t) { var e = Math.round((t - this.lng) / 360); if (0 !== e) for (var n in this.indexes) { var r = this.indexes[n], i = {}; for (var o in r) { var a = r[o]; a.tileID = a.tileID.unwrapTo(a.tileID.wrap + e), i[a.tileID.key] = a } this.indexes[n] = i } this.lng = t }, ze.prototype.addBucket = function (t, e, n) { if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) { if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]) } for (var r = 0; r < e.symbolInstances.length; r++)e.symbolInstances.get(r).crossTileID = 0; this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {}); var i = this.usedCrossTileIDs[t.overscaledZ]; for (var o in this.indexes) { var a = this.indexes[o]; if (Number(o) > t.overscaledZ) for (var s in a) { var l = a[s]; l.tileID.isChildOf(t) && l.findMatches(e.symbolInstances, t, i) } else { var u = a[t.scaledTo(Number(o)).key]; u && u.findMatches(e.symbolInstances, t, i) } } for (var c = 0; c < e.symbolInstances.length; c++) { var p = e.symbolInstances.get(c); p.crossTileID || (p.crossTileID = n.generate(), i[p.crossTileID] = !0) } return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new De(t, e.symbolInstances, e.bucketInstanceId), !0 }, ze.prototype.removeBucketCrossTileIDs = function (t, e) { for (var n in e.indexedSymbolInstances) for (var r = 0, i = e.indexedSymbolInstances[n]; r < i.length; r += 1)delete this.usedCrossTileIDs[t][i[r].crossTileID] }, ze.prototype.removeStaleBuckets = function (t) { var e = !1; for (var n in this.indexes) { var r = this.indexes[n]; for (var i in r) t[r[i].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, r[i]), delete r[i], e = !0) } return e }; var Fe = function () { this.layerIndexes = {}, this.crossTileIDs = new Ne, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} }; Fe.prototype.addLayer = function (t, e, n) { var r = this.layerIndexes[t.id]; void 0 === r && (r = this.layerIndexes[t.id] = new ze); var i = !1, o = {}; r.handleWrapJump(n); for (var a = 0, s = e; a < s.length; a += 1) { var l = s[a], u = l.getBucket(t); u && t.id === u.layerIds[0] && (u.bucketInstanceId || (u.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(l.tileID, u, this.crossTileIDs) && (i = !0), o[u.bucketInstanceId] = !0) } return r.removeStaleBuckets(o) && (i = !0), i }, Fe.prototype.pruneUnusedLayers = function (t) { var e = {}; for (var n in t.forEach((function (t) { e[t] = !0 })), this.layerIndexes) e[n] || delete this.layerIndexes[n] }; var Be = function (e, n) { return t.emitValidationErrors(e, n && n.filter((function (t) { return "source.canvas" !== t.identifier }))) }, je = t.pick(Ut, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ue = t.pick(Ut, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ve = function () { var e = {}, n = t.styleSpec.$version; for (var r in t.styleSpec.$root) { var i, o = t.styleSpec.$root[r]; o.required && null != (i = "version" === r ? n : "array" === o.type ? [] : {}) && (e[r] = i) } return e }(), Ge = function (e) { function n(r, i) { var o = this; void 0 === i && (i = {}), e.call(this), this.map = r, this.dispatcher = new E(Ft(), this), this.imageManager = new h, this.imageManager.setEventedParent(this), this.glyphManager = new _(r._requestManager, i.localIdeographFontFamily), this.lineAtlas = new S(256, 512), this.crossTileSymbolIndex = new Fe, this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer()); var a = this; this._rtlTextPluginCallback = n.registerForPluginStateChange((function (e) { a.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e.pluginStatus, pluginURL: e.pluginURL }, (function (e, n) { if (t.triggerPluginCompletionEvent(e), n && n.every((function (t) { return t }))) for (var r in a.sourceCaches) a.sourceCaches[r].reload() })) })), this.on("data", (function (t) { if ("source" === t.dataType && "metadata" === t.sourceDataType) { var e = o.sourceCaches[t.sourceId]; if (e) { var n = e.getSource(); if (n && n.vectorLayerIds) for (var r in o._layers) { var i = o._layers[r]; i.source === n.id && o._validateLayer(i) } } } })) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.loadURL = function (e, n) { var r = this; void 0 === n && (n = {}), this.fire(new t.Event("dataloading", { dataType: "style" })); var i = "boolean" == typeof n.validate ? n.validate : !t.isMapboxURL(e); e = this.map._requestManager.normalizeStyleURL(e, n.accessToken); var o = this.map._requestManager.transformRequest(e, t.ResourceType.Style); this._request = t.getJSON(o, (function (e, n) { r._request = null, e ? r.fire(new t.ErrorEvent(e)) : n && r._load(n, i) })) }, n.prototype.loadJSON = function (e, n) { var r = this; void 0 === n && (n = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame((function () { r._request = null, r._load(e, !1 !== n.validate) })) }, n.prototype.loadEmpty = function () { this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(Ve, !1) }, n.prototype._load = function (e, n) { if (!n || !Be(this, t.validateStyle(e))) { for (var r in this._loaded = !0, this.stylesheet = e, e.sources) this.addSource(r, e.sources[r], { validate: !1 }); e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs); var i = jt(this.stylesheet.layers); this._order = i.map((function (t) { return t.id })), this._layers = {}, this._serializedLayers = {}; for (var o = 0, a = i; o < a.length; o += 1) { var s = a[o]; (s = t.createStyleLayer(s)).setEventedParent(this, { layer: { id: s.id } }), this._layers[s.id] = s, this._serializedLayers[s.id] = s.serialize() } this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load")) } }, n.prototype._loadSprite = function (e) { var n = this; this._spriteRequest = function (e, n, r) { var i, o, a, s = t.browser.devicePixelRatio > 1 ? "@2x" : "", l = t.getJSON(n.transformRequest(n.normalizeSpriteURL(e, s, ".json"), t.ResourceType.SpriteJSON), (function (t, e) { l = null, a || (a = t, i = e, c()) })), u = t.getImage(n.transformRequest(n.normalizeSpriteURL(e, s, ".png"), t.ResourceType.SpriteImage), (function (t, e) { u = null, a || (a = t, o = e, c()) })); function c() { if (a) r(a); else if (i && o) { var e = t.browser.getImageData(o), n = {}; for (var s in i) { var l = i[s], u = l.width, c = l.height, p = l.x, h = l.y, f = l.sdf, d = l.pixelRatio, m = l.stretchX, v = l.stretchY, y = l.content, g = new t.RGBAImage({ width: u, height: c }); t.RGBAImage.copy(e, g, { x: p, y: h }, { x: 0, y: 0 }, { width: u, height: c }), n[s] = { data: g, pixelRatio: d, sdf: f, stretchX: m, stretchY: v, content: y } } r(null, n) } } return { cancel: function () { l && (l.cancel(), l = null), u && (u.cancel(), u = null) } } }(e, this.map._requestManager, (function (e, r) { if (n._spriteRequest = null, e) n.fire(new t.ErrorEvent(e)); else if (r) for (var i in r) n.imageManager.addImage(i, r[i]); n.imageManager.setLoaded(!0), n._availableImages = n.imageManager.listImages(), n.dispatcher.broadcast("setImages", n._availableImages), n.fire(new t.Event("data", { dataType: "style" })) })) }, n.prototype._validateLayer = function (e) { var n = this.sourceCaches[e.source]; if (n) { var r = e.sourceLayer; if (r) { var i = n.getSource(); ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(r)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + r + '" does not exist on source "' + i.id + '" as specified by style layer "' + e.id + '"'))) } } }, n.prototype.loaded = function () { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (var t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1; return !!this.imageManager.isLoaded() }, n.prototype._serializeLayers = function (t) { for (var e = [], n = 0, r = t; n < r.length; n += 1) { var i = this._layers[r[n]]; "custom" !== i.type && e.push(i.serialize()) } return e }, n.prototype.hasTransitions = function () { if (this.light && this.light.hasTransition()) return !0; for (var t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0; for (var e in this._layers) if (this._layers[e].hasTransition()) return !0; return !1 }, n.prototype._checkLoaded = function () { if (!this._loaded) throw new Error("Style is not done loading") }, n.prototype.update = function (e) { if (this._loaded) { var n = this._changed; if (this._changed) { var r = Object.keys(this._updatedLayers), i = Object.keys(this._removedLayers); for (var o in (r.length || i.length) && this._updateWorkerLayers(r, i), this._updatedSources) { var a = this._updatedSources[o]; "reload" === a ? this._reloadSource(o) : "clear" === a && this._clearSource(o) } for (var s in this._updateTilesForChangedImages(), this._updatedPaintProps) this._layers[s].updateTransitions(e); this.light.updateTransitions(e), this._resetUpdates() } var l = {}; for (var u in this.sourceCaches) { var c = this.sourceCaches[u]; l[u] = c.used, c.used = !1 } for (var p = 0, h = this._order; p < h.length; p += 1) { var f = this._layers[h[p]]; f.recalculate(e, this._availableImages), !f.isHidden(e.zoom) && f.source && (this.sourceCaches[f.source].used = !0) } for (var d in l) { var m = this.sourceCaches[d]; l[d] !== m.used && m.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: d })) } this.light.recalculate(e), this.z = e.zoom, n && this.fire(new t.Event("data", { dataType: "style" })) } }, n.prototype._updateTilesForChangedImages = function () { var t = Object.keys(this._changedImages); if (t.length) { for (var e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t); this._changedImages = {} } }, n.prototype._updateWorkerLayers = function (t, e) { this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t), removedIds: e }) }, n.prototype._resetUpdates = function () { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {} }, n.prototype.setState = function (e) { var n = this; if (this._checkLoaded(), Be(this, t.validateStyle(e))) return !1; (e = t.clone$1(e)).layers = jt(e.layers); var r = function (e, n) { if (!e) return [{ command: Ut.setStyle, args: [n] }]; var r = []; try { if (!t.deepEqual(e.version, n.version)) return [{ command: Ut.setStyle, args: [n] }]; t.deepEqual(e.center, n.center) || r.push({ command: Ut.setCenter, args: [n.center] }), t.deepEqual(e.zoom, n.zoom) || r.push({ command: Ut.setZoom, args: [n.zoom] }), t.deepEqual(e.bearing, n.bearing) || r.push({ command: Ut.setBearing, args: [n.bearing] }), t.deepEqual(e.pitch, n.pitch) || r.push({ command: Ut.setPitch, args: [n.pitch] }), t.deepEqual(e.sprite, n.sprite) || r.push({ command: Ut.setSprite, args: [n.sprite] }), t.deepEqual(e.glyphs, n.glyphs) || r.push({ command: Ut.setGlyphs, args: [n.glyphs] }), t.deepEqual(e.transition, n.transition) || r.push({ command: Ut.setTransition, args: [n.transition] }), t.deepEqual(e.light, n.light) || r.push({ command: Ut.setLight, args: [n.light] }); var i = {}, o = []; !function (e, n, r, i) { var o; for (o in n = n || {}, e = e || {}) e.hasOwnProperty(o) && (n.hasOwnProperty(o) || Gt(o, r, i)); for (o in n) n.hasOwnProperty(o) && (e.hasOwnProperty(o) ? t.deepEqual(e[o], n[o]) || ("geojson" === e[o].type && "geojson" === n[o].type && Wt(e, n, o) ? r.push({ command: Ut.setGeoJSONSourceData, args: [o, n[o].data] }) : Ht(o, n, r, i)) : Vt(o, n, r)) }(e.sources, n.sources, o, i); var a = []; e.layers && e.layers.forEach((function (t) { i[t.source] ? r.push({ command: Ut.removeLayer, args: [t.id] }) : a.push(t) })), r = r.concat(o), function (e, n, r) { n = n || []; var i, o, a, s, l, u, c, p = (e = e || []).map(qt), h = n.map(qt), f = e.reduce(Zt, {}), d = n.reduce(Zt, {}), m = p.slice(), v = Object.create(null); for (i = 0, o = 0; i < p.length; i++)d.hasOwnProperty(a = p[i]) ? o++ : (r.push({ command: Ut.removeLayer, args: [a] }), m.splice(m.indexOf(a, o), 1)); for (i = 0, o = 0; i < h.length; i++)m[m.length - 1 - i] !== (a = h[h.length - 1 - i]) && (f.hasOwnProperty(a) ? (r.push({ command: Ut.removeLayer, args: [a] }), m.splice(m.lastIndexOf(a, m.length - o), 1)) : o++, r.push({ command: Ut.addLayer, args: [d[a], u = m[m.length - i]] }), m.splice(m.length - i, 0, a), v[a] = !0); for (i = 0; i < h.length; i++)if (s = f[a = h[i]], l = d[a], !v[a] && !t.deepEqual(s, l)) if (t.deepEqual(s.source, l.source) && t.deepEqual(s["source-layer"], l["source-layer"]) && t.deepEqual(s.type, l.type)) { for (c in Xt(s.layout, l.layout, r, a, null, Ut.setLayoutProperty), Xt(s.paint, l.paint, r, a, null, Ut.setPaintProperty), t.deepEqual(s.filter, l.filter) || r.push({ command: Ut.setFilter, args: [a, l.filter] }), t.deepEqual(s.minzoom, l.minzoom) && t.deepEqual(s.maxzoom, l.maxzoom) || r.push({ command: Ut.setLayerZoomRange, args: [a, l.minzoom, l.maxzoom] }), s) s.hasOwnProperty(c) && "layout" !== c && "paint" !== c && "filter" !== c && "metadata" !== c && "minzoom" !== c && "maxzoom" !== c && (0 === c.indexOf("paint.") ? Xt(s[c], l[c], r, a, c.slice(6), Ut.setPaintProperty) : t.deepEqual(s[c], l[c]) || r.push({ command: Ut.setLayerProperty, args: [a, c, l[c]] })); for (c in l) l.hasOwnProperty(c) && !s.hasOwnProperty(c) && "layout" !== c && "paint" !== c && "filter" !== c && "metadata" !== c && "minzoom" !== c && "maxzoom" !== c && (0 === c.indexOf("paint.") ? Xt(s[c], l[c], r, a, c.slice(6), Ut.setPaintProperty) : t.deepEqual(s[c], l[c]) || r.push({ command: Ut.setLayerProperty, args: [a, c, l[c]] })) } else r.push({ command: Ut.removeLayer, args: [a] }), u = m[m.lastIndexOf(a) + 1], r.push({ command: Ut.addLayer, args: [l, u] }) }(a, n.layers, r) } catch (t) { console.warn("Unable to compute style diff:", t), r = [{ command: Ut.setStyle, args: [n] }] } return r }(this.serialize(), e).filter((function (t) { return !(t.command in Ue) })); if (0 === r.length) return !1; var i = r.filter((function (t) { return !(t.command in je) })); if (i.length > 0) throw new Error("Unimplemented: " + i.map((function (t) { return t.command })).join(", ") + "."); return r.forEach((function (t) { "setTransition" !== t.command && n[t.command].apply(n, t.args) })), this.stylesheet = e, !0 }, n.prototype.addImage = function (e, n) { if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("An image with this name already exists."))); this.imageManager.addImage(e, n), this._afterImageUpdated(e) }, n.prototype.updateImage = function (t, e) { this.imageManager.updateImage(t, e) }, n.prototype.getImage = function (t) { return this.imageManager.getImage(t) }, n.prototype.removeImage = function (e) { if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("No image with this name exists."))); this.imageManager.removeImage(e), this._afterImageUpdated(e) }, n.prototype._afterImageUpdated = function (e) { this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" })) }, n.prototype.listImages = function () { return this._checkLoaded(), this.imageManager.listImages() }, n.prototype.addSource = function (e, n, r) { var i = this; if (void 0 === r && (r = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error("There is already a source with this ID"); if (!n.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(n).join(", ") + "."); if (!(["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e, n, null, r))) { this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0); var o = this.sourceCaches[e] = new kt(e, n, this.dispatcher); o.style = this, o.setEventedParent(this, (function () { return { isSourceLoaded: i.loaded(), source: o.serialize(), sourceId: e } })), o.onAdd(this.map), this._changed = !0 } }, n.prototype.removeSource = function (e) { if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID"); for (var n in this._layers) if (this._layers[n].source === e) return this.fire(new t.ErrorEvent(new Error('Source "' + e + '" cannot be removed while layer "' + n + '" is using it.'))); var r = this.sourceCaches[e]; delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.clearTiles(), r.onRemove && r.onRemove(this.map), this._changed = !0 }, n.prototype.setGeoJSONSourceData = function (t, e) { this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0 }, n.prototype.getSource = function (t) { return this.sourceCaches[t] && this.sourceCaches[t].getSource() }, n.prototype.addLayer = function (e, n, r) { void 0 === r && (r = {}), this._checkLoaded(); var i = e.id; if (this.getLayer(i)) this.fire(new t.ErrorEvent(new Error('Layer with id "' + i + '" already exists on this map'))); else { var o; if ("custom" === e.type) { if (Be(this, t.validateCustomStyleLayer(e))) return; o = t.createStyleLayer(e) } else { if ("object" == typeof e.source && (this.addSource(i, e.source), e = t.clone$1(e), e = t.extend(e, { source: i })), this._validate(t.validateStyle.layer, "layers." + i, e, { arrayIndex: -1 }, r)) return; o = t.createStyleLayer(e), this._validateLayer(o), o.setEventedParent(this, { layer: { id: i } }), this._serializedLayers[o.id] = o.serialize() } var a = n ? this._order.indexOf(n) : this._order.length; if (n && -1 === a) this.fire(new t.ErrorEvent(new Error('Layer with id "' + n + '" does not exist on this map.'))); else { if (this._order.splice(a, 0, i), this._layerOrderChanged = !0, this._layers[i] = o, this._removedLayers[i] && o.source && "custom" !== o.type) { var s = this._removedLayers[i]; delete this._removedLayers[i], s.type !== o.type ? this._updatedSources[o.source] = "clear" : (this._updatedSources[o.source] = "reload", this.sourceCaches[o.source].pause()) } this._updateLayer(o), o.onAdd && o.onAdd(this.map) } } }, n.prototype.moveLayer = function (e, n) { if (this._checkLoaded(), this._changed = !0, this._layers[e]) { if (e !== n) { var r = this._order.indexOf(e); this._order.splice(r, 1); var i = n ? this._order.indexOf(n) : this._order.length; n && -1 === i ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + n + '" does not exist on this map.'))) : (this._order.splice(i, 0, e), this._layerOrderChanged = !0) } } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be moved."))) }, n.prototype.removeLayer = function (e) { this._checkLoaded(); var n = this._layers[e]; if (n) { n.setEventedParent(null); var r = this._order.indexOf(e); this._order.splice(r, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = n, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], n.onRemove && n.onRemove(this.map) } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be removed."))) }, n.prototype.getLayer = function (t) { return this._layers[t] }, n.prototype.hasLayer = function (t) { return t in this._layers }, n.prototype.setLayerZoomRange = function (e, n, r) { this._checkLoaded(); var i = this.getLayer(e); i ? i.minzoom === n && i.maxzoom === r || (null != n && (i.minzoom = n), null != r && (i.maxzoom = r), this._updateLayer(i)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot have zoom extent."))) }, n.prototype.setFilter = function (e, n, r) { void 0 === r && (r = {}), this._checkLoaded(); var i = this.getLayer(e); if (i) { if (!t.deepEqual(i.filter, n)) return null == n ? (i.filter = void 0, void this._updateLayer(i)) : void (this._validate(t.validateStyle.filter, "layers." + i.id + ".filter", n, null, r) || (i.filter = t.clone$1(n), this._updateLayer(i))) } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be filtered."))) }, n.prototype.getFilter = function (e) { return t.clone$1(this.getLayer(e).filter) }, n.prototype.setLayoutProperty = function (e, n, r, i) { void 0 === i && (i = {}), this._checkLoaded(); var o = this.getLayer(e); o ? t.deepEqual(o.getLayoutProperty(n), r) || (o.setLayoutProperty(n, r, i), this._updateLayer(o)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be styled."))) }, n.prototype.getLayoutProperty = function (e, n) { var r = this.getLayer(e); if (r) return r.getLayoutProperty(n); this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style."))) }, n.prototype.setPaintProperty = function (e, n, r, i) { void 0 === i && (i = {}), this._checkLoaded(); var o = this.getLayer(e); o ? t.deepEqual(o.getPaintProperty(n), r) || (o.setPaintProperty(n, r, i) && this._updateLayer(o), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be styled."))) }, n.prototype.getPaintProperty = function (t, e) { return this.getLayer(t).getPaintProperty(e) }, n.prototype.setFeatureState = function (e, n) { this._checkLoaded(); var r = e.source, i = e.sourceLayer, o = this.sourceCaches[r]; if (void 0 !== o) { var a = o.getSource().type; "geojson" === a && i ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== a || i ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), o.setFeatureState(i, e.id, n)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + r + "' does not exist in the map's style."))) }, n.prototype.removeFeatureState = function (e, n) { this._checkLoaded(); var r = e.source, i = this.sourceCaches[r]; if (void 0 !== i) { var o = i.getSource().type, a = "vector" === o ? e.sourceLayer : void 0; "vector" !== o || a ? n && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : i.removeFeatureState(a, e.id, n) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + r + "' does not exist in the map's style."))) }, n.prototype.getFeatureState = function (e) { this._checkLoaded(); var n = e.source, r = e.sourceLayer, i = this.sourceCaches[n]; if (void 0 !== i) { if ("vector" !== i.getSource().type || r) return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), i.getFeatureState(r, e.id); this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + n + "' does not exist in the map's style."))) }, n.prototype.getTransition = function () { return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) }, n.prototype.serialize = function () { return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (function (t) { return t.serialize() })), layers: this._serializeLayers(this._order) }, (function (t) { return void 0 !== t })) }, n.prototype._updateLayer = function (t) { this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && "raster" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0 }, n.prototype._flattenAndSortRenderedFeatures = function (t) { for (var e = this, n = function (t) { return "fill-extrusion" === e._layers[t].type }, r = {}, i = [], o = this._order.length - 1; o >= 0; o--) { var a = this._order[o]; if (n(a)) { r[a] = o; for (var s = 0, l = t; s < l.length; s += 1) { var u = l[s][a]; if (u) for (var c = 0, p = u; c < p.length; c += 1)i.push(p[c]) } } } i.sort((function (t, e) { return e.intersectionZ - t.intersectionZ })); for (var h = [], f = this._order.length - 1; f >= 0; f--) { var d = this._order[f]; if (n(d)) for (var m = i.length - 1; m >= 0; m--) { var v = i[m].feature; if (r[v.layer.id] < f) break; h.push(v), i.pop() } else for (var y = 0, g = t; y < g.length; y += 1) { var _ = g[y][d]; if (_) for (var x = 0, b = _; x < b.length; x += 1)h.push(b[x].feature) } } return h }, n.prototype.queryRenderedFeatures = function (e, n, r) { n && n.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", n.filter, null, n); var i = {}; if (n && n.layers) { if (!Array.isArray(n.layers)) return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), []; for (var o = 0, a = n.layers; o < a.length; o += 1) { var s = a[o], l = this._layers[s]; if (!l) return this.fire(new t.ErrorEvent(new Error("The layer '" + s + "' does not exist in the map's style and cannot be queried for features."))), []; i[l.source] = !0 } } var u = []; for (var c in n.availableImages = this._availableImages, this.sourceCaches) n.layers && !i[c] || u.push(z(this.sourceCaches[c], this._layers, this._serializedLayers, e, n, r)); return this.placement && u.push(function (t, e, n, r, i, o, a) { for (var s = {}, l = o.queryRenderedSymbols(r), u = [], c = 0, p = Object.keys(l).map(Number); c < p.length; c += 1)u.push(a[p[c]]); u.sort(F); for (var h = function () { var n = d[f], r = n.featureIndex.lookupSymbolFeatures(l[n.bucketInstanceId], e, n.bucketIndex, n.sourceLayerIndex, i.filter, i.layers, i.availableImages, t); for (var o in r) { var a = s[o] = s[o] || [], u = r[o]; u.sort((function (t, e) { var r = n.featureSortOrder; if (r) { var i = r.indexOf(t.featureIndex); return r.indexOf(e.featureIndex) - i } return e.featureIndex - t.featureIndex })); for (var c = 0, p = u; c < p.length; c += 1)a.push(p[c]) } }, f = 0, d = u; f < d.length; f += 1)h(); var m = function (e) { s[e].forEach((function (r) { var i = r.feature, o = n[t[e].source].getFeatureState(i.layer["source-layer"], i.id); i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o })) }; for (var v in s) m(v); return s }(this._layers, this._serializedLayers, this.sourceCaches, e, n, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(u) }, n.prototype.querySourceFeatures = function (e, n) { n && n.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", n.filter, null, n); var r = this.sourceCaches[e]; return r ? function (t, e) { for (var n = t.getRenderableIds().map((function (e) { return t.getTileByID(e) })), r = [], i = {}, o = 0; o < n.length; o++) { var a = n[o], s = a.tileID.canonical.key; i[s] || (i[s] = !0, a.querySourceFeatures(r, e)) } return r }(r, n) : [] }, n.prototype.addSourceType = function (t, e, r) { return n.getSourceType(t) ? r(new Error('A source type called "' + t + '" already exists.')) : (n.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: e.workerSourceURL }, r) : r(null, null)) }, n.prototype.getLight = function () { return this.light.getLight() }, n.prototype.setLight = function (e, n) { void 0 === n && (n = {}), this._checkLoaded(); var r = this.light.getLight(), i = !1; for (var o in e) if (!t.deepEqual(e[o], r[o])) { i = !0; break } if (i) { var a = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(e, n), this.light.updateTransitions(a) } }, n.prototype._validate = function (e, n, r, i, o) { return void 0 === o && (o = {}), (!o || !1 !== o.validate) && Be(this, e.call(t.validateStyle, t.extend({ key: n, style: this.serialize(), value: r, styleSpec: t.styleSpec }, i))) }, n.prototype._remove = function () { for (var e in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) this._layers[e].setEventedParent(null); for (var n in this.sourceCaches) this.sourceCaches[n].clearTiles(), this.sourceCaches[n].setEventedParent(null); this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove() }, n.prototype._clearSource = function (t) { this.sourceCaches[t].clearTiles() }, n.prototype._reloadSource = function (t) { this.sourceCaches[t].resume(), this.sourceCaches[t].reload() }, n.prototype._updateSources = function (t) { for (var e in this.sourceCaches) this.sourceCaches[e].update(t) }, n.prototype._generateCollisionBoxes = function () { for (var t in this.sourceCaches) this._reloadSource(t) }, n.prototype._updatePlacement = function (e, n, r, i, o) { void 0 === o && (o = !1); for (var a = !1, s = !1, l = {}, u = 0, c = this._order; u < c.length; u += 1) { var p = this._layers[c[u]]; if ("symbol" === p.type) { if (!l[p.source]) { var h = this.sourceCaches[p.source]; l[p.source] = h.getRenderableIds(!0).map((function (t) { return h.getTileByID(t) })).sort((function (t, e) { return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1) })) } var f = this.crossTileSymbolIndex.addLayer(p, l[p.source], e.center.lng); a = a || f } } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o = o || this._layerOrderChanged || 0 === r) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e.zoom)) && (this.pauseablePlacement = new Le(e, this._order, o, n, r, i, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s = !0), a && this.pauseablePlacement.placement.setStale()), s || a) for (var d = 0, m = this._order; d < m.length; d += 1) { var v = this._layers[m[d]]; "symbol" === v.type && this.placement.updateLayerOpacities(v, l[v.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now()) }, n.prototype._releaseSymbolFadeTiles = function () { for (var t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles() }, n.prototype.getImages = function (t, e, n) { this.imageManager.getImages(e.icons, n), this._updateTilesForChangedImages(); var r = this.sourceCaches[e.source]; r && r.setDependencies(e.tileID.key, e.type, e.icons) }, n.prototype.getGlyphs = function (t, e, n) { this.glyphManager.getGlyphs(e.stacks, n) }, n.prototype.getResource = function (e, n, r) { return t.makeRequest(n, r) }, n }(t.Evented); Ge.getSourceType = function (t) { return D[t] }, Ge.setSourceType = function (t, e) { D[t] = e }, Ge.registerForPluginStateChange = t.registerForPluginStateChange; var He = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), We = gn("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), Xe = gn("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), qe = gn("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Ze = gn("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), Ye = gn("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Ke = gn("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), Qe = gn("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Je = gn("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), $e = gn("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), tn = gn("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), en = gn("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), nn = gn("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), rn = gn("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), on = gn("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), an = gn("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), sn = gn("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), ln = gn("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), un = gn("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), cn = gn("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), pn = gn("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), hn = gn("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), fn = gn("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), dn = gn("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), mn = gn("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), vn = gn("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), yn = gn("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"); function gn(t, e) { var n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r = e.match(/attribute ([\w]+) ([\w]+)/g), i = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = o ? o.concat(i) : i, s = {}; return { fragmentSource: t = t.replace(n, (function (t, e, n, r, i) { return s[i] = !0, "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + i + "\nvarying " + n + " " + r + " " + i + ";\n#else\nuniform " + n + " " + r + " u_" + i + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + i + "\n    " + n + " " + r + " " + i + " = u_" + i + ";\n#endif\n" })), vertexSource: e = e.replace(n, (function (t, e, n, r, i) { var o = "float" === r ? "vec2" : "vec4", a = i.match(/color/) ? "color" : o; return s[i] ? "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + i + "\nuniform lowp float u_" + i + "_t;\nattribute " + n + " " + o + " a_" + i + ";\nvarying " + n + " " + r + " " + i + ";\n#else\nuniform " + n + " " + r + " u_" + i + ";\n#endif\n" : "vec4" === a ? "\n#ifndef HAS_UNIFORM_u_" + i + "\n    " + i + " = a_" + i + ";\n#else\n    " + n + " " + r + " " + i + " = u_" + i + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + i + "\n    " + i + " = unpack_mix_" + a + "(a_" + i + ", u_" + i + "_t);\n#else\n    " + n + " " + r + " " + i + " = u_" + i + ";\n#endif\n" : "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + i + "\nuniform lowp float u_" + i + "_t;\nattribute " + n + " " + o + " a_" + i + ";\n#else\nuniform " + n + " " + r + " u_" + i + ";\n#endif\n" : "vec4" === a ? "\n#ifndef HAS_UNIFORM_u_" + i + "\n    " + n + " " + r + " " + i + " = a_" + i + ";\n#else\n    " + n + " " + r + " " + i + " = u_" + i + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + i + "\n    " + n + " " + r + " " + i + " = unpack_mix_" + a + "(a_" + i + ", u_" + i + "_t);\n#else\n    " + n + " " + r + " " + i + " = u_" + i + ";\n#endif\n" })), staticAttributes: r, staticUniforms: a } } var _n = Object.freeze({ __proto__: null, prelude: We, background: Xe, backgroundPattern: qe, circle: Ze, clippingMask: Ye, heatmap: Ke, heatmapTexture: Qe, collisionBox: Je, collisionCircle: $e, debug: tn, fill: en, fillOutline: nn, fillOutlinePattern: rn, fillPattern: on, fillExtrusion: an, fillExtrusionPattern: sn, hillshadePrepare: ln, hillshade: un, line: cn, lineGradient: pn, linePattern: hn, lineSDF: fn, raster: dn, symbolIcon: mn, symbolSDF: vn, symbolTextAndIcon: yn }), xn = function () { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null }; function bn(t) { for (var e = [], n = 0; n < t.length; n++)if (null !== t[n]) { var r = t[n].split(" "); e.push(r.pop()) } return e } xn.prototype.bind = function (t, e, n, r, i, o, a, s) { this.context = t; for (var l = this.boundPaintVertexBuffers.length !== r.length, u = 0; !l && u < r.length; u++)this.boundPaintVertexBuffers[u] !== r[u] && (l = !0); t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === n && !l && this.boundIndexBuffer === i && this.boundVertexOffset === o && this.boundDynamicVertexBuffer === a && this.boundDynamicVertexBuffer2 === s ? (t.bindVertexArrayOES.set(this.vao), a && a.bind(), i && i.dynamicDraw && i.bind(), s && s.bind()) : this.freshBind(e, n, r, i, o, a, s) }, xn.prototype.freshBind = function (t, e, n, r, i, o, a) { var s, l = t.numAttributes, u = this.context, c = u.gl; if (u.extVertexArrayObject) this.vao && this.destroy(), this.vao = u.extVertexArrayObject.createVertexArrayOES(), u.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = r, this.boundVertexOffset = i, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = a; else { s = u.currentNumAttributes || 0; for (var p = l; p < s; p++)c.disableVertexAttribArray(p) } e.enableAttributes(c, t); for (var h = 0, f = n; h < f.length; h += 1)f[h].enableAttributes(c, t); o && o.enableAttributes(c, t), a && a.enableAttributes(c, t), e.bind(), e.setVertexAttribPointers(c, t, i); for (var d = 0, m = n; d < m.length; d += 1) { var v = m[d]; v.bind(), v.setVertexAttribPointers(c, t, i) } o && (o.bind(), o.setVertexAttribPointers(c, t, i)), r && r.bind(), a && (a.bind(), a.setVertexAttribPointers(c, t, i)), u.currentNumAttributes = l }, xn.prototype.destroy = function () { this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null) }; var wn = function (t, e, n, r, i, o) { var a = t.gl; this.program = a.createProgram(); for (var s = bn(n.staticAttributes), l = r ? r.getBinderAttributes() : [], u = s.concat(l), c = n.staticUniforms ? bn(n.staticUniforms) : [], p = r ? r.getBinderUniforms() : [], h = [], f = 0, d = c.concat(p); f < d.length; f += 1) { var m = d[f]; h.indexOf(m) < 0 && h.push(m) } var v = r ? r.defines() : []; o && v.push("#define OVERDRAW_INSPECTOR;"); var y = v.concat(We.fragmentSource, n.fragmentSource).join("\n"), g = v.concat(We.vertexSource, n.vertexSource).join("\n"), _ = a.createShader(a.FRAGMENT_SHADER); if (a.isContextLost()) this.failedToCreate = !0; else { a.shaderSource(_, y), a.compileShader(_), a.attachShader(this.program, _); var x = a.createShader(a.VERTEX_SHADER); if (a.isContextLost()) this.failedToCreate = !0; else { a.shaderSource(x, g), a.compileShader(x), a.attachShader(this.program, x), this.attributes = {}; var b = {}; this.numAttributes = u.length; for (var w = 0; w < this.numAttributes; w++)u[w] && (a.bindAttribLocation(this.program, w, u[w]), this.attributes[u[w]] = w); a.linkProgram(this.program), a.deleteShader(x), a.deleteShader(_); for (var S = 0; S < h.length; S++) { var E = h[S]; if (E && !b[E]) { var C = a.getUniformLocation(this.program, E); C && (b[E] = C) } } this.fixedUniforms = i(t, b), this.binderUniforms = r ? r.getUniforms(t, b) : [] } } }; function Sn(t, e, n) { var r = 1 / he(n, 1, e.transform.tileZoom), i = Math.pow(2, n.tileID.overscaledZ), o = n.tileSize * Math.pow(2, e.transform.tileZoom) / i, a = o * (n.tileID.canonical.x + n.tileID.wrap * i), s = o * n.tileID.canonical.y; return { u_image: 0, u_texsize: n.imageAtlasTexture.size, u_scale: [r, t.fromScale, t.toScale], u_fade: t.t, u_pixel_coord_upper: [a >> 16, s >> 16], u_pixel_coord_lower: [65535 & a, 65535 & s] } } wn.prototype.draw = function (t, e, n, r, i, o, a, s, l, u, c, p, h, f, d, m) { var v, y = t.gl; if (!this.failedToCreate) { for (var g in t.program.set(this.program), t.setDepthMode(n), t.setStencilMode(r), t.setColorMode(i), t.setCullFace(o), this.fixedUniforms) this.fixedUniforms[g].set(a[g]); f && f.setUniforms(t, this.binderUniforms, p, { zoom: h }); for (var _ = (v = {}, v[y.LINES] = 2, v[y.TRIANGLES] = 3, v[y.LINE_STRIP] = 1, v)[e], x = 0, b = c.get(); x < b.length; x += 1) { var w = b[x], S = w.vaos || (w.vaos = {}); (S[s] || (S[s] = new xn)).bind(t, this, l, f ? f.getPaintVertexBuffers() : [], u, w.vertexOffset, d, m), y.drawElements(e, w.primitiveLength * _, y.UNSIGNED_SHORT, w.primitiveOffset * _ * 2) } } }; var En = function (e, n, r, i) { var o = n.style.light, a = o.properties.get("position"), s = [a.x, a.y, a.z], l = t.create$1(); "viewport" === o.properties.get("anchor") && t.fromRotation(l, -n.transform.angle), t.transformMat3(s, s, l); var u = o.properties.get("color"); return { u_matrix: e, u_lightpos: s, u_lightintensity: o.properties.get("intensity"), u_lightcolor: [u.r, u.g, u.b], u_vertical_gradient: +r, u_opacity: i } }, Cn = function (e, n, r, i, o, a, s) { return t.extend(En(e, n, r, i), Sn(a, n, s), { u_height_factor: -Math.pow(2, o.overscaledZ) / s.tileSize / 8 }) }, Tn = function (t) { return { u_matrix: t } }, An = function (e, n, r, i) { return t.extend(Tn(e), Sn(r, n, i)) }, Mn = function (t, e) { return { u_matrix: t, u_world: e } }, On = function (e, n, r, i, o) { return t.extend(An(e, n, r, i), { u_world: o }) }, kn = function (e, n, r, i) { var o, a, s = e.transform; if ("map" === i.paint.get("circle-pitch-alignment")) { var l = he(r, 1, s.zoom); o = !0, a = [l, l] } else o = !1, a = s.pixelsToGLUnits; return { u_camera_to_center_distance: s.cameraToCenterDistance, u_scale_with_map: +("map" === i.paint.get("circle-pitch-scale")), u_matrix: e.translatePosMatrix(n.posMatrix, r, i.paint.get("circle-translate"), i.paint.get("circle-translate-anchor")), u_pitch_with_map: +o, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: a } }, In = function (t, e, n) { var r = he(n, 1, e.zoom), i = Math.pow(2, e.zoom - n.tileID.overscaledZ), o = n.tileID.overscaleFactor(); return { u_matrix: t, u_camera_to_center_distance: e.cameraToCenterDistance, u_pixels_to_tile_units: r, u_extrude_scale: [e.pixelsToGLUnits[0] / (r * i), e.pixelsToGLUnits[1] / (r * i)], u_overscale_factor: o } }, Pn = function (t, e, n) { return { u_matrix: t, u_inv_matrix: e, u_camera_to_center_distance: n.cameraToCenterDistance, u_viewport_size: [n.width, n.height] } }, Ln = function (t, e, n) { return void 0 === n && (n = 1), { u_matrix: t, u_color: e, u_overlay: 0, u_overlay_scale: n } }, Rn = function (t) { return { u_matrix: t } }, Dn = function (t, e, n, r) { return { u_matrix: t, u_extrude_scale: he(e, 1, n), u_intensity: r } }, Nn = function (e, n, r) { var i = e.transform; return { u_matrix: Un(e, n, r), u_ratio: 1 / he(n, 1, i.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / i.pixelsToGLUnits[0], 1 / i.pixelsToGLUnits[1]] } }, zn = function (e, n, r, i) { return t.extend(Nn(e, n, r), { u_image: 0, u_image_height: i }) }, Fn = function (e, n, r, i) { var o = e.transform, a = jn(n, o); return { u_matrix: Un(e, n, r), u_texsize: n.imageAtlasTexture.size, u_ratio: 1 / he(n, 1, o.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [a, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] } }, Bn = function (e, n, r, i, o) { var a = e.lineAtlas, s = jn(n, e.transform), l = "round" === r.layout.get("line-cap"), u = a.getDash(i.from, l), c = a.getDash(i.to, l), p = u.width * o.fromScale, h = c.width * o.toScale; return t.extend(Nn(e, n, r), { u_patternscale_a: [s / p, -u.height / 2], u_patternscale_b: [s / h, -c.height / 2], u_sdfgamma: a.width / (256 * Math.min(p, h) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: u.y, u_tex_y_b: c.y, u_mix: o.t }) }; function jn(t, e) { return 1 / he(t, 1, e.tileZoom) } function Un(t, e, n) { return t.translatePosMatrix(e.tileID.posMatrix, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor")) } var Vn = function (t, e, n, r, i) { return { u_matrix: t, u_tl_parent: e, u_scale_parent: n, u_buffer_scale: 1, u_fade_t: r.mix, u_opacity: r.opacity * i.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: i.paint.get("raster-brightness-min"), u_brightness_high: i.paint.get("raster-brightness-max"), u_saturation_factor: (a = i.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a), u_contrast_factor: (o = i.paint.get("raster-contrast"), o > 0 ? 1 / (1 - o) : 1 + o), u_spin_weights: Gn(i.paint.get("raster-hue-rotate")) }; var o, a }; function Gn(t) { t *= Math.PI / 180; var e = Math.sin(t), n = Math.cos(t); return [(2 * n + 1) / 3, (-Math.sqrt(3) * e - n + 1) / 3, (Math.sqrt(3) * e - n + 1) / 3] } var Hn, Wn = function (t, e, n, r, i, o, a, s, l, u) { var c = i.transform; return { u_is_size_zoom_constant: +("constant" === t || "source" === t), u_is_size_feature_constant: +("constant" === t || "camera" === t), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: c.cameraToCenterDistance, u_pitch: c.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +n, u_aspect_ratio: c.width / c.height, u_fade_change: i.options.fadeDuration ? i.symbolFadeChange : 1, u_matrix: o, u_label_plane_matrix: a, u_coord_matrix: s, u_is_text: +l, u_pitch_with_map: +r, u_texsize: u, u_texture: 0 } }, Xn = function (e, n, r, i, o, a, s, l, u, c, p) { var h = o.transform; return t.extend(Wn(e, n, r, i, o, a, s, l, u, c), { u_gamma_scale: i ? Math.cos(h._pitch) * h.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +p }) }, qn = function (e, n, r, i, o, a, s, l, u, c) { return t.extend(Xn(e, n, r, i, o, a, s, l, !0, u, !0), { u_texsize_icon: c, u_texture_icon: 1 }) }, Zn = function (t, e, n) { return { u_matrix: t, u_opacity: e, u_color: n } }, Yn = function (e, n, r, i, o, a) { return t.extend(function (t, e, n, r) { var i = n.imageManager.getPattern(t.from.toString()), o = n.imageManager.getPattern(t.to.toString()), a = n.imageManager.getPixelSize(), s = a.width, l = a.height, u = Math.pow(2, r.tileID.overscaledZ), c = r.tileSize * Math.pow(2, n.transform.tileZoom) / u, p = c * (r.tileID.canonical.x + r.tileID.wrap * u), h = c * r.tileID.canonical.y; return { u_image: 0, u_pattern_tl_a: i.tl, u_pattern_br_a: i.br, u_pattern_tl_b: o.tl, u_pattern_br_b: o.br, u_texsize: [s, l], u_mix: e.t, u_pattern_size_a: i.displaySize, u_pattern_size_b: o.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / he(r, 1, n.transform.tileZoom), u_pixel_coord_upper: [p >> 16, h >> 16], u_pixel_coord_lower: [65535 & p, 65535 & h] } }(i, a, r, o), { u_matrix: e, u_opacity: n }) }, Kn = { fillExtrusion: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_lightpos: new t.Uniform3f(e, n.u_lightpos), u_lightintensity: new t.Uniform1f(e, n.u_lightintensity), u_lightcolor: new t.Uniform3f(e, n.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e, n.u_vertical_gradient), u_opacity: new t.Uniform1f(e, n.u_opacity) } }, fillExtrusionPattern: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_lightpos: new t.Uniform3f(e, n.u_lightpos), u_lightintensity: new t.Uniform1f(e, n.u_lightintensity), u_lightcolor: new t.Uniform3f(e, n.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e, n.u_vertical_gradient), u_height_factor: new t.Uniform1f(e, n.u_height_factor), u_image: new t.Uniform1i(e, n.u_image), u_texsize: new t.Uniform2f(e, n.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, n.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, n.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, n.u_scale), u_fade: new t.Uniform1f(e, n.u_fade), u_opacity: new t.Uniform1f(e, n.u_opacity) } }, fill: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix) } }, fillPattern: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_image: new t.Uniform1i(e, n.u_image), u_texsize: new t.Uniform2f(e, n.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, n.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, n.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, n.u_scale), u_fade: new t.Uniform1f(e, n.u_fade) } }, fillOutline: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_world: new t.Uniform2f(e, n.u_world) } }, fillOutlinePattern: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_world: new t.Uniform2f(e, n.u_world), u_image: new t.Uniform1i(e, n.u_image), u_texsize: new t.Uniform2f(e, n.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, n.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, n.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, n.u_scale), u_fade: new t.Uniform1f(e, n.u_fade) } }, circle: function (e, n) { return { u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e, n.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e, n.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e, n.u_matrix) } }, collisionBox: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e, n.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e, n.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e, n.u_overscale_factor) } }, collisionCircle: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e, n.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e, n.u_viewport_size) } }, debug: function (e, n) { return { u_color: new t.UniformColor(e, n.u_color), u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_overlay: new t.Uniform1i(e, n.u_overlay), u_overlay_scale: new t.Uniform1f(e, n.u_overlay_scale) } }, clippingMask: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix) } }, heatmap: function (e, n) { return { u_extrude_scale: new t.Uniform1f(e, n.u_extrude_scale), u_intensity: new t.Uniform1f(e, n.u_intensity), u_matrix: new t.UniformMatrix4f(e, n.u_matrix) } }, heatmapTexture: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_world: new t.Uniform2f(e, n.u_world), u_image: new t.Uniform1i(e, n.u_image), u_color_ramp: new t.Uniform1i(e, n.u_color_ramp), u_opacity: new t.Uniform1f(e, n.u_opacity) } }, hillshade: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_image: new t.Uniform1i(e, n.u_image), u_latrange: new t.Uniform2f(e, n.u_latrange), u_light: new t.Uniform2f(e, n.u_light), u_shadow: new t.UniformColor(e, n.u_shadow), u_highlight: new t.UniformColor(e, n.u_highlight), u_accent: new t.UniformColor(e, n.u_accent) } }, hillshadePrepare: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_image: new t.Uniform1i(e, n.u_image), u_dimension: new t.Uniform2f(e, n.u_dimension), u_zoom: new t.Uniform1f(e, n.u_zoom), u_unpack: new t.Uniform4f(e, n.u_unpack) } }, line: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_ratio: new t.Uniform1f(e, n.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels) } }, lineGradient: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_ratio: new t.Uniform1f(e, n.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels), u_image: new t.Uniform1i(e, n.u_image), u_image_height: new t.Uniform1f(e, n.u_image_height) } }, linePattern: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_texsize: new t.Uniform2f(e, n.u_texsize), u_ratio: new t.Uniform1f(e, n.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_image: new t.Uniform1i(e, n.u_image), u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels), u_scale: new t.Uniform3f(e, n.u_scale), u_fade: new t.Uniform1f(e, n.u_fade) } }, lineSDF: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_ratio: new t.Uniform1f(e, n.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e, n.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e, n.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e, n.u_sdfgamma), u_image: new t.Uniform1i(e, n.u_image), u_tex_y_a: new t.Uniform1f(e, n.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e, n.u_tex_y_b), u_mix: new t.Uniform1f(e, n.u_mix) } }, raster: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_tl_parent: new t.Uniform2f(e, n.u_tl_parent), u_scale_parent: new t.Uniform1f(e, n.u_scale_parent), u_buffer_scale: new t.Uniform1f(e, n.u_buffer_scale), u_fade_t: new t.Uniform1f(e, n.u_fade_t), u_opacity: new t.Uniform1f(e, n.u_opacity), u_image0: new t.Uniform1i(e, n.u_image0), u_image1: new t.Uniform1i(e, n.u_image1), u_brightness_low: new t.Uniform1f(e, n.u_brightness_low), u_brightness_high: new t.Uniform1f(e, n.u_brightness_high), u_saturation_factor: new t.Uniform1f(e, n.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e, n.u_contrast_factor), u_spin_weights: new t.Uniform3f(e, n.u_spin_weights) } }, symbolIcon: function (e, n) { return { u_is_size_zoom_constant: new t.Uniform1i(e, n.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, n.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, n.u_size_t), u_size: new t.Uniform1f(e, n.u_size), u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, n.u_pitch), u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, n.u_fade_change), u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, n.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix), u_is_text: new t.Uniform1i(e, n.u_is_text), u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map), u_texsize: new t.Uniform2f(e, n.u_texsize), u_texture: new t.Uniform1i(e, n.u_texture) } }, symbolSDF: function (e, n) { return { u_is_size_zoom_constant: new t.Uniform1i(e, n.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, n.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, n.u_size_t), u_size: new t.Uniform1f(e, n.u_size), u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, n.u_pitch), u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, n.u_fade_change), u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, n.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix), u_is_text: new t.Uniform1i(e, n.u_is_text), u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map), u_texsize: new t.Uniform2f(e, n.u_texsize), u_texture: new t.Uniform1i(e, n.u_texture), u_gamma_scale: new t.Uniform1f(e, n.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e, n.u_is_halo) } }, symbolTextAndIcon: function (e, n) { return { u_is_size_zoom_constant: new t.Uniform1i(e, n.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, n.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, n.u_size_t), u_size: new t.Uniform1f(e, n.u_size), u_camera_to_center_distance: new t.Uniform1f(e, n.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, n.u_pitch), u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, n.u_fade_change), u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, n.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix), u_is_text: new t.Uniform1i(e, n.u_is_text), u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map), u_texsize: new t.Uniform2f(e, n.u_texsize), u_texsize_icon: new t.Uniform2f(e, n.u_texsize_icon), u_texture: new t.Uniform1i(e, n.u_texture), u_texture_icon: new t.Uniform1i(e, n.u_texture_icon), u_gamma_scale: new t.Uniform1f(e, n.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e, n.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e, n.u_is_halo) } }, background: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_opacity: new t.Uniform1f(e, n.u_opacity), u_color: new t.UniformColor(e, n.u_color) } }, backgroundPattern: function (e, n) { return { u_matrix: new t.UniformMatrix4f(e, n.u_matrix), u_opacity: new t.Uniform1f(e, n.u_opacity), u_image: new t.Uniform1i(e, n.u_image), u_pattern_tl_a: new t.Uniform2f(e, n.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e, n.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e, n.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e, n.u_pattern_br_b), u_texsize: new t.Uniform2f(e, n.u_texsize), u_mix: new t.Uniform1f(e, n.u_mix), u_pattern_size_a: new t.Uniform2f(e, n.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e, n.u_pattern_size_b), u_scale_a: new t.Uniform1f(e, n.u_scale_a), u_scale_b: new t.Uniform1f(e, n.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e, n.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, n.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e, n.u_tile_units_to_pixels) } } }; function Qn(e, n, r, i, o, a, s) { for (var l = e.context, u = l.gl, c = e.useProgram("collisionBox"), p = [], h = 0, f = 0, d = 0; d < i.length; d++) { var m = i[d], v = n.getTile(m), y = v.getBucket(r); if (y) { var g = m.posMatrix; 0 === o[0] && 0 === o[1] || (g = e.translatePosMatrix(m.posMatrix, v, o, a)); var _ = s ? y.textCollisionBox : y.iconCollisionBox, x = y.collisionCircleArray; if (x.length > 0) { var b = t.create(), w = g; t.mul(b, y.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(b, b, y.placementViewportMatrix), p.push({ circleArray: x, circleOffset: f, transform: w, invTransform: b }), f = h += x.length / 4 } _ && c.draw(l, u.LINES, Ct.disabled, Tt.disabled, e.colorModeForRenderPass(), Mt.disabled, In(g, e.transform, v), r.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, null, e.transform.zoom, null, null, _.collisionVertexBuffer) } } if (s && p.length) { var S = e.useProgram("collisionCircle"), E = new t.StructArrayLayout2f1f2i16; E.resize(4 * h), E._trim(); for (var C = 0, T = 0, A = p; T < A.length; T += 1)for (var M = A[T], O = 0; O < M.circleArray.length / 4; O++) { var k = 4 * O, I = M.circleArray[k + 0], P = M.circleArray[k + 1], L = M.circleArray[k + 2], R = M.circleArray[k + 3]; E.emplace(C++, I, P, L, R, 0), E.emplace(C++, I, P, L, R, 1), E.emplace(C++, I, P, L, R, 2), E.emplace(C++, I, P, L, R, 3) } (!Hn || Hn.length < 2 * h) && (Hn = function (e) { var n = 2 * e, r = new t.StructArrayLayout3ui6; r.resize(n), r._trim(); for (var i = 0; i < n; i++) { var o = 6 * i; r.uint16[o + 0] = 4 * i + 0, r.uint16[o + 1] = 4 * i + 1, r.uint16[o + 2] = 4 * i + 2, r.uint16[o + 3] = 4 * i + 2, r.uint16[o + 4] = 4 * i + 3, r.uint16[o + 5] = 4 * i + 0 } return r }(h)); for (var D = l.createIndexBuffer(Hn, !0), N = l.createVertexBuffer(E, t.collisionCircleLayout.members, !0), z = 0, F = p; z < F.length; z += 1) { var B = F[z], j = Pn(B.transform, B.invTransform, e.transform); S.draw(l, u.TRIANGLES, Ct.disabled, Tt.disabled, e.colorModeForRenderPass(), Mt.disabled, j, r.id, N, D, t.SegmentVector.simpleSegment(0, 2 * B.circleOffset, B.circleArray.length, B.circleArray.length / 2), null, e.transform.zoom, null, null, null) } N.destroy(), D.destroy() } } var Jn = t.identity(new Float32Array(16)); function $n(e, n, r, i, o, a) { var s = t.getAnchorAlignment(e), l = -(s.horizontalAlign - .5) * n, u = -(s.verticalAlign - .5) * r, c = t.evaluateVariableOffset(e, i); return new t.Point((l / o + c[0]) * a, (u / o + c[1]) * a) } function tr(e, n, r, i, o, a, s, l, u, c, p) { var h = e.text.placedSymbolArray, f = e.text.dynamicLayoutVertexArray, d = e.icon.dynamicLayoutVertexArray, m = {}; f.clear(); for (var v = 0; v < h.length; v++) { var y = h.get(v), g = y.hidden || !y.crossTileID || e.allowVerticalPlacement && !y.placedOrientation ? null : i[y.crossTileID]; if (g) { var _ = new t.Point(y.anchorX, y.anchorY), x = $t(_, r ? l : s), b = te(a.cameraToCenterDistance, x.signedDistanceFromCamera), w = o.evaluateSizeForFeature(e.textSizeData, c, y) * b / t.ONE_EM; r && (w *= e.tilePixelRatio / u); for (var S = $n(g.anchor, g.width, g.height, g.textOffset, g.textBoxScale, w), E = r ? $t(_.add(S), s).point : x.point.add(n ? S.rotate(-a.angle) : S), C = e.allowVerticalPlacement && y.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, T = 0; T < y.numGlyphs; T++)t.addDynamicAttributes(f, E, C); p && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = { shiftedAnchor: E, angle: C }) } else ue(y.numGlyphs, f) } if (p) { d.clear(); for (var A = e.icon.placedSymbolArray, M = 0; M < A.length; M++) { var O = A.get(M); if (O.hidden) ue(O.numGlyphs, d); else { var k = m[M]; if (k) for (var I = 0; I < O.numGlyphs; I++)t.addDynamicAttributes(d, k.shiftedAnchor, k.angle); else ue(O.numGlyphs, d) } } e.icon.dynamicLayoutVertexBuffer.updateData(d) } e.text.dynamicLayoutVertexBuffer.updateData(f) } function er(t, e, n) { return n.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon" } function nr(e, n, r, i, o, a, s, l, u, c, p, h) { for (var f = e.context, d = f.gl, m = e.transform, v = "map" === l, y = "map" === u, g = v && "point" !== r.layout.get("symbol-placement"), _ = v && !y && !g, x = void 0 !== r.layout.get("symbol-sort-key").constantOr(1), b = !1, w = e.depthModeForSublayer(0, Ct.ReadOnly), S = r.layout.get("text-variable-anchor"), E = [], C = 0, T = i; C < T.length; C += 1) { var A = T[C], M = n.getTile(A), O = M.getBucket(r); if (O) { var k = o ? O.text : O.icon; if (k && k.segments.get().length) { var I = k.programConfigurations.get(r.id), P = o || O.sdfIcons, L = o ? O.textSizeData : O.iconSizeData, R = y || 0 !== m.pitch, D = e.useProgram(er(P, o, O), I), N = t.evaluateSizeForZoom(L, m.zoom), z = void 0, F = [0, 0], B = void 0, j = void 0, U = null, V = void 0; if (o) B = M.glyphAtlasTexture, j = d.LINEAR, z = M.glyphAtlasTexture.size, O.iconsInText && (F = M.imageAtlasTexture.size, U = M.imageAtlasTexture, V = R || e.options.rotating || e.options.zooming || "composite" === L.kind || "camera" === L.kind ? d.LINEAR : d.NEAREST); else { var G = 1 !== r.layout.get("icon-size").constantOr(0) || O.iconsNeedLinear; B = M.imageAtlasTexture, j = P || e.options.rotating || e.options.zooming || G || R ? d.LINEAR : d.NEAREST, z = M.imageAtlasTexture.size } var H = he(M, 1, e.transform.zoom), W = Qt(A.posMatrix, y, v, e.transform, H), X = Jt(A.posMatrix, y, v, e.transform, H), q = S && O.hasTextData(), Z = "none" !== r.layout.get("icon-text-fit") && q && O.hasIconData(); g && ne(O, A.posMatrix, e, o, W, X, y, c); var Y = e.translatePosMatrix(A.posMatrix, M, a, s), K = g || o && S || Z ? Jn : W, Q = e.translatePosMatrix(X, M, a, s, !0), J = P && 0 !== r.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1), $ = { program: D, buffers: k, uniformValues: P ? O.iconsInText ? qn(L.kind, N, _, y, e, Y, K, Q, z, F) : Xn(L.kind, N, _, y, e, Y, K, Q, o, z, !0) : Wn(L.kind, N, _, y, e, Y, K, Q, o, z), atlasTexture: B, atlasTextureIcon: U, atlasInterpolation: j, atlasInterpolationIcon: V, isSDF: P, hasHalo: J }; if (x && O.canOverlap) { b = !0; for (var tt = 0, et = k.segments.get(); tt < et.length; tt += 1) { var nt = et[tt]; E.push({ segments: new t.SegmentVector([nt]), sortKey: nt.sortKey, state: $ }) } } else E.push({ segments: k.segments, sortKey: 0, state: $ }) } } } b && E.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var rt = 0, it = E; rt < it.length; rt += 1) { var ot = it[rt], at = ot.state; if (f.activeTexture.set(d.TEXTURE0), at.atlasTexture.bind(at.atlasInterpolation, d.CLAMP_TO_EDGE), at.atlasTextureIcon && (f.activeTexture.set(d.TEXTURE1), at.atlasTextureIcon && at.atlasTextureIcon.bind(at.atlasInterpolationIcon, d.CLAMP_TO_EDGE)), at.isSDF) { var st = at.uniformValues; at.hasHalo && (st.u_is_halo = 1, rr(at.buffers, ot.segments, r, e, at.program, w, p, h, st)), st.u_is_halo = 0 } rr(at.buffers, ot.segments, r, e, at.program, w, p, h, at.uniformValues) } } function rr(t, e, n, r, i, o, a, s, l) { var u = r.context; i.draw(u, u.gl.TRIANGLES, o, a, s, Mt.disabled, l, n.id, t.layoutVertexBuffer, t.indexBuffer, e, n.paint, r.transform.zoom, t.programConfigurations.get(n.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer) } function ir(t, e, n, r, i, o, a) { var s, l, u, c, p, h = t.context.gl, f = n.paint.get("fill-pattern"), d = f && f.constantOr(1), m = n.getCrossfadeParameters(); a ? (l = d && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s = h.LINES) : (l = d ? "fillPattern" : "fill", s = h.TRIANGLES); for (var v = 0, y = r; v < y.length; v += 1) { var g = y[v], _ = e.getTile(g); if (!d || _.patternsLoaded()) { var x = _.getBucket(n); if (x) { var b = x.programConfigurations.get(n.id), w = t.useProgram(l, b); d && (t.context.activeTexture.set(h.TEXTURE0), _.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), b.updatePaintBuffers(m)); var S = f.constantOr(null); if (S && _.imageAtlas) { var E = _.imageAtlas, C = E.patternPositions[S.to.toString()], T = E.patternPositions[S.from.toString()]; C && T && b.setConstantPatternPositions(C, T) } var A = t.translatePosMatrix(g.posMatrix, _, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor")); if (a) { c = x.indexBuffer2, p = x.segments2; var M = [h.drawingBufferWidth, h.drawingBufferHeight]; u = "fillOutlinePattern" === l && d ? On(A, t, m, _, M) : Mn(A, M) } else c = x.indexBuffer, p = x.segments, u = d ? An(A, t, m, _) : Tn(A); w.draw(t.context, s, i, t.stencilModeForClipping(g), o, Mt.disabled, u, n.id, x.layoutVertexBuffer, c, p, n.paint, t.transform.zoom, b) } } } } function or(t, e, n, r, i, o, a) { for (var s = t.context, l = s.gl, u = n.paint.get("fill-extrusion-pattern"), c = u.constantOr(1), p = n.getCrossfadeParameters(), h = n.paint.get("fill-extrusion-opacity"), f = 0, d = r; f < d.length; f += 1) { var m = d[f], v = e.getTile(m), y = v.getBucket(n); if (y) { var g = y.programConfigurations.get(n.id), _ = t.useProgram(c ? "fillExtrusionPattern" : "fillExtrusion", g); c && (t.context.activeTexture.set(l.TEXTURE0), v.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), g.updatePaintBuffers(p)); var x = u.constantOr(null); if (x && v.imageAtlas) { var b = v.imageAtlas, w = b.patternPositions[x.to.toString()], S = b.patternPositions[x.from.toString()]; w && S && g.setConstantPatternPositions(w, S) } var E = t.translatePosMatrix(m.posMatrix, v, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), C = n.paint.get("fill-extrusion-vertical-gradient"), T = c ? Cn(E, t, C, h, m, p, v) : En(E, t, C, h); _.draw(s, s.gl.TRIANGLES, i, o, a, Mt.backCCW, T, n.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, n.paint, t.transform.zoom, g) } } } function ar(e, n, r, i, o, a) { var s = e.context, l = s.gl, u = n.fbo; if (u) { var c = e.useProgram("hillshade"); s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, u.colorAttachment.get()); var p = function (e, n, r) { var i = r.paint.get("hillshade-shadow-color"), o = r.paint.get("hillshade-highlight-color"), a = r.paint.get("hillshade-accent-color"), s = r.paint.get("hillshade-illumination-direction") * (Math.PI / 180); "viewport" === r.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle); var l, u, c, p = !e.options.moving; return { u_matrix: e.transform.calculatePosMatrix(n.tileID.toUnwrapped(), p), u_image: 0, u_latrange: (l = n.tileID, u = Math.pow(2, l.canonical.z), c = l.canonical.y, [new t.MercatorCoordinate(0, c / u).toLngLat().lat, new t.MercatorCoordinate(0, (c + 1) / u).toLngLat().lat]), u_light: [r.paint.get("hillshade-exaggeration"), s], u_shadow: i, u_highlight: o, u_accent: a } }(e, n, r); c.draw(s, l.TRIANGLES, i, o, a, Mt.disabled, p, r.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments) } } function sr(e, n, r, i, o, a) { var s = e.context, l = s.gl, u = n.dem; if (u && u.data) { var c = u.dim, p = u.stride, h = u.getPixels(); if (s.activeTexture.set(l.TEXTURE1), s.pixelStoreUnpackPremultiplyAlpha.set(!1), n.demTexture = n.demTexture || e.getTileTexture(p), n.demTexture) { var f = n.demTexture; f.update(h, { premultiply: !1 }), f.bind(l.NEAREST, l.CLAMP_TO_EDGE) } else n.demTexture = new t.Texture(s, h, l.RGBA, { premultiply: !1 }), n.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE); s.activeTexture.set(l.TEXTURE0); var d = n.fbo; if (!d) { var m = new t.Texture(s, { width: c, height: c, data: null }, l.RGBA); m.bind(l.LINEAR, l.CLAMP_TO_EDGE), (d = n.fbo = s.createFramebuffer(c, c, !0)).colorAttachment.set(m.texture) } s.bindFramebuffer.set(d.framebuffer), s.viewport.set([0, 0, c, c]), e.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, i, o, a, Mt.disabled, function (e, n) { var r = n.stride, i = t.create(); return t.ortho(i, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(i, i, [0, -t.EXTENT, 0]), { u_matrix: i, u_image: 1, u_dimension: [r, r], u_zoom: e.overscaledZ, u_unpack: n.getUnpackVector() } }(n.tileID, u), r.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), n.needsHillshadePrepare = !1 } } function lr(e, n, r, i, o) { var a = i.paint.get("raster-fade-duration"); if (a > 0) { var s = t.browser.now(), l = (s - e.timeAdded) / a, u = n ? (s - n.timeAdded) / a : -1, c = r.getSource(), p = o.coveringZoomLevel({ tileSize: c.tileSize, roundZoom: c.roundZoom }), h = !n || Math.abs(n.tileID.overscaledZ - p) > Math.abs(e.tileID.overscaledZ - p), f = h && e.refreshedUponExpiration ? 1 : t.clamp(h ? l : 1 - u, 0, 1); return e.refreshedUponExpiration && l >= 1 && (e.refreshedUponExpiration = !1), n ? { opacity: 1, mix: 1 - f } : { opacity: f, mix: 0 } } return { opacity: 1, mix: 0 } } var ur = new t.Color(1, 0, 0, 1), cr = new t.Color(0, 1, 0, 1), pr = new t.Color(0, 0, 1, 1), hr = new t.Color(1, 0, 1, 1), fr = new t.Color(0, 1, 1, 1); function dr(t, e, n, r) { vr(t, 0, e + n / 2, t.transform.width, n, r) } function mr(t, e, n, r) { vr(t, e - n / 2, 0, n, t.transform.height, r) } function vr(e, n, r, i, o, a) { var s = e.context, l = s.gl; l.enable(l.SCISSOR_TEST), l.scissor(n * t.browser.devicePixelRatio, r * t.browser.devicePixelRatio, i * t.browser.devicePixelRatio, o * t.browser.devicePixelRatio), s.clear({ color: a }), l.disable(l.SCISSOR_TEST) } function yr(e, n, r) { var i = e.context, o = i.gl, a = r.posMatrix, s = e.useProgram("debug"), l = Ct.disabled, u = Tt.disabled, c = e.colorModeForRenderPass(); i.activeTexture.set(o.TEXTURE0), e.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE), s.draw(i, o.LINE_STRIP, l, u, c, Mt.disabled, Ln(a, t.Color.red), "$debug", e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments); var p = n.getTileByID(r.key).latestRawTileData, h = Math.floor((p && p.byteLength || 0) / 1024), f = n.getTile(r).tileSize, d = 512 / Math.min(f, 512) * (r.overscaledZ / e.transform.zoom) * .5, m = r.canonical.toString(); r.overscaledZ !== r.canonical.z && (m += " => " + r.overscaledZ), function (t, e) { t.initDebugOverlayCanvas(); var n = t.debugOverlayCanvas, r = t.context.gl, i = t.debugOverlayCanvas.getContext("2d"); i.clearRect(0, 0, n.width, n.height), i.shadowColor = "white", i.shadowBlur = 2, i.lineWidth = 1.5, i.strokeStyle = "white", i.textBaseline = "top", i.font = "bold 36px Open Sans, sans-serif", i.fillText(e, 5, 5), i.strokeText(e, 5, 5), t.debugOverlayTexture.update(n), t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE) }(e, m + " " + h + "kb"), s.draw(i, o.TRIANGLES, l, u, At.alphaBlended, Mt.disabled, Ln(a, t.Color.transparent, d), "$debug", e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments) } var gr = { symbol: function (e, n, r, i, o) { if ("translucent" === e.renderPass) { var a = Tt.disabled, s = e.colorModeForRenderPass(); r.layout.get("text-variable-anchor") && function (e, n, r, i, o, a, s) { for (var l = n.transform, u = "map" === o, c = "map" === a, p = 0, h = e; p < h.length; p += 1) { var f = h[p], d = i.getTile(f), m = d.getBucket(r); if (m && m.text && m.text.segments.get().length) { var v = t.evaluateSizeForZoom(m.textSizeData, l.zoom), y = he(d, 1, n.transform.zoom), g = Qt(f.posMatrix, c, u, n.transform, y), _ = "none" !== r.layout.get("icon-text-fit") && m.hasIconData(); if (v) { var x = Math.pow(2, l.zoom - d.tileID.overscaledZ); tr(m, u, c, s, t.symbolSize, l, g, f.posMatrix, x, v, _) } } } }(i, e, r, n, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), o), 0 !== r.paint.get("icon-opacity").constantOr(1) && nr(e, n, r, i, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), a, s), 0 !== r.paint.get("text-opacity").constantOr(1) && nr(e, n, r, i, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), a, s), n.map.showCollisionBoxes && (Qn(e, n, r, i, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), !0), Qn(e, n, r, i, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), !1)) } }, circle: function (e, n, r, i) { if ("translucent" === e.renderPass) { var o = r.paint.get("circle-opacity"), a = r.paint.get("circle-stroke-width"), s = r.paint.get("circle-stroke-opacity"), l = void 0 !== r.layout.get("circle-sort-key").constantOr(1); if (0 !== o.constantOr(1) || 0 !== a.constantOr(1) && 0 !== s.constantOr(1)) { for (var u = e.context, c = u.gl, p = e.depthModeForSublayer(0, Ct.ReadOnly), h = Tt.disabled, f = e.colorModeForRenderPass(), d = [], m = 0; m < i.length; m++) { var v = i[m], y = n.getTile(v), g = y.getBucket(r); if (g) { var _ = g.programConfigurations.get(r.id), x = { programConfiguration: _, program: e.useProgram("circle", _), layoutVertexBuffer: g.layoutVertexBuffer, indexBuffer: g.indexBuffer, uniformValues: kn(e, v, y, r) }; if (l) for (var b = 0, w = g.segments.get(); b < w.length; b += 1) { var S = w[b]; d.push({ segments: new t.SegmentVector([S]), sortKey: S.sortKey, state: x }) } else d.push({ segments: g.segments, sortKey: 0, state: x }) } } l && d.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var E = 0, C = d; E < C.length; E += 1) { var T = C[E], A = T.state; A.program.draw(u, c.TRIANGLES, p, h, f, Mt.disabled, A.uniformValues, r.id, A.layoutVertexBuffer, A.indexBuffer, T.segments, r.paint, e.transform.zoom, A.programConfiguration) } } } }, heatmap: function (e, n, r, i) { if (0 !== r.paint.get("heatmap-opacity")) if ("offscreen" === e.renderPass) { var o = e.context, a = o.gl, s = Tt.disabled, l = new At([a.ONE, a.ONE], t.Color.transparent, [!0, !0, !0, !0]); !function (t, e, n) { var r = t.gl; t.activeTexture.set(r.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]); var i = n.heatmapFbo; if (i) r.bindTexture(r.TEXTURE_2D, i.colorAttachment.get()), t.bindFramebuffer.set(i.framebuffer); else { var o = r.createTexture(); r.bindTexture(r.TEXTURE_2D, o), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), i = n.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, n, r) { var i = t.gl; i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, e.width / 4, e.height / 4, 0, i.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : i.UNSIGNED_BYTE, null), r.colorAttachment.set(n) }(t, e, o, i) } }(o, e, r), o.clear({ color: t.Color.transparent }); for (var u = 0; u < i.length; u++) { var c = i[u]; if (!n.hasRenderableParent(c)) { var p = n.getTile(c), h = p.getBucket(r); if (h) { var f = h.programConfigurations.get(r.id); e.useProgram("heatmap", f).draw(o, a.TRIANGLES, Ct.disabled, s, l, Mt.disabled, Dn(c.posMatrix, p, e.transform.zoom, r.paint.get("heatmap-intensity")), r.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, r.paint, e.transform.zoom, f) } } } o.viewport.set([0, 0, e.width, e.height]) } else "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, n) { var r = e.context, i = r.gl, o = n.heatmapFbo; if (o) { r.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, o.colorAttachment.get()), r.activeTexture.set(i.TEXTURE1); var a = n.colorRampTexture; a || (a = n.colorRampTexture = new t.Texture(r, n.colorRamp, i.RGBA)), a.bind(i.LINEAR, i.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(r, i.TRIANGLES, Ct.disabled, Tt.disabled, e.colorModeForRenderPass(), Mt.disabled, function (e, n, r, i) { var o = t.create(); t.ortho(o, 0, e.width, e.height, 0, 0, 1); var a = e.context.gl; return { u_matrix: o, u_world: [a.drawingBufferWidth, a.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: n.paint.get("heatmap-opacity") } }(e, n), n.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, n.paint, e.transform.zoom) } }(e, r)) }, line: function (e, n, r, i) { if ("translucent" === e.renderPass) { var o = r.paint.get("line-opacity"), a = r.paint.get("line-width"); if (0 !== o.constantOr(1) && 0 !== a.constantOr(1)) for (var s = e.depthModeForSublayer(0, Ct.ReadOnly), l = e.colorModeForRenderPass(), u = r.paint.get("line-dasharray"), c = r.paint.get("line-pattern"), p = c.constantOr(1), h = r.paint.get("line-gradient"), f = r.getCrossfadeParameters(), d = p ? "linePattern" : u ? "lineSDF" : h ? "lineGradient" : "line", m = e.context, v = m.gl, y = !0, g = 0, _ = i; g < _.length; g += 1) { var x = _[g], b = n.getTile(x); if (!p || b.patternsLoaded()) { var w = b.getBucket(r); if (w) { var S = w.programConfigurations.get(r.id), E = e.context.program.get(), C = e.useProgram(d, S), T = y || C.program !== E, A = c.constantOr(null); if (A && b.imageAtlas) { var M = b.imageAtlas, O = M.patternPositions[A.to.toString()], k = M.patternPositions[A.from.toString()]; O && k && S.setConstantPatternPositions(O, k) } var I = p ? Fn(e, b, r, f) : u ? Bn(e, b, r, u, f) : h ? zn(e, b, r, w.lineClipsArray.length) : Nn(e, b, r); if (p) m.activeTexture.set(v.TEXTURE0), b.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), S.updatePaintBuffers(f); else if (u && (T || e.lineAtlas.dirty)) m.activeTexture.set(v.TEXTURE0), e.lineAtlas.bind(m); else if (h) { var P = w.gradients[r.id], L = P.texture; if (r.gradientVersion !== P.version) { var R = 256; if (r.stepInterpolant) { var D = n.getSource().maxzoom, N = x.canonical.z === D ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1; R = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * N), 256, m.maxTextureSize) } P.gradient = t.renderColorRamp({ expression: r.gradientExpression(), evaluationKey: "lineProgress", resolution: R, image: P.gradient || void 0, clips: w.lineClipsArray }), P.texture ? P.texture.update(P.gradient) : P.texture = new t.Texture(m, P.gradient, v.RGBA), P.version = r.gradientVersion, L = P.texture } m.activeTexture.set(v.TEXTURE0), L.bind(r.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE) } C.draw(m, v.TRIANGLES, s, e.stencilModeForClipping(x), l, Mt.disabled, I, r.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, r.paint, e.transform.zoom, S, w.layoutVertexBuffer2), y = !1 } } } } }, fill: function (e, n, r, i) { var o = r.paint.get("fill-color"), a = r.paint.get("fill-opacity"); if (0 !== a.constantOr(1)) { var s = e.colorModeForRenderPass(), l = r.paint.get("fill-pattern"), u = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === o.constantOr(t.Color.transparent).a && 1 === a.constantOr(0) ? "opaque" : "translucent"; if (e.renderPass === u) { var c = e.depthModeForSublayer(1, "opaque" === e.renderPass ? Ct.ReadWrite : Ct.ReadOnly); ir(e, n, r, i, c, s, !1) } if ("translucent" === e.renderPass && r.paint.get("fill-antialias")) { var p = e.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, Ct.ReadOnly); ir(e, n, r, i, p, s, !0) } } }, "fill-extrusion": function (t, e, n, r) { var i = n.paint.get("fill-extrusion-opacity"); if (0 !== i && "translucent" === t.renderPass) { var o = new Ct(t.context.gl.LEQUAL, Ct.ReadWrite, t.depthRangeFor3D); if (1 !== i || n.paint.get("fill-extrusion-pattern").constantOr(1)) or(t, e, n, r, o, Tt.disabled, At.disabled), or(t, e, n, r, o, t.stencilModeFor3D(), t.colorModeForRenderPass()); else { var a = t.colorModeForRenderPass(); or(t, e, n, r, o, Tt.disabled, a) } } }, hillshade: function (t, e, n, r) { if ("offscreen" === t.renderPass || "translucent" === t.renderPass) { for (var i = t.context, o = t.depthModeForSublayer(0, Ct.ReadOnly), a = t.colorModeForRenderPass(), s = "translucent" === t.renderPass ? t.stencilConfigForOverlap(r) : [{}, r], l = s[0], u = 0, c = s[1]; u < c.length; u += 1) { var p = c[u], h = e.getTile(p); h.needsHillshadePrepare && "offscreen" === t.renderPass ? sr(t, h, n, o, Tt.disabled, a) : "translucent" === t.renderPass && ar(t, h, n, o, l[p.overscaledZ], a) } i.viewport.set([0, 0, t.width, t.height]) } }, raster: function (t, e, n, r) { if ("translucent" === t.renderPass && 0 !== n.paint.get("raster-opacity") && r.length) for (var i = t.context, o = i.gl, a = e.getSource(), s = t.useProgram("raster"), l = t.colorModeForRenderPass(), u = a instanceof P ? [{}, r] : t.stencilConfigForOverlap(r), c = u[0], p = u[1], h = p[p.length - 1].overscaledZ, f = !t.options.moving, d = 0, m = p; d < m.length; d += 1) { var v = m[d], y = t.depthModeForSublayer(v.overscaledZ - h, 1 === n.paint.get("raster-opacity") ? Ct.ReadWrite : Ct.ReadOnly, o.LESS), g = e.getTile(v), _ = t.transform.calculatePosMatrix(v.toUnwrapped(), f); g.registerFadeDuration(n.paint.get("raster-fade-duration")); var x = e.findLoadedParent(v, 0), b = lr(g, x, e, n, t.transform), w = void 0, S = void 0, E = "nearest" === n.paint.get("raster-resampling") ? o.NEAREST : o.LINEAR; i.activeTexture.set(o.TEXTURE0), g.texture.bind(E, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), i.activeTexture.set(o.TEXTURE1), x ? (x.texture.bind(E, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - g.tileID.overscaledZ), S = [g.tileID.canonical.x * w % 1, g.tileID.canonical.y * w % 1]) : g.texture.bind(E, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST); var C = Vn(_, S || [0, 0], w || 1, b, n); a instanceof P ? s.draw(i, o.TRIANGLES, y, Tt.disabled, l, Mt.disabled, C, n.id, a.boundsBuffer, t.quadTriangleIndexBuffer, a.boundsSegments) : s.draw(i, o.TRIANGLES, y, c[v.overscaledZ], l, Mt.disabled, C, n.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments) } }, background: function (t, e, n) { var r = n.paint.get("background-color"), i = n.paint.get("background-opacity"); if (0 !== i) { var o = t.context, a = o.gl, s = t.transform, l = s.tileSize, u = n.paint.get("background-pattern"); if (!t.isPatternMissing(u)) { var c = !u && 1 === r.a && 1 === i && t.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (t.renderPass === c) { var p = Tt.disabled, h = t.depthModeForSublayer(0, "opaque" === c ? Ct.ReadWrite : Ct.ReadOnly), f = t.colorModeForRenderPass(), d = t.useProgram(u ? "backgroundPattern" : "background"), m = s.coveringTiles({ tileSize: l }); u && (o.activeTexture.set(a.TEXTURE0), t.imageManager.bind(t.context)); for (var v = n.getCrossfadeParameters(), y = 0, g = m; y < g.length; y += 1) { var _ = g[y], x = t.transform.calculatePosMatrix(_.toUnwrapped()), b = u ? Yn(x, i, t, u, { tileID: _, tileSize: l }, v) : Zn(x, i, r); d.draw(o, a.TRIANGLES, h, p, f, Mt.disabled, b, n.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments) } } } } }, debug: function (t, e, n) { for (var r = 0; r < n.length; r++)yr(t, e, n[r]) }, custom: function (t, e, n) { var r = t.context, i = n.implementation; if ("offscreen" === t.renderPass) { var o = i.prerender; o && (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), o.call(i, r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState()) } else if ("translucent" === t.renderPass) { t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(Tt.disabled); var a = "3d" === i.renderingMode ? new Ct(t.context.gl.LEQUAL, Ct.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, Ct.ReadOnly); r.setDepthMode(a), i.render(r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null) } } }, _r = function (t, e) { this.context = new Ot(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = kt.maxUnderzooming + kt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe, this.gpuTimers = {} }; _r.prototype.resize = function (e, n) { if (this.width = e * t.browser.devicePixelRatio, this.height = n * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var r = 0, i = this.style._order; r < i.length; r += 1)this.style._layers[i[r]].resize() }, _r.prototype.setup = function () { var e = this.context, n = new t.StructArrayLayout2i4; n.emplaceBack(0, 0), n.emplaceBack(t.EXTENT, 0), n.emplaceBack(0, t.EXTENT), n.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(n, He.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var r = new t.StructArrayLayout2i4; r.emplaceBack(0, 0), r.emplaceBack(t.EXTENT, 0), r.emplaceBack(0, t.EXTENT), r.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(r, He.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5); var i = new t.StructArrayLayout4i8; i.emplaceBack(0, 0, 0, 0), i.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), i.emplaceBack(0, t.EXTENT, 0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(i, I.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var o = new t.StructArrayLayout2i4; o.emplaceBack(0, 0), o.emplaceBack(1, 0), o.emplaceBack(0, 1), o.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(o, He.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var a = new t.StructArrayLayout1ui2; a.emplaceBack(0), a.emplaceBack(1), a.emplaceBack(3), a.emplaceBack(2), a.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(a); var s = new t.StructArrayLayout3ui6; s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s), this.emptyTexture = new t.Texture(e, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e.gl.RGBA); var l = this.context.gl; this.stencilClearMode = new Tt({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO) }, _r.prototype.clearStencil = function () { var e = this.context, n = e.gl; this.nextStencilID = 1, this.currentStencilSource = void 0; var r = t.create(); t.ortho(r, 0, this.width, this.height, 0, 0, 1), t.scale(r, r, [n.drawingBufferWidth, n.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, n.TRIANGLES, Ct.disabled, this.stencilClearMode, At.disabled, Mt.disabled, Rn(r), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments) }, _r.prototype._renderTileClippingMasks = function (t, e) { if (this.currentStencilSource !== t.source && t.isTileClipped() && e && e.length) { this.currentStencilSource = t.source; var n = this.context, r = n.gl; this.nextStencilID + e.length > 256 && this.clearStencil(), n.setColorMode(At.disabled), n.setDepthMode(Ct.disabled); var i = this.useProgram("clippingMask"); this._tileClippingMaskIDs = {}; for (var o = 0, a = e; o < a.length; o += 1) { var s = a[o], l = this._tileClippingMaskIDs[s.key] = this.nextStencilID++; i.draw(n, r.TRIANGLES, Ct.disabled, new Tt({ func: r.ALWAYS, mask: 0 }, l, 255, r.KEEP, r.KEEP, r.REPLACE), At.disabled, Mt.disabled, Rn(s.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments) } } }, _r.prototype.stencilModeFor3D = function () { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); var t = this.nextStencilID++, e = this.context.gl; return new Tt({ func: e.NOTEQUAL, mask: 255 }, t, 255, e.KEEP, e.KEEP, e.REPLACE) }, _r.prototype.stencilModeForClipping = function (t) { var e = this.context.gl; return new Tt({ func: e.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE) }, _r.prototype.stencilConfigForOverlap = function (t) { var e, n = this.context.gl, r = t.sort((function (t, e) { return e.overscaledZ - t.overscaledZ })), i = r[r.length - 1].overscaledZ, o = r[0].overscaledZ - i + 1; if (o > 1) { this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil(); for (var a = {}, s = 0; s < o; s++)a[s + i] = new Tt({ func: n.GEQUAL, mask: 255 }, s + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE); return this.nextStencilID += o, [a, r] } return [(e = {}, e[i] = Tt.disabled, e), r] }, _r.prototype.colorModeForRenderPass = function () { var e = this.context.gl; return this._showOverdrawInspector ? new At([e.CONSTANT_COLOR, e.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? At.unblended : At.alphaBlended }, _r.prototype.depthModeForSublayer = function (t, e, n) { if (!this.opaquePassEnabledForLayer()) return Ct.disabled; var r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon; return new Ct(n || this.context.gl.LEQUAL, e, [r, r]) }, _r.prototype.opaquePassEnabledForLayer = function () { return this.currentLayer < this.opaquePassCutoff }, _r.prototype.render = function (e, n) { var r = this; this.style = e, this.options = n, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame(); var i = this.style._order, o = this.style.sourceCaches; for (var a in o) { var s = o[a]; s.used && s.prepare(this.context) } var l, u, c = {}, p = {}, h = {}; for (var f in o) { var d = o[f]; c[f] = d.getVisibleCoordinates(), p[f] = c[f].slice().reverse(), h[f] = d.getVisibleCoordinates(!0).reverse() } this.opaquePassCutoff = 1 / 0; for (var m = 0; m < i.length; m++)if (this.style._layers[i[m]].is3D()) { this.opaquePassCutoff = m; break } this.renderPass = "offscreen"; for (var v = 0, y = i; v < y.length; v += 1) { var g = this.style._layers[y[v]]; if (g.hasOffscreenPass() && !g.isHidden(this.transform.zoom)) { var _ = p[g.source]; ("custom" === g.type || _.length) && this.renderLayer(this, o[g.source], g, _) } } for (this.context.bindFramebuffer.set(null), this.context.clear({ color: n.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = i.length - 1; this.currentLayer >= 0; this.currentLayer--) { var x = this.style._layers[i[this.currentLayer]], b = o[x.source], w = c[x.source]; this._renderTileClippingMasks(x, w), this.renderLayer(this, b, x, w) } for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < i.length; this.currentLayer++) { var S = this.style._layers[i[this.currentLayer]], E = o[S.source], C = ("symbol" === S.type ? h : p)[S.source]; this._renderTileClippingMasks(S, c[S.source]), this.renderLayer(this, E, S, C) } this.options.showTileBoundaries && (t.values(this.style._layers).forEach((function (t) { t.source && !t.isHidden(r.transform.zoom) && (t.source !== (u && u.id) && (u = r.style.sourceCaches[t.source]), (!l || l.getSource().maxzoom < u.getSource().maxzoom) && (l = u)) })), l && gr.debug(this, l, l.getVisibleCoordinates())), this.options.showPadding && function (t) { var e = t.transform.padding; dr(t, t.transform.height - (e.top || 0), 3, ur), dr(t, e.bottom || 0, 3, cr), mr(t, e.left || 0, 3, pr), mr(t, t.transform.width - (e.right || 0), 3, hr); var n = t.transform.centerPoint; !function (t, e, n, r) { vr(t, e - 1, n - 10, 2, 20, r), vr(t, e - 10, n - 1, 20, 2, r) }(t, n.x, t.transform.height - n.y, fr) }(this), this.context.setDefault() }, _r.prototype.renderLayer = function (t, e, n, r) { n.isHidden(this.transform.zoom) || ("background" === n.type || "custom" === n.type || r.length) && (this.id = n.id, this.gpuTimingStart(n), gr[n.type](t, e, n, r, this.style.placement.variableOffsets), this.gpuTimingEnd()) }, _r.prototype.gpuTimingStart = function (t) { if (this.options.gpuTiming) { var e = this.context.extTimerQuery, n = this.gpuTimers[t.id]; n || (n = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: e.createQueryEXT() }), n.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, n.query) } }, _r.prototype.gpuTimingEnd = function () { if (this.options.gpuTiming) { var t = this.context.extTimerQuery; t.endQueryEXT(t.TIME_ELAPSED_EXT) } }, _r.prototype.collectGpuTimers = function () { var t = this.gpuTimers; return this.gpuTimers = {}, t }, _r.prototype.queryGpuTimers = function (t) { var e = {}; for (var n in t) { var r = t[n], i = this.context.extTimerQuery, o = i.getQueryObjectEXT(r.query, i.QUERY_RESULT_EXT) / 1e6; i.deleteQueryEXT(r.query), e[n] = o } return e }, _r.prototype.translatePosMatrix = function (e, n, r, i, o) { if (!r[0] && !r[1]) return e; var a = o ? "map" === i ? this.transform.angle : 0 : "viewport" === i ? -this.transform.angle : 0; if (a) { var s = Math.sin(a), l = Math.cos(a); r = [r[0] * l - r[1] * s, r[0] * s + r[1] * l] } var u = [o ? r[0] : he(n, r[0], this.transform.zoom), o ? r[1] : he(n, r[1], this.transform.zoom), 0], c = new Float32Array(16); return t.translate(c, e, u), c }, _r.prototype.saveTileTexture = function (t) { var e = this._tileTextures[t.size[0]]; e ? e.push(t) : this._tileTextures[t.size[0]] = [t] }, _r.prototype.getTileTexture = function (t) { var e = this._tileTextures[t]; return e && e.length > 0 ? e.pop() : null }, _r.prototype.isPatternMissing = function (t) { if (!t) return !1; if (!t.from || !t.to) return !0; var e = this.imageManager.getPattern(t.from.toString()), n = this.imageManager.getPattern(t.to.toString()); return !e || !n }, _r.prototype.useProgram = function (t, e) { this.cache = this.cache || {}; var n = "" + t + (e ? e.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : ""); return this.cache[n] || (this.cache[n] = new wn(this.context, t, _n[t], e, Kn[t], this._showOverdrawInspector)), this.cache[n] }, _r.prototype.setCustomLayerDefaults = function () { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault() }, _r.prototype.setBaseState = function () { var t = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD) }, _r.prototype.initDebugOverlayCanvas = function () { null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)) }, _r.prototype.destroy = function () { this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy() }; var xr = function (t, e) { this.points = t, this.planes = e }; xr.fromInvProjectionMatrix = function (e, n, r) { var i = Math.pow(2, r), o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((function (n) { return t.transformMat4([], n, e) })).map((function (e) { return t.scale$1([], e, 1 / e[3] / n * i) })), a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((function (e) { var n = t.sub([], o[e[0]], o[e[1]]), r = t.sub([], o[e[2]], o[e[1]]), i = t.normalize([], t.cross([], n, r)), a = -t.dot(i, o[e[1]]); return i.concat(a) })); return new xr(o, a) }; var br = function (e, n) { this.min = e, this.max = n, this.center = t.scale$2([], t.add([], this.min, this.max), .5) }; br.prototype.quadrant = function (e) { for (var n = [e % 2 == 0, e < 2], r = t.clone$2(this.min), i = t.clone$2(this.max), o = 0; o < n.length; o++)r[o] = n[o] ? this.min[o] : this.center[o], i[o] = n[o] ? this.center[o] : this.max[o]; return i[2] = this.max[2], new br(r, i) }, br.prototype.distanceX = function (t) { return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0] }, br.prototype.distanceY = function (t) { return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1] }, br.prototype.intersects = function (e) { for (var n = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], r = !0, i = 0; i < e.planes.length; i++) { for (var o = e.planes[i], a = 0, s = 0; s < n.length; s++)a += t.dot$1(o, n[s]) >= 0; if (0 === a) return 0; a !== n.length && (r = !1) } if (r) return 2; for (var l = 0; l < 3; l++) { for (var u = Number.MAX_VALUE, c = -Number.MAX_VALUE, p = 0; p < e.points.length; p++) { var h = e.points[p][l] - this.min[l]; u = Math.min(u, h), c = Math.max(c, h) } if (c < 0 || u > this.max[l] - this.min[l]) return 0 } return 1 }; var wr = function (t, e, n, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(n) || n < 0 || isNaN(r) || r < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = t, this.bottom = e, this.left = n, this.right = r }; wr.prototype.interpolate = function (e, n, r) { return null != n.top && null != e.top && (this.top = t.number(e.top, n.top, r)), null != n.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, n.bottom, r)), null != n.left && null != e.left && (this.left = t.number(e.left, n.left, r)), null != n.right && null != e.right && (this.right = t.number(e.right, n.right, r)), this }, wr.prototype.getCenter = function (e, n) { var r = t.clamp((this.left + e - this.right) / 2, 0, e), i = t.clamp((this.top + n - this.bottom) / 2, 0, n); return new t.Point(r, i) }, wr.prototype.equals = function (t) { return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right }, wr.prototype.clone = function () { return new wr(this.top, this.bottom, this.left, this.right) }, wr.prototype.toJSON = function () { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } }; var Sr = function (e, n, r, i, o) { this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o || o, this._minZoom = e || 0, this._maxZoom = n || 22, this._minPitch = null == r ? 0 : r, this._maxPitch = null == i ? 60 : i, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new wr, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} }, Er = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } }; Sr.prototype.clone = function () { var t = new Sr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies); return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t }, Er.minZoom.get = function () { return this._minZoom }, Er.minZoom.set = function (t) { this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t)) }, Er.maxZoom.get = function () { return this._maxZoom }, Er.maxZoom.set = function (t) { this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t)) }, Er.minPitch.get = function () { return this._minPitch }, Er.minPitch.set = function (t) { this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t)) }, Er.maxPitch.get = function () { return this._maxPitch }, Er.maxPitch.set = function (t) { this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t)) }, Er.renderWorldCopies.get = function () { return this._renderWorldCopies }, Er.renderWorldCopies.set = function (t) { void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t }, Er.worldSize.get = function () { return this.tileSize * this.scale }, Er.centerOffset.get = function () { return this.centerPoint._sub(this.size._div(2)) }, Er.size.get = function () { return new t.Point(this.width, this.height) }, Er.bearing.get = function () { return -this.angle / Math.PI * 180 }, Er.bearing.set = function (e) { var n = -t.wrap(e, -180, 180) * Math.PI / 180; this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle)) }, Er.pitch.get = function () { return this._pitch / Math.PI * 180 }, Er.pitch.set = function (e) { var n = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices()) }, Er.fov.get = function () { return this._fov / Math.PI * 180 }, Er.fov.set = function (t) { t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices()) }, Er.zoom.get = function () { return this._zoom }, Er.zoom.set = function (t) { var e = Math.min(Math.max(t, this.minZoom), this.maxZoom); this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices()) }, Er.center.get = function () { return this._center }, Er.center.set = function (t) { t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices()) }, Er.padding.get = function () { return this._edgeInsets.toJSON() }, Er.padding.set = function (t) { this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices()) }, Er.centerPoint.get = function () { return this._edgeInsets.getCenter(this.width, this.height) }, Sr.prototype.isPaddingEqual = function (t) { return this._edgeInsets.equals(t) }, Sr.prototype.interpolatePadding = function (t, e, n) { this._unmodified = !1, this._edgeInsets.interpolate(t, e, n), this._constrain(), this._calcMatrices() }, Sr.prototype.coveringZoomLevel = function (t) { var e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize)); return Math.max(0, e) }, Sr.prototype.getVisibleUnwrappedCoordinates = function (e) { var n = [new t.UnwrappedTileID(0, e)]; if (this._renderWorldCopies) for (var r = this.pointCoordinate(new t.Point(0, 0)), i = this.pointCoordinate(new t.Point(this.width, 0)), o = this.pointCoordinate(new t.Point(this.width, this.height)), a = this.pointCoordinate(new t.Point(0, this.height)), s = Math.floor(Math.min(r.x, i.x, o.x, a.x)), l = Math.floor(Math.max(r.x, i.x, o.x, a.x)), u = s - 1; u <= l + 1; u++)0 !== u && n.push(new t.UnwrappedTileID(u, e)); return n }, Sr.prototype.coveringTiles = function (e) { var n = this.coveringZoomLevel(e), r = n; if (void 0 !== e.minzoom && n < e.minzoom) return []; void 0 !== e.maxzoom && n > e.maxzoom && (n = e.maxzoom); var i = t.MercatorCoordinate.fromLngLat(this.center), o = Math.pow(2, n), a = [o * i.x, o * i.y, 0], s = xr.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, n), l = e.minzoom || 0; this.pitch <= 60 && this._edgeInsets.top < .1 && (l = n); var u = function (t) { return { aabb: new br([t * o, 0, 0], [(t + 1) * o, o, 0]), zoom: 0, x: 0, y: 0, wrap: t, fullyVisible: !1 } }, c = [], p = [], h = n, f = e.reparseOverscaled ? r : n; if (this._renderWorldCopies) for (var d = 1; d <= 3; d++)c.push(u(-d)), c.push(u(d)); for (c.push(u(0)); c.length > 0;) { var m = c.pop(), v = m.x, y = m.y, g = m.fullyVisible; if (!g) { var _ = m.aabb.intersects(s); if (0 === _) continue; g = 2 === _ } var x = m.aabb.distanceX(a), b = m.aabb.distanceY(a), w = Math.max(Math.abs(x), Math.abs(b)); if (m.zoom === h || w > 3 + (1 << h - m.zoom) - 2 && m.zoom >= l) p.push({ tileID: new t.OverscaledTileID(m.zoom === h ? f : m.zoom, m.wrap, m.zoom, v, y), distanceSq: t.sqrLen([a[0] - .5 - v, a[1] - .5 - y]) }); else for (var S = 0; S < 4; S++) { var E = (v << 1) + S % 2, C = (y << 1) + (S >> 1); c.push({ aabb: m.aabb.quadrant(S), zoom: m.zoom + 1, x: E, y: C, wrap: m.wrap, fullyVisible: g }) } } return p.sort((function (t, e) { return t.distanceSq - e.distanceSq })).map((function (t) { return t.tileID })) }, Sr.prototype.resize = function (t, e) { this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices() }, Er.unmodified.get = function () { return this._unmodified }, Sr.prototype.zoomScale = function (t) { return Math.pow(2, t) }, Sr.prototype.scaleZoom = function (t) { return Math.log(t) / Math.LN2 }, Sr.prototype.project = function (e) { var n = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude); return new t.Point(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(n) * this.worldSize) }, Sr.prototype.unproject = function (e) { return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat() }, Er.point.get = function () { return this.project(this.center) }, Sr.prototype.setLocationAtPoint = function (e, n) { var r = this.pointCoordinate(n), i = this.pointCoordinate(this.centerPoint), o = this.locationCoordinate(e), a = new t.MercatorCoordinate(o.x - (r.x - i.x), o.y - (r.y - i.y)); this.center = this.coordinateLocation(a), this._renderWorldCopies && (this.center = this.center.wrap()) }, Sr.prototype.locationPoint = function (t) { return this.coordinatePoint(this.locationCoordinate(t)) }, Sr.prototype.pointLocation = function (t) { return this.coordinateLocation(this.pointCoordinate(t)) }, Sr.prototype.locationCoordinate = function (e) { return t.MercatorCoordinate.fromLngLat(e) }, Sr.prototype.coordinateLocation = function (t) { return t.toLngLat() }, Sr.prototype.pointCoordinate = function (e) { var n = [e.x, e.y, 0, 1], r = [e.x, e.y, 1, 1]; t.transformMat4(n, n, this.pixelMatrixInverse), t.transformMat4(r, r, this.pixelMatrixInverse); var i = n[3], o = r[3], a = n[1] / i, s = r[1] / o, l = n[2] / i, u = r[2] / o, c = l === u ? 0 : (0 - l) / (u - l); return new t.MercatorCoordinate(t.number(n[0] / i, r[0] / o, c) / this.worldSize, t.number(a, s, c) / this.worldSize) }, Sr.prototype.coordinatePoint = function (e) { var n = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return t.transformMat4(n, n, this.pixelMatrix), new t.Point(n[0] / n[3], n[1] / n[3]) }, Sr.prototype.getBounds = function () { return (new t.LngLatBounds).extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height))) }, Sr.prototype.getMaxBounds = function () { return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null }, Sr.prototype.setMaxBounds = function (t) { t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]) }, Sr.prototype.calculatePosMatrix = function (e, n) { void 0 === n && (n = !1); var r = e.key, i = n ? this._alignedPosMatrixCache : this._posMatrixCache; if (i[r]) return i[r]; var o = e.canonical, a = this.worldSize / this.zoomScale(o.z), s = o.x + Math.pow(2, o.z) * e.wrap, l = t.identity(new Float64Array(16)); return t.translate(l, l, [s * a, o.y * a, 0]), t.scale(l, l, [a / t.EXTENT, a / t.EXTENT, 1]), t.multiply(l, n ? this.alignedProjMatrix : this.projMatrix, l), i[r] = new Float32Array(l), i[r] }, Sr.prototype.customLayerMatrix = function () { return this.mercatorMatrix.slice() }, Sr.prototype._constrain = function () { if (this.center && this.width && this.height && !this._constraining) { this._constraining = !0; var e, n, r, i, o = -90, a = 90, s = -180, l = 180, u = this.size, c = this._unmodified; if (this.latRange) { var p = this.latRange; o = t.mercatorYfromLat(p[1]) * this.worldSize, e = (a = t.mercatorYfromLat(p[0]) * this.worldSize) - o < u.y ? u.y / (a - o) : 0 } if (this.lngRange) { var h = this.lngRange; s = t.mercatorXfromLng(h[0]) * this.worldSize, n = (l = t.mercatorXfromLng(h[1]) * this.worldSize) - s < u.x ? u.x / (l - s) : 0 } var f = this.point, d = Math.max(n || 0, e || 0); if (d) return this.center = this.unproject(new t.Point(n ? (l + s) / 2 : f.x, e ? (a + o) / 2 : f.y)), this.zoom += this.scaleZoom(d), this._unmodified = c, void (this._constraining = !1); if (this.latRange) { var m = f.y, v = u.y / 2; m - v < o && (i = o + v), m + v > a && (i = a - v) } if (this.lngRange) { var y = f.x, g = u.x / 2; y - g < s && (r = s + g), y + g > l && (r = l - g) } void 0 === r && void 0 === i || (this.center = this.unproject(new t.Point(void 0 !== r ? r : f.x, void 0 !== i ? i : f.y))), this._unmodified = c, this._constraining = !1 } }, Sr.prototype._calcMatrices = function () { if (this.height) { var e = this.centerOffset; this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height; var n = Math.PI / 2 + this._pitch, r = this._fov * (.5 + e.y / this.height), i = Math.sin(r) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - n - r, .01, Math.PI - .01)), o = this.point, a = o.x, s = o.y, l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * i + this.cameraToCenterDistance), u = this.height / 50, c = new Float64Array(16); t.perspective(c, this._fov, this.width / this.height, u, l), c[8] = 2 * -e.x / this.width, c[9] = 2 * e.y / this.height, t.scale(c, c, [1, -1, 1]), t.translate(c, c, [0, 0, -this.cameraToCenterDistance]), t.rotateX(c, c, this._pitch), t.rotateZ(c, c, this.angle), t.translate(c, c, [-a, -s, 0]), this.mercatorMatrix = t.scale([], c, [this.worldSize, this.worldSize, this.worldSize]), t.scale(c, c, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = c, this.invProjMatrix = t.invert([], this.projMatrix); var p = this.width % 2 / 2, h = this.height % 2 / 2, f = Math.cos(this.angle), d = Math.sin(this.angle), m = a - Math.round(a) + f * p + d * h, v = s - Math.round(s) + f * h + d * p, y = new Float64Array(c); if (t.translate(y, y, [m > .5 ? m - 1 : m, v > .5 ? v - 1 : v, 0]), this.alignedProjMatrix = y, c = t.create(), t.scale(c, c, [this.width / 2, -this.height / 2, 1]), t.translate(c, c, [1, -1, 0]), this.labelPlaneMatrix = c, c = t.create(), t.scale(c, c, [1, -1, 1]), t.translate(c, c, [-1, -1, 0]), t.scale(c, c, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = c, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(c = t.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix"); this.pixelMatrixInverse = c, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} } }, Sr.prototype.maxPitchScaleFactor = function () { if (!this.pixelMatrixInverse) return 1; var e = this.pointCoordinate(new t.Point(0, 0)), n = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return t.transformMat4(n, n, this.pixelMatrix)[3] / this.cameraToCenterDistance }, Sr.prototype.getCameraPoint = function () { var e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new t.Point(0, e)) }, Sr.prototype.getCameraQueryGeometry = function (e) { var n = this.getCameraPoint(); if (1 === e.length) return [e[0], n]; for (var r = n.x, i = n.y, o = n.x, a = n.y, s = 0, l = e; s < l.length; s += 1) { var u = l[s]; r = Math.min(r, u.x), i = Math.min(i, u.y), o = Math.max(o, u.x), a = Math.max(a, u.y) } return [new t.Point(r, i), new t.Point(o, i), new t.Point(o, a), new t.Point(r, a), new t.Point(r, i)] }, Object.defineProperties(Sr.prototype, Er); var Cr = function (e) { var n, r, i, o; this._hashName = e && encodeURIComponent(e), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (n = this._updateHashUnthrottled.bind(this), r = !1, i = null, o = function () { i = null, r && (n(), i = setTimeout(o, 300), r = !1) }, function () { return r = !0, i || o(), i }) }; Cr.prototype.addTo = function (e) { return this._map = e, t.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this }, Cr.prototype.remove = function () { return t.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this }, Cr.prototype.getHashString = function (e) { var n = this._map.getCenter(), r = Math.round(100 * this._map.getZoom()) / 100, i = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), o = Math.pow(10, i), a = Math.round(n.lng * o) / o, s = Math.round(n.lat * o) / o, l = this._map.getBearing(), u = this._map.getPitch(), c = ""; if (c += e ? "/" + a + "/" + s + "/" + r : r + "/" + s + "/" + a, (l || u) && (c += "/" + Math.round(10 * l) / 10), u && (c += "/" + Math.round(u)), this._hashName) { var p = this._hashName, h = !1, f = t.window.location.hash.slice(1).split("&").map((function (t) { var e = t.split("=")[0]; return e === p ? (h = !0, e + "=" + c) : t })).filter((function (t) { return t })); return h || f.push(p + "=" + c), "#" + f.join("&") } return "#" + c }, Cr.prototype._getCurrentHash = function () { var e, n = this, r = t.window.location.hash.replace("#", ""); return this._hashName ? (r.split("&").map((function (t) { return t.split("=") })).forEach((function (t) { t[0] === n._hashName && (e = t) })), (e && e[1] || "").split("/")) : r.split("/") }, Cr.prototype._onHashChange = function () { var t = this._getCurrentHash(); if (t.length >= 3 && !t.some((function (t) { return isNaN(t) }))) { var e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing(); return this._map.jumpTo({ center: [+t[2], +t[1]], zoom: +t[0], bearing: e, pitch: +(t[4] || 0) }), !0 } return !1 }, Cr.prototype._updateHashUnthrottled = function () { var e = t.window.location.href.replace(/(#.+)?$/, this.getHashString()); try { t.window.history.replaceState(t.window.history.state, null, e) } catch (t) { } }; var Tr = { linearity: .3, easing: t.bezier(0, 0, .3, 1) }, Ar = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Tr), Mr = t.extend({ deceleration: 20, maxSpeed: 1400 }, Tr), Or = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Tr), kr = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Tr), Ir = function (t) { this._map = t, this.clear() }; function Pr(t, e) { (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing) } function Lr(e, n, r) { var i = r.maxSpeed, o = r.linearity, a = r.deceleration, s = t.clamp(e * o / (n / 1e3), -i, i), l = Math.abs(s) / (a * o); return { easing: r.easing, duration: 1e3 * l, amount: s * (l / 2) } } Ir.prototype.clear = function () { this._inertiaBuffer = [] }, Ir.prototype.record = function (e) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.browser.now(), settings: e }) }, Ir.prototype._drainInertiaBuffer = function () { for (var e = this._inertiaBuffer, n = t.browser.now(); e.length > 0 && n - e[0].time > 160;)e.shift() }, Ir.prototype._onMoveEnd = function (e) { if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) { for (var n = { zoom: 0, bearing: 0, pitch: 0, pan: new t.Point(0, 0), pinchAround: void 0, around: void 0 }, r = 0, i = this._inertiaBuffer; r < i.length; r += 1) { var o = i[r].settings; n.zoom += o.zoomDelta || 0, n.bearing += o.bearingDelta || 0, n.pitch += o.pitchDelta || 0, o.panDelta && n.pan._add(o.panDelta), o.around && (n.around = o.around), o.pinchAround && (n.pinchAround = o.pinchAround) } var a = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s = {}; if (n.pan.mag()) { var l = Lr(n.pan.mag(), a, t.extend({}, Ar, e || {})); s.offset = n.pan.mult(l.amount / n.pan.mag()), s.center = this._map.transform.center, Pr(s, l) } if (n.zoom) { var u = Lr(n.zoom, a, Mr); s.zoom = this._map.transform.zoom + u.amount, Pr(s, u) } if (n.bearing) { var c = Lr(n.bearing, a, Or); s.bearing = this._map.transform.bearing + t.clamp(c.amount, -179, 179), Pr(s, c) } if (n.pitch) { var p = Lr(n.pitch, a, kr); s.pitch = this._map.transform.pitch + p.amount, Pr(s, p) } if (s.zoom || s.bearing) { var h = void 0 === n.pinchAround ? n.around : n.pinchAround; s.around = h ? this._map.unproject(h) : this._map.getCenter() } return this.clear(), t.extend(s, { noMoveStart: !0 }) } }; var Rr = function (e) { function r(r, i, o, a) { void 0 === a && (a = {}); var s = n.mousePos(i.getCanvasContainer(), o), l = i.unproject(s); e.call(this, r, t.extend({ point: s, lngLat: l, originalEvent: o }, a)), this._defaultPrevented = !1, this.target = i } e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r; var i = { defaultPrevented: { configurable: !0 } }; return r.prototype.preventDefault = function () { this._defaultPrevented = !0 }, i.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(r.prototype, i), r }(t.Event), Dr = function (e) { function r(r, i, o) { var a = "touchend" === r ? o.changedTouches : o.touches, s = n.touchPos(i.getCanvasContainer(), a), l = s.map((function (t) { return i.unproject(t) })), u = s.reduce((function (t, e, n, r) { return t.add(e.div(r.length)) }), new t.Point(0, 0)), c = i.unproject(u); e.call(this, r, { points: s, point: u, lngLats: l, lngLat: c, originalEvent: o }), this._defaultPrevented = !1 } e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r; var i = { defaultPrevented: { configurable: !0 } }; return r.prototype.preventDefault = function () { this._defaultPrevented = !0 }, i.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(r.prototype, i), r }(t.Event), Nr = function (t) { function e(e, n, r) { t.call(this, e, { originalEvent: r }), this._defaultPrevented = !1 } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { defaultPrevented: { configurable: !0 } }; return e.prototype.preventDefault = function () { this._defaultPrevented = !0 }, n.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(e.prototype, n), e }(t.Event), zr = function (t, e) { this._map = t, this._clickTolerance = e.clickTolerance }; zr.prototype.reset = function () { delete this._mousedownPos }, zr.prototype.wheel = function (t) { return this._firePreventable(new Nr(t.type, this._map, t)) }, zr.prototype.mousedown = function (t, e) { return this._mousedownPos = e, this._firePreventable(new Rr(t.type, this._map, t)) }, zr.prototype.mouseup = function (t) { this._map.fire(new Rr(t.type, this._map, t)) }, zr.prototype.click = function (t, e) { this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new Rr(t.type, this._map, t)) }, zr.prototype.dblclick = function (t) { return this._firePreventable(new Rr(t.type, this._map, t)) }, zr.prototype.mouseover = function (t) { this._map.fire(new Rr(t.type, this._map, t)) }, zr.prototype.mouseout = function (t) { this._map.fire(new Rr(t.type, this._map, t)) }, zr.prototype.touchstart = function (t) { return this._firePreventable(new Dr(t.type, this._map, t)) }, zr.prototype.touchmove = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, zr.prototype.touchend = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, zr.prototype.touchcancel = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, zr.prototype._firePreventable = function (t) { if (this._map.fire(t), t.defaultPrevented) return {} }, zr.prototype.isEnabled = function () { return !0 }, zr.prototype.isActive = function () { return !1 }, zr.prototype.enable = function () { }, zr.prototype.disable = function () { }; var Fr = function (t) { this._map = t }; Fr.prototype.reset = function () { this._delayContextMenu = !1, delete this._contextMenuEvent }, Fr.prototype.mousemove = function (t) { this._map.fire(new Rr(t.type, this._map, t)) }, Fr.prototype.mousedown = function () { this._delayContextMenu = !0 }, Fr.prototype.mouseup = function () { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Rr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent) }, Fr.prototype.contextmenu = function (t) { this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Rr(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault() }, Fr.prototype.isEnabled = function () { return !0 }, Fr.prototype.isActive = function () { return !1 }, Fr.prototype.enable = function () { }, Fr.prototype.disable = function () { }; var Br = function (t, e) { this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1 }; function jr(t, e) { for (var n = {}, r = 0; r < t.length; r++)n[t[r].identifier] = e[r]; return n } Br.prototype.isEnabled = function () { return !!this._enabled }, Br.prototype.isActive = function () { return !!this._active }, Br.prototype.enable = function () { this.isEnabled() || (this._enabled = !0) }, Br.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, Br.prototype.mousedown = function (t, e) { this.isEnabled() && t.shiftKey && 0 === t.button && (n.disableDrag(), this._startPos = this._lastPos = e, this._active = !0) }, Br.prototype.mousemoveWindow = function (t, e) { if (this._active) { var r = e; if (!(this._lastPos.equals(r) || !this._box && r.dist(this._startPos) < this._clickTolerance)) { var i = this._startPos; this._lastPos = r, this._box || (this._box = n.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t)); var o = Math.min(i.x, r.x), a = Math.max(i.x, r.x), s = Math.min(i.y, r.y), l = Math.max(i.y, r.y); n.setTransform(this._box, "translate(" + o + "px," + s + "px)"), this._box.style.width = a - o + "px", this._box.style.height = l - s + "px" } } }, Br.prototype.mouseupWindow = function (e, r) { var i = this; if (this._active && 0 === e.button) { var o = this._startPos, a = r; if (this.reset(), n.suppressClick(), o.x !== a.x || o.y !== a.y) return this._map.fire(new t.Event("boxzoomend", { originalEvent: e })), { cameraAnimation: function (t) { return t.fitScreenCoordinates(o, a, i._map.getBearing(), { linear: !0 }) } }; this._fireEvent("boxzoomcancel", e) } }, Br.prototype.keydown = function (t) { this._active && 27 === t.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t)) }, Br.prototype.blur = function () { this.reset() }, Br.prototype.reset = function () { this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos }, Br.prototype._fireEvent = function (e, n) { return this._map.fire(new t.Event(e, { originalEvent: n })) }; var Ur = function (t) { this.reset(), this.numTouches = t.numTouches }; Ur.prototype.reset = function () { delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1 }, Ur.prototype.touchstart = function (e, n, r) { (this.centroid || r.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), r.length === this.numTouches && (this.centroid = function (e) { for (var n = new t.Point(0, 0), r = 0, i = e; r < i.length; r += 1)n._add(i[r]); return n.div(e.length) }(n), this.touches = jr(r, n))) }, Ur.prototype.touchmove = function (t, e, n) { if (!this.aborted && this.centroid) { var r = jr(n, e); for (var i in this.touches) { var o = r[i]; (!o || o.dist(this.touches[i]) > 30) && (this.aborted = !0) } } }, Ur.prototype.touchend = function (t, e, n) { if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === n.length) { var r = !this.aborted && this.centroid; if (this.reset(), r) return r } }; var Vr = function (t) { this.singleTap = new Ur(t), this.numTaps = t.numTaps, this.reset() }; Vr.prototype.reset = function () { this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset() }, Vr.prototype.touchstart = function (t, e, n) { this.singleTap.touchstart(t, e, n) }, Vr.prototype.touchmove = function (t, e, n) { this.singleTap.touchmove(t, e, n) }, Vr.prototype.touchend = function (t, e, n) { var r = this.singleTap.touchend(t, e, n); if (r) { var i = t.timeStamp - this.lastTime < 500, o = !this.lastTap || this.lastTap.dist(r) < 30; if (i && o || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = r, this.count === this.numTaps) return this.reset(), r } }; var Gr = function () { this._zoomIn = new Vr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vr({ numTouches: 2, numTaps: 1 }), this.reset() }; Gr.prototype.reset = function () { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset() }, Gr.prototype.touchstart = function (t, e, n) { this._zoomIn.touchstart(t, e, n), this._zoomOut.touchstart(t, e, n) }, Gr.prototype.touchmove = function (t, e, n) { this._zoomIn.touchmove(t, e, n), this._zoomOut.touchmove(t, e, n) }, Gr.prototype.touchend = function (t, e, n) { var r = this, i = this._zoomIn.touchend(t, e, n), o = this._zoomOut.touchend(t, e, n); return i ? (this._active = !0, t.preventDefault(), setTimeout((function () { return r.reset() }), 0), { cameraAnimation: function (e) { return e.easeTo({ duration: 300, zoom: e.getZoom() + 1, around: e.unproject(i) }, { originalEvent: t }) } }) : o ? (this._active = !0, t.preventDefault(), setTimeout((function () { return r.reset() }), 0), { cameraAnimation: function (e) { return e.easeTo({ duration: 300, zoom: e.getZoom() - 1, around: e.unproject(o) }, { originalEvent: t }) } }) : void 0 }, Gr.prototype.touchcancel = function () { this.reset() }, Gr.prototype.enable = function () { this._enabled = !0 }, Gr.prototype.disable = function () { this._enabled = !1, this.reset() }, Gr.prototype.isEnabled = function () { return this._enabled }, Gr.prototype.isActive = function () { return this._active }; var Hr = { 0: 1, 2: 2 }, Wr = function (t) { this.reset(), this._clickTolerance = t.clickTolerance || 1 }; Wr.prototype.blur = function () { this.reset() }, Wr.prototype.reset = function () { this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton }, Wr.prototype._correctButton = function (t, e) { return !1 }, Wr.prototype._move = function (t, e) { return {} }, Wr.prototype.mousedown = function (t, e) { if (!this._lastPoint) { var r = n.mouseButton(t); this._correctButton(t, r) && (this._lastPoint = e, this._eventButton = r) } }, Wr.prototype.mousemoveWindow = function (t, e) { var n = this._lastPoint; if (n) if (t.preventDefault(), function (t, e) { var n = Hr[e]; return void 0 === t.buttons || (t.buttons & n) !== n }(t, this._eventButton)) this.reset(); else if (this._moved || !(e.dist(n) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(n, e) }, Wr.prototype.mouseupWindow = function (t) { this._lastPoint && n.mouseButton(t) === this._eventButton && (this._moved && n.suppressClick(), this.reset()) }, Wr.prototype.enable = function () { this._enabled = !0 }, Wr.prototype.disable = function () { this._enabled = !1, this.reset() }, Wr.prototype.isEnabled = function () { return this._enabled }, Wr.prototype.isActive = function () { return this._active }; var Xr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.mousedown = function (e, n) { t.prototype.mousedown.call(this, e, n), this._lastPoint && (this._active = !0) }, e.prototype._correctButton = function (t, e) { return 0 === e && !t.ctrlKey }, e.prototype._move = function (t, e) { return { around: e, panDelta: e.sub(t) } }, e }(Wr), qr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) { return 0 === e && t.ctrlKey || 2 === e }, e.prototype._move = function (t, e) { var n = .8 * (e.x - t.x); if (n) return this._active = !0, { bearingDelta: n } }, e.prototype.contextmenu = function (t) { t.preventDefault() }, e }(Wr), Zr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) { return 0 === e && t.ctrlKey || 2 === e }, e.prototype._move = function (t, e) { var n = -.5 * (e.y - t.y); if (n) return this._active = !0, { pitchDelta: n } }, e.prototype.contextmenu = function (t) { t.preventDefault() }, e }(Wr), Yr = function (t) { this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset() }; Yr.prototype.reset = function () { this._active = !1, this._touches = {}, this._sum = new t.Point(0, 0) }, Yr.prototype.touchstart = function (t, e, n) { return this._calculateTransform(t, e, n) }, Yr.prototype.touchmove = function (t, e, n) { if (this._active && !(n.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, n) }, Yr.prototype.touchend = function (t, e, n) { this._calculateTransform(t, e, n), this._active && n.length < this._minTouches && this.reset() }, Yr.prototype.touchcancel = function () { this.reset() }, Yr.prototype._calculateTransform = function (e, n, r) { r.length > 0 && (this._active = !0); var i = jr(r, n), o = new t.Point(0, 0), a = new t.Point(0, 0), s = 0; for (var l in i) { var u = i[l], c = this._touches[l]; c && (o._add(u), a._add(u.sub(c)), s++, i[l] = u) } if (this._touches = i, !(s < this._minTouches) && a.mag()) { var p = a.div(s); if (this._sum._add(p), !(this._sum.mag() < this._clickTolerance)) return { around: o.div(s), panDelta: p } } }, Yr.prototype.enable = function () { this._enabled = !0 }, Yr.prototype.disable = function () { this._enabled = !1, this.reset() }, Yr.prototype.isEnabled = function () { return this._enabled }, Yr.prototype.isActive = function () { return this._active }; var Kr = function () { this.reset() }; function Qr(t, e, n) { for (var r = 0; r < t.length; r++)if (t[r].identifier === n) return e[r] } function Jr(t, e) { return Math.log(t / e) / Math.LN2 } Kr.prototype.reset = function () { this._active = !1, delete this._firstTwoTouches }, Kr.prototype._start = function (t) { }, Kr.prototype._move = function (t, e, n) { return {} }, Kr.prototype.touchstart = function (t, e, n) { this._firstTwoTouches || n.length < 2 || (this._firstTwoTouches = [n[0].identifier, n[1].identifier], this._start([e[0], e[1]])) }, Kr.prototype.touchmove = function (t, e, n) { if (this._firstTwoTouches) { t.preventDefault(); var r = this._firstTwoTouches, i = r[1], o = Qr(n, e, r[0]), a = Qr(n, e, i); if (o && a) { var s = this._aroundCenter ? null : o.add(a).div(2); return this._move([o, a], s, t) } } }, Kr.prototype.touchend = function (t, e, r) { if (this._firstTwoTouches) { var i = this._firstTwoTouches, o = i[1], a = Qr(r, e, i[0]), s = Qr(r, e, o); a && s || (this._active && n.suppressClick(), this.reset()) } }, Kr.prototype.touchcancel = function () { this.reset() }, Kr.prototype.enable = function (t) { this._enabled = !0, this._aroundCenter = !!t && "center" === t.around }, Kr.prototype.disable = function () { this._enabled = !1, this.reset() }, Kr.prototype.isEnabled = function () { return this._enabled }, Kr.prototype.isActive = function () { return this._active }; var $r = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), delete this._distance, delete this._startDistance }, e.prototype._start = function (t) { this._startDistance = this._distance = t[0].dist(t[1]) }, e.prototype._move = function (t, e) { var n = this._distance; if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Jr(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Jr(this._distance, n), pinchAround: e } }, e }(Kr); function ti(t, e) { return 180 * t.angleWith(e) / Math.PI } var ei = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector }, e.prototype._start = function (t) { this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]) }, e.prototype._move = function (t, e) { var n = this._vector; if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: ti(this._vector, n), pinchAround: e } }, e.prototype._isBelowThreshold = function (t) { this._minDiameter = Math.min(this._minDiameter, t.mag()); var e = 25 / (Math.PI * this._minDiameter) * 360, n = ti(t, this._startVector); return Math.abs(n) < e }, e }(Kr); function ni(t) { return Math.abs(t.y) > Math.abs(t.x) } var ri = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints }, e.prototype._start = function (t) { this._lastPoints = t, ni(t[0].sub(t[1])) && (this._valid = !1) }, e.prototype._move = function (t, e, n) { var r = t[0].sub(this._lastPoints[0]), i = t[1].sub(this._lastPoints[1]); if (this._valid = this.gestureBeginsVertically(r, i, n.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, { pitchDelta: (r.y + i.y) / 2 * -.5 } }, e.prototype.gestureBeginsVertically = function (t, e, n) { if (void 0 !== this._valid) return this._valid; var r = t.mag() >= 2, i = e.mag() >= 2; if (r || i) { if (!r || !i) return void 0 === this._firstMove && (this._firstMove = n), n - this._firstMove < 100 && void 0; var o = t.y > 0 == e.y > 0; return ni(t) && ni(e) && o } }, e }(Kr), ii = { panStep: 100, bearingStep: 15, pitchStep: 10 }, oi = function () { var t = ii; this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1 }; function ai(t) { return t * (2 - t) } oi.prototype.blur = function () { this.reset() }, oi.prototype.reset = function () { this._active = !1 }, oi.prototype.keydown = function (t) { var e = this; if (!(t.altKey || t.ctrlKey || t.metaKey)) { var n = 0, r = 0, i = 0, o = 0, a = 0; switch (t.keyCode) { case 61: case 107: case 171: case 187: n = 1; break; case 189: case 109: case 173: n = -1; break; case 37: t.shiftKey ? r = -1 : (t.preventDefault(), o = -1); break; case 39: t.shiftKey ? r = 1 : (t.preventDefault(), o = 1); break; case 38: t.shiftKey ? i = 1 : (t.preventDefault(), a = -1); break; case 40: t.shiftKey ? i = -1 : (t.preventDefault(), a = 1); break; default: return }return this._rotationDisabled && (r = 0, i = 0), { cameraAnimation: function (s) { var l = s.getZoom(); s.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ai, zoom: n ? Math.round(l) + n * (t.shiftKey ? 2 : 1) : l, bearing: s.getBearing() + r * e._bearingStep, pitch: s.getPitch() + i * e._pitchStep, offset: [-o * e._panStep, -a * e._panStep], center: s.getCenter() }, { originalEvent: t }) } } } }, oi.prototype.enable = function () { this._enabled = !0 }, oi.prototype.disable = function () { this._enabled = !1, this.reset() }, oi.prototype.isEnabled = function () { return this._enabled }, oi.prototype.isActive = function () { return this._active }, oi.prototype.disableRotation = function () { this._rotationDisabled = !0 }, oi.prototype.enableRotation = function () { this._rotationDisabled = !1 }; var si = function (e, n) { this._map = e, this._el = e.getCanvasContainer(), this._handler = n, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this) }; si.prototype.setZoomRate = function (t) { this._defaultZoomRate = t }, si.prototype.setWheelZoomRate = function (t) { this._wheelZoomRate = t }, si.prototype.isEnabled = function () { return !!this._enabled }, si.prototype.isActive = function () { return !!this._active || void 0 !== this._finishTimeout }, si.prototype.isZooming = function () { return !!this._zooming }, si.prototype.enable = function (t) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around) }, si.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, si.prototype.wheel = function (e) { if (this.isEnabled()) { var n = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY, r = t.browser.now(), i = r - (this._lastWheelEventTime || 0); this._lastWheelEventTime = r, 0 !== n && n % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== n && Math.abs(n) < 4 ? this._type = "trackpad" : i > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(i * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), e.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = e, this._delta -= n, this._active || this._start(e)), e.preventDefault() } }, si.prototype._onTimeout = function (t) { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t) }, si.prototype._start = function (e) { if (this._delta) { this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); var r = n.mousePos(this._el, e); this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(r)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame()) } }, si.prototype.renderFrame = function () { var e = this; if (this._frameId && (this._frameId = null, this.isActive())) { var n = this._map.transform; if (0 !== this._delta) { var r = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, i = 2 / (1 + Math.exp(-Math.abs(this._delta * r))); this._delta < 0 && 0 !== i && (i = 1 / i); var o = "number" == typeof this._targetZoom ? n.zoomScale(this._targetZoom) : n.scale; this._targetZoom = Math.min(n.maxZoom, Math.max(n.minZoom, n.scaleZoom(o * i))), "wheel" === this._type && (this._startZoom = n.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0 } var a, s = "number" == typeof this._targetZoom ? this._targetZoom : n.zoom, l = this._startZoom, u = this._easing, c = !1; if ("wheel" === this._type && l && u) { var p = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), h = u(p); a = t.number(l, s, h), p < 1 ? this._frameId || (this._frameId = !0) : c = !0 } else a = s, c = !0; return this._active = !0, c && (this._active = !1, this._finishTimeout = setTimeout((function () { e._zooming = !1, e._handler._triggerRenderFrame(), delete e._targetZoom, delete e._finishTimeout }), 200)), { noInertia: !0, needsRenderFrame: !c, zoomDelta: a - n.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent } } }, si.prototype._smoothOutEasing = function (e) { var n = t.ease; if (this._prevEase) { var r = this._prevEase, i = (t.browser.now() - r.start) / r.duration, o = r.easing(i + .01) - r.easing(i), a = .27 / Math.sqrt(o * o + 1e-4) * .01, s = Math.sqrt(.0729 - a * a); n = t.bezier(a, s, .25, 1) } return this._prevEase = { start: t.browser.now(), duration: e, easing: n }, n }, si.prototype.blur = function () { this.reset() }, si.prototype.reset = function () { this._active = !1 }; var li = function (t, e) { this._clickZoom = t, this._tapZoom = e }; li.prototype.enable = function () { this._clickZoom.enable(), this._tapZoom.enable() }, li.prototype.disable = function () { this._clickZoom.disable(), this._tapZoom.disable() }, li.prototype.isEnabled = function () { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() }, li.prototype.isActive = function () { return this._clickZoom.isActive() || this._tapZoom.isActive() }; var ui = function () { this.reset() }; ui.prototype.reset = function () { this._active = !1 }, ui.prototype.blur = function () { this.reset() }, ui.prototype.dblclick = function (t, e) { return t.preventDefault(), { cameraAnimation: function (n) { n.easeTo({ duration: 300, zoom: n.getZoom() + (t.shiftKey ? -1 : 1), around: n.unproject(e) }, { originalEvent: t }) } } }, ui.prototype.enable = function () { this._enabled = !0 }, ui.prototype.disable = function () { this._enabled = !1, this.reset() }, ui.prototype.isEnabled = function () { return this._enabled }, ui.prototype.isActive = function () { return this._active }; var ci = function () { this._tap = new Vr({ numTouches: 1, numTaps: 1 }), this.reset() }; ci.prototype.reset = function () { this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset() }, ci.prototype.touchstart = function (t, e, n) { this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? n.length > 0 && (this._swipePoint = e[0], this._swipeTouch = n[0].identifier) : this._tap.touchstart(t, e, n)) }, ci.prototype.touchmove = function (t, e, n) { if (this._tapTime) { if (this._swipePoint) { if (n[0].identifier !== this._swipeTouch) return; var r = e[0], i = r.y - this._swipePoint.y; return this._swipePoint = r, t.preventDefault(), this._active = !0, { zoomDelta: i / 128 } } } else this._tap.touchmove(t, e, n) }, ci.prototype.touchend = function (t, e, n) { this._tapTime ? this._swipePoint && 0 === n.length && this.reset() : this._tap.touchend(t, e, n) && (this._tapTime = t.timeStamp) }, ci.prototype.touchcancel = function () { this.reset() }, ci.prototype.enable = function () { this._enabled = !0 }, ci.prototype.disable = function () { this._enabled = !1, this.reset() }, ci.prototype.isEnabled = function () { return this._enabled }, ci.prototype.isActive = function () { return this._active }; var pi = function (t, e, n) { this._el = t, this._mousePan = e, this._touchPan = n }; pi.prototype.enable = function (t) { this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan") }, pi.prototype.disable = function () { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan") }, pi.prototype.isEnabled = function () { return this._mousePan.isEnabled() && this._touchPan.isEnabled() }, pi.prototype.isActive = function () { return this._mousePan.isActive() || this._touchPan.isActive() }; var hi = function (t, e, n) { this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = n }; hi.prototype.enable = function () { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable() }, hi.prototype.disable = function () { this._mouseRotate.disable(), this._mousePitch.disable() }, hi.prototype.isEnabled = function () { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) }, hi.prototype.isActive = function () { return this._mouseRotate.isActive() || this._mousePitch.isActive() }; var fi = function (t, e, n, r) { this._el = t, this._touchZoom = e, this._touchRotate = n, this._tapDragZoom = r, this._rotationDisabled = !1, this._enabled = !0 }; fi.prototype.enable = function (t) { this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate") }, fi.prototype.disable = function () { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate") }, fi.prototype.isEnabled = function () { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() }, fi.prototype.isActive = function () { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() }, fi.prototype.disableRotation = function () { this._rotationDisabled = !0, this._touchRotate.disable() }, fi.prototype.enableRotation = function () { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable() }; var di = function (t) { return t.zoom || t.drag || t.pitch || t.rotate }, mi = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(t.Event); function vi(t) { return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta } var yi = function (e, r) { this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ir(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r), t.bindAll(["handleEvent", "handleWindowEvent"], this); var i = this._el; this._listeners = [[i, "touchstart", { passive: !0 }], [i, "touchmove", { passive: !1 }], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [t.window.document, "mousemove", { capture: !0 }], [t.window.document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", { capture: !1 }], [i, "keyup", void 0], [i, "wheel", { passive: !1 }], [i, "contextmenu", void 0], [t.window, "blur", void 0]]; for (var o = 0, a = this._listeners; o < a.length; o += 1) { var s = a[o], l = s[0]; n.addEventListener(l, s[1], l === t.window.document ? this.handleWindowEvent : this.handleEvent, s[2]) } }; yi.prototype.destroy = function () { for (var e = 0, r = this._listeners; e < r.length; e += 1) { var i = r[e], o = i[0]; n.removeEventListener(o, i[1], o === t.window.document ? this.handleWindowEvent : this.handleEvent, i[2]) } }, yi.prototype._addDefaultHandlers = function (t) { var e = this._map, n = e.getCanvasContainer(); this._add("mapEvent", new zr(e, t)); var r = e.boxZoom = new Br(e, t); this._add("boxZoom", r); var i = new Gr, o = new ui; e.doubleClickZoom = new li(o, i), this._add("tapZoom", i), this._add("clickZoom", o); var a = new ci; this._add("tapDragZoom", a); var s = e.touchPitch = new ri; this._add("touchPitch", s); var l = new qr(t), u = new Zr(t); e.dragRotate = new hi(t, l, u), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", u, ["mouseRotate"]); var c = new Xr(t), p = new Yr(t); e.dragPan = new pi(n, c, p), this._add("mousePan", c), this._add("touchPan", p, ["touchZoom", "touchRotate"]); var h = new ei, f = new $r; e.touchZoomRotate = new fi(n, f, h, a), this._add("touchRotate", h, ["touchPan", "touchZoom"]), this._add("touchZoom", f, ["touchPan", "touchRotate"]); var d = e.scrollZoom = new si(e, this); this._add("scrollZoom", d, ["mousePan"]); var m = e.keyboard = new oi; this._add("keyboard", m), this._add("blockableMapEvent", new Fr(e)); for (var v = 0, y = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; v < y.length; v += 1) { var g = y[v]; t.interactive && t[g] && e[g].enable(t[g]) } }, yi.prototype._add = function (t, e, n) { this._handlers.push({ handlerName: t, handler: e, allowed: n }), this._handlersById[t] = e }, yi.prototype.stop = function (t) { if (!this._updatingCamera) { for (var e = 0, n = this._handlers; e < n.length; e += 1)n[e].handler.reset(); this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [] } }, yi.prototype.isActive = function () { for (var t = 0, e = this._handlers; t < e.length; t += 1)if (e[t].handler.isActive()) return !0; return !1 }, yi.prototype.isZooming = function () { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() }, yi.prototype.isRotating = function () { return !!this._eventsInProgress.rotate }, yi.prototype.isMoving = function () { return Boolean(di(this._eventsInProgress)) || this.isZooming() }, yi.prototype._blockedByActive = function (t, e, n) { for (var r in t) if (r !== n && (!e || e.indexOf(r) < 0)) return !0; return !1 }, yi.prototype.handleWindowEvent = function (t) { this.handleEvent(t, t.type + "Window") }, yi.prototype._getMapTouches = function (t) { for (var e = [], n = 0, r = t; n < r.length; n += 1) { var i = r[n]; this._el.contains(i.target) && e.push(i) } return e }, yi.prototype.handleEvent = function (t, e) { this._updatingCamera = !0; for (var r = "renderFrame" === t.type ? void 0 : t, i = { needsRenderFrame: !1 }, o = {}, a = {}, s = t.touches ? this._getMapTouches(t.touches) : void 0, l = s ? n.touchPos(this._el, s) : n.mousePos(this._el, t), u = 0, c = this._handlers; u < c.length; u += 1) { var p = c[u], h = p.handlerName, f = p.handler, d = p.allowed; if (f.isEnabled()) { var m = void 0; this._blockedByActive(a, d, h) ? f.reset() : f[e || t.type] && (m = f[e || t.type](t, l, s), this.mergeHandlerResult(i, o, m, h, r), m && m.needsRenderFrame && this._triggerRenderFrame()), (m || f.isActive()) && (a[h] = f) } } var v = {}; for (var y in this._previousActiveHandlers) a[y] || (v[y] = r); this._previousActiveHandlers = a, (Object.keys(v).length || vi(i)) && (this._changes.push([i, o, v]), this._triggerRenderFrame()), (Object.keys(a).length || vi(i)) && this._map._stop(!0), this._updatingCamera = !1; var g = i.cameraAnimation; g && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], g(this._map)) }, yi.prototype.mergeHandlerResult = function (e, n, r, i, o) { if (r) { t.extend(e, r); var a = { handlerName: i, originalEvent: r.originalEvent || o }; void 0 !== r.zoomDelta && (n.zoom = a), void 0 !== r.panDelta && (n.drag = a), void 0 !== r.pitchDelta && (n.pitch = a), void 0 !== r.bearingDelta && (n.rotate = a) } }, yi.prototype._applyChanges = function () { for (var e = {}, n = {}, r = {}, i = 0, o = this._changes; i < o.length; i += 1) { var a = o[i], s = a[0], l = a[1], u = a[2]; s.panDelta && (e.panDelta = (e.panDelta || new t.Point(0, 0))._add(s.panDelta)), s.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (e.around = s.around), void 0 !== s.pinchAround && (e.pinchAround = s.pinchAround), s.noInertia && (e.noInertia = s.noInertia), t.extend(n, l), t.extend(r, u) } this._updateMapTransform(e, n, r), this._changes = [] }, yi.prototype._updateMapTransform = function (t, e, n) { var r = this._map, i = r.transform; if (!vi(t)) return this._fireEvents(e, n, !0); var o = t.panDelta, a = t.zoomDelta, s = t.bearingDelta, l = t.pitchDelta, u = t.around, c = t.pinchAround; void 0 !== c && (u = c), r._stop(!0), u = u || r.transform.centerPoint; var p = i.pointLocation(o ? u.sub(o) : u); s && (i.bearing += s), l && (i.pitch += l), a && (i.zoom += a), i.setLocationAtPoint(p, u), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, n, !0) }, yi.prototype._fireEvents = function (e, n, r) { var i = this, o = di(this._eventsInProgress), a = di(e), s = {}; for (var l in e) this._eventsInProgress[l] || (s[l + "start"] = e[l].originalEvent), this._eventsInProgress[l] = e[l]; for (var u in !o && a && this._fireEvent("movestart", a.originalEvent), s) this._fireEvent(u, s[u]); for (var c in a && this._fireEvent("move", a.originalEvent), e) this._fireEvent(c, e[c].originalEvent); var p, h = {}; for (var f in this._eventsInProgress) { var d = this._eventsInProgress[f], m = d.handlerName, v = d.originalEvent; this._handlersById[m].isActive() || (delete this._eventsInProgress[f], h[f + "end"] = p = n[m] || v) } for (var y in h) this._fireEvent(y, h[y]); var g = di(this._eventsInProgress); if (r && (o || a) && !g) { this._updatingCamera = !0; var _ = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), x = function (t) { return 0 !== t && -i._bearingSnap < t && t < i._bearingSnap }; _ ? (x(_.bearing || this._map.getBearing()) && (_.bearing = 0), this._map.easeTo(_, { originalEvent: p })) : (this._map.fire(new t.Event("moveend", { originalEvent: p })), x(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1 } }, yi.prototype._fireEvent = function (e, n) { this._map.fire(new t.Event(e, n ? { originalEvent: n } : {})) }, yi.prototype._requestFrame = function () { var t = this; return this._map.triggerRepaint(), this._map._renderTaskQueue.add((function (e) { delete t._frameId, t.handleEvent(new mi("renderFrame", { timeStamp: e })), t._applyChanges() })) }, yi.prototype._triggerRenderFrame = function () { void 0 === this._frameId && (this._frameId = this._requestFrame()) }; var gi = function (e) { function n(n, r) { e.call(this), this._moving = !1, this._zooming = !1, this.transform = n, this._bearingSnap = r.bearingSnap, t.bindAll(["_renderFrameCallback"], this) } return e && (n.__proto__ = e), (n.prototype = Object.create(e && e.prototype)).constructor = n, n.prototype.getCenter = function () { return new t.LngLat(this.transform.center.lng, this.transform.center.lat) }, n.prototype.setCenter = function (t, e) { return this.jumpTo({ center: t }, e) }, n.prototype.panBy = function (e, n, r) { return e = t.Point.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e }, n), r) }, n.prototype.panTo = function (e, n, r) { return this.easeTo(t.extend({ center: e }, n), r) }, n.prototype.getZoom = function () { return this.transform.zoom }, n.prototype.setZoom = function (t, e) { return this.jumpTo({ zoom: t }, e), this }, n.prototype.zoomTo = function (e, n, r) { return this.easeTo(t.extend({ zoom: e }, n), r) }, n.prototype.zoomIn = function (t, e) { return this.zoomTo(this.getZoom() + 1, t, e), this }, n.prototype.zoomOut = function (t, e) { return this.zoomTo(this.getZoom() - 1, t, e), this }, n.prototype.getBearing = function () { return this.transform.bearing }, n.prototype.setBearing = function (t, e) { return this.jumpTo({ bearing: t }, e), this }, n.prototype.getPadding = function () { return this.transform.padding }, n.prototype.setPadding = function (t, e) { return this.jumpTo({ padding: t }, e), this }, n.prototype.rotateTo = function (e, n, r) { return this.easeTo(t.extend({ bearing: e }, n), r) }, n.prototype.resetNorth = function (e, n) { return this.rotateTo(0, t.extend({ duration: 1e3 }, e), n), this }, n.prototype.resetNorthPitch = function (e, n) { return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e), n), this }, n.prototype.snapToNorth = function (t, e) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this }, n.prototype.getPitch = function () { return this.transform.pitch }, n.prototype.setPitch = function (t, e) { return this.jumpTo({ pitch: t }, e), this }, n.prototype.cameraForBounds = function (e, n) { e = t.LngLatBounds.convert(e); var r = n && n.bearing || 0; return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), r, n) }, n.prototype._cameraForBoxAndBearing = function (e, n, r, i) { var o = { top: 0, bottom: 0, right: 0, left: 0 }; if ("number" == typeof (i = t.extend({ padding: o, offset: [0, 0], maxZoom: this.transform.maxZoom }, i)).padding) { var a = i.padding; i.padding = { top: a, bottom: a, right: a, left: a } } i.padding = t.extend(o, i.padding); var s = this.transform, l = s.padding, u = s.project(t.LngLat.convert(e)), c = s.project(t.LngLat.convert(n)), p = u.rotate(-r * Math.PI / 180), h = c.rotate(-r * Math.PI / 180), f = new t.Point(Math.max(p.x, h.x), Math.max(p.y, h.y)), d = new t.Point(Math.min(p.x, h.x), Math.min(p.y, h.y)), m = f.sub(d), v = (s.width - (l.left + l.right + i.padding.left + i.padding.right)) / m.x, y = (s.height - (l.top + l.bottom + i.padding.top + i.padding.bottom)) / m.y; if (!(y < 0 || v < 0)) { var g = Math.min(s.scaleZoom(s.scale * Math.min(v, y)), i.maxZoom), _ = "number" == typeof i.offset.x ? new t.Point(i.offset.x, i.offset.y) : t.Point.convert(i.offset), x = new t.Point((i.padding.left - i.padding.right) / 2, (i.padding.top - i.padding.bottom) / 2).rotate(r * Math.PI / 180), b = _.add(x).mult(s.scale / s.zoomScale(g)); return { center: s.unproject(u.add(c).div(2).sub(b)), zoom: g, bearing: r } } t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.") }, n.prototype.fitBounds = function (t, e, n) { return this._fitInternal(this.cameraForBounds(t, e), e, n) }, n.prototype.fitScreenCoordinates = function (e, n, r, i, o) { return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)), this.transform.pointLocation(t.Point.convert(n)), r, i), i, o) }, n.prototype._fitInternal = function (e, n, r) { return e ? (delete (n = t.extend(e, n)).padding, n.linear ? this.easeTo(n, r) : this.flyTo(n, r)) : this }, n.prototype.jumpTo = function (e, n) { this.stop(); var r = this.transform, i = !1, o = !1, a = !1; return "zoom" in e && r.zoom !== +e.zoom && (i = !0, r.zoom = +e.zoom), void 0 !== e.center && (r.center = t.LngLat.convert(e.center)), "bearing" in e && r.bearing !== +e.bearing && (o = !0, r.bearing = +e.bearing), "pitch" in e && r.pitch !== +e.pitch && (a = !0, r.pitch = +e.pitch), null == e.padding || r.isPaddingEqual(e.padding) || (r.padding = e.padding), this.fire(new t.Event("movestart", n)).fire(new t.Event("move", n)), i && this.fire(new t.Event("zoomstart", n)).fire(new t.Event("zoom", n)).fire(new t.Event("zoomend", n)), o && this.fire(new t.Event("rotatestart", n)).fire(new t.Event("rotate", n)).fire(new t.Event("rotateend", n)), a && this.fire(new t.Event("pitchstart", n)).fire(new t.Event("pitch", n)).fire(new t.Event("pitchend", n)), this.fire(new t.Event("moveend", n)) }, n.prototype.easeTo = function (e, n) { var r = this; this._stop(!1, e.easeId), (!1 === (e = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e)).animate || !e.essential && t.browser.prefersReducedMotion) && (e.duration = 0); var i = this.transform, o = this.getZoom(), a = this.getBearing(), s = this.getPitch(), l = this.getPadding(), u = "zoom" in e ? +e.zoom : o, c = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a, p = "pitch" in e ? +e.pitch : s, h = "padding" in e ? e.padding : i.padding, f = t.Point.convert(e.offset), d = i.centerPoint.add(f), m = i.pointLocation(d), v = t.LngLat.convert(e.center || m); this._normalizeCenter(v); var y, g, _ = i.project(m), x = i.project(v).sub(_), b = i.zoomScale(u - o); e.around && (y = t.LngLat.convert(e.around), g = i.locationPoint(y)); var w = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching }; return this._zooming = this._zooming || u !== o, this._rotating = this._rotating || a !== c, this._pitching = this._pitching || p !== s, this._padding = !i.isPaddingEqual(h), this._easeId = e.easeId, this._prepareEase(n, e.noMoveStart, w), this._ease((function (e) { if (r._zooming && (i.zoom = t.number(o, u, e)), r._rotating && (i.bearing = t.number(a, c, e)), r._pitching && (i.pitch = t.number(s, p, e)), r._padding && (i.interpolatePadding(l, h, e), d = i.centerPoint.add(f)), y) i.setLocationAtPoint(y, g); else { var m = i.zoomScale(i.zoom - o), v = u > o ? Math.min(2, b) : Math.max(.5, b), w = Math.pow(v, 1 - e), S = i.unproject(_.add(x.mult(e * w)).mult(m)); i.setLocationAtPoint(i.renderWorldCopies ? S.wrap() : S, d) } r._fireMoveEvents(n) }), (function (t) { r._afterEase(n, t) }), e), this }, n.prototype._prepareEase = function (e, n, r) { void 0 === r && (r = {}), this._moving = !0, n || r.moving || this.fire(new t.Event("movestart", e)), this._zooming && !r.zooming && this.fire(new t.Event("zoomstart", e)), this._rotating && !r.rotating && this.fire(new t.Event("rotatestart", e)), this._pitching && !r.pitching && this.fire(new t.Event("pitchstart", e)) }, n.prototype._fireMoveEvents = function (e) { this.fire(new t.Event("move", e)), this._zooming && this.fire(new t.Event("zoom", e)), this._rotating && this.fire(new t.Event("rotate", e)), this._pitching && this.fire(new t.Event("pitch", e)) }, n.prototype._afterEase = function (e, n) { if (!this._easeId || !n || this._easeId !== n) { delete this._easeId; var r = this._zooming, i = this._rotating, o = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, r && this.fire(new t.Event("zoomend", e)), i && this.fire(new t.Event("rotateend", e)), o && this.fire(new t.Event("pitchend", e)), this.fire(new t.Event("moveend", e)) } }, n.prototype.flyTo = function (e, n) { var r = this; if (!e.essential && t.browser.prefersReducedMotion) { var i = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]); return this.jumpTo(i, n) } this.stop(), e = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e); var o = this.transform, a = this.getZoom(), s = this.getBearing(), l = this.getPitch(), u = this.getPadding(), c = "zoom" in e ? t.clamp(+e.zoom, o.minZoom, o.maxZoom) : a, p = "bearing" in e ? this._normalizeBearing(e.bearing, s) : s, h = "pitch" in e ? +e.pitch : l, f = "padding" in e ? e.padding : o.padding, d = o.zoomScale(c - a), m = t.Point.convert(e.offset), v = o.centerPoint.add(m), y = o.pointLocation(v), g = t.LngLat.convert(e.center || y); this._normalizeCenter(g); var _ = o.project(y), x = o.project(g).sub(_), b = e.curve, w = Math.max(o.width, o.height), S = w / d, E = x.mag(); if ("minZoom" in e) { var C = t.clamp(Math.min(e.minZoom, a, c), o.minZoom, o.maxZoom), T = w / o.zoomScale(C - a); b = Math.sqrt(T / E * 2) } var A = b * b; function M(t) { var e = (S * S - w * w + (t ? -1 : 1) * A * A * E * E) / (2 * (t ? S : w) * A * E); return Math.log(Math.sqrt(e * e + 1) - e) } function O(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function k(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } var I = M(0), P = function (t) { return k(I) / k(I + b * t) }, L = function (t) { return w * ((k(I) * (O(e = I + b * t) / k(e)) - O(I)) / A) / E; var e }, R = (M(1) - I) / b; if (Math.abs(E) < 1e-6 || !isFinite(R)) { if (Math.abs(w - S) < 1e-6) return this.easeTo(e, n); var D = S < w ? -1 : 1; R = Math.abs(Math.log(S / w)) / b, L = function () { return 0 }, P = function (t) { return Math.exp(D * b * t) } } return e.duration = "duration" in e ? +e.duration : 1e3 * R / ("screenSpeed" in e ? +e.screenSpeed / b : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== p, this._pitching = h !== l, this._padding = !o.isPaddingEqual(f), this._prepareEase(n, !1), this._ease((function (e) { var i = e * R, d = 1 / P(i); o.zoom = 1 === e ? c : a + o.scaleZoom(d), r._rotating && (o.bearing = t.number(s, p, e)), r._pitching && (o.pitch = t.number(l, h, e)), r._padding && (o.interpolatePadding(u, f, e), v = o.centerPoint.add(m)); var y = 1 === e ? g : o.unproject(_.add(x.mult(L(i))).mult(d)); o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, v), r._fireMoveEvents(n) }), (function () { return r._afterEase(n) }), e), this }, n.prototype.isEasing = function () { return !!this._easeFrameId }, n.prototype.stop = function () { return this._stop() }, n.prototype._stop = function (t, e) { if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { var n = this._onEaseEnd; delete this._onEaseEnd, n.call(this, e) } if (!t) { var r = this.handlers; r && r.stop(!1) } return this }, n.prototype._ease = function (e, n, r) { !1 === r.animate || 0 === r.duration ? (e(1), n()) : (this._easeStart = t.browser.now(), this._easeOptions = r, this._onEaseFrame = e, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) }, n.prototype._renderFrameCallback = function () { var e = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() }, n.prototype._normalizeBearing = function (e, n) { e = t.wrap(e, -180, 180); var r = Math.abs(e - n); return Math.abs(e - 360 - n) < r && (e -= 360), Math.abs(e + 360 - n) < r && (e += 360), e }, n.prototype._normalizeCenter = function (t) { var e = this.transform; if (e.renderWorldCopies && !e.lngRange) { var n = t.lng - e.center.lng; t.lng += n > 180 ? -360 : n < -180 ? 360 : 0 } }, n }(t.Evented), _i = function (e) { void 0 === e && (e = {}), this.options = e, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this) }; _i.prototype.getDefaultPosition = function () { return "bottom-right" }, _i.prototype.onAdd = function (t) { var e = this.options && this.options.compact; return this._map = t, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container }, _i.prototype.onRemove = function () { n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0 }, _i.prototype._setElementTitle = function (t, e) { var n = this._map._getUIString("AttributionControl." + e); t.title = n, t.setAttribute("aria-label", n) }, _i.prototype._toggleAttribution = function () { this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true")) }, _i.prototype._updateEditLink = function () { var e = this._editLink; e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map")); var n = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }]; if (e) { var r = n.reduce((function (t, e, r) { return e.value && (t += e.key + "=" + e.value + (r < n.length - 1 ? "&" : "")), t }), "?"); e.href = t.config.FEEDBACK_URL + "/" + r + (this._map._hash ? this._map._hash.getHashString(!0) : ""), e.rel = "noopener nofollow", this._setElementTitle(e, "MapFeedback") } }, _i.prototype._updateData = function (t) { !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(), this._updateEditLink()) }, _i.prototype._updateAttributions = function () { if (this._map.style) { var t = []; if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map((function (t) { return "string" != typeof t ? "" : t }))) : "string" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) { var e = this._map.style.stylesheet; this.styleOwner = e.owner, this.styleId = e.id } var n = this._map.style.sourceCaches; for (var r in n) { var i = n[r]; if (i.used) { var o = i.getSource(); o.attribution && t.indexOf(o.attribution) < 0 && t.push(o.attribution) } } t.sort((function (t, e) { return t.length - e.length })); var a = (t = t.filter((function (e, n) { for (var r = n + 1; r < t.length; r++)if (t[r].indexOf(e) >= 0) return !1; return !0 }))).join(" | "); a !== this._attribHTML && (this._attribHTML = a, t.length ? (this._innerContainer.innerHTML = a, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null) } }, _i.prototype._updateCompact = function () { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show") }; var xi = function () { t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this) }; xi.prototype.onAdd = function (t) { this._map = t, this._container = n.create("div", "mapboxgl-ctrl"); var e = n.create("a", "mapboxgl-ctrl-logo"); return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://www.mapbox.com/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container }, xi.prototype.onRemove = function () { n.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact) }, xi.prototype.getDefaultPosition = function () { return "bottom-left" }, xi.prototype._updateLogo = function (t) { t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none") }, xi.prototype._logoRequired = function () { if (this._map.style) { var t = this._map.style.sourceCaches; for (var e in t) if (t[e].getSource().mapbox_logo) return !0; return !1 } }, xi.prototype._updateCompact = function () { var t = this._container.children; if (t.length) { var e = t[0]; this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("mapboxgl-compact") : e.classList.remove("mapboxgl-compact") } }; var bi = function () { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 }; bi.prototype.add = function (t) { var e = ++this._id; return this._queue.push({ callback: t, id: e, cancelled: !1 }), e }, bi.prototype.remove = function (t) { for (var e = this._currentlyRunning, n = 0, r = e ? this._queue.concat(e) : this._queue; n < r.length; n += 1) { var i = r[n]; if (i.id === t) return void (i.cancelled = !0) } }, bi.prototype.run = function (t) { void 0 === t && (t = 0); var e = this._currentlyRunning = this._queue; this._queue = []; for (var n = 0, r = e; n < r.length; n += 1) { var i = r[n]; if (!i.cancelled && (i.callback(t), this._cleared)) break } this._cleared = !1, this._currentlyRunning = !1 }, bi.prototype.clear = function () { this._currentlyRunning && (this._cleared = !0), this._queue = [] }; var wi = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Si = t.window.HTMLImageElement, Ei = t.window.HTMLElement, Ci = t.window.ImageBitmap, Ti = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Ai = function (r) { function i(e) { var n = this; if (null != (e = t.extend({}, Ti, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (null != e.maxPitch && e.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60"); var i = new Sr(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies); if (r.call(this, i, e), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new bi, this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wi, e.locale), this._clickTolerance = e.clickTolerance, this._requestManager = new t.RequestManager(e.transformRequest, e.accessToken), "string" == typeof e.container) { if (this._container = t.window.document.getElementById(e.container), !this._container) throw new Error("Container '" + e.container + "' not found.") } else { if (!(e.container instanceof Ei)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = e.container } if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL."); this.on("move", (function () { return n._update(!1) })), this.on("moveend", (function () { return n._update(!1) })), this.on("zoom", (function () { return n._update(!0) })), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1), t.window.addEventListener("resize", this._onWindowResize, !1), t.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new yi(this, e), this._hash = e.hash && new Cr("string" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, { localIdeographFontFamily: e.localIdeographFontFamily }), e.attributionControl && this.addControl(new _i({ customAttribution: e.customAttribution })), this.addControl(new xi, e.logoPosition), this.on("style.load", (function () { n.transform.unmodified && n.jumpTo(n.style.stylesheet) })), this.on("data", (function (e) { n._update("style" === e.dataType), n.fire(new t.Event(e.dataType + "data", e)) })), this.on("dataloading", (function (e) { n.fire(new t.Event(e.dataType + "dataloading", e)) })) } r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i; var o = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } }; return i.prototype._getMapId = function () { return this._mapId }, i.prototype.addControl = function (e, n) { if (void 0 === n && (n = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); var r = e.onAdd(this); this._controls.push(e); var i = this._controlPositions[n]; return -1 !== n.indexOf("bottom") ? i.insertBefore(r, i.firstChild) : i.appendChild(r), this }, i.prototype.removeControl = function (e) { if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); var n = this._controls.indexOf(e); return n > -1 && this._controls.splice(n, 1), e.onRemove(this), this }, i.prototype.hasControl = function (t) { return this._controls.indexOf(t) > -1 }, i.prototype.resize = function (e) { var n = this._containerDimensions(), r = n[0], i = n[1]; if (r === this.transform.width && i === this.transform.height) return this; this._resizeCanvas(r, i), this.transform.resize(r, i), this.painter.resize(r, i); var o = !this._moving; return o && this.fire(new t.Event("movestart", e)).fire(new t.Event("move", e)), this.fire(new t.Event("resize", e)), o && this.fire(new t.Event("moveend", e)), this }, i.prototype.getBounds = function () { return this.transform.getBounds() }, i.prototype.getMaxBounds = function () { return this.transform.getMaxBounds() }, i.prototype.setMaxBounds = function (e) { return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update() }, i.prototype.setMinZoom = function (t) { if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") }, i.prototype.getMinZoom = function () { return this.transform.minZoom }, i.prototype.setMaxZoom = function (t) { if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this; throw new Error("maxZoom must be greater than the current minZoom") }, i.prototype.getMaxZoom = function () { return this.transform.maxZoom }, i.prototype.setMinPitch = function (t) { if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") }, i.prototype.getMinPitch = function () { return this.transform.minPitch }, i.prototype.setMaxPitch = function (t) { if ((t = null == t ? 60 : t) > 60) throw new Error("maxPitch must be less than or equal to 60"); if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this; throw new Error("maxPitch must be greater than the current minPitch") }, i.prototype.getMaxPitch = function () { return this.transform.maxPitch }, i.prototype.getRenderWorldCopies = function () { return this.transform.renderWorldCopies }, i.prototype.setRenderWorldCopies = function (t) { return this.transform.renderWorldCopies = t, this._update() }, i.prototype.project = function (e) { return this.transform.locationPoint(t.LngLat.convert(e)) }, i.prototype.unproject = function (e) { return this.transform.pointLocation(t.Point.convert(e)) }, i.prototype.isMoving = function () { return this._moving || this.handlers.isMoving() }, i.prototype.isZooming = function () { return this._zooming || this.handlers.isZooming() }, i.prototype.isRotating = function () { return this._rotating || this.handlers.isRotating() }, i.prototype._createDelegatedListener = function (t, e, n) { var r, i = this; if ("mouseenter" === t || "mouseover" === t) { var o = !1; return { layer: e, listener: n, delegates: { mousemove: function (r) { var a = i.getLayer(e) ? i.queryRenderedFeatures(r.point, { layers: [e] }) : []; a.length ? o || (o = !0, n.call(i, new Rr(t, i, r.originalEvent, { features: a }))) : o = !1 }, mouseout: function () { o = !1 } } } } if ("mouseleave" === t || "mouseout" === t) { var a = !1; return { layer: e, listener: n, delegates: { mousemove: function (r) { (i.getLayer(e) ? i.queryRenderedFeatures(r.point, { layers: [e] }) : []).length ? a = !0 : a && (a = !1, n.call(i, new Rr(t, i, r.originalEvent))) }, mouseout: function (e) { a && (a = !1, n.call(i, new Rr(t, i, e.originalEvent))) } } } } return { layer: e, listener: n, delegates: (r = {}, r[t] = function (t) { var r = i.getLayer(e) ? i.queryRenderedFeatures(t.point, { layers: [e] }) : []; r.length && (t.features = r, n.call(i, t), delete t.features) }, r) } }, i.prototype.on = function (t, e, n) { if (void 0 === n) return r.prototype.on.call(this, t, e); var i = this._createDelegatedListener(t, e, n); for (var o in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(i), i.delegates) this.on(o, i.delegates[o]); return this }, i.prototype.once = function (t, e, n) { if (void 0 === n) return r.prototype.once.call(this, t, e); var i = this._createDelegatedListener(t, e, n); for (var o in i.delegates) this.once(o, i.delegates[o]); return this }, i.prototype.off = function (t, e, n) { var i = this; return void 0 === n ? r.prototype.off.call(this, t, e) : (this._delegatedListeners && this._delegatedListeners[t] && function (r) { for (var o = r[t], a = 0; a < o.length; a++) { var s = o[a]; if (s.layer === e && s.listener === n) { for (var l in s.delegates) i.off(l, s.delegates[l]); return o.splice(a, 1), i } } }(this._delegatedListeners), this) }, i.prototype.queryRenderedFeatures = function (e, n) { if (!this.style) return []; var r; if (void 0 !== n || void 0 === e || e instanceof t.Point || Array.isArray(e) || (n = e, e = void 0), n = n || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e[0]) r = [t.Point.convert(e)]; else { var i = t.Point.convert(e[0]), o = t.Point.convert(e[1]); r = [i, new t.Point(o.x, i.y), o, new t.Point(i.x, o.y), i] } return this.style.queryRenderedFeatures(r, n, this.transform) }, i.prototype.querySourceFeatures = function (t, e) { return this.style.querySourceFeatures(t, e) }, i.prototype.setStyle = function (e, n) { return !1 !== (n = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, n)).diff && n.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, n), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._updateStyle(e, n)) }, i.prototype._getUIString = function (t) { var e = this._locale[t]; if (null == e) throw new Error("Missing UI string '" + t + "'"); return e }, i.prototype._updateStyle = function (t, e) { return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new Ge(this, e || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this) }, i.prototype._lazyInitEmptyStyle = function () { this.style || (this.style = new Ge(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()) }, i.prototype._diffStyle = function (e, n) { var r = this; if ("string" == typeof e) { var i = this._requestManager.normalizeStyleURL(e), o = this._requestManager.transformRequest(i, t.ResourceType.Style); t.getJSON(o, (function (e, i) { e ? r.fire(new t.ErrorEvent(e)) : i && r._updateDiff(i, n) })) } else "object" == typeof e && this._updateDiff(e, n) }, i.prototype._updateDiff = function (e, n) { try { this.style.setState(e) && this._update(!0) } catch (r) { t.warnOnce("Unable to perform style diff: " + (r.message || r.error || r) + ".  Rebuilding the style from scratch."), this._updateStyle(e, n) } }, i.prototype.getStyle = function () { if (this.style) return this.style.serialize() }, i.prototype.isStyleLoaded = function () { return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.") }, i.prototype.addSource = function (t, e) { return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0) }, i.prototype.isSourceLoaded = function (e) { var n = this.style && this.style.sourceCaches[e]; if (void 0 !== n) return n.loaded(); this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e + "'"))) }, i.prototype.areTilesLoaded = function () { var t = this.style && this.style.sourceCaches; for (var e in t) { var n = t[e]._tiles; for (var r in n) { var i = n[r]; if ("loaded" !== i.state && "errored" !== i.state) return !1 } } return !0 }, i.prototype.addSourceType = function (t, e, n) { return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, n) }, i.prototype.removeSource = function (t) { return this.style.removeSource(t), this._update(!0) }, i.prototype.getSource = function (t) { return this.style.getSource(t) }, i.prototype.addImage = function (e, n, r) { void 0 === r && (r = {}); var i = r.pixelRatio; void 0 === i && (i = 1); var o = r.sdf; void 0 === o && (o = !1); var a = r.stretchX, s = r.stretchY, l = r.content; if (this._lazyInitEmptyStyle(), n instanceof Si || Ci && n instanceof Ci) { var u = t.browser.getImageData(n); this.style.addImage(e, { data: new t.RGBAImage({ width: u.width, height: u.height }, u.data), pixelRatio: i, stretchX: a, stretchY: s, content: l, sdf: o, version: 0 }) } else { if (void 0 === n.width || void 0 === n.height) return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); var c = n; this.style.addImage(e, { data: new t.RGBAImage({ width: n.width, height: n.height }, new Uint8Array(n.data)), pixelRatio: i, stretchX: a, stretchY: s, content: l, sdf: o, version: 0, userImage: c }), c.onAdd && c.onAdd(this, e) } }, i.prototype.updateImage = function (e, n) { var r = this.style.getImage(e); if (!r) return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); var i = n instanceof Si || Ci && n instanceof Ci ? t.browser.getImageData(n) : n, o = i.width, a = i.height, s = i.data; return void 0 === o || void 0 === a ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : o !== r.data.width || a !== r.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (r.data.replace(s, !(n instanceof Si || Ci && n instanceof Ci)), void this.style.updateImage(e, r)) }, i.prototype.hasImage = function (e) { return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1) }, i.prototype.removeImage = function (t) { this.style.removeImage(t) }, i.prototype.loadImage = function (e, n) { t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), n) }, i.prototype.listImages = function () { return this.style.listImages() }, i.prototype.addLayer = function (t, e) { return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0) }, i.prototype.moveLayer = function (t, e) { return this.style.moveLayer(t, e), this._update(!0) }, i.prototype.removeLayer = function (t) { return this.style.removeLayer(t), this._update(!0) }, i.prototype.getLayer = function (t) { return this.style.getLayer(t) }, i.prototype.setLayerZoomRange = function (t, e, n) { return this.style.setLayerZoomRange(t, e, n), this._update(!0) }, i.prototype.setFilter = function (t, e, n) { return void 0 === n && (n = {}), this.style.setFilter(t, e, n), this._update(!0) }, i.prototype.getFilter = function (t) { return this.style.getFilter(t) }, i.prototype.setPaintProperty = function (t, e, n, r) { return void 0 === r && (r = {}), this.style.setPaintProperty(t, e, n, r), this._update(!0) }, i.prototype.getPaintProperty = function (t, e) { return this.style.getPaintProperty(t, e) }, i.prototype.setLayoutProperty = function (t, e, n, r) { return void 0 === r && (r = {}), this.style.setLayoutProperty(t, e, n, r), this._update(!0) }, i.prototype.getLayoutProperty = function (t, e) { return this.style.getLayoutProperty(t, e) }, i.prototype.setLight = function (t, e) { return void 0 === e && (e = {}), this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0) }, i.prototype.getLight = function () { return this.style.getLight() }, i.prototype.setFeatureState = function (t, e) { return this.style.setFeatureState(t, e), this._update() }, i.prototype.removeFeatureState = function (t, e) { return this.style.removeFeatureState(t, e), this._update() }, i.prototype.getFeatureState = function (t) { return this.style.getFeatureState(t) }, i.prototype.getContainer = function () { return this._container }, i.prototype.getCanvasContainer = function () { return this._canvasContainer }, i.prototype.getCanvas = function () { return this._canvas }, i.prototype._containerDimensions = function () { var t = 0, e = 0; return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e] }, i.prototype._detectMissingCSS = function () { "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.") }, i.prototype._setupContainer = function () { var t = this._container; t.classList.add("mapboxgl-map"), (this._missingCSSCanary = n.create("div", "mapboxgl-canary", t)).style.visibility = "hidden", this._detectMissingCSS(); var e = this._canvasContainer = n.create("div", "mapboxgl-canvas-container", t); this._interactive && e.classList.add("mapboxgl-interactive"), this._canvas = n.create("canvas", "mapboxgl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"); var r = this._containerDimensions(); this._resizeCanvas(r[0], r[1]); var i = this._controlContainer = n.create("div", "mapboxgl-control-container", t), o = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach((function (t) { o[t] = n.create("div", "mapboxgl-ctrl-" + t, i) })), this._container.addEventListener("scroll", this._onMapScroll, !1) }, i.prototype._resizeCanvas = function (e, n) { var r = t.browser.devicePixelRatio || 1; this._canvas.width = r * e, this._canvas.height = r * n, this._canvas.style.width = e + "px", this._canvas.style.height = n + "px" }, i.prototype._setupPainter = function () { var n = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), r = this._canvas.getContext("webgl", n) || this._canvas.getContext("experimental-webgl", n); r ? (this.painter = new _r(r, this.transform), t.webpSupported.testSupport(r)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL"))) }, i.prototype._contextLost = function (e) { e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e })) }, i.prototype._contextRestored = function (e) { this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e })) }, i.prototype._onMapScroll = function (t) { if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 }, i.prototype.loaded = function () { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() }, i.prototype._update = function (t) { return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this }, i.prototype._requestRenderFrame = function (t) { return this._update(), this._renderTaskQueue.add(t) }, i.prototype._cancelRenderFrame = function (t) { this._renderTaskQueue.remove(t) }, i.prototype._render = function (e) { var n, r = this, i = 0, o = this.painter.context.extTimerQuery; if (this.listens("gpu-timing-frame") && (n = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, n), i = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), !this._removed) { var a = !1; if (this.style && this._styleDirty) { this._styleDirty = !1; var s = this.transform.zoom, l = t.browser.now(); this.style.zoomHistory.update(s, l); var u = new t.EvaluationParameters(s, { now: l, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), c = u.crossFadingFactor(); 1 === c && c === this._crossFadingFactor || (a = !0, this._crossFadingFactor = c), this.style.update(u) } if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || a) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) { var p = t.browser.now() - i; o.endQueryEXT(o.TIME_ELAPSED_EXT, n), setTimeout((function () { var e = o.getQueryObjectEXT(n, o.QUERY_RESULT_EXT) / 1e6; o.deleteQueryEXT(n), r.fire(new t.Event("gpu-timing-frame", { cpuTime: p, gpuTime: e })) }), 50) } if (this.listens("gpu-timing-layer")) { var h = this.painter.collectGpuTimers(); setTimeout((function () { var e = r.painter.queryGpuTimers(h); r.fire(new t.Event("gpu-timing-layer", { layerTimes: e })) }), 50) } var f = this._sourcesDirty || this._styleDirty || this._placementDirty; return f || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || f || (this._fullyLoaded = !0), this } }, i.prototype.remove = function () { this._hash && this._hash.remove(); for (var e = 0, n = this._controls; e < n.length; e += 1)n[e].onRemove(this); this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1), t.window.removeEventListener("orientationchange", this._onWindowResize, !1), t.window.removeEventListener("online", this._onWindowOnline, !1)); var r = this.painter.context.gl.getExtension("WEBGL_lose_context"); r && r.loseContext(), Mi(this._canvasContainer), Mi(this._controlContainer), Mi(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new t.Event("remove")) }, i.prototype.triggerRepaint = function () { var e = this; this.style && !this._frame && (this._frame = t.browser.frame((function (t) { e._frame = null, e._render(t) }))) }, i.prototype._onWindowOnline = function () { this._update() }, i.prototype._onWindowResize = function (t) { this._trackResize && this.resize({ originalEvent: t })._update() }, o.showTileBoundaries.get = function () { return !!this._showTileBoundaries }, o.showTileBoundaries.set = function (t) { this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update()) }, o.showPadding.get = function () { return !!this._showPadding }, o.showPadding.set = function (t) { this._showPadding !== t && (this._showPadding = t, this._update()) }, o.showCollisionBoxes.get = function () { return !!this._showCollisionBoxes }, o.showCollisionBoxes.set = function (t) { this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update()) }, o.showOverdrawInspector.get = function () { return !!this._showOverdrawInspector }, o.showOverdrawInspector.set = function (t) { this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update()) }, o.repaint.get = function () { return !!this._repaint }, o.repaint.set = function (t) { this._repaint !== t && (this._repaint = t, this.triggerRepaint()) }, o.vertices.get = function () { return !!this._vertices }, o.vertices.set = function (t) { this._vertices = t, this._update() }, i.prototype._setCacheLimits = function (e, n) { t.setCacheLimits(e, n) }, o.version.get = function () { return t.version }, Object.defineProperties(i.prototype, o), i }(gi); function Mi(t) { t.parentNode && t.parentNode.removeChild(t) } var Oi = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, ki = function (e) { var r = this; this.options = t.extend({}, Oi, e), this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (function (t) { return t.preventDefault() })), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (function (t) { return r._map.zoomIn({}, { originalEvent: t }) })), n.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (function (t) { return r._map.zoomOut({}, { originalEvent: t }) })), n.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (function (t) { r.options.visualizePitch ? r._map.resetNorthPitch({}, { originalEvent: t }) : r._map.resetNorth({}, { originalEvent: t }) })), this._compassIcon = n.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0)) }; ki.prototype._updateZoomButtons = function () { var t = this._map.getZoom(), e = t === this._map.getMaxZoom(), n = t === this._map.getMinZoom(); this._zoomInButton.disabled = e, this._zoomOutButton.disabled = n, this._zoomInButton.setAttribute("aria-disabled", e.toString()), this._zoomOutButton.setAttribute("aria-disabled", n.toString()) }, ki.prototype._rotateCompassArrow = function () { var t = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)"; this._compassIcon.style.transform = t }, ki.prototype.onAdd = function (t) { return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ii(this._map, this._compass, this.options.visualizePitch)), this._container }, ki.prototype.onRemove = function () { n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map }, ki.prototype._createButton = function (t, e) { var r = n.create("button", t, this._container); return r.type = "button", r.addEventListener("click", e), r }, ki.prototype._setButtonTitle = function (t, e) { var n = this._map._getUIString("NavigationControl." + e); t.title = n, t.setAttribute("aria-label", n) }; var Ii = function (e, r, i) { void 0 === i && (i = !1), this._clickTolerance = 10, this.element = r, this.mouseRotate = new qr({ clickTolerance: e.dragRotate._mouseRotate._clickTolerance }), this.map = e, i && (this.mousePitch = new Zr({ clickTolerance: e.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), n.addEventListener(r, "mousedown", this.mousedown), n.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), n.addEventListener(r, "touchmove", this.touchmove), n.addEventListener(r, "touchend", this.touchend), n.addEventListener(r, "touchcancel", this.reset) }; function Pi(e, n, r) { if (e = new t.LngLat(e.lng, e.lat), n) { var i = new t.LngLat(e.lng - 360, e.lat), o = new t.LngLat(e.lng + 360, e.lat), a = r.locationPoint(e).distSqr(n); r.locationPoint(i).distSqr(n) < a ? e = i : r.locationPoint(o).distSqr(n) < a && (e = o) } for (; Math.abs(e.lng - r.center.lng) > 180;) { var s = r.locationPoint(e); if (s.x >= 0 && s.y >= 0 && s.x <= r.width && s.y <= r.height) break; e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360 } return e } Ii.prototype.down = function (t, e) { this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), n.disableDrag() }, Ii.prototype.move = function (t, e) { var n = this.map, r = this.mouseRotate.mousemoveWindow(t, e); if (r && r.bearingDelta && n.setBearing(n.getBearing() + r.bearingDelta), this.mousePitch) { var i = this.mousePitch.mousemoveWindow(t, e); i && i.pitchDelta && n.setPitch(n.getPitch() + i.pitchDelta) } }, Ii.prototype.off = function () { var t = this.element; n.removeEventListener(t, "mousedown", this.mousedown), n.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), n.removeEventListener(t, "touchmove", this.touchmove), n.removeEventListener(t, "touchend", this.touchend), n.removeEventListener(t, "touchcancel", this.reset), this.offTemp() }, Ii.prototype.offTemp = function () { n.enableDrag(), n.removeEventListener(t.window, "mousemove", this.mousemove), n.removeEventListener(t.window, "mouseup", this.mouseup) }, Ii.prototype.mousedown = function (e) { this.down(t.extend({}, e, { ctrlKey: !0, preventDefault: function () { return e.preventDefault() } }), n.mousePos(this.element, e)), n.addEventListener(t.window, "mousemove", this.mousemove), n.addEventListener(t.window, "mouseup", this.mouseup) }, Ii.prototype.mousemove = function (t) { this.move(t, n.mousePos(this.element, t)) }, Ii.prototype.mouseup = function (t) { this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp() }, Ii.prototype.touchstart = function (t) { 1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function () { return t.preventDefault() } }, this._startPos)) }, Ii.prototype.touchmove = function (t) { 1 !== t.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, t.targetTouches)[0], this.move({ preventDefault: function () { return t.preventDefault() } }, this._lastPos)) }, Ii.prototype.touchend = function (t) { 0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset() }, Ii.prototype.reset = function () { this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp() }; var Li = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Ri(t, e, n) { var r = t.classList; for (var i in Li) r.remove("mapboxgl-" + n + "-anchor-" + i); r.add("mapboxgl-" + n + "-anchor-" + e) } var Di, Ni = function (e) { function r(r, i) { if (e.call(this), (r instanceof t.window.HTMLElement || i) && (r = t.extend({ element: r }, i)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = r && r.anchor || "center", this._color = r && r.color || "#3FB1CE", this._scale = r && r.scale || 1, this._draggable = r && r.draggable || !1, this._clickTolerance = r && r.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = r && r.rotation || 0, this._rotationAlignment = r && r.rotationAlignment || "auto", this._pitchAlignment = r && r.pitchAlignment && "auto" !== r.pitchAlignment ? r.pitchAlignment : this._rotationAlignment, r && r.element) this._element = r.element, this._offset = t.Point.convert(r && r.offset || [0, 0]); else { this._defaultMarker = !0, this._element = n.create("div"), this._element.setAttribute("aria-label", "Map marker"); var o = n.createNS("http://www.w3.org/2000/svg", "svg"); o.setAttributeNS(null, "display", "block"), o.setAttributeNS(null, "height", "41px"), o.setAttributeNS(null, "width", "27px"), o.setAttributeNS(null, "viewBox", "0 0 27 41"); var a = n.createNS("http://www.w3.org/2000/svg", "g"); a.setAttributeNS(null, "stroke", "none"), a.setAttributeNS(null, "stroke-width", "1"), a.setAttributeNS(null, "fill", "none"), a.setAttributeNS(null, "fill-rule", "evenodd"); var s = n.createNS("http://www.w3.org/2000/svg", "g"); s.setAttributeNS(null, "fill-rule", "nonzero"); var l = n.createNS("http://www.w3.org/2000/svg", "g"); l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000"); for (var u = 0, c = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; u < c.length; u += 1) { var p = c[u], h = n.createNS("http://www.w3.org/2000/svg", "ellipse"); h.setAttributeNS(null, "opacity", "0.04"), h.setAttributeNS(null, "cx", "10.5"), h.setAttributeNS(null, "cy", "5.80029008"), h.setAttributeNS(null, "rx", p.rx), h.setAttributeNS(null, "ry", p.ry), l.appendChild(h) } var f = n.createNS("http://www.w3.org/2000/svg", "g"); f.setAttributeNS(null, "fill", this._color); var d = n.createNS("http://www.w3.org/2000/svg", "path"); d.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), f.appendChild(d); var m = n.createNS("http://www.w3.org/2000/svg", "g"); m.setAttributeNS(null, "opacity", "0.25"), m.setAttributeNS(null, "fill", "#000000"); var v = n.createNS("http://www.w3.org/2000/svg", "path"); v.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), m.appendChild(v); var y = n.createNS("http://www.w3.org/2000/svg", "g"); y.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), y.setAttributeNS(null, "fill", "#FFFFFF"); var g = n.createNS("http://www.w3.org/2000/svg", "g"); g.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); var _ = n.createNS("http://www.w3.org/2000/svg", "circle"); _.setAttributeNS(null, "fill", "#000000"), _.setAttributeNS(null, "opacity", "0.25"), _.setAttributeNS(null, "cx", "5.5"), _.setAttributeNS(null, "cy", "5.5"), _.setAttributeNS(null, "r", "5.4999962"); var x = n.createNS("http://www.w3.org/2000/svg", "circle"); x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), g.appendChild(_), g.appendChild(x), s.appendChild(l), s.appendChild(f), s.appendChild(m), s.appendChild(y), s.appendChild(g), o.appendChild(s), o.setAttributeNS(null, "height", 41 * this._scale + "px"), o.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(o), this._offset = t.Point.convert(r && r.offset || [0, -14]) } this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (function (t) { t.preventDefault() })), this._element.addEventListener("mousedown", (function (t) { t.preventDefault() })), Ri(this._element, this._anchor, "marker"), this._popup = null } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.addTo = function (t) { return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this }, r.prototype.remove = function () { return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this }, r.prototype.getLngLat = function () { return this._lngLat }, r.prototype.setLngLat = function (e) { return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this }, r.prototype.getElement = function () { return this._element }, r.prototype.setPopup = function (t) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) { if (!("offset" in t.options)) { var e = Math.sqrt(Math.pow(13.5, 2) / 2); t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e, -1 * (24.6 + e)], "bottom-right": [-e, -1 * (24.6 + e)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset } this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress) } return this }, r.prototype._onKeyPress = function (t) { var e = t.code, n = t.charCode || t.keyCode; "Space" !== e && "Enter" !== e && 32 !== n && 13 !== n || this.togglePopup() }, r.prototype._onMapClick = function (t) { var e = t.originalEvent.target, n = this._element; this._popup && (e === n || n.contains(e)) && this.togglePopup() }, r.prototype.getPopup = function () { return this._popup }, r.prototype.togglePopup = function () { var t = this._popup; return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this }, r.prototype._update = function (t) { if (this._map) { this._map.transform.renderWorldCopies && (this._lngLat = Pi(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset); var e = ""; "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)"); var r = ""; "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? r = "rotateX(0deg)" : "map" === this._pitchAlignment && (r = "rotateX(" + this._map.getPitch() + "deg)"), t && "moveend" !== t.type || (this._pos = this._pos.round()), n.setTransform(this._element, Li[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + r + " " + e) } }, r.prototype.getOffset = function () { return this._offset }, r.prototype.setOffset = function (e) { return this._offset = t.Point.convert(e), this._update(), this }, r.prototype._onMove = function (e) { if (!this._isDragging) { var n = this._clickTolerance || this._map._clickTolerance; this._isDragging = e.point.dist(this._pointerdownPos) >= n } this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag"))) }, r.prototype._onUp = function () { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive" }, r.prototype._addDragHandler = function (t) { this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)) }, r.prototype.setDraggable = function (t) { return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this }, r.prototype.isDraggable = function () { return this._draggable }, r.prototype.setRotation = function (t) { return this._rotation = t || 0, this._update(), this }, r.prototype.getRotation = function () { return this._rotation }, r.prototype.setRotationAlignment = function (t) { return this._rotationAlignment = t || "auto", this._update(), this }, r.prototype.getRotationAlignment = function () { return this._rotationAlignment }, r.prototype.setPitchAlignment = function (t) { return this._pitchAlignment = t && "auto" !== t ? t : this._rotationAlignment, this._update(), this }, r.prototype.getPitchAlignment = function () { return this._pitchAlignment }, r }(t.Evented), zi = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, Fi = 0, Bi = !1, ji = function (e) { function r(n) { e.call(this), this.options = t.extend({}, zi, n), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this) } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.onAdd = function (e) { var r; return this._map = e, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), r = this._setupUI, void 0 !== Di ? r(Di) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then((function (t) { r(Di = "denied" !== t.state) })) : r(Di = !!t.window.navigator.geolocation), this._container }, r.prototype.onRemove = function () { void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fi = 0, Bi = !1 }, r.prototype._isOutOfMapMaxBounds = function (t) { var e = this._map.getMaxBounds(), n = t.coords; return e && (n.longitude < e.getWest() || n.longitude > e.getEast() || n.latitude < e.getSouth() || n.latitude > e.getNorth()) }, r.prototype._setErrorState = function () { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting") } }, r.prototype._onSuccess = function (e) { if (this._map) { if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background") }this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e)), this._finish() } }, r.prototype._updateCamera = function (e) { var n = new t.LngLat(e.coords.longitude, e.coords.latitude), r = e.coords.accuracy, i = this._map.getBearing(), o = t.extend({ bearing: i }, this.options.fitBoundsOptions); this._map.fitBounds(n.toBounds(r), o, { geolocateSource: !0 }) }, r.prototype._updateMarker = function (e) { if (e) { var n = new t.LngLat(e.coords.longitude, e.coords.latitude); this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove() }, r.prototype._updateCircleRadius = function () { var t = this._map._container.clientHeight / 2, e = this._map.unproject([0, t]), n = this._map.unproject([1, t]), r = e.distanceTo(n), i = Math.ceil(2 * this._accuracy / r); this._circleElement.style.width = i + "px", this._circleElement.style.height = i + "px" }, r.prototype._onZoom = function () { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() }, r.prototype._onError = function (e) { if (this._map) { if (this.options.trackUserLocation) if (1 === e.code) { this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; var n = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n), void 0 !== this._geolocationWatchID && this._clearWatch() } else { if (3 === e.code && Bi) return; this._setErrorState() } "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e)), this._finish() } }, r.prototype._finish = function () { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 }, r.prototype._setupUI = function (e) { var r = this; if (this._container.addEventListener("contextmenu", (function (t) { return t.preventDefault() })), this._geolocateButton = n.create("button", "mapboxgl-ctrl-geolocate", this._container), n.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === e) { t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled."); var i = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i) } else { var o = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o) } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Ni(this._dotElement), this._circleElement = n.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ni({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (function (e) { e.geolocateSource || "ACTIVE_LOCK" !== r._watchState || e.originalEvent && "resize" === e.originalEvent.type || (r._watchState = "BACKGROUND", r._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), r._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), r.fire(new t.Event("trackuserlocationend"))) })) }, r.prototype.trigger = function () { if (!this._setup) return t.warnOnce("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": Fi--, Bi = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart")) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "BACKGROUND": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"); break; case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error") }if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch(); else if (void 0 === this._geolocationWatchID) { var e; this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fi > 1 ? (e = { maximumAge: 6e5, timeout: 0 }, Bi = !0) : (e = this.options.positionOptions, Bi = !1), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e) } } else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 }, r.prototype._clearWatch = function () { t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) }, r }(t.Evented), Ui = { maxWidth: 100, unit: "metric" }, Vi = function (e) { this.options = t.extend({}, Ui, e), t.bindAll(["_onMove", "setUnit"], this) }; function Gi(t, e, n) { var r = n && n.maxWidth || 100, i = t._container.clientHeight / 2, o = t.unproject([0, i]), a = t.unproject([r, i]), s = o.distanceTo(a); if (n && "imperial" === n.unit) { var l = 3.2808 * s; l > 5280 ? Hi(e, r, l / 5280, t._getUIString("ScaleControl.Miles")) : Hi(e, r, l, t._getUIString("ScaleControl.Feet")) } else n && "nautical" === n.unit ? Hi(e, r, s / 1852, t._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? Hi(e, r, s / 1e3, t._getUIString("ScaleControl.Kilometers")) : Hi(e, r, s, t._getUIString("ScaleControl.Meters")) } function Hi(t, e, n, r) { var i, o, a, s = (i = n, (o = Math.pow(10, ("" + Math.floor(i)).length - 1)) * (a = (a = i / o) >= 10 ? 10 : a >= 5 ? 5 : a >= 3 ? 3 : a >= 2 ? 2 : a >= 1 ? 1 : function (t) { var e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10)); return Math.round(t * e) / e }(a))); t.style.width = e * (s / n) + "px", t.innerHTML = s + "&nbsp;" + r } Vi.prototype.getDefaultPosition = function () { return "bottom-left" }, Vi.prototype._onMove = function () { Gi(this._map, this._container, this.options) }, Vi.prototype.onAdd = function (t) { return this._map = t, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container }, Vi.prototype.onRemove = function () { n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0 }, Vi.prototype.setUnit = function (t) { this.options.unit = t, Gi(this._map, this._container, this.options) }; var Wi = function (e) { this._fullscreen = !1, e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange") }; Wi.prototype.onAdd = function (e) { return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer }, Wi.prototype.onRemove = function () { n.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon) }, Wi.prototype._checkFullscreenSupport = function () { return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled) }, Wi.prototype._setupUI = function () { var e = this._fullscreenButton = n.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer); n.create("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", !0), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon) }, Wi.prototype._updateTitle = function () { var t = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t }, Wi.prototype._getTitle = function () { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") }, Wi.prototype._isFullscreen = function () { return this._fullscreen }, Wi.prototype._changeIcon = function () { (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle()) }, Wi.prototype._onClickFullscreen = function () { this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen() }; var Xi = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, qi = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Zi = function (e) { function r(n) { e.call(this), this.options = t.extend(Object.create(Xi), n), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this) } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.addTo = function (e) { return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this }, r.prototype.isOpen = function () { return !!this._map }, r.prototype.remove = function () { return this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this }, r.prototype.getLngLat = function () { return this._lngLat }, r.prototype.setLngLat = function (e) { return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this }, r.prototype.trackPointer = function () { return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this }, r.prototype.getElement = function () { return this._container }, r.prototype.setText = function (e) { return this.setDOMContent(t.window.document.createTextNode(e)) }, r.prototype.setHTML = function (e) { var n, r = t.window.document.createDocumentFragment(), i = t.window.document.createElement("body"); for (i.innerHTML = e; n = i.firstChild;)r.appendChild(n); return this.setDOMContent(r) }, r.prototype.getMaxWidth = function () { return this._container && this._container.style.maxWidth }, r.prototype.setMaxWidth = function (t) { return this.options.maxWidth = t, this._update(), this }, r.prototype.setDOMContent = function (t) { if (this._content) for (; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = n.create("div", "mapboxgl-popup-content", this._container); return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this }, r.prototype.addClassName = function (t) { this._container && this._container.classList.add(t) }, r.prototype.removeClassName = function (t) { this._container && this._container.classList.remove(t) }, r.prototype.setOffset = function (t) { return this.options.offset = t, this._update(), this }, r.prototype.toggleClassName = function (t) { if (this._container) return this._container.classList.toggle(t) }, r.prototype._createCloseButton = function () { this.options.closeButton && (this._closeButton = n.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose)) }, r.prototype._onMouseUp = function (t) { this._update(t.point) }, r.prototype._onMouseMove = function (t) { this._update(t.point) }, r.prototype._onDrag = function (t) { this._update(t.point) }, r.prototype._update = function (e) { var r = this; if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = n.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = n.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((function (t) { return r._container.classList.add(t) })), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Pi(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e)) { var i = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat), o = this.options.anchor, a = function e(n) { if (n) { if ("number" == typeof n) { var r = Math.round(Math.sqrt(.5 * Math.pow(n, 2))); return { center: new t.Point(0, 0), top: new t.Point(0, n), "top-left": new t.Point(r, r), "top-right": new t.Point(-r, r), bottom: new t.Point(0, -n), "bottom-left": new t.Point(r, -r), "bottom-right": new t.Point(-r, -r), left: new t.Point(n, 0), right: new t.Point(-n, 0) } } if (n instanceof t.Point || Array.isArray(n)) { var i = t.Point.convert(n); return { center: i, top: i, "top-left": i, "top-right": i, bottom: i, "bottom-left": i, "bottom-right": i, left: i, right: i } } return { center: t.Point.convert(n.center || [0, 0]), top: t.Point.convert(n.top || [0, 0]), "top-left": t.Point.convert(n["top-left"] || [0, 0]), "top-right": t.Point.convert(n["top-right"] || [0, 0]), bottom: t.Point.convert(n.bottom || [0, 0]), "bottom-left": t.Point.convert(n["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(n["bottom-right"] || [0, 0]), left: t.Point.convert(n.left || [0, 0]), right: t.Point.convert(n.right || [0, 0]) } } return e(new t.Point(0, 0)) }(this.options.offset); if (!o) { var s, l = this._container.offsetWidth, u = this._container.offsetHeight; s = i.y + a.bottom.y < u ? ["top"] : i.y > this._map.transform.height - u ? ["bottom"] : [], i.x < l / 2 ? s.push("left") : i.x > this._map.transform.width - l / 2 && s.push("right"), o = 0 === s.length ? "bottom" : s.join("-") } var c = i.add(a[o]).round(); n.setTransform(this._container, Li[o] + " translate(" + c.x + "px," + c.y + "px)"), Ri(this._container, o, "popup") } }, r.prototype._focusFirstElement = function () { if (this.options.focusAfterOpen && this._container) { var t = this._container.querySelector(qi); t && t.focus() } }, r.prototype._onClose = function () { this.remove() }, r }(t.Evented), Yi = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: Ai, NavigationControl: ki, GeolocateControl: ji, AttributionControl: _i, ScaleControl: Vi, FullscreenControl: Wi, Popup: Zi, Marker: Ni, Style: Ge, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, prewarm: function () { Ft().acquire(Rt) }, clearPrewarmedResources: function () { var t = Nt; t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Rt), Nt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")) }, get accessToken() { return t.config.ACCESS_TOKEN }, set accessToken(e) { t.config.ACCESS_TOKEN = e }, get baseApiUrl() { return t.config.API_URL }, set baseApiUrl(e) { t.config.API_URL = e }, get workerCount() { return Dt.workerCount }, set workerCount(t) { Dt.workerCount = t }, get maxParallelImageRequests() { return t.config.MAX_PARALLEL_IMAGE_REQUESTS }, set maxParallelImageRequests(e) { t.config.MAX_PARALLEL_IMAGE_REQUESTS = e }, clearStorage: function (e) { t.clearTileCache(e) }, workerUrl: "" }; return Yi })), n }() }(rM); var iM, oM, aM, sM, lM, uM, cM, pM, hM, fM, dM, mM = rM.exports, vM = function () { function t() { Ar(this, t), kr(this, "viewport", void 0) } return Or(t, [{ key: "syncWithMapCamera", value: function (t) { var e = t.center, n = t.zoom, r = t.pitch, i = t.bearing, o = t.viewportHeight, a = t.viewportWidth; this.viewport = new nM({ width: a, height: o, longitude: e && e[0], latitude: e && e[1], zoom: n, pitch: r, bearing: i }) } }, { key: "getZoom", value: function () { return this.viewport.zoom } }, { key: "getZoomScale", value: function () { return Math.pow(2, this.getZoom()) } }, { key: "getCenter", value: function () { return [this.viewport.longitude, this.viewport.latitude] } }, { key: "getProjectionMatrix", value: function () { return this.viewport.projectionMatrix } }, { key: "getModelMatrix", value: function () { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } }, { key: "getViewMatrix", value: function () { return this.viewport.viewMatrix } }, { key: "getViewMatrixUncentered", value: function () { return this.viewport.viewMatrixUncentered } }, { key: "getViewProjectionMatrix", value: function () { return this.viewport.viewProjectionMatrix } }, { key: "getViewProjectionMatrixUncentered", value: function () { return this.viewport.viewProjectionMatrix } }, { key: "getFocalDistance", value: function () { return 1 } }, { key: "projectFlat", value: function (t, e) { return this.viewport.projectFlat(t, e) } }]), t }(), yM = { light: "mapbox://styles/zcxduo/ck2ypyb1r3q9o1co1766dex29", dark: "mapbox://styles/zcxduo/ck241p6413s0b1cpayzldv7x7", normal: "mapbox://styles/mapbox/streets-v11", blank: { version: 8, sources: {}, layers: [{ id: "background", type: "background", layout: { visibility: "none" } }] } }, gM = ["id", "attributionControl", "style", "token", "rotation", "mapInstance"]; function _M(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function xM(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? _M(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _M(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } !function (t, e) { var n = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, r = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram); if (!n && !r && (e || (e = document), e)) { var i = e.head || e.getElementsByTagName("head")[0]; if (!i) { i = e.createElement("head"); var o = e.body || e.getElementsByTagName("body")[0]; o ? o.parentNode.insertBefore(i, o) : e.documentElement.appendChild(i) } var a = e.createElement("style"); a.type = "text/css", a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), i.appendChild(a) } }(".mapboxgl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mapboxgl-canvas{position:absolute;left:0;top:0}.mapboxgl-map:-webkit-full-screen{width:100%;height:100%}.mapboxgl-canary{background-color:salmon}.mapboxgl-canvas-container.mapboxgl-interactive,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass{cursor:-webkit-grab;cursor:grab;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.mapboxgl-canvas-container.mapboxgl-interactive.mapboxgl-track-pointer{cursor:pointer}.mapboxgl-canvas-container.mapboxgl-interactive:active,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass:active{cursor:-webkit-grabbing;cursor:grabbing}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate .mapboxgl-canvas{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.mapboxgl-canvas-container.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-drag-pan .mapboxgl-canvas{-ms-touch-action:pinch-zoom;touch-action:pinch-zoom}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas{-ms-touch-action:none;touch-action:none}.mapboxgl-ctrl-bottom-left,.mapboxgl-ctrl-bottom-right,.mapboxgl-ctrl-top-left,.mapboxgl-ctrl-top-right{position:absolute;pointer-events:none;z-index:2}.mapboxgl-ctrl-top-left{top:0;left:0}.mapboxgl-ctrl-top-right{top:0;right:0}.mapboxgl-ctrl-bottom-left{bottom:0;left:0}.mapboxgl-ctrl-bottom-right{right:0;bottom:0}.mapboxgl-ctrl{clear:both;pointer-events:auto;-webkit-transform:translate(0);transform:translate(0)}.mapboxgl-ctrl-top-left .mapboxgl-ctrl{margin:10px 0 0 10px;float:left}.mapboxgl-ctrl-top-right .mapboxgl-ctrl{margin:10px 10px 0 0;float:right}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl{margin:0 0 10px 10px;float:left}.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl{margin:0 10px 10px 0;float:right}.mapboxgl-ctrl-group{border-radius:4px;background:#fff}.mapboxgl-ctrl-group:not(:empty){-webkit-box-shadow:0 0 2px rgba(0,0,0,.1);box-shadow:0 0 0 2px rgba(0,0,0,.1)}@media (-ms-high-contrast:active){.mapboxgl-ctrl-group:not(:empty){-webkit-box-shadow:0 0 0 2px ButtonText;box-shadow:0 0 0 2px ButtonText}}.mapboxgl-ctrl-group button{width:29px;height:29px;display:block;padding:0;outline:none;border:0;-webkit-box-sizing:border-box;box-sizing:border-box;background-color:transparent;cursor:pointer}.mapboxgl-ctrl-group button+button{border-top:1px solid #ddd}.mapboxgl-ctrl button .mapboxgl-ctrl-icon{display:block;width:100%;height:100%;background-repeat:no-repeat;background-position:50%}@media (-ms-high-contrast:active){.mapboxgl-ctrl-icon{background-color:transparent}.mapboxgl-ctrl-group button+button{border-top:1px solid ButtonText}}.mapboxgl-ctrl button::-moz-focus-inner{border:0;padding:0}.mapboxgl-ctrl-attrib-button:focus,.mapboxgl-ctrl-group button:focus{-webkit-box-shadow:0 0 2px 2px #0096ff;box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl button:disabled{cursor:not-allowed}.mapboxgl-ctrl button:disabled .mapboxgl-ctrl-icon{opacity:.25}.mapboxgl-ctrl button:not(:disabled):hover{background-color:rgba(0,0,0,.05)}.mapboxgl-ctrl-group button:focus:focus-visible{-webkit-box-shadow:0 0 2px 2px #0096ff;box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl-group button:focus:not(:focus-visible){-webkit-box-shadow:none;box-shadow:none}.mapboxgl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.mapboxgl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.mapboxgl-ctrl-group button:focus:only-child{border-radius:inherit}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23999'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23aaa'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-waiting .mapboxgl-ctrl-icon{-webkit-animation:mapboxgl-spin 2s linear infinite;animation:mapboxgl-spin 2s linear infinite}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23999'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23666'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}}@-webkit-keyframes mapboxgl-spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes mapboxgl-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}a.mapboxgl-ctrl-logo{width:88px;height:23px;margin:0 0 -4px -4px;display:block;background-repeat:no-repeat;cursor:pointer;overflow:hidden;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg opacity='.3' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg opacity='.9' fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E\")}a.mapboxgl-ctrl-logo.mapboxgl-compact{width:23px}@media (-ms-high-contrast:active){a.mapboxgl-ctrl-logo{background-color:transparent;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){a.mapboxgl-ctrl-logo{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23fff' stroke-width='3' fill='%23fff'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl.mapboxgl-ctrl-attrib{padding:0 5px;background-color:hsla(0,0%,100%,.5);margin:0}@media screen{.mapboxgl-ctrl-attrib.mapboxgl-compact{min-height:20px;padding:2px 24px 2px 0;margin:10px;position:relative;background-color:#fff;border-radius:12px}.mapboxgl-ctrl-attrib.mapboxgl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show,.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show{padding:2px 8px 2px 28px;border-radius:12px}.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-inner{display:none}.mapboxgl-ctrl-attrib-button{display:none;cursor:pointer;position:absolute;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\");background-color:hsla(0,0%,100%,.5);width:24px;height:24px;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:12px;outline:none;top:0;right:0;border:0}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl-attrib-button,.mapboxgl-ctrl-top-left .mapboxgl-ctrl-attrib-button{left:0}.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-inner,.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-button{display:block}.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-button{background-color:rgba(0,0,0,.05)}.mapboxgl-ctrl-bottom-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;right:0}.mapboxgl-ctrl-top-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;right:0}.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;left:0}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;left:0}}@media screen and (-ms-high-contrast:active){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' fill='%23fff'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\")}}@media screen and (-ms-high-contrast:black-on-white){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl-attrib a{color:rgba(0,0,0,.75);text-decoration:none}.mapboxgl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.mapboxgl-ctrl-attrib .mapbox-improve-map{font-weight:700;margin-left:2px}.mapboxgl-attrib-empty{display:none}.mapboxgl-ctrl-scale{background-color:hsla(0,0%,100%,.75);font-size:10px;border:2px solid #333;border-top:#333;padding:0 5px;color:#333;-webkit-box-sizing:border-box;box-sizing:border-box}.mapboxgl-popup{position:absolute;top:0;left:0;display:-webkit-box;display:-ms-flexbox;display:flex;will-change:transform;pointer-events:none}.mapboxgl-popup-anchor-top,.mapboxgl-popup-anchor-top-left,.mapboxgl-popup-anchor-top-right{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.mapboxgl-popup-anchor-bottom,.mapboxgl-popup-anchor-bottom-left,.mapboxgl-popup-anchor-bottom-right{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.mapboxgl-popup-anchor-left{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.mapboxgl-popup-anchor-right{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.mapboxgl-popup-tip{width:0;height:0;border:10px solid transparent;z-index:1}.mapboxgl-popup-anchor-top .mapboxgl-popup-tip{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;border-top:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip{-webkit-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start;border-top:none;border-left:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip{-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border-top:none;border-right:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;border-bottom:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip{-webkit-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip{-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.mapboxgl-popup-anchor-left .mapboxgl-popup-tip{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;border-left:none;border-right-color:#fff}.mapboxgl-popup-anchor-right .mapboxgl-popup-tip{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;border-right:none;border-left-color:#fff}.mapboxgl-popup-close-button{position:absolute;right:0;top:0;border:0;border-radius:0 3px 0 0;cursor:pointer;background-color:transparent}.mapboxgl-popup-close-button:hover{background-color:rgba(0,0,0,.05)}.mapboxgl-popup-content{position:relative;background:#fff;border-radius:3px;-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);box-shadow:0 1px 2px rgba(0,0,0,.1);padding:10px 10px 15px;pointer-events:auto}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-content{border-top-left-radius:0}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-content{border-top-right-radius:0}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-content{border-bottom-left-radius:0}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-content{border-bottom-right-radius:0}.mapboxgl-popup-track-pointer{display:none}.mapboxgl-popup-track-pointer *{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mapboxgl-map:hover .mapboxgl-popup-track-pointer{display:-webkit-box;display:-ms-flexbox;display:flex}.mapboxgl-map:active .mapboxgl-popup-track-pointer{display:none}.mapboxgl-marker{position:absolute;top:0;left:0;will-change:transform}.mapboxgl-user-location-dot,.mapboxgl-user-location-dot:before{background-color:#1da1f2;width:15px;height:15px;border-radius:50%}.mapboxgl-user-location-dot:before{content:\"\";position:absolute;-webkit-animation:mapboxgl-user-location-dot-pulse 2s infinite;animation:mapboxgl-user-location-dot-pulse 2s infinite}.mapboxgl-user-location-dot:after{border-radius:50%;border:2px solid #fff;content:\"\";height:19px;left:-2px;position:absolute;top:-2px;width:19px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 0 3px rgba(0,0,0,.35);box-shadow:0 0 3px rgba(0,0,0,.35)}@-webkit-keyframes mapboxgl-user-location-dot-pulse{0%{-webkit-transform:scale(1);opacity:1}70%{-webkit-transform:scale(3);opacity:0}to{-webkit-transform:scale(1);opacity:0}}@keyframes mapboxgl-user-location-dot-pulse{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}70%{-webkit-transform:scale(3);transform:scale(3);opacity:0}to{-webkit-transform:scale(1);transform:scale(1);opacity:0}}.mapboxgl-user-location-dot-stale{background-color:#aaa}.mapboxgl-user-location-dot-stale:after{display:none}.mapboxgl-user-location-accuracy-circle{background-color:rgba(29,161,242,.2);width:1px;height:1px;border-radius:100%}.mapboxgl-crosshair,.mapboxgl-crosshair .mapboxgl-interactive,.mapboxgl-crosshair .mapboxgl-interactive:active{cursor:crosshair}.mapboxgl-boxzoom{position:absolute;top:0;left:0;width:0;height:0;background:#fff;border:2px dotted #202020;opacity:.5}@media print{.mapbox-improve-map{display:none}}"), window.mapboxgl = mM; var bM = { mapmove: "move", camerachange: "move", zoomchange: "zoom", dragging: "drag" }, wM = 0, SM = "pk.eyJ1IjoibHp4dWUiLCJhIjoiY2tvaWZuM2s4MWZuYjJ1dHI5ZGduYTlrdiJ9.DQCfMRbZzx0VSwecQ69McA", EM = (iM = ut.injectable(), oM = ut.inject(Tr.MapConfig), aM = ut.inject(Tr.IGlobalConfigService), sM = ut.inject(Tr.ICoordinateSystemService), lM = ut.inject(Tr.IEventEmitter), iM((cM = function () { function t() { var e = this; Ar(this, t), kr(this, "version", lA.MAPBOX), kr(this, "map", void 0), kr(this, "simpleMapCoord", new cA), kr(this, "bgColor", "rgba(0.0, 0.0, 0.0, 0.0)"), Ef(this, "config", pM, this), Ef(this, "configService", hM, this), Ef(this, "coordinateSystemService", fM, this), Ef(this, "eventEmitter", dM, this), kr(this, "viewport", void 0), kr(this, "markerContainer", void 0), kr(this, "cameraChangedCallback", void 0), kr(this, "$mapContainer", void 0), kr(this, "handleCameraChanged", (function () { var t = e.map.getCenter().wrap(), n = t.lat, r = t.lng; e.emit("mapchange"), e.viewport.syncWithMapCamera({ bearing: e.map.getBearing(), center: [r, n], viewportHeight: e.map.transform.height, pitch: e.map.getPitch(), viewportWidth: e.map.transform.width, zoom: e.map.getZoom(), cameraHeight: 0 }); var i = e.config.offsetZoom, o = void 0 === i ? 12 : i; e.viewport.getZoom() > o ? e.coordinateSystemService.setCoordinateSystem(Tf.LNGLAT_OFFSET) : e.coordinateSystemService.setCoordinateSystem(Tf.LNGLAT), e.cameraChangedCallback(e.viewport) })) } var e; return Or(t, [{ key: "setBgColor", value: function (t) { this.bgColor = t } }, { key: "addMarkerContainer", value: function () { var t = this.map.getCanvasContainer(); this.markerContainer = lo("div", "l7-marker-container", t), this.markerContainer.setAttribute("tabindex", "-1") } }, { key: "getMarkerContainer", value: function () { return this.markerContainer } }, { key: "on", value: function (t, e) { -1 !== Mx.indexOf(t) ? this.eventEmitter.on(t, e) : this.map.on(bM[t] || t, e) } }, { key: "off", value: function (t, e) { this.map.off(bM[t] || t, e), this.eventEmitter.off(t, e) } }, { key: "getContainer", value: function () { return this.map.getContainer() } }, { key: "getMapCanvasContainer", value: function () { return this.map.getCanvasContainer() } }, { key: "getSize", value: function () { var t = this.map.transform; return [t.width, t.height] } }, { key: "getType", value: function () { return "mapbox" } }, { key: "getZoom", value: function () { return this.map.getZoom() } }, { key: "setZoom", value: function (t) { return this.map.setZoom(t) } }, { key: "getCenter", value: function () { return this.map.getCenter() } }, { key: "setCenter", value: function (t) { this.map.setCenter(t) } }, { key: "getPitch", value: function () { return this.map.getPitch() } }, { key: "getRotation", value: function () { return this.map.getBearing() } }, { key: "getBounds", value: function () { return this.map.getBounds().toArray() } }, { key: "getMinZoom", value: function () { return this.map.getMinZoom() } }, { key: "getMaxZoom", value: function () { return this.map.getMaxZoom() } }, { key: "setRotation", value: function (t) { this.map.setBearing(t) } }, { key: "zoomIn", value: function (t, e) { this.map.zoomIn(t, e) } }, { key: "zoomOut", value: function (t, e) { this.map.zoomOut(t, e) } }, { key: "setPitch", value: function (t) { return this.map.setPitch(t) } }, { key: "panTo", value: function (t) { this.map.panTo(t) } }, { key: "panBy", value: function (t, e) { this.panTo([t, e]) } }, { key: "fitBounds", value: function (t, e) { this.map.fitBounds(t, e) } }, { key: "setMaxZoom", value: function (t) { this.map.setMaxZoom(t) } }, { key: "setMinZoom", value: function (t) { this.map.setMinZoom(t) } }, { key: "setMapStatus", value: function (t) { !0 === t.doubleClickZoom && this.map.doubleClickZoom.enable(), !1 === t.doubleClickZoom && this.map.doubleClickZoom.disable(), !1 === t.dragEnable && this.map.dragPan.disable(), !0 === t.dragEnable && this.map.dragPan.enable(), !1 === t.rotateEnable && this.map.dragRotate.disable(), !0 === t.rotateEnable && this.map.dragRotate.enable(), !1 === t.keyboardEnable && this.map.keyboard.disable(), !0 === t.keyboardEnable && this.map.keyboard.enable(), !1 === t.zoomEnable && this.map.scrollZoom.disable(), !0 === t.zoomEnable && this.map.scrollZoom.enable() } }, { key: "setZoomAndCenter", value: function (t, e) { this.map.flyTo({ zoom: t, center: e }) } }, { key: "setMapStyle", value: function (t) { this.map.setStyle(this.getMapStyle(t)) } }, { key: "pixelToLngLat", value: function (t) { return this.map.unproject(t) } }, { key: "lngLatToPixel", value: function (t) { return this.map.project(t) } }, { key: "containerToLngLat", value: function (t) { return this.map.unproject(t) } }, { key: "lngLatToContainer", value: function (t) { return this.map.project(t) } }, { key: "lngLatToCoord", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { x: 0, y: 0, z: 0 }, n = this.lngLatToMercator(t, 0), r = n.x, i = n.y; return [r - e.x, i - e.y] } }, { key: "lngLatToMercator", value: function (t, e) { var n = window.mapboxgl.MercatorCoordinate.fromLngLat(t, e), r = n.x, i = void 0 === r ? 0 : r, o = n.y, a = void 0 === o ? 0 : o, s = n.z; return { x: i, y: a, z: void 0 === s ? 0 : s } } }, { key: "getModelMatrix", value: function (t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1, 1], i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { x: 0, y: 0, z: 0 }, o = window.mapboxgl.MercatorCoordinate.fromLngLat(t, e), a = o.meterInMercatorCoordinateUnits(), s = os(); return ps(s, s, Is(o.x - i.x, o.y - i.y, o.z || 0 - i.z)), hs(s, s, Is(a * r[0], -a * r[1], a * r[2])), fs(s, s, n[0]), ds(s, s, n[1]), ms(s, s, n[2]), s } }, { key: "init", value: (e = nd(gd.mark((function t() { var e, n, r, i, o, a, s, l, u, c, p, h, f; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: e = this.config, n = e.id, r = void 0 === n ? "map" : n, i = e.attributionControl, o = void 0 !== i && i, a = e.style, s = void 0 === a ? "light" : a, l = e.token, u = void 0 === l ? SM : l, c = e.rotation, p = void 0 === c ? 0 : c, h = e.mapInstance, f = zd(e, gM), this.viewport = new vM, h || window.mapboxgl || console.error(this.configService.getSceneWarninfo("SDK")), u !== SM || "blank" === s || window.mapboxgl.accessToken || h || console.warn(this.configService.getSceneWarninfo("MapToken")), h || window.mapboxgl.accessToken || (window.mapboxgl.accessToken = u), h ? (this.map = h, this.$mapContainer = this.map.getContainer()) : (this.$mapContainer = this.creatAmapContainer(r), this.map = new window.mapboxgl.Map(xM({ container: this.$mapContainer, style: this.getMapStyle(s), attributionControl: o, bearing: p }, f))), this.map.on("load", this.handleCameraChanged), this.map.on("move", this.handleCameraChanged), this.handleCameraChanged(); case 9: case "end": return t.stop() } }), t, this) }))), function () { return e.apply(this, arguments) }) }, { key: "destroy", value: function () { var t, e; null === (t = this.$mapContainer) || void 0 === t || null === (e = t.parentNode) || void 0 === e || e.removeChild(this.$mapContainer), this.eventEmitter.removeAllListeners(), this.map && (this.map.remove(), this.$mapContainer = null) } }, { key: "emit", value: function (t) { for (var e, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; (e = this.eventEmitter).emit.apply(e, [t].concat(r)) } }, { key: "once", value: function (t) { for (var e, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; (e = this.eventEmitter).once.apply(e, [t].concat(r)) } }, { key: "getMapContainer", value: function () { return this.$mapContainer } }, { key: "meterToCoord", value: function (t, e) { var n = new mM.LngLat(t[0], t[1]), r = new mM.LngLat(e[0], e[1]), i = n.distanceTo(r), o = mM.MercatorCoordinate.fromLngLat({ lng: t[0], lat: t[1] }), a = mM.MercatorCoordinate.fromLngLat({ lng: e[0], lat: e[1] }), s = o.x, l = o.y, u = a.x, c = a.y; return 4194304 * Math.sqrt(Math.pow(s - u, 2) + Math.pow(l - c, 2)) * 2 / i } }, { key: "exportMap", value: function (t) { var e = this.map.getCanvas(); return "jpg" === t ? null == e ? void 0 : e.toDataURL("image/jpeg") : null == e ? void 0 : e.toDataURL("image/png") } }, { key: "onCameraChanged", value: function (t) { this.cameraChangedCallback = t } }, { key: "creatAmapContainer", value: function (t) { var e = t; "string" == typeof t && (e = document.getElementById(t)); var n = document.createElement("div"); return n.style.cssText += "\n      position: absolute;\n      top: 0;\n      height: 100%;\n      width: 100%;\n    ", n.id = "l7_mapbox_div" + wM++, e.appendChild(n), n } }, { key: "getMapStyle", value: function (t) { return "string" != typeof t ? t : yM[t] ? yM[t] : t } }]), t }(), pM = Cf(cM.prototype, "config", [oM], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), hM = Cf(cM.prototype, "configService", [aM], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), fM = Cf(cM.prototype, "coordinateSystemService", [sM], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), dM = Cf(cM.prototype, "eventEmitter", [lM], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), uM = cM)) || uM); function CM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } !function (t, e) { var n = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM, r = "undefined" != typeof wx && null !== wx && (void 0 !== wx.request || void 0 !== wx.miniProgram); if (!n && !r && (e || (e = document), e)) { var i = e.head || e.getElementsByTagName("head")[0]; if (!i) { i = e.createElement("head"); var o = e.body || e.getElementsByTagName("body")[0]; o ? o.parentNode.insertBefore(i, o) : e.documentElement.appendChild(i) } var a = e.createElement("style"); a.type = "text/css", a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), i.appendChild(a) } }(".mapboxgl-ctrl-logo {\n display: none !important;\n}\n"); var TM = function (t) { Ur(n, t); var e = CM(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getServiceConstructor", value: function () { return EM } }]), n }(aA); function AM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var MM = function (t) { Ur(n, t); var e = AM(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(); return { u_opacity: t.opacity || 1, u_coverage: t.coverage || .9, u_angle: t.angle || 0, u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset] } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "gridheatmap", vertexShader: 'precision highp float;\r\n// 多边形顶点坐标\r\nattribute vec3 a_Position;\r\n// 多边形经纬度坐标\r\nattribute vec3 a_Pos;\r\nattribute float a_Size;\r\nattribute vec4 a_Color;\r\nuniform vec2 u_radius;\r\nuniform float u_coverage: 0.9;\r\nuniform float u_angle: 0;\r\nuniform mat4 u_ModelMatrix;\r\nuniform mat4 u_Mvp;\r\nvarying vec4 v_color;\r\n\r\nuniform vec2 u_SceneCenterMKT;\r\n\r\n#pragma include "projection"\r\n#pragma include "project"\r\n#pragma include "picking"\r\n\r\nvoid main() {\r\n  v_color = a_Color;\r\n\r\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\r\n  vec2 offset = a_Position.xy * u_radius * rotationMatrix * u_coverage ;\r\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n  // gl_Position = project_common_position_to_clipspace(project_pos);\r\n\r\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\r\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // 将经纬度转换为高德2.0需要的平面坐标\r\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\r\n    gl_Position = u_Mvp * (project_pos);\r\n  } else {\r\n     vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n    gl_Position = project_common_position_to_clipspace(project_pos);\r\n  }\r\n\r\n  setPickingColor(a_PickingColor);\r\n}\r\n', fragmentShader: 'precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include "picking"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: tA, depth: { enable: !1 }, primitive: id.TRIANGLES, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "pos", type: bx.Attribute, descriptor: { name: "a_Pos", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e) { var n = "GAODE2.x" === t.version ? t.originCoordinates : t.coordinates; return [n[0], n[1], 0] } } }) } }]), n }(UC); function OM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var kM, IM = function (t) { Ur(n, t); var e = OM(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(); return { u_opacity: t.opacity || 1, u_coverage: t.coverage || 1, u_angle: t.angle || 0, u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset] } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "grid3dheatmap", vertexShader: 'precision highp float;\n// 多边形顶点坐标\nattribute vec3 a_Position;\n// 多边形经纬度坐标\nattribute vec3 a_Pos;\n\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec4 a_Color;\nuniform vec2 u_radius;\nuniform float u_coverage: 0.9;\nuniform float u_angle: 0;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform vec2 u_SceneCenterMKT;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "light"\n#pragma include "picking"\n\n\nvoid main() {\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // 实际的经纬度\n  // vec2 lnglat = (a_Pos.xy + offset); \n  // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n  // gl_Position = project_common_position_to_clipspace(project_pos);\n  // float lightWeight = calc_lighting(project_pos);\n  // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // vec2 lnglat = (a_Pos.xy + offset); \n    // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n\n    // float lightWeight = calc_lighting(project_pos);\n    // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n  \n    // gl_Position = u_Mvp * vec4(lnglat , a_Position.z * a_Size, 1.0);\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // 经纬度\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // 将经纬度转换为高德2.0需要的平面坐标\n    vec4 project_pos = project_position(vec4(customLnglat, a_Position.z * a_Size, 1.0));\n\n    float lightWeight = calc_lighting(project_pos);\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n  \n    gl_Position = u_Mvp * vec4(customLnglat , a_Position.z * a_Size, 1.0);\n  } else {\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // 实际的经纬度\n    vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n    \n    float lightWeight = calc_lighting(project_pos);\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n    \n    gl_Position = project_common_position_to_clipspace(project_pos);\n  }\n\n\n\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: 'precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include "picking"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: XT, depth: { enable: !0 }, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size; return Array.isArray(i) ? [i[0]] : [i] } } }), this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "pos", type: bx.Attribute, descriptor: { name: "a_Pos", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e) { var n = "GAODE2.x" === t.version ? t.originCoordinates : t.coordinates; return [n[0], n[1], 0] } } }) } }]), n }(UC); function PM(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function LM(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? PM(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : PM(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function RM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var DM = ut.injectable()(kM = function (t) { Ur(n, t); var e = RM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "colorTexture", void 0), kr(Gr(t), "heatmapFramerBuffer", void 0), kr(Gr(t), "intensityModel", void 0), kr(Gr(t), "colorModel", void 0), kr(Gr(t), "shapeType", void 0), t } return Or(n, [{ key: "render", value: function () { var t = this, e = this.rendererService, n = e.clear; (0, e.useFramebuffer)(this.heatmapFramerBuffer, (function () { n({ color: [0, 0, 0, 0], depth: 1, stencil: 0, framebuffer: t.heatmapFramerBuffer }), t.drawIntensityMode() })), this.layer.styleNeedUpdate && this.updateColorTexture(), "heatmap" === this.shapeType ? this.drawColorMode() : this.draw3DHeatMap() } }, { key: "getUninforms", value: function () { throw new Error("Method not implemented.") } }, { key: "initModels", value: function () { var t, e = this.rendererService, n = e.createFramebuffer; e.clear; var r = e.getViewportSize, i = e.createTexture2D; e.useFramebuffer; var o = this.styleAttributeService.getLayerStyleAttribute("shape"), a = (null == o || null === (t = o.scale) || void 0 === t ? void 0 : t.field) || "heatmap"; this.shapeType = a, this.intensityModel = this.buildHeatMapIntensity(), this.colorModel = "heatmap" === a ? this.buildHeatmapColor() : this.build3dHeatMap(); var s = r(), l = s.width, u = s.height; return this.heatmapFramerBuffer = n({ color: i({ width: Math.floor(l / 4), height: Math.floor(u / 4), wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE, min: id.LINEAR, mag: id.LINEAR }), depth: !1 }), this.updateColorTexture(), [this.intensityModel, this.colorModel] } }, { key: "buildModels", value: function () { return this.initModels() } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "dir", type: bx.Attribute, descriptor: { name: "a_Dir", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { return [n[3], n[4]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size; return [void 0 === i ? 1 : i] } } }) } }, { key: "buildHeatMapIntensity", value: function () { return this.layer.buildLayerModel({ moduleName: "heatmapintensity", vertexShader: 'precision highp float;\nattribute vec3 a_Position;\nattribute float a_Size;\nattribute vec2 a_Dir;\nuniform float u_intensity;\nuniform float u_radius;\nvarying vec2 v_extrude;\nvarying float v_weight;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\n#define GAUSS_COEF  0.3989422804014327\n\n#pragma include "projection"\n\nvoid main(){\n    v_weight = a_Size;\n    float ZERO = 1.0 / 255.0 / 16.0;\n    float extrude_x = a_Dir.x * 2.0 -1.0;\n    float extrude_y = a_Dir.y * 2.0 -1.0;\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 2.5;\n    v_extrude = extrude_dir * S;\n\n    vec2 offset = project_pixel(v_extrude * u_radius);\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n    // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n        gl_Position = u_Mvp * (vec4(project_pos.xy + offset, 0.0, 1.0));\n    } else {\n        gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n    }\n}\n', fragmentShader: "precision highp float;\nuniform float u_intensity;\nvarying float v_weight;\nvarying vec2 v_extrude;\n#define GAUSS_COEF  0.3989422804014327\nvoid main(){\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\n    gl_FragColor = vec4(val, 1., 1., 1.);\n}\n", triangulation: nA, depth: { enable: !1 }, cull: { enable: !0, face: Ma(this.mapService.version) }, blend: { enable: !0, func: { srcRGB: id.ONE, srcAlpha: 1, dstRGB: id.ONE, dstAlpha: 1 } } }) } }, { key: "buildHeatmapColor", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; this.shaderModuleService.registerModule("heatmapColor", { vs: "precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = a_Uv;\n\n  gl_Position = vec4(a_Position.xy, 0, 1.);\n}\n", fs: "uniform sampler2D u_texture;        // 热力强度图\nuniform sampler2D u_colorTexture;   // 根据强度分布的色带\nuniform float u_opacity;\nvarying vec2 v_texCoord;\n\nfloat getBlurIndusty() {\n    float h = 2.0/512.0;\n    vec2 vUv = v_texCoord;\n    float i11 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y + 1.0 * h) ).r;\n    float i12 = texture2D( u_texture, vec2( vUv.x - 0.0 * h, vUv.y + 1.0 * h) ).r;\n    float i13 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y + 1.0 * h) ).r;\n\n    float i21 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y) ).r;\n    float i22 = texture2D( u_texture, vec2( vUv.x , vUv.y) ).r;\n    float i23 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y) ).r;\n\n    float i31 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y-1.0*h) ).r;\n    float i32 = texture2D( u_texture, vec2( vUv.x - 0.0 * h, vUv.y-1.0*h) ).r;\n    float i33 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y-1.0*h) ).r;\n\n    return(\n        i11 + \n        i12 + \n        i13 + \n        i21 + \n        i21 + \n        i22 + \n        i23 + \n        i31 + \n        i32 + \n        i33\n        )/9.0;\n}\n\n\nvoid main(){\n    // float intensity = texture2D(u_texture, v_texCoord).r;\n    float intensity = getBlurIndusty();\n    vec4 color = texture2D(u_colorTexture, vec2(intensity, 0.0));\n\n    gl_FragColor =color;\n    gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n\n}\n" }); var o = this.shaderModuleService.getModule("heatmapColor"), a = o.vs, s = o.fs, l = o.uniforms, u = this.rendererService, c = u.createAttribute, p = u.createElements, h = u.createBuffer; return (0, u.createModel)({ vs: a, fs: s, attributes: { a_Position: c({ buffer: h({ data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], type: id.FLOAT }), size: 3 }), a_Uv: c({ buffer: h({ data: [0, 1, 1, 1, 0, 0, 1, 0], type: id.FLOAT }), size: 2 }) }, uniforms: LM({}, l), depth: { enable: !1 }, blend: this.getBlend(), count: 6, elements: p({ data: [0, 2, 1, 2, 3, 1], type: id.UNSIGNED_INT, count: 6 }), stencil: Ca(n, i) }) } }, { key: "drawIntensityMode", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.intensity, r = void 0 === n ? 10 : n, i = t.radius, o = void 0 === i ? 5 : i; this.intensityModel.draw({ uniforms: { u_opacity: e || 1, u_radius: o, u_intensity: r } }) } }, { key: "drawColorMode", value: function () { var t = this.layer.getLayerConfig().opacity; this.colorModel.draw({ uniforms: { u_opacity: t || 1, u_colorTexture: this.colorTexture, u_texture: this.heatmapFramerBuffer } }) } }, { key: "draw3DHeatMap", value: function () { var t = this.layer.getLayerConfig().opacity, e = os(); us(e, this.cameraService.getViewProjectionMatrixUncentered()), this.colorModel.draw({ uniforms: { u_opacity: t || 1, u_colorTexture: this.colorTexture, u_texture: this.heatmapFramerBuffer, u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(), u_InverseViewProjectionMatrix: Fd(e) } }) } }, { key: "build3dHeatMap", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = (0, this.rendererService.getViewportSize)(), a = function (t, e) { for (var n = [], r = [], i = [], o = t + 1, a = e + 1, s = t / 2, l = e / 2, u = 0; u < a; u++)for (var c = u - l, p = 0; p < o; p++) { var h = p - s; r.push(h / s, -c / l, 0), i.push(p / t), i.push(1 - u / e) } for (var f = 0; f < e; f++)for (var d = 0; d < t; d++) { var m = d + o * f, v = d + o * (f + 1), y = d + 1 + o * (f + 1), g = d + 1 + o * f; n.push(m, v, g), n.push(v, y, g) } return { vertices: r, indices: n, uvs: i } }(o.width / 4, o.height / 4); this.shaderModuleService.registerModule("heatmap3dColor", { vs: 'precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_InverseViewProjectionMatrix;\nuniform mat4 u_ViewProjectionMatrixUncentered;\nvarying float v_intensity;\n\n\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    float t2 = t * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\n}\nvec2 toBezier(float t, vec4 p){\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\n}\n#pragma include "projection"\nvoid main() {\n  v_texCoord = a_Uv;\n\n  vec2 pos = a_Uv * vec2(2.0) - vec2(1.0); // 将原本 0 -> 1 的 uv 转换为 -1 -> 1 的标准坐标空间（NDC）\n\n  vec4 p1 = vec4(pos, 0.0, 1.0); // x/y 平面上的点（z == 0）可以认为是三维上的点被投影到平面后的点\n\tvec4 p2 = vec4(pos, 1.0, 1.0); // 平行于x/y平面、z==1 的平面上的点\n\n\tvec4 inverseP1 = u_InverseViewProjectionMatrix * p1; // 根据视图投影矩阵的逆矩阵平面上的反算出三维空间中的点（p1平面上的点）\n\tvec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\n\n  inverseP1 = inverseP1 / inverseP1.w; // 归一化操作（归一化后为世界坐标）\n\tinverseP2 = inverseP2 / inverseP2.w;\n\n\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z); // ??\n\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\n\n  vec4 b= vec4(0.5000, 0.0, 1.0, 0.5000);\n  float fh;\n\n  v_intensity = texture2D(u_texture, v_texCoord).r;\n  fh = toBezier(v_intensity, b).y;\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.), 1.0);\n \n}\n', fs: "uniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_opacity;\nvarying vec2 v_texCoord;\nvarying float v_intensity;\n\nvoid main(){\n   \n     float intensity = texture2D(u_texture, v_texCoord).r;\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\n    gl_FragColor = color;\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\n     gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n}\n" }); var s = this.shaderModuleService.getModule("heatmap3dColor"), l = s.vs, u = s.fs, c = s.uniforms, p = this.rendererService, h = p.createAttribute, f = p.createElements, d = p.createBuffer; return (0, p.createModel)({ vs: l, fs: u, attributes: { a_Position: h({ buffer: d({ data: a.vertices, type: id.FLOAT }), size: 3 }), a_Uv: h({ buffer: d({ data: a.uvs, type: id.FLOAT }), size: 2 }) }, primitive: id.TRIANGLES, uniforms: LM({}, c), depth: { enable: !0 }, blend: { enable: !0, func: { srcRGB: id.SRC_ALPHA, srcAlpha: 1, dstRGB: id.ONE_MINUS_SRC_ALPHA, dstAlpha: 1 } }, elements: f({ data: a.indices, type: id.UNSIGNED_INT, count: a.indices.length }), stencil: Ca(n, i) }) } }, { key: "updateStyle", value: function () { this.updateColorTexture() } }, { key: "updateColorTexture", value: function () { var t = this.rendererService.createTexture2D; this.texture && this.texture.destroy(); var e = function (t) { var e = oo.document.createElement("canvas"), n = e.getContext("2d"); e.width = 256, e.height = 1; for (var r = n.createLinearGradient(0, 0, 256, 1), i = null, o = t.positions[0], a = t.positions[t.positions.length - 1], s = 0; s < t.colors.length; ++s) { var l = (t.positions[s] - o) / (a - o); r.addColorStop(l, t.colors[s]) } if (n.fillStyle = r, n.fillRect(0, 0, 256, 1), ro) return { data: i = new Uint8ClampedArray(n.getImageData(0, 0, 256, 1).data), width: 256, height: 1 }; i = n.getImageData(0, 0, 256, 1).data; for (var u = n.createImageData(256, 1), c = 0; c < u.data.length; c += 4)u.data[c + 0] = i[c + 0], u.data[c + 1] = i[c + 1], u.data[c + 2] = i[c + 2], u.data[c + 3] = i[c + 3]; return u }(this.layer.getLayerConfig().rampColors); this.colorTexture = t({ data: new Uint8Array(e.data), width: e.width, height: e.height, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE, min: id.NEAREST, mag: id.NEAREST, flipY: !1 }) } }]), n }(UC)) || kM; function NM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var zM = function (t) { Ur(n, t); var e = NM(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(); return { u_opacity: t.opacity || 1, u_coverage: t.coverage || .9, u_angle: t.angle || 0, u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset] } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "hexagonheatmap", vertexShader: 'precision highp float;\n// 多边形顶点坐标\nattribute vec3 a_Position;\n// 多边形经纬度坐标\nattribute vec3 a_Pos;\nattribute float a_Size;\nattribute vec4 a_Color;\nuniform vec2 u_radius;\nuniform float u_coverage: 0.9;\nuniform float u_angle: 0;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform vec2 u_SceneCenterMKT;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nvoid main() {\n  v_color = a_Color;\n    \n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\n \n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xy, 0., 1.0));\n    // gl_Position = u_Mvp * (vec4(a_Pos.xy + offset, 0., 1.0));\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT;\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\n    gl_Position = u_Mvp * vec4(project_pos.xy, 0.0, 1.0);\n  } else {\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: 'precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include "picking"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: tA, depth: { enable: !1 }, primitive: id.TRIANGLES, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "pos", type: bx.Attribute, descriptor: { name: "a_Pos", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e) { var n = "GAODE2.x" === t.version ? t.originCoordinates : t.coordinates; return [n[0], n[1], 0] } } }) } }]), n }(UC), FM = { heatmap: DM, heatmap3d: DM, grid: MM, grid3d: IM, hexagon: zM }; function BM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var jM = function (t) { Ur(n, t); var e = BM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "type", "HeatMapLayer"), t } return Or(n, [{ key: "buildModels", value: function () { var t = this.getModelType(); this.layerModel = new FM[t](this), this.models = this.layerModel.initModels() } }, { key: "rebuildModels", value: function () { this.models = this.layerModel.buildModels() } }, { key: "renderModels", value: function () { var t = this; return "heatmap" === this.getModelType() ? (this.layerModel && this.layerModel.render(), this) : (this.layerModelNeedUpdate && (this.models = this.layerModel.buildModels(), this.layerModelNeedUpdate = !1), this.models.forEach((function (e) { return e.draw({ uniforms: t.layerModel.getUninforms() }) })), this) } }, { key: "getConfigSchema", value: function () { return { properties: { opacity: { type: "number", minimum: 0, maximum: 1 } } } } }, { key: "getModelType", value: function () { var t, e = this.styleAttributeService.getLayerStyleAttribute("shape"), n = this.getLayerConfig().shape3d, r = this.getSource().data.type, i = (null == e || null === (t = e.scale) || void 0 === t ? void 0 : t.field) || "heatmap"; return "heatmap" === i || "heatmap3d" === i ? "heatmap" : "hexagon" === r ? -1 === (null == n ? void 0 : n.indexOf(i)) ? "hexagon" : "grid3d" : "grid" === r ? -1 === (null == n ? void 0 : n.indexOf(i)) ? "grid" : "grid3d" : "heatmap" } }]), n }(tC); function UM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var VM = { solid: 0, dash: 1 }, GM = function (t) { Ur(n, t); var e = UM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas() }), void t.layer.render(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.NEAREST, min: id.NEAREST, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.textureBlend, o = void 0 === i ? "normal" : i, a = t.lineType, s = void 0 === a ? "solid" : a, l = t.dashArray, u = void 0 === l ? [10, 5] : l, c = t.forward, p = void 0 === c || c, h = t.lineTexture, f = void 0 !== h && h, d = t.iconStep, m = void 0 === d ? 100 : d, v = t.segmentNumber, y = void 0 === v ? 30 : v, g = t.thetaOffset, _ = void 0 === g ? .314 : g; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e, thetaOffset: _ })) { this.judgeStyleAttributes({ opacity: e, thetaOffset: _ }); var x = this.layer.getEncodedData(), b = this.calDataFrame(this.cellLength, x, this.cellProperties), w = b.data, S = b.width, E = b.height; this.rowCount = E, this.dataTexture = this.cellLength > 0 && w.length > 0 ? this.createTexture2D({ flipY: !0, data: w, format: id.LUMINANCE, type: id.FLOAT, width: S, height: E }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } 2 === u.length && u.push(0, 0); var C = 0, T = [0, 0, 0, 0], A = [0, 0, 0, 0]; return n && r && (T = xa(n), A = xa(r), C = 1), this.rendererService.getDirty() && this.texture.bind(), { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_thetaOffset: DE(_) ? _ : 0, u_opacity: DE(e) ? e : 1, u_textureBlend: "normal" === o ? 0 : 1, segmentNumber: y, u_line_type: VM[s || "solid"], u_dash_array: u, u_blur: .9, u_lineDir: p ? 1 : -1, u_texture: this.texture, u_line_texture: f ? 1 : 0, u_icon_step: m, u_textSize: [1024, this.iconService.canvasHeight || 128], u_linearColor: C, u_sourceColor: T, u_targetColor: A } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "getShaders", value: function () { var t = this.layer.getLayerConfig(), e = t.sourceColor, n = t.targetColor; return "dash" === t.lineType ? { frag: '\nuniform float u_opacity;\n\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float segmentNumber;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].b; // 当前顶点在弧线中所处的分段比例\n\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity;\n\n  float flag = 0.;\n  float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n  if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n    flag = 1.;\n  }\n  gl_FragColor.a *=flag;\n  \n  gl_FragColor = filterColor(gl_FragColor);\n}', vert: '\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nvarying vec4 v_color;\n\n\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nuniform float u_lineDir: 1.0;\nvarying vec4 v_dash_array;\n\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n#pragma include "styleMappingCalThetaOffset"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // 正向\n    return mid;\n  } else { // 逆向\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  \n  vec2 source = a_Instance.rg;  // 起始点\n  vec2 target =  a_Instance.ba; // 终点\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 s = source;\n  vec2 t = target;\n  \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    s = unProjCustomCoord(source);\n    t = unProjCustomCoord(target);\n  }\n  float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n  \n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  \n\n   styleMappingMat[3].b = segmentIndex / segmentNumber;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n', type: "dash" } : e && n ? { frag: '#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nuniform float segmentNumber;\nvarying vec2 v_iconMapUV;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_segmentIndex = styleMappingMat[3].r;   // 当前顶点在弧线中所处的分段位置\n\n  // 设置弧线的底色\n  gl_FragColor = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}', vert: '\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nvarying vec4 v_color;\n\nuniform float u_lineDir: 1.0;\n\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n#pragma include "styleMappingCalThetaOffset"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // 正向\n    return mid;\n  } else { // 逆向\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  \n  vec2 source = a_Instance.rg;  // 起始点\n  vec2 target =  a_Instance.ba; // 终点\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n\n   styleMappingMat[3].b = d_distance_ratio;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n\n  float d_segmentIndex = a_Position.x + 1.0; // 当前顶点在弧线中所处的分段位置\n  styleMappingMat[3].r = d_segmentIndex;\n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n', type: "linear" } : { frag: '\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nuniform float segmentNumber;\nvarying vec2 v_iconMapUV;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // 运动速度\n  float d_segmentIndex = styleMappingMat[3].r;   // 当前顶点在弧线中所处的分段位置\n  float d_distance_ratio = styleMappingMat[3].b; // 当前顶点在弧线中所处的分段比例\n\n  gl_FragColor = v_color;\n  \n  gl_FragColor.a *= opacity;\n\n  if(u_aimate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n  }\n\n  // 当存在贴图时在底色上贴上贴图\n  if(u_line_texture == LineTexture) { // while load texture\n    float arcRadio = smoothstep( 0.0, 1.0, (d_segmentIndex / segmentNumber));\n    // float arcRadio = smoothstep( 0.0, 1.0, d_distance_ratio);\n\n    float count = styleMappingMat[3].g; // 贴图在弧线上重复的数量\n\n    float time = 0.0;\n    if(u_aimate.x == Animate) {\n      time = u_time / u_aimate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n    float v = styleMappingMat[3].a; // 横向 v\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n\n    vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_aimate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_aimate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n    \n  } else {\n     gl_FragColor = filterColor(gl_FragColor);\n  }\n  // gl_FragColor = filterColor(gl_FragColor);\n}', vert: '#define Animate 0.0\n#define LineTexture 1.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n\nuniform float u_lineDir: 1.0;\n\nuniform float u_thetaOffset: 0.314;\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n#pragma include "styleMappingCalThetaOffset"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // 正向\n    return mid;\n  } else { // 逆向\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  \n  vec2 source = a_Instance.rg;  // 起始点\n  vec2 target =  a_Instance.ba; // 终点\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n  \n  if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n      if(u_lineDir != 1.0) {\n        d_distance_ratio = 1.0 - d_distance_ratio;\n      }\n  }\n\n   styleMappingMat[3].b = d_distance_ratio;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n\n  float d_segmentIndex = a_Position.x + 1.0; // 当前顶点在弧线中所处的分段位置\n  styleMappingMat[3].r = d_segmentIndex;\n\n  if(LineTexture == u_line_texture) { // 开启贴图模式\n\n    float arcDistrance = length(source - target); // 起始点和终点的距离\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20) { // amap\n      arcDistrance *= 1000000.0;\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) { // mapbox\n      // arcDistrance *= 8.0;\n      arcDistrance = project_pixel_allmap(arcDistrance);\n    }\n    v_iconMapUV = a_iconMapUV;\n\n    float pixelLen = project_pixel_texture(u_icon_step); // 贴图沿弧线方向的长度 - 随地图缩放改变\n    float texCount = floor(arcDistrance/pixelLen); // 贴图在弧线上重复的数量\n     styleMappingMat[3].g = texCount;\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size); // 定点位置偏移\n     styleMappingMat[3].a = lineOffsetWidth/linePixelSize; // 线图层贴图部分的 v 坐标值\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n', type: "normal" } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.segmentNumber, n = void 0 === e ? 30 : e, r = t.mask, i = void 0 !== r && r, o = t.maskInside, a = void 0 === o || o, s = this.getShaders(), l = s.frag, u = s.vert, c = s.type; return [this.layer.buildLayerModel({ moduleName: "arc2dline" + c, vertexShader: u, fragmentShader: l, triangulation: eA, depth: { enable: !1 }, blend: this.getBlend(), segmentNumber: n, stencil: Ca(i, a) })] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "instance", type: bx.Attribute, descriptor: { name: "a_Instance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 4, update: function (t, e, n, r) { return [n[3], n[4], n[5], n[6]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_iconMapUV", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.texture] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC); function HM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var WM = { solid: 0, dash: 1 }, XM = function (t) { Ur(n, t); var e = HM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas() }), void t.layer.render(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.NEAREST, min: id.NEAREST, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.textureBlend, o = void 0 === i ? "normal" : i, a = t.lineType, s = void 0 === a ? "solid" : a, l = t.dashArray, u = void 0 === l ? [10, 5] : l, c = t.lineTexture, p = void 0 !== c && c, h = t.iconStep, f = void 0 === h ? 100 : h, d = t.segmentNumber, m = void 0 === d ? 30 : d, v = t.globalArcHeight, y = void 0 === v ? 10 : v; 2 === u.length && u.push(0, 0); var g = 0, _ = [0, 0, 0, 0], x = [0, 0, 0, 0]; if (n && r && (_ = xa(n), x = xa(r), g = 1), this.rendererService.getDirty() && this.texture.bind(), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e })) { this.judgeStyleAttributes({ opacity: e }); var b = this.layer.getEncodedData(), w = this.calDataFrame(this.cellLength, b, this.cellProperties), S = w.data, E = w.width, C = w.height; this.rowCount = C, this.dataTexture = this.cellLength > 0 && S.length > 0 ? this.createTexture2D({ flipY: !0, data: S, format: id.LUMINANCE, type: id.FLOAT, width: E, height: C }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_globel: "GLOBEL" === this.mapService.version ? 1 : 0, u_globel_radius: 100, u_global_height: y, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(e) ? e : 1, u_textureBlend: "normal" === o ? 0 : 1, segmentNumber: m, u_line_type: WM[s] || 0, u_dash_array: u, u_texture: this.texture, u_line_texture: p ? 1 : 0, u_icon_step: f, u_textSize: [1024, this.iconService.canvasHeight || 128], u_linearColor: g, u_sourceColor: _, u_targetColor: x } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "getShaders", value: function () { var t = this.layer.getLayerConfig(), e = t.sourceColor, n = t.targetColor; return t.lineType, e && n ? { frag: '\n#define Animate 0.0\n\nuniform float u_opacity;\nuniform float u_blur : 0.9;\nvarying float v_segmentIndex;\nuniform float segmentNumber;\n\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = styleMappingMat[3].g; // 当前点位距离占线总长的比例\n\n  gl_FragColor = mix(u_sourceColor, u_targetColor, v_segmentIndex/segmentNumber);\n\n  gl_FragColor.a *= opacity;\n\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n\n      // u_aimate \n      // x enable\n      // y duration\n      // z interval\n      // w trailLength\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform float u_globel;\nuniform float u_globel_radius;\nuniform float u_global_height: 10;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nvarying float v_segmentIndex;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nfloat torad(float deg) {\n  return (deg / 180.0) * acos(-1.0);\n}\n\nvec3 lglt2xyz(vec2 lnglat) {\n  float pi = 3.1415926;\n  // TODO: + Math.PI/2 是为了对齐坐标\n  float lng = torad(lnglat.x) + pi / 2.0;\n  float lat = torad(lnglat.y);\n\n  // TODO: 手动增加一些偏移，减轻面的冲突\n  float radius = u_globel_radius;\n\n  float z = radius * cos(lat) * cos(lng);\n  float x = radius * cos(lat) * sin(lng);\n  float y = radius * sin(lat);\n  return vec3(x, y, z);\n}\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_color = a_Color;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  float d_distance_ratio;\n   if(u_line_type == LineTypeDash) {\n    d_distance_ratio = segmentIndex / segmentNumber;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n  }\n  styleMappingMat[3].g = d_distance_ratio; // 当前点位距离占线总长的比例\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n\n  v_segmentIndex = a_Position.x;\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { // 开启贴图模式  \n\n    float arcDistrance = length(source - target);\n    float pixelLen =  project_pixel_texture(u_icon_step);\n    styleMappingMat[3].b = floor(arcDistrance/pixelLen); // 贴图在弧线上重复的数量\n\n    vec2 projectOffset = project_pixel(offset);\n    float lineOffsetWidth = length(projectOffset + projectOffset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size);  // 定点位置偏移，按地图等级缩放后的距离\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // 线图层贴图部分的 v 坐标值\n\n    v_iconMapUV = a_iconMapUV;\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  }\n\n  // 地球模式\n  if(u_globel > 0.0) {\n    vec3 startLngLat = lglt2xyz(a_Instance.rg);\n    vec3 endLngLat = lglt2xyz(a_Instance.ba);\n    float globalRadius = length(startLngLat);\n\n    vec3 lineDir = normalize(endLngLat - startLngLat);\n    vec3 midPointDir = normalize((startLngLat + endLngLat)/2.0);\n\n    // 线的偏移\n    vec3 lnglatOffset = cross(lineDir, midPointDir) * a_Position.y;\n    // 计算起始点和终止点的距离\n    float lnglatLength = length(a_Instance.rg - a_Instance.ba)/50.0;\n    // 计算飞线各个节点相应的高度\n    float lineHeight = u_global_height * (-4.0*segmentRatio*segmentRatio + 4.0 * segmentRatio) * lnglatLength;\n    // 地球点位\n    vec3 globalPoint = normalize(mix(startLngLat, endLngLat, segmentRatio)) * (globalRadius + lineHeight) + lnglatOffset * a_Size;\n    \n    gl_Position = u_ViewProjectionMatrix * vec4(globalPoint, 1.0);\n  }\n \n\n  setPickingColor(a_PickingColor);\n}\n', type: "linear" } : { frag: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_line_texture: 0.0;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\nvarying float v_segmentIndex;\nuniform float segmentNumber;\n\nvarying vec2 v_iconMapUV;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nvarying mat4 styleMappingMat;\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = styleMappingMat[3].g; // 当前点位距离占线总长的比例\n  gl_FragColor = v_color;\n\n  gl_FragColor.a *= opacity;\n  if(u_line_type == LineTypeDash) {\n    float flag = 0.;\n    float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    gl_FragColor.a *=flag;\n  }\n\n  if(u_aimate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n\n      // u_aimate \n      // x enable\n      // y duration\n      // z interval\n      // w trailLength\n  }\n\n  if(u_line_texture == LineTexture && u_line_type != LineTypeDash) { // while load texture\n    // float arcRadio = smoothstep( 0.0, 1.0, (v_segmentIndex / segmentNumber));\n    float arcRadio = v_segmentIndex / (segmentNumber - 1.0);\n    float count = styleMappingMat[3].b; // // 贴图在弧线上重复的数量\n\n    float time = 0.0;\n    if(u_aimate.x == Animate) {\n      time = u_time / u_aimate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n\n    float v = styleMappingMat[3].a;  // 线图层贴图部分的 v 坐标值\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_aimate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_aimate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n          discard;\n        } else {\n          gl_FragColor = filterColor(pattern);\n        }\n    }\n\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n', vert: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform float u_globel;\nuniform float u_globel_radius;\nuniform float u_global_height: 10;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nvarying float v_segmentIndex;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nfloat torad(float deg) {\n  return (deg / 180.0) * acos(-1.0);\n}\n\nvec3 lglt2xyz(vec2 lnglat) {\n  float pi = 3.1415926;\n  // TODO: + Math.PI/2 是为了对齐坐标\n  float lng = torad(lnglat.x) + pi / 2.0;\n  float lat = torad(lnglat.y);\n\n  // TODO: 手动增加一些偏移，减轻面的冲突\n  float radius = u_globel_radius;\n\n  float z = radius * cos(lat) * cos(lng);\n  float x = radius * cos(lat) * sin(lng);\n  float y = radius * sin(lat);\n  return vec3(x, y, z);\n}\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_color = a_Color;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  float d_distance_ratio;\n   if(u_line_type == LineTypeDash) {\n    d_distance_ratio = segmentIndex / segmentNumber;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n  }\n  styleMappingMat[3].g = d_distance_ratio; // 当前点位距离占线总长的比例\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n\n  v_segmentIndex = a_Position.x;\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { // 开启贴图模式  \n\n    float arcDistrance = length(source - target);\n    float pixelLen =  project_pixel_texture(u_icon_step);\n    styleMappingMat[3].b = floor(arcDistrance/pixelLen); // 贴图在弧线上重复的数量\n\n    vec2 projectOffset = project_pixel(offset);\n    float lineOffsetWidth = length(projectOffset + projectOffset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size);  // 定点位置偏移，按地图等级缩放后的距离\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // 线图层贴图部分的 v 坐标值\n\n    v_iconMapUV = a_iconMapUV;\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  }\n\n  // 地球模式\n  if(u_globel > 0.0) {\n    vec3 startLngLat = lglt2xyz(a_Instance.rg);\n    vec3 endLngLat = lglt2xyz(a_Instance.ba);\n    float globalRadius = length(startLngLat);\n\n    vec3 lineDir = normalize(endLngLat - startLngLat);\n    vec3 midPointDir = normalize((startLngLat + endLngLat)/2.0);\n\n    // 线的偏移\n    vec3 lnglatOffset = cross(lineDir, midPointDir) * a_Position.y;\n    // 计算起始点和终止点的距离\n    float lnglatLength = length(a_Instance.rg - a_Instance.ba)/50.0;\n    // 计算飞线各个节点相应的高度\n    float lineHeight = u_global_height * (-4.0*segmentRatio*segmentRatio + 4.0 * segmentRatio) * lnglatLength;\n    // 地球点位\n    vec3 globalPoint = normalize(mix(startLngLat, endLngLat, segmentRatio)) * (globalRadius + lineHeight) + lnglatOffset * a_Size;\n    \n    gl_Position = u_ViewProjectionMatrix * vec4(globalPoint, 1.0);\n  }\n \n\n  setPickingColor(a_PickingColor);\n}\n', type: "normal" } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.segmentNumber, n = void 0 === e ? 30 : e, r = t.mask, i = void 0 !== r && r, o = t.maskInside, a = void 0 === o || o, s = this.getShaders(), l = s.frag, u = s.vert, c = s.type; return [this.layer.buildLayerModel({ moduleName: "arc3Dline" + c, vertexShader: u, fragmentShader: l, triangulation: eA, blend: this.getBlend(), segmentNumber: n, stencil: Ca(i, a) })] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "instance", type: bx.Attribute, descriptor: { name: "a_Instance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 4, update: function (t, e, n, r) { return [n[3], n[4], n[5], n[6]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_iconMapUV", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.texture] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC); function qM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ZM = function (t) { Ur(n, t); var e = qM(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.forward, o = void 0 === i || i, a = t.segmentNumber, s = void 0 === a ? 30 : a, l = t.thetaOffset, u = void 0 === l ? .314 : l, c = 0, p = [0, 0, 0, 0], h = [0, 0, 0, 0]; return n && r && (p = xa(n), h = xa(r), c = 1), { u_thetaOffset: u, u_opacity: DE(e) ? e : 1, segmentNumber: s, u_blur: .9, u_lineDir: o ? 1 : -1, u_linearColor: c, u_sourceColor: p, u_targetColor: h } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig().segmentNumber, e = void 0 === t ? 30 : t; return [this.layer.buildLayerModel({ moduleName: "arc2dminiline", vertexShader: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\n\nuniform float u_lineDir: 1.0;\n\n// 偏移量\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying float v_distance_ratio;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = u_thetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // 正向\n    return mid;\n  } else { // 逆向\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n  \n  vec2 source = a_Instance.rg;  // 起始点\n  vec2 target =  a_Instance.ba; // 终点\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  v_distance_ratio = segmentIndex / segmentNumber;\n  \n  if(u_aimate.x == Animate && u_lineDir != 1.0) {\n      v_distance_ratio = 1.0 - v_distance_ratio;\n  }\n\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n}\n', fragmentShader: '#define LineTypeSolid 0.0\n#define Animate 0.0\n\nuniform float u_opacity;\nuniform float u_blur : 0.9;\n// varying vec2 v_normal;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float segmentNumber;\nvarying float v_distance_ratio;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include "picking"\n\nvoid main() {\n\n  // 设置弧线的底色\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v_distance_ratio);\n  } else { // 使用 color 方法传入的颜色\n     gl_FragColor = v_color;\n  }\n  \n \n  gl_FragColor.a *= u_opacity;\n\n  if(u_aimate.x == Animate) {\n      float animateSpeed = u_time / u_aimate.y; // 运动速度\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n  }\n}', triangulation: eA, depth: { enable: !1 }, blend: this.getBlend(), segmentNumber: e })] } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "instance", type: bx.Attribute, descriptor: { name: "a_Instance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 4, update: function (t, e, n, r) { return [n[3], n[4], n[5], n[6]] } } }) } }]), n }(UC); function YM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var KM = { solid: 0, dash: 1 }, QM = function (t) { Ur(n, t); var e = YM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas() }), void t.layer.render(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.NEAREST, min: id.NEAREST, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.textureBlend, o = void 0 === i ? "normal" : i, a = t.lineType, s = void 0 === a ? "solid" : a, l = t.dashArray, u = void 0 === l ? [10, 5] : l, c = t.lineTexture, p = void 0 !== c && c, h = t.iconStep, f = void 0 === h ? 100 : h, d = t.segmentNumber, m = void 0 === d ? 30 : d; 2 === u.length && u.push(0, 0), this.rendererService.getDirty() && this.texture.bind(); var v = 0, y = [0, 0, 0, 0], g = [0, 0, 0, 0]; if (n && r && (y = xa(n), g = xa(r), v = 1), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e })) { this.judgeStyleAttributes({ opacity: e }); var _ = this.layer.getEncodedData(), x = this.calDataFrame(this.cellLength, _, this.cellProperties), b = x.data, w = x.width, S = x.height; this.rowCount = S, this.dataTexture = this.cellLength > 0 && b.length > 0 ? this.createTexture2D({ flipY: !0, data: b, format: id.LUMINANCE, type: id.FLOAT, width: w, height: S }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(e) ? e : 1, u_textureBlend: "normal" === o ? 0 : 1, segmentNumber: m, u_line_type: KM[s] || 0, u_dash_array: u, u_texture: this.texture, u_line_texture: p ? 1 : 0, u_icon_step: f, u_textSize: [1024, this.iconService.canvasHeight || 128], u_linearColor: v, u_sourceColor: y, u_targetColor: g } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "greatcircleline", vertexShader: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\n\nvarying float v_distance_ratio;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n    vec2 x = mix(source, target, ratio);\n    vec2 center = mix(source, target, 0.5);\n    float dSourceCenter = distance(source, center);\n    float dXCenter = distance(x, center);\n    return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n     float vertex_height = paraboloid(source, target, segmentRatio);\n\n    return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n    );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size)/ 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 delta = source - target;\n  vec2 sin_half_delta = sin(delta / 2.0);\n  float a =\n    sin_half_delta.y * sin_half_delta.y +\n    cos(source.y) * cos(target.y) *\n    sin_half_delta.x * sin_half_delta.x;\n  return 2.0 * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvec2 midPoint(vec2 source, vec2 target) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = 0.314;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  return mid;\n}\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\n\nvec2 interpolate (vec2 source, vec2 target, float angularDist, float t) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    vec2 mid = midPoint(source, target);\n    vec3 x = vec3(source.x, mid.x, target.x);\n    vec3 y = vec3(source.y, mid.y, target.y);\n    return vec2(bezier3(x ,t), bezier3(y,t));\n  }else {\n    if(abs(angularDist - PI) < 0.001) {\n      return (1.0 - t) * source + t * target;\n    }\n    float a = sin((1.0 - t) * angularDist) / sin(angularDist);\n    float b = sin(t * angularDist) / sin(angularDist);\n    vec2 sin_source = sin(source);\n    vec2 cos_source = cos(source);\n    vec2 sin_target = sin(target);\n    vec2 cos_target = cos(target);\n    float x = a * cos_source.y * cos_source.x + b * cos_target.y * cos_target.x;\n    float y = a * cos_source.y * sin_source.x + b * cos_target.y * sin_target.x;\n    float z = a * sin_source.y + b * sin_target.y;\n    return vec2(atan(y, x), atan(z, sqrt(x * x + y * y)));\n  }\n}\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset 数据集\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_color = a_Color;\n  vec2 source = radians(a_Instance.rg);\n  vec2 target = radians(a_Instance.ba);\n  float angularDist = getAngularDist(source, target);\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  if(u_line_type == LineTypeDash) {\n    v_distance_ratio = segmentIndex / segmentNumber;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    total_Distance = total_Distance*8.0;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba);\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n  if(u_aimate.x == Animate) {\n      v_distance_ratio = segmentIndex / segmentNumber;\n  }\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  v_distance_ratio = segmentIndex / segmentNumber;\n  vec4 curr = project_position(vec4(degrees(interpolate(source, target, angularDist, segmentRatio)), 0.0, 1.0));\n  vec4 next = project_position(vec4(degrees(interpolate(source, target, angularDist, nextSegmentRatio)), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n  //  vec4 project_pos = project_position(vec4(curr.xy, 0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\n\n  styleMappingMat[3].g = a_Position.x; // 该顶点在弧线上的分段排序\n  if(LineTexture == u_line_texture) { // 开启贴图模式  \n    // float mapZoomScale = u_CoordinateSystem !== COORDINATE_SYSTEM_P20_2?10000000.0:1.0;\n    float d_arcDistrance = length(source - target);\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20) { // amap\n      d_arcDistrance = d_arcDistrance * 1000000.0;\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) { // mapbox\n      d_arcDistrance = project_pixel_allmap(d_arcDistrance);\n    }\n    float d_pixelLen = project_pixel(u_icon_step)/8.0;\n    styleMappingMat[3].b = floor(d_arcDistrance/d_pixelLen); // 贴图在弧线上重复的数量\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size);  // 定点位置偏移，按地图等级缩放后的距离\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // 线图层贴图部分的 v 坐标值\n\n    v_iconMapUV = a_iconMapUV;\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n\n', fragmentShader: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying float v_distance_ratio;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture: 0.0;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\nuniform float segmentNumber;\n\nvarying vec2 v_iconMapUV;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\n\n#pragma include "picking"\n#pragma include "project"\n#pragma include "projection"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0;\n  float d_segmentIndex = styleMappingMat[3].g;\n  \n  // 设置弧线的底色\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    gl_FragColor = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  } else { // 使用 color 方法传入的颜色\n     gl_FragColor = v_color;\n  }\n\n  // float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\n  // float blur = smoothstep(1.0, u_blur, length(v_normal.xy));\n  gl_FragColor.a *= opacity;\n  if(u_line_type == LineTypeDash) {\n   float flag = 0.;\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    gl_FragColor.a *=flag;\n  }\n\n  // 设置弧线的动画模式\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- smoothstep(0.0, 1.0, v_distance_ratio), u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  // 设置弧线的贴图\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { \n    float arcRadio = smoothstep( 0.0, 1.0, (d_segmentIndex / (segmentNumber - 1.0)));\n    // float arcRadio = d_segmentIndex / (segmentNumber - 1.0);\n    float count = styleMappingMat[3].b; // 贴图在弧线上重复的数量\n    float u = fract(arcRadio * count - animateSpeed * count);\n    // float u = fract(arcRadio * count - animateSpeed);\n    if(u_aimate.x == Animate) {\n      u = gl_FragColor.a/opacity;\n    }\n\n    float v = styleMappingMat[3].a; // 线图层贴图部分的 v 坐标值\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n    \n    // 设置贴图和底色的叠加模式\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n\n  // gl_FragColor = filterColor(gl_FragColor);\n}', triangulation: eA, depth: { enable: !1 }, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "instance", type: bx.Attribute, descriptor: { name: "a_Instance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 4, update: function (t, e, n, r) { return [n[3], n[4], n[5], n[6]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_iconMapUV", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.texture] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC); function JM(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var $M = '\n#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nuniform float u_icon_step: 100;\n\nuniform float u_heightfixed: 0.0;\nuniform float u_vertexScale: 1.0;\nuniform float u_raisingHeight: 0.0;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvarying vec4 v_color;\n\n// texV 线图层 - 贴图部分的 v 坐标（线的宽度方向）\nvarying vec2 v_iconMapUV;\n\n\nuniform float u_linearColor: 0;\nuniform float u_arrow: 0.0;\nuniform float u_arrowHeight: 3.0;\nuniform float u_arrowWidth: 2.0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\nvec2 calculateArrow(vec2 offset) {\n  /*\n  * 在支持箭头的时候，第二、第三组顶点是额外插入用于构建顶点的\n  */\n  float arrowFlag = -1.0;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // 高德 2.0 的旋转角度不同\n    arrowFlag = 1.0;\n  }\n  float pi = arrowFlag * 3.1415926/2.;\n  if(a_Miter < 0.) {\n    // 根据线的两侧偏移不同、旋转的方向相反\n    pi = -pi;\n  }\n  highp float angle_sin = sin(pi);\n  highp float angle_cos = cos(pi);\n  // 计算垂直与线方向的旋转矩阵\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  float arrowWidth = u_arrowWidth;\n  float arrowHeight = u_arrowHeight;\n\n  vec2 arrowOffset = vec2(0.0);\n  /*\n  * a_Distance.y 用于标记当前顶点属于哪一组（两个顶点一组，构成线的其实是矩形，最简需要四个顶点、两组顶点构成）\n  */\n  if(a_Distance.y == 0.0) {\n    // 箭头尖部\n    offset = vec2(0.0);\n  } else if(a_Distance.y == 1.0) {\n    // 箭头两侧\n    arrowOffset = rotation_matrix*(offset * arrowHeight);\n    offset += arrowOffset; // 沿线偏移\n    offset = offset * arrowWidth; // 垂直线向外偏移（是构建箭头两侧的顶点）\n  } else if(a_Distance.y == 2.0 || a_Distance.y == 3.0 || a_Distance.y == 4.0) {\n    // 偏移其余的点位（将长度让位给箭头）\n    arrowOffset = rotation_matrix*(offset * arrowHeight) * arrowWidth;\n    offset += arrowOffset;// 沿线偏移\n  }\n\n  return offset;\n}\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  float d_texPixelLen;    // 贴图的像素长度，根据地图层级缩放\n\n  v_iconMapUV = a_iconMapUV;\n  d_texPixelLen = project_float_pixel(u_icon_step);\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    d_texPixelLen *= 10.0;\n  }\n\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n\n  vec2 offset = project_pixel(size.xy);\n \n  if(u_arrow > 0.0) {\n      //  计算箭头\n    offset = calculateArrow(offset);\n  }\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // 线横向偏移的距离（向两侧偏移的和）\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // 定点位置偏移，按地图等级缩放后的距离 单侧 * 2\n  float texV = lineOffsetWidth/linePixelSize; // 线图层贴图部分的 v 坐标值\n\n  // 设置数据集的参数\n  styleMappingMat[3][0] = a_Distance.x / a_Total_Distance;; // 当前点位距离占线总长的比例\n  styleMappingMat[3][1] = a_Distance.x;       // 当前顶点的距离\n  styleMappingMat[3][2] = d_texPixelLen;    // 贴图的像素长度，根据地图层级缩放\n  styleMappingMat[3][3] = texV;             // 线图层贴图部分的 v 坐标值\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // 线顶点的高度 - 兼容不存在第三个数值的情况 vertex height\n  float lineHeight = a_Size.y; // size 第二个参数代表的高度 [linewidth, lineheight]\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // 保持和 amap/mapbox 一致的效果\n    h *= 0.2;\n    if(u_heightfixed < 1.0) {\n      lineHeight = project_pixel(a_Size.y);\n    }\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight + h + u_raisingHeight, 1.0));\n  } else {\n    // mapbox -  amap\n    \n    // 兼容 mapbox 在线高度上的效果表现基本一致\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // mapbox\n      // 保持高度相对不变\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      h *= mapboxZoomScale;\n      h += u_raisingHeight * mapboxZoomScale;\n      if(u_heightfixed > 0.0) {\n        lineHeight *= mapboxZoomScale;\n      }\n      \n    } else {\n      // amap\n      h += u_raisingHeight;\n      // lineHeight 顶点偏移高度\n      if(u_heightfixed < 1.0) {\n        lineHeight *= pow(2.0, 20.0 - u_Zoom);\n      }\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n', tO = { solid: 0, dash: 1 }, eO = function (t) { Ur(n, t); var e = JM(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas() }), void t.layer.render(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.NEAREST, min: id.NEAREST, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.textureBlend, o = void 0 === i ? "normal" : i, a = t.lineType, s = void 0 === a ? "solid" : a, l = t.dashArray, u = void 0 === l ? [10, 5, 0, 0] : l, c = t.lineTexture, p = void 0 !== c && c, h = t.iconStep, f = void 0 === h ? 100 : h, d = t.vertexHeightScale, m = void 0 === d ? 20 : d, v = t.borderWidth, y = void 0 === v ? 0 : v, g = t.borderColor, _ = void 0 === g ? "#ccc" : g, x = t.raisingHeight, b = void 0 === x ? 0 : x, w = t.heightfixed, S = void 0 !== w && w, E = t.arrow, C = void 0 === E ? { enable: !1, arrowWidth: 2, arrowHeight: 3 } : E; 2 === u.length && u.push(0, 0), this.rendererService.getDirty() && this.texture.bind(); var T = 0, A = [0, 0, 0, 0], M = [0, 0, 0, 0]; if (n && r && (A = xa(n), M = xa(r), T = 1), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e })) { this.judgeStyleAttributes({ opacity: e }); var O = this.layer.getEncodedData(), k = this.calDataFrame(this.cellLength, O, this.cellProperties), I = k.data, P = k.width, L = k.height; this.rowCount = L, this.dataTexture = this.cellLength > 0 && I.length > 0 ? this.createTexture2D({ flipY: !0, data: I, format: id.LUMINANCE, type: id.FLOAT, width: P, height: L }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(e) ? e : 1, u_textureBlend: "normal" === o ? 0 : 1, u_line_type: tO[s], u_dash_array: u, u_texture: this.texture, u_line_texture: p ? 1 : 0, u_icon_step: f, u_textSize: [1024, this.iconService.canvasHeight || 128], u_borderWidth: y, u_borderColor: xa(_), u_linearColor: T, u_sourceColor: A, u_targetColor: M, u_heightfixed: Number(S), u_vertexScale: m, u_raisingHeight: Number(b), u_arrow: Number(C.enable), u_arrowHeight: C.arrowHeight || 3, u_arrowWidth: C.arrowWidth || 2 } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = t.depth, a = void 0 !== o && o, s = this.getShaders(), l = s.frag, u = s.vert, c = s.type; return [this.layer.buildLayerModel({ moduleName: "line_" + c, vertexShader: u, fragmentShader: l, triangulation: ZT, primitive: id.TRIANGLES, blend: this.getBlend(), depth: { enable: a }, stencil: Ca(n, i) })] } }, { key: "getShaders", value: function () { var t = this.layer.getLayerConfig(), e = t.sourceColor, n = t.targetColor; return "dash" === t.lineType ? { frag: '#define LineTypeSolid 0.0\nuniform float u_opacity : 1.0;\n\nvarying vec4 v_color;\n\n// dash\nvarying vec4 v_dash_array;\n\n#pragma include "picking"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // 控制运动\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity; // 全局透明度\n // dash line\n \n  float flag = 0.;\n  float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n  if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n    flag = 1.;\n  }\n  gl_FragColor.a *=flag;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute float a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\n\nuniform float u_vertexScale: 1.0;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvarying vec4 v_color;\nvarying vec4 v_dash_array;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  vec2 offset = project_pixel(size.xy);\n\n  // 设置数据集的参数\n  styleMappingMat[3][0] = a_Distance / a_Total_Distance; // 当前点位距离占线总长的比例\n  styleMappingMat[3][1] = a_Distance;       // 当前顶点的距离\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, project_pixel(a_Size.y), 1.0));\n  } else {\n    float lineHeight = a_Size.y;\n \n    // #define COORDINATE_SYSTEM_P20 5.0\n    // #define COORDINATE_SYSTEM_P20_OFFSET 6.0\n    // amap1.x\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // 保持高度相对不变\n      lineHeight *= pow(2.0, 20.0 - u_Zoom);\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n', type: "dash" } : e && n ? { frag: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nuniform float u_blur : 0.99;\nuniform float u_line_type: 0.0;\nuniform float u_opacity : 1.0;\n\nvarying vec4 v_color;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include "picking"\n\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    gl_FragColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n  } else { // 使用 color 方法传入的颜色\n     gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity; // 全局透明度\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: $M, type: "linear" } : { frag: '#define Animate 0.0\n#define LineTexture 1.0\nuniform float u_blur : 0.99;\nuniform float u_opacity : 1.0;\nuniform float u_textureBlend;\n\nuniform float u_borderWidth: 0.0;\nuniform vec4 u_borderColor;\nvarying vec4 v_color;\n\n// line texture\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nvarying vec2 v_iconMapUV;\n\n#pragma include "picking"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // 控制运动\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n  gl_FragColor = v_color;\n  // anti-alias\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\n  gl_FragColor.a *= opacity; // 全局透明度\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + animateSpeed);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = styleMappingMat[3].g;      // 当前顶点的距离\n    float d_texPixelLen = styleMappingMat[3].b;  // 贴图的像素长度，根据地图层级缩放\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = styleMappingMat[3].a;  // 线图层贴图部分的 v 坐标值\n\n    // v = max(smoothstep(0.95, 1.0, v), v);\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    \n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, vec2(u, v)));\n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, uv));\n     vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor += pattern;\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = pattern;\n    }\n  } \n\n  float v = styleMappingMat[3].a;\n  float borderWidth = min(0.5, u_borderWidth);\n  // 绘制 border\n  if(borderWidth > 0.01) {\n    float borderOuterWidth = borderWidth/2.0;\n\n    if(v >= 1.0 - borderWidth || v <= borderWidth) {\n      if(v > borderWidth) {\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - borderWidth))/borderWidth);\n        gl_FragColor.rgb = mix(gl_FragColor.rgb, u_borderColor.rgb, linear);\n      } else if(v <= borderWidth) {\n        float linear = smoothstep(0.0, 1.0, v/borderWidth);\n        gl_FragColor.rgb = mix(u_borderColor.rgb, gl_FragColor.rgb, linear);\n      }\n    }\n\n    if(v < borderOuterWidth) {\n      gl_FragColor.a = mix(0.0, gl_FragColor.a, v/borderOuterWidth);\n    } else if(v > 1.0 - borderOuterWidth) {\n      gl_FragColor.a = mix(gl_FragColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\n    }\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: $M, type: "normal" } } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "distance", type: bx.Attribute, descriptor: { name: "a_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r, i, o) { return void 0 === o ? [n[3], 10] : [n[3], o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "total_distance", type: bx.Attribute, descriptor: { name: "a_Total_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[5]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0], o[1]] : [o, 0] } } }), this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "miter", type: bx.Attribute, descriptor: { name: "a_Miter", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[4]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_iconMapUV", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.texture] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC); function nO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var rO = '\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Position;\n\n\n// dash line\nattribute float a_Total_Distance;\nattribute float a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_opacity: 1.0;\nuniform float u_vertexScale: 1.0;\n\n#pragma include "projection"\n\nvarying vec4 v_color;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  float d_distance_ratio; // 当前点位距离占线总长的比例\n  v_color = a_Color;  \n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // 线顶点的高度 - 兼容不存在第三个数值的情况\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy, project_pixel(a_Size.y) + h * 0.2, 1.0));\n  } else {\n    float lineHeight = a_Size.y;\n    // 兼容 mapbox 在线高度上的效果表现基本一致\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // 保持高度相对不变\n      h *= 2.0/pow(2.0, 20.0 - u_Zoom);\n    }\n\n    // #define COORDINATE_SYSTEM_P20 5.0\n    // #define COORDINATE_SYSTEM_P20_OFFSET 6.0\n    // amap1.x\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // 保持高度相对不变\n      lineHeight *= pow(2.0, 20.0 - u_Zoom);\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, lineHeight + h, 1.0));\n  }\n}\n', iO = function (t) { Ur(n, t); var e = nO(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.vertexHeightScale, o = void 0 === i ? 20 : i, a = 0, s = [0, 0, 0, 0], l = [0, 0, 0, 0]; if (n && r && (s = xa(n), l = xa(r), a = 1), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e })) { this.judgeStyleAttributes({ opacity: e }); var u = this.layer.getEncodedData(), c = this.calDataFrame(this.cellLength, u, this.cellProperties), p = c.data, h = c.width, f = c.height; this.rowCount = f, this.dataTexture = this.cellLength > 0 && p.length > 0 ? this.createTexture2D({ flipY: !0, data: p, format: id.LUMINANCE, type: id.FLOAT, width: h, height: f }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(e) ? e : 1, u_linearColor: a, u_sourceColor: s, u_targetColor: l, u_vertexScale: o } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "getShaders", value: function () { var t = this.layer.getLayerConfig(), e = t.sourceColor, n = t.targetColor; return e && n ? { frag: "\n\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n\n  gl_FragColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n  gl_FragColor.a *= opacity; // 全局透明度\n}\n", vert: rO, type: "linear" } : { frag: "\nvarying vec4 v_color;\nvarying mat4 styleMappingMat;\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity; // 全局透明度\n}\n", vert: rO, type: "normal" } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = this.getShaders(), a = o.frag, s = o.vert, l = o.type; return [this.layer.buildLayerModel({ moduleName: "simpleline" + l, vertexShader: s, fragmentShader: a, triangulation: YT, primitive: id.LINES, blend: this.getBlend(), depth: { enable: !1 }, stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "distance", type: bx.Attribute, descriptor: { name: "a_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[3]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "total_distance", type: bx.Attribute, descriptor: { name: "a_Total_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[5]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0], o[1]] : [o, 0] } } }), this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "miter", type: bx.Attribute, descriptor: { name: "a_Miter", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[4]] } } }) } }]), n }(UC); function oO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var aO = function (t) { Ur(n, t); var e = oO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas() }), void t.layer.render(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.NEAREST, min: id.NEAREST, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.sourceColor, r = t.targetColor, i = t.textureBlend, o = void 0 === i ? "normal" : i, a = t.heightfixed, s = void 0 !== a && a, l = t.lineTexture, u = void 0 !== l && l, c = t.iconStep, p = void 0 === c ? 100 : c, h = t.iconStepCount, f = void 0 === h ? 1 : h; this.rendererService.getDirty() && this.texture.bind(); var d = 0, m = [0, 0, 0, 0], v = [0, 0, 0, 0]; if (n && r && (m = xa(n), v = xa(r), d = 1), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e })) { this.judgeStyleAttributes({ opacity: e }); var y = this.layer.getEncodedData(), g = this.calDataFrame(this.cellLength, y, this.cellProperties), _ = g.data, x = g.width, b = g.height; this.rowCount = b, this.dataTexture = this.cellLength > 0 && _.length > 0 ? this.createTexture2D({ flipY: !0, data: _, format: id.LUMINANCE, type: id.FLOAT, width: x, height: b }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_heightfixed: Number(s), u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(e) ? e : 1, u_textureBlend: "normal" === o ? 0 : 1, u_texture: this.texture, u_line_texture: u ? 1 : 0, u_iconStepCount: f, u_icon_step: p, u_textSize: [1024, this.iconService.canvasHeight || 128], u_linearColor: d, u_sourceColor: m, u_targetColor: v } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption; return { u_aimate: this.animateOption2Array(t), u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "buildModels", value: function () { return [this.layer.buildLayerModel({ moduleName: "linewall", vertexShader: '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute float a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nuniform float u_icon_step: 100;\nuniform float u_heightfixed;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvarying vec4 v_color;\nvarying float v_blur;\n\n// texV 线图层 - 贴图部分的 v 坐标（线的宽度方向）\nvarying vec2 v_iconMapUV;\n\n\nuniform float u_linearColor: 0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "light"\n#pragma include "styleMappingCalOpacity"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  float d_distance_ratio; // 当前点位距离占线总长的比例\n  float d_texPixelLen;    // 贴图的像素长度，根据地图层级缩放\n\n  v_iconMapUV = a_iconMapUV;\n  if(u_heightfixed < 1.0) {     // 高度随 zoom 调整\n    d_texPixelLen = project_pixel(u_icon_step);\n  } else {\n    d_texPixelLen = u_icon_step;\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    d_texPixelLen *= 10.0;\n  }\n\n  if(u_aimate.x == Animate || u_linearColor == 1.0) {\n      d_distance_ratio = a_Distance / a_Total_Distance;\n  }\n\n  float miter = (a_Miter + 1.0)/2.0;\n  // 设置数据集的参数\n  styleMappingMat[3][0] = d_distance_ratio; // 当前点位距离占线总长的比例\n  styleMappingMat[3][1] = a_Distance;       // 当前顶点的距离\n  styleMappingMat[3][2] = d_texPixelLen;    // 贴图的像素长度，根据地图层级缩放\n  styleMappingMat[3][3] = miter;          // 线图层贴图部分的 v 坐标值 0 - 1\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  float originSize = a_Size.x;  // 固定高度\n  if(u_heightfixed < 1.0) {     // 高度随 zoom 调整\n    originSize = project_float_pixel(a_Size.x);\n  }\n\n  float wallHeight = originSize * miter;\n  float lightWeight = calc_lighting(vec4(project_pos.xy, wallHeight, 1.0));\n\n  v_blur = min(project_float_pixel(2.0) / originSize, 0.05);\n\n  // v_lightWeight = lightWeight;\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n  // v_color = a_Color;\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy, wallHeight, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, wallHeight, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: '#define LineTypeSolid 0.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity : 1.0;\nuniform float u_textureBlend;\nuniform float u_iconStepCount;\n\nvarying vec4 v_color;\n\n// line texture\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\n// dash\nuniform float u_dash_offset : 0.0;\nuniform float u_dash_ratio : 0.1;\n\nvarying vec2 v_iconMapUV;\nvarying float v_blur;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include "picking"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // 控制运动\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = styleMappingMat[3].r; // 当前点位距离占线总长的比例\n  float v = styleMappingMat[3].a;\n\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v);\n  } else { // 使用 color 方法传入的颜色\n     gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity; // 全局透明度\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + animateSpeed);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = styleMappingMat[3].g;      // 当前顶点的距离\n    float d_texPixelLen = styleMappingMat[3].b;  // 贴图的像素长度，根据地图层级缩放\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = styleMappingMat[3].a;  // 线图层贴图部分的 v 坐标值\n\n    // 计算纹理间隔 start\n    float flag = 0.0;\n    if(u > 1.0/u_iconStepCount) {\n      flag = 1.0;\n    }\n    u = fract(u*u_iconStepCount);\n    // 计算纹理间隔 end\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n\n    // Tip: 判断纹理间隔\n    if(flag > 0.0) {\n      pattern = vec4(0.0);\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n  }\n  \n\n  // blur - AA\n  if(v < v_blur) {\n    gl_FragColor.a = mix(0.0, gl_FragColor.a, v/v_blur);\n  } else if(v > 1.0 - v_blur) {\n    gl_FragColor.a = mix(gl_FragColor.a, 0.0, (v - (1.0 - v_blur))/v_blur);\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n\n    \n  \n  \n}\n', triangulation: ZT, primitive: id.TRIANGLES, blend: this.getBlend(), depth: { enable: !1 } })] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.layer.getLayerConfig().lineType, this.styleAttributeService.registerStyleAttribute({ name: "distance", type: bx.Attribute, descriptor: { name: "a_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[3]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "total_distance", type: bx.Attribute, descriptor: { name: "a_Total_Distance", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[5]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0], o[1]] : [o, 0] } } }), this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "miter", type: bx.Attribute, descriptor: { name: "a_Miter", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [n[4]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_iconMapUV", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.texture] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC), sO = { arc: GM, arcmini: ZM, arc3d: XM, greatcircle: QM, wall: aO, line: eO, simple: iO }; function lO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var uO = function (t) { Ur(n, t); var e = lO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "type", "LineLayer"), t } return Or(n, [{ key: "buildModels", value: function () { var t = this.getModelType(); this.layerModel = new sO[t](this), this.models = this.layerModel.initModels() } }, { key: "rebuildModels", value: function () { this.models = this.layerModel.buildModels() } }, { key: "getConfigSchema", value: function () { return { properties: { opacity: { type: "number", minimum: 0, maximum: 1 } } } } }, { key: "getDefaultConfig", value: function () { return { line: {}, simple: {}, wall: {}, arc3d: { blend: "additive" }, arc: { blend: "additive" }, arcmini: { blend: "additive" }, greatcircle: { blend: "additive" } }[this.getModelType()] } }, { key: "getModelType", value: function () { var t, e = this.styleAttributeService.getLayerStyleAttribute("shape"); return (null == e || null === (t = e.scale) || void 0 === t ? void 0 : t.field) || "line" } }]), n }(tC); function cO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var pO = function (t) { Ur(n, t); var e = cO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "raiseCount", 0), kr(Gr(t), "raiserepeat", 0), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.animateOption, n = void 0 === e ? { enable: !1, speed: .01, repeat: !1 } : e, r = t.opacity, i = void 0 === r ? 1 : r, o = t.sourceColor, a = t.targetColor, s = t.pickLight, l = void 0 !== s && s, u = t.heightfixed, c = void 0 !== u && u, p = t.opacityLinear, h = void 0 === p ? { enable: !1, dir: "up" } : p, f = t.lightEnable, d = void 0 === f || f; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: i })) { this.judgeStyleAttributes({ opacity: i }); var m = this.layer.getEncodedData(), v = this.calDataFrame(this.cellLength, m, this.cellProperties), y = v.data, g = v.width, _ = v.height; this.rowCount = _, this.dataTexture = this.cellLength > 0 && y.length > 0 ? this.createTexture2D({ flipY: !0, data: y, format: id.LUMINANCE, type: id.FLOAT, width: g, height: _ }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } var x = 0, b = [0, 0, 0, 0], w = [0, 0, 0, 0]; if (o && a && (b = xa(o), w = xa(a), x = 1), this.raiseCount < 1 && this.raiserepeat > 0 && n.enable) { var S = n.speed, E = void 0 === S ? .01 : S; n.repeat, this.raiseCount += E, this.raiseCount >= 1 && (this.raiserepeat > 1 ? (this.raiseCount = 0, this.raiserepeat--) : this.raiseCount = 1) } return { u_pickLight: Number(l), u_heightfixed: Number(c), u_r: n.enable && this.raiserepeat > 0 ? this.raiseCount : 1, u_globel: "GLOBEL" === this.mapService.version ? 1 : 0, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(i) ? i : 1, u_linearColor: x, u_sourceColor: b, u_targetColor: w, u_opacitylinear: Number(h.enable), u_opacitylinear_dir: "up" === h.dir ? 1 : 0, u_lightEnable: Number(d) } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.depth, n = void 0 === e || e, r = t.animateOption.repeat, i = void 0 === r ? 1 : r; return this.raiserepeat = i, [this.layer.buildLayerModel({ moduleName: "pointExtrude2", vertexShader: 'precision highp float;\n\n#define pi 3.1415926535\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec3 a_Position;\nattribute vec3 a_Pos;\nattribute vec4 a_Color;\nattribute vec3 a_Size;\nattribute vec3 a_Normal;\n\nuniform float u_heightfixed: 0.0; // 默认不固定\nuniform float u_globel;\nuniform float u_r;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform float u_lightEnable: 1;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\nvarying float v_z;\nvarying float v_lightWeight;\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nfloat getYRadian(float x, float z) {\n  if(x > 0.0 && z > 0.0) {\n    return atan(x/z);\n  } else if(x > 0.0 && z <= 0.0){\n    return atan(-z/x) + pi/2.0;\n  } else if(x <= 0.0 && z <= 0.0) {\n    return  pi + atan(x/z); //atan(x/z) + \n  } else {\n    return atan(z/-x) + pi*3.0/2.0;\n  }\n}\n\nfloat getXRadian(float y, float r) {\n  return atan(y/r);\n}\n\nvoid main() {\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n  vec3 size = a_Size * a_Position;\n\n  // a_Position.z 是在构建网格的时候传入的标准值 0 - 1，在插值器插值可以获取 0～1 线性渐变的值\n  v_z = a_Position.z;\n\n \n\n  // vec2 offset = project_pixel(size.xy);\n  // vec2 offset = (size.xy);\n\n  vec3 offset = size; // 控制圆柱体的大小 - 从标准单位圆柱体进行偏移\n  if(u_heightfixed < 1.0) { // 圆柱体不固定高度\n    // offset = project_pixel(offset);\n    if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // P20 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1\n      offset = offset * pow(2.0, (19.0 - u_Zoom));\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n      // P20_2 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减3\n      offset = offset * pow(2.0, (19.0 - 3.0 - u_Zoom));\n    }\n  } else {// 圆柱体固定高度 （ 处理 mapbox ）\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      offset *= 4.0/pow(2.0, 21.0 - u_Zoom);\n    }\n  }\n\n\n  vec4 project_pos = project_position(vec4(a_Pos.xy, 0., 1.0));\n\n  // vec4 pos = vec4(project_pos.xy + offset, project_pixel(size.z) * u_r, 1.0);\n  // u_r 控制圆柱的生长\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\n\n  // 圆柱光照效果\n  // float lightWeight = u_lightEnable > 0.0 ? calc_lighting(pos): 1.0;\n  float lightWeight = 1.0;\n  if(u_lightEnable > 0.0) { // 取消三元表达式，增强健壮性\n    lightWeight = calc_lighting(pos);\n  }\n  v_lightWeight = lightWeight;\n\n  v_color =vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  // gl_Position = project_common_position_to_clipspace(pos);\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * pos;\n  } else {\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  \n  if(u_globel > 0.0) {\n    // 在地球模式下，将原本垂直于 xy 平面的圆柱调整姿态到适应圆的角度\n    //旋转矩阵mx，创建绕x轴旋转矩阵\n    float r = sqrt(a_Pos.z*a_Pos.z + a_Pos.x*a_Pos.x);\n    float xRadian = getXRadian(a_Pos.y, r);\n    float xcos = cos(xRadian);//求解旋转角度余弦值\n    float xsin = sin(xRadian);//求解旋转角度正弦值\n    mat4 mx = mat4(\n      1,0,0,0,  \n      0,xcos,-xsin,0,  \n      0,xsin,xcos,0,  \n      0,0,0,1);\n\n    //旋转矩阵my，创建绕y轴旋转矩阵\n    float yRadian = getYRadian(a_Pos.x, a_Pos.z);\n    float ycos = cos(yRadian);//求解旋转角度余弦值\n    float ysin = sin(yRadian);//求解旋转角度正弦值\n    mat4 my = mat4(\n      ycos,0,-ysin,0,  \n      0,1,0,0,  \n      ysin,0,ycos,0,  \n      0,0,0,1);\n\n    gl_Position = u_ViewProjectionMatrix * vec4(( my * mx *  vec4(a_Position * a_Size, 1.0)).xyz + a_Pos, 1.0);\n  }\n\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: 'varying vec4 v_color;\nuniform float u_opacity: 1.0;\n\nvarying float v_z;\nvarying float v_lightWeight;\nuniform float u_pickLight: 0.0;\n\n#pragma include "picking"\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nuniform float u_opacitylinear: 0.0;\nuniform float u_opacitylinear_dir: 1.0;\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n\n  // 设置圆柱的底色\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v_z);\n    gl_FragColor.rgb *= v_lightWeight;\n  } else { // 使用 color 方法传入的颜色\n     gl_FragColor = v_color;\n  }\n\n  // 应用透明度\n  gl_FragColor.a *= opacity;\n\n  // 开启透明度渐变\n  if(u_opacitylinear > 0.0) {\n    gl_FragColor.a *= u_opacitylinear_dir > 0.0 ? (1.0 - v_z): v_z;\n  }\n\n  // picking\n  if(u_pickLight > 0.0) {\n    gl_FragColor = filterColorWithLight(gl_FragColor, v_lightWeight);\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n', triangulation: XT, blend: this.getBlend(), cull: { enable: !0, face: Ma(this.mapService.version) }, depth: { enable: n } })] } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = "GLOBEL" === this.mapService.version; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r) { var i = t.size; if (i) { var o = []; return Array.isArray(i) && (o = 2 === i.length ? [i[0], i[0], i[1]] : i), Array.isArray(i) || (o = [i, i, i]), o } return [2, 2, 2] } } }), this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "pos", type: bx.Attribute, descriptor: { name: "a_Pos", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (e, n) { var r = kT(e.coordinates); return t ? yT([r[0], r[1]]) : [r[0], r[1], 0] } } }) } }]), n }(UC); function hO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var fO = "\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  \n  outer_df = sdCircle(v_data.xy, 1.0);\n  inner_df = sdCircle(v_data.xy, r);\n\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n  float PI = 3.14159;\n  float N_RINGS = 3.0;\n  float FREQ = 1.0;\n\n gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n\n  float d = length(v_data.xy);\n  if(d > 0.5) {\n    discard;\n  }\n  float intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_aimate.z - u_aimate.y * u_time)), 0.0, 1.0);\n  \n  // TODO: 根据叠加模式选择效果\n  if(u_additive > 0.0) {\n    gl_FragColor *= intensity;\n    gl_FragColor = filterColorAnimate(gl_FragColor);\n  } else {\n    gl_FragColor = vec4(gl_FragColor.xyz, gl_FragColor.a * intensity);\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n", dO = 'attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\nuniform float u_globel;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_isMeter;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_opacity : 1;\nuniform float u_stroke_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\nuniform vec2 u_offsets;\n\nuniform float u_blur : 0.0;\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n#pragma include "styleMappingCalStrokeOpacity"\n#pragma include "styleMappingCalStrokeWidth"\n\n#pragma include "projection"\n#pragma include "picking"\n\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  float newSize = setPickingSize(a_Size);\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 strokeOpacityAndOffset = calStrokeOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = strokeOpacityAndOffset.r;\n  textureOffset = strokeOpacityAndOffset.g;\n\n  vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // TODO: billboard\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, u_blur);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // 不以米为实际单位\n    offset = project_pixel(offset);\n  } else {\n    // 以米为实际单位\n    antialiasblur *= pow(19.0 - u_Zoom, 2.0);\n    antialiasblur = max(antialiasblur, -0.01);\n    // offset *= 0.5;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n  // TODP: /abs(extrude.x) 是为了兼容地球模式\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n  }\n\n  if(u_globel > 0.0) {\n    gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1, 1.0);\n  }\n \n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n', mO = function (t) { Ur(n, t); var e = hO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "meter2coord", 1), kr(Gr(t), "isMeter", !1), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.strokeOpacity, i = void 0 === r ? 1 : r, o = t.strokeWidth, a = void 0 === o ? 0 : o, s = t.stroke, l = void 0 === s ? "rgba(0,0,0,0)" : s, u = t.offsets, c = void 0 === u ? [0, 0] : u, p = t.blend; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c })) { this.judgeStyleAttributes({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c }); var h = this.layer.getEncodedData(), f = this.calDataFrame(this.cellLength, h, this.cellProperties), d = f.data, m = f.width, v = f.height; this.rowCount = v, this.dataTexture = this.cellLength > 0 && d.length > 0 ? this.createTexture2D({ flipY: !0, data: d, format: id.LUMINANCE, type: id.FLOAT, width: m, height: v }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_isMeter: Number(this.isMeter), u_additive: "additive" === p ? 1 : 0, u_globel: this.mapService.version === lA.GLOBEL ? 1 : 0, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1, u_stroke_opacity: DE(i) ? i : 1, u_stroke_width: DE(a) ? a : 0, u_stroke_color: this.getStrokeColor(l), u_offsets: this.isOffsetStatic(c) ? c : [0, 0] } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption, e = void 0 === t ? { enable: !1 } : t; return { u_aimate: this.animateOption2Array(e), u_time: this.layer.getLayerAnimateTime() } } }, { key: "getAttribute", value: function () { return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), HT) } }, { key: "initModels", value: function () { var t = this.layer.getLayerConfig().unit, e = void 0 === t ? "l7size" : t, n = this.mapService.version; return "meter" === e && n !== lA.L7MAP && n !== lA.GLOBEL && (this.isMeter = !0, this.calMeter2Coord()), this.buildModels() } }, { key: "calMeter2Coord", value: function () { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = [(e + r) / 2, (n + i) / 2]; if (this.mapService.version === lA.MAPBOX && window.mapboxgl.MercatorCoordinate) { var a = window.mapboxgl.MercatorCoordinate.fromLngLat({ lng: o[0], lat: o[1] }, 0), s = 1 * a.meterInMercatorCoordinateUnits(), l = new window.mapboxgl.MercatorCoordinate(a.x - s, a.y, a.z).toLngLat(); this.meter2coord = o[0] - l.lng } else { var u = this.mapService.meterToCoord(o, [e, n]), c = this.mapService.meterToCoord(o, [r === e ? r + .1 : r, i === n ? n + .1 : i]); this.meter2coord = (u + c) / 2, Boolean(this.meter2coord) || (this.meter2coord = 7.70681090738883) } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = t.animateOption, a = void 0 === o ? { enable: !1 } : o, s = this.getShaders(a), l = s.frag, u = s.vert, c = s.type, p = "GLOBEL" === this.mapService.version; return [this.layer.buildLayerModel({ moduleName: "pointfill_" + c, vertexShader: u, fragmentShader: l, triangulation: p ? WT : HT, depth: { enable: p }, blend: this.getBlend(), stencil: Ca(n, i), cull: { enable: !0, face: Ma(this.mapService.version) } })] } }, { key: "getShaders", value: function (t) { return t.enable ? (t.type, { frag: fO, vert: dO, type: "wave" }) : { frag: "\nuniform float u_globel;\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n  float stroke_opacity = styleMappingMat[0][1];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 strokeColor = textrueStroke == vec4(0) ? v_color : textrueStroke;\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius + strokeWidth);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  if (shape == 0) {\n    outer_df = sdCircle(v_data.xy, 1.0);\n    inner_df = sdCircle(v_data.xy, r);\n  } else if (shape == 1) {\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n  } else if (shape == 2) {\n    outer_df = sdBox(v_data.xy, vec2(1.));\n    inner_df = sdBox(v_data.xy, vec2(r));\n  } else if (shape == 3) {\n    outer_df = sdPentagon(v_data.xy, 0.8);\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\n  } else if (shape == 4) {\n    outer_df = sdHexagon(v_data.xy, 0.8);\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\n  } else if (shape == 5) {\n    outer_df = sdOctogon(v_data.xy, 1.0);\n    inner_df = sdOctogon(v_data.xy, r);\n  } else if (shape == 6) {\n    outer_df = sdHexagram(v_data.xy, 0.52);\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\n  } else if (shape == 7) {\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\n    inner_df = sdRhombus(v_data.xy, vec2(r));\n  } else if (shape == 8) {\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n  }\n\n  if(u_globel > 0.0) {\n    // TODO: 地球模式下避免多余片元绘制，同时也能避免有用片元在透明且重叠的情况下无法写入\n    // 付出的代价是边缘会有一些锯齿\n    if(outer_df > antialiasblur + 0.018) discard;\n  }\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = strokeWidth < 0.01 ? 0.0 : smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n\n  if(strokeWidth < 0.01) {\n    gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n  } else {\n    gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), strokeColor * stroke_opacity, color_t);\n  }\n\n  if(u_additive > 0.0) {\n    gl_FragColor *= opacity_t;\n  } else {\n    gl_FragColor.a *= opacity_t;\n  }\n\n  if(gl_FragColor.a > 0.0) {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n", vert: dO, type: "normal" } } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "animateOption2Array", value: function (t) { return [t.enable ? 0 : 1, t.speed || 1, t.rings || 3, 0] } }, { key: "registerBuiltinAttributes", value: function () { var t = this, e = "GLOBEL" === this.mapService.version; this.styleAttributeService.registerStyleAttribute({ name: "extrude", type: bx.Attribute, descriptor: { name: "a_Extrude", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, n, r, i) { var o; if (e) { var a = Lr(r, 3), s = a[0], l = a[1], u = a[2], c = Is(0, 0, 1), p = Is(s, 0, u), h = s >= 0 ? Gs(c, p) : 2 * Math.PI - Gs(c, p), f = 2 * Math.PI - Math.asin(l / 100), d = os(); ds(d, d, h), fs(d, d, f); var m = Is(1, 1, 0); Vs(m, m, d), Bs(m, m); var v = Is(-1, 1, 0); Vs(v, v, d), Bs(v, v); var y = Is(-1, -1, 0); Vs(y, y, d), Bs(y, y); var g = Is(1, -1, 0); Vs(g, g, d), Bs(g, g), o = [].concat(Fd(m), Fd(v), Fd(y), Fd(g)) } else o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]; var _ = i % 4 * 3; return [o[_], o[_ + 1], o[_ + 2]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (e, n, r, i) { var o = e.size, a = void 0 === o ? 5 : o; return Array.isArray(a) ? [a[0] * t.meter2coord] : [a * t.meter2coord] } } }), this.styleAttributeService.registerStyleAttribute({ name: "shape", type: bx.Attribute, descriptor: { name: "a_Shape", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (e, n, r, i) { var o = e.shape, a = void 0 === o ? 2 : o; return [t.layer.getLayerConfig().shape2d.indexOf(a)] } } }) } }]), n }(UC); function vO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var yO = function (t) { Ur(n, t); var e = vO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "meter2coord", 1), kr(Gr(t), "texture", void 0), kr(Gr(t), "isMeter", !1), kr(Gr(t), "radian", 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas(), mag: "linear", min: "linear mipmap nearest", mipmap: !0 }), void t.layer.renderLayers(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.LINEAR, min: id.LINEAR_MIPMAP_LINEAR, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128, mipmap: !0 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.strokeOpacity, i = void 0 === r ? 1 : r, o = t.strokeWidth, a = void 0 === o ? 0 : o, s = t.stroke, l = void 0 === s ? "rgba(0,0,0,0)" : s, u = t.offsets, c = void 0 === u ? [0, 0] : u, p = t.blend, h = t.rotation; this.rendererService.getDirty() && this.texture.bind(); var f = 1; if ("GAODE2.x" !== this.mapService.version && "GAODE1.x" !== this.mapService.version || (f = -1), this.radian = void 0 !== h ? f * Math.PI * h / 180 : f * Math.PI * (this.mapService.getRotation() % 360) / 180, this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c })) { this.judgeStyleAttributes({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c }); var d = this.layer.getEncodedData(), m = this.calDataFrame(this.cellLength, d, this.cellProperties), v = m.data, y = m.width, g = m.height; this.rowCount = g, this.dataTexture = this.cellLength > 0 && v.length > 0 ? this.createTexture2D({ flipY: !0, data: v, format: id.LUMINANCE, type: id.FLOAT, width: y, height: g }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_isMeter: Number(this.isMeter), u_RotateMatrix: new Float32Array([Math.cos(this.radian), Math.sin(this.radian), -Math.sin(this.radian), Math.cos(this.radian)]), u_additive: "additive" === p ? 1 : 0, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_texture: this.texture, u_textSize: [1024, this.iconService.canvasHeight || 128], u_opacity: DE(n) ? n : 1, u_offsets: this.isOffsetStatic(c) ? c : [0, 0] } } }, { key: "getAttribute", value: function () { return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), HT) } }, { key: "initModels", value: function () { this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture); var t = this.layer.getLayerConfig().unit, e = void 0 === t ? "l7size" : t, n = this.mapService.version; return "meter" === e && n !== lA.L7MAP && n !== lA.GLOBEL && (this.isMeter = !0, this.calMeter2Coord()), this.buildModels() } }, { key: "calMeter2Coord", value: function () { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = [(e + r) / 2, (n + i) / 2]; if (this.mapService.version === lA.MAPBOX && window.mapboxgl.MercatorCoordinate) { var a = window.mapboxgl.MercatorCoordinate.fromLngLat({ lng: o[0], lat: o[1] }, 0), s = 1 * a.meterInMercatorCoordinateUnits(), l = new window.mapboxgl.MercatorCoordinate(a.x - s, a.y, a.z).toLngLat(); this.meter2coord = o[0] - l.lng } else { var u = this.mapService.meterToCoord(o, [e, n]), c = this.mapService.meterToCoord(o, [r === e ? r + .1 : r, i === n ? n + .1 : i]); this.meter2coord = (u + c) / 2, Boolean(this.meter2coord) || (this.meter2coord = 7.70681090738883) } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = this.getShaders(), a = o.frag, s = o.vert, l = o.type; return [this.layer.buildLayerModel({ moduleName: "pointfill_" + l, vertexShader: s, fragmentShader: a, triangulation: HT, depth: { enable: !1 }, blend: this.getBlend(), stencil: Ca(n, i), cull: { enable: !0, face: Ma(this.mapService.version) } })] } }, { key: "getShaders", value: function () { return { frag: 'uniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nvarying float v_radius;\n\n#pragma include "sdf_2d"\n#pragma include "picking"\nvarying vec2 v_uv; // 本身的 uv 坐标\nvarying vec2 v_Iconuv;\n\nvoid main() {\n\n  float opacity = styleMappingMat[0][0];\n\n  vec2 pos = v_Iconuv / u_textSize + v_uv / u_textSize * 64.;\n  gl_FragColor = texture2D(u_texture, pos);\n  gl_FragColor.a *= opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: 'attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute vec2 a_Uv;\nattribute float a_Rotate;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform mat2 u_RotateMatrix;\nuniform float u_isMeter;\n\nvarying float v_radius;\nvarying vec2 v_uv; // 本身的 uv 坐标\nvarying vec2 v_Iconuv; // icon 贴图的 uv 坐标\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n\n  v_uv = (a_Extrude.xy + 1.0)/2.0;\n  v_uv.y = 1.0 - v_uv.y;\n  v_Iconuv = a_Uv;\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // empty - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  // radius(16-bit)\n  v_radius = a_Size;\n\n  // TODO: billboard\n  // anti-alias\n  \n\n  highp float angle_sin = sin(a_Rotate);\n  highp float angle_cos = cos(a_Rotate);\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n  // vec2 offset = (u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec2 offset = (rotation_matrix * u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // 不以米为实际单位\n    offset = project_pixel(offset);\n  } else {\n    // 以米为实际单位\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n  }\n \n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n', type: "normal" } } }, { key: "clearModels", value: function () { var t, e; this.iconService.off("imageUpdate", this.updateTexture), null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "rotate", type: bx.Attribute, descriptor: { name: "a_Rotate", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.rotate, o = void 0 === i ? 0 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_Uv", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.shape] || { x: 0, y: 0 }; return [o.x, o.y] } } }), this.styleAttributeService.registerStyleAttribute({ name: "extrude", type: bx.Attribute, descriptor: { name: "a_Extrude", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r) { var i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0], o = r % 4 * 3; return [i[o], i[o + 1], i[o + 2]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (e, n, r, i) { var o = e.size, a = void 0 === o ? 5 : o; return Array.isArray(a) ? [a[0] * t.meter2coord] : [a * t.meter2coord] } } }) } }]), n }(UC); function gO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var _O = function (t) { Ur(n, t); var e = gO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), t } return Or(n, [{ key: "getUninforms", value: function () { return { u_opacity: this.layer.getLayerConfig().opacity || 1, u_texture: this.texture, u_textSize: [1024, this.iconService.canvasHeight || 128] } } }, { key: "initModels", value: function () { var t = this; return this.initIconFontGlyphs(), this.registerBuiltinAttributes(), this.updateTexture(), this.iconService.on("imageUpdate", (function () { t.updateTexture(), t.layer.render() })), [this.layer.buildLayerModel({ moduleName: "pointiconImage", vertexShader: 'precision highp float;\nattribute vec3 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Uv;\nattribute float a_Size;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_stroke_width : 1;\nuniform vec2 u_offsets;\n\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  styleMappingMat[1][0] = a_Size;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping - 数据纹理映射部分的计算\n   v_color = a_Color;\n   v_uv = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  //  vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n\n  //  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0);\n    } else {\n      gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n    }\n   gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n\n  setPickingColor(a_PickingColor);\n\n}\n', fragmentShader: '\nuniform sampler2D u_texture;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform vec2 u_textSize;\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\nvoid main(){\n      float opacity = styleMappingMat[0][0];\n      float size = styleMappingMat[1][0];\n      vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n      vec4 textureColor;\n\n      // Y = 0.299R + 0.587G + 0.114B // 亮度提取\n     \n      textureColor = texture2D(u_texture, pos);\n\n      // Tip: 去除边缘部分 mipmap 导致的混合变暗\n      float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n      if(fragmengTocenter >= 0.5) {\n            float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n            textureColor.a *= luma;\n      }\n      \n      \n\n      if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n            gl_FragColor= textureColor;\n      }else {\n            gl_FragColor= step(0.01, textureColor.z) * v_color;\n      }\n\n      gl_FragColor.a = gl_FragColor.a * opacity;\n      gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: qT, primitive: id.POINTS, depth: { enable: !1 }, blend: this.getBlend() })] } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size; return Array.isArray(i) ? [i[0]] : [i] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_Uv", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.fontService.mapping, a = e.shape, s = o[t.fontService.getGlyph(a)]; return [s.x, s.y] } } }) } }, { key: "updateTexture", value: function () { var t = this.rendererService.createTexture2D, e = this.fontService.canvas; this.texture = t({ data: e, mag: id.LINEAR, min: id.LINEAR, width: e.width, height: e.height }) } }, { key: "initIconFontGlyphs", value: function () { var t = this, e = this.layer.getLayerConfig(), n = e.fontWeight, r = void 0 === n ? "normal" : n, i = e.fontFamily, o = void 0 === i ? "sans-serif" : i, a = this.layer.getEncodedData(), s = []; a.forEach((function (e) { var n = e.shape, r = void 0 === n ? "" : n; r = r.toString(); var i = t.fontService.getGlyph(r); -1 === s.indexOf(i) && s.push(i) })), this.fontService.setFontOptions({ characterSet: s, fontWeight: r, fontFamily: o, fontSize: 48 }) } }]), n }(UC); function xO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var bO = function (t) { Ur(n, t); var e = xO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), kr(Gr(t), "updateTexture", (function () { var e = t.rendererService.createTexture2D; if (t.texture) return t.texture.update({ data: t.iconService.getCanvas(), mag: "linear", min: "linear mipmap nearest", mipmap: !0 }), void t.layer.renderLayers(); t.texture = e({ data: t.iconService.getCanvas(), mag: id.LINEAR, min: id.LINEAR_MIPMAP_LINEAR, premultiplyAlpha: !1, width: 1024, height: t.iconService.canvasHeight || 128, mipmap: !0 }) })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = t.offsets, r = void 0 === n ? [0, 0] : n; if (this.rendererService.getDirty() && this.texture.bind(), this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: e, offsets: r })) { this.judgeStyleAttributes({ opacity: e, offsets: r }); var i = this.layer.getEncodedData(), o = this.calDataFrame(this.cellLength, i, this.cellProperties), a = o.data, s = o.width, l = o.height; this.rowCount = l, this.dataTexture = this.cellLength > 0 && a.length > 0 ? this.createTexture2D({ flipY: !0, data: a, format: id.LUMINANCE, type: id.FLOAT, width: s, height: l }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_texture: this.texture, u_textSize: [1024, this.iconService.canvasHeight || 128], u_opacity: DE(e) ? e : 1, u_offsets: this.isOffsetStatic(r) ? r : [0, 0] } } }, { key: "initModels", value: function () { return this.registerBuiltinAttributes(), this.updateTexture(), this.iconService.on("imageUpdate", this.updateTexture), this.buildModels() } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy(), this.iconService.off("imageUpdate", this.updateTexture) } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "pointImage", vertexShader: 'precision highp float;\nattribute vec3 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Uv;\nattribute float a_Size;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_stroke_width : 1;\nuniform vec2 u_offsets;\n\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  styleMappingMat[1][0] = a_Size;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping - 数据纹理映射部分的计算\n   v_color = a_Color;\n   v_uv = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  //  vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n\n  //  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0);\n    } else {\n      gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n    }\n   gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n\n  setPickingColor(a_PickingColor);\n\n}\n', fragmentShader: '\nuniform sampler2D u_texture;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform vec2 u_textSize;\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\nvoid main(){\n      float opacity = styleMappingMat[0][0];\n      float size = styleMappingMat[1][0];\n      vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n      vec4 textureColor;\n\n      // Y = 0.299R + 0.587G + 0.114B // 亮度提取\n     \n      textureColor = texture2D(u_texture, pos);\n\n      // Tip: 去除边缘部分 mipmap 导致的混合变暗\n      float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n      if(fragmengTocenter >= 0.5) {\n            float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n            textureColor.a *= luma;\n      }\n      \n      \n\n      if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n            gl_FragColor= textureColor;\n      }else {\n            gl_FragColor= step(0.01, textureColor.z) * v_color;\n      }\n\n      gl_FragColor.a = gl_FragColor.a * opacity;\n      gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: qT, primitive: id.POINTS, depth: { enable: !1 }, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 5 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "uv", type: bx.Attribute, descriptor: { name: "a_Uv", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (e, n, r, i) { var o = t.iconService.getIconMap()[e.shape] || { x: 0, y: 0 }; return [o.x, o.y] } } }) } }]), n }(UC); function wO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function SO(t) { var e = t.coordinates; return { vertices: Fd(e), indices: [0], size: e.length } } var EO = function (e) { Ur(r, e); var n = wO(r); function r() { return Ar(this, r), n.apply(this, arguments) } return Or(r, [{ key: "getDefaultStyle", value: function () { return { blend: "additive" } } }, { key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.offsets, i = void 0 === r ? [0, 0] : r; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, offsets: i })) { this.judgeStyleAttributes({ opacity: n, offsets: i }); var o = this.layer.getEncodedData(), a = this.calDataFrame(this.cellLength, o, this.cellProperties), s = a.data, l = a.width, u = a.height; this.rowCount = u, this.dataTexture = this.cellLength > 0 && s.length > 0 ? this.createTexture2D({ flipY: !0, data: s, format: id.LUMINANCE, type: id.FLOAT, width: l, height: u }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1, u_offsets: this.isOffsetStatic(i) ? i : [0, 0] } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "normalpoint", vertexShader: '\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute float a_Size;\nattribute vec4 a_Color;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "project"\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n  \n  // vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n  // vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n  // gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\\\n  // \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // vec2 offset = project_pixel((u_offsets));\n    gl_Position = u_Mvp * vec4(a_Position.xy + offset, a_Position.z, 1.0);\n  } else { // else\n    // vec2 offset = project_pixel(u_offsets);\n    vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n  }\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: '\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nvarying vec4 v_color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n\n  gl_FragColor = v_color;\n  // gl_FragColor.a =gl_FragColor.a * u_opacity;\n  gl_FragColor.a =gl_FragColor.a * opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: SO, depth: { enable: !1 }, primitive: id.POINTS, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }) } }, { key: "defaultStyleOptions", value: function () { return { blend: t.BlendType.additive } } }]), r }(UC); function CO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var TO = function (t) { Ur(n, t); var e = CO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "meter2coord", 1), kr(Gr(t), "isMeter", !1), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.strokeOpacity, i = void 0 === r ? 1 : r, o = t.strokeWidth, a = void 0 === o ? 0 : o, s = t.stroke, l = void 0 === s ? "rgba(0,0,0,0)" : s, u = t.offsets, c = void 0 === u ? [0, 0] : u, p = t.blend, h = t.speed, f = void 0 === h ? 1 : h; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c })) { this.judgeStyleAttributes({ opacity: n, strokeOpacity: i, strokeWidth: a, stroke: l, offsets: c }); var d = this.layer.getEncodedData(), m = this.calDataFrame(this.cellLength, d, this.cellProperties), v = m.data, y = m.width, g = m.height; this.rowCount = g, this.dataTexture = this.cellLength > 0 && v.length > 0 ? this.createTexture2D({ flipY: !0, data: v, format: id.LUMINANCE, type: id.FLOAT, width: y, height: g }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_isMeter: Number(this.isMeter), u_speed: f, u_additive: "additive" === p ? 1 : 0, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1, u_offsets: this.isOffsetStatic(c) ? c : [0, 0] } } }, { key: "getAnimateUniforms", value: function () { var t = this.layer.getLayerConfig().animateOption, e = void 0 === t ? { enable: !1 } : t; return { u_aimate: this.animateOption2Array(e), u_time: this.layer.getLayerAnimateTime() } } }, { key: "getAttribute", value: function () { return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), HT) } }, { key: "initModels", value: function () { var t = this.layer.getLayerConfig().unit, e = void 0 === t ? "l7size" : t, n = this.mapService.version; return "meter" === e && n !== lA.L7MAP && n !== lA.GLOBEL && (this.isMeter = !0, this.calMeter2Coord()), this.buildModels() } }, { key: "calMeter2Coord", value: function () { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = [(e + r) / 2, (n + i) / 2]; if (this.mapService.version === lA.MAPBOX && window.mapboxgl.MercatorCoordinate) { var a = window.mapboxgl.MercatorCoordinate.fromLngLat({ lng: o[0], lat: o[1] }, 0), s = 1 * a.meterInMercatorCoordinateUnits(), l = new window.mapboxgl.MercatorCoordinate(a.x - s, a.y, a.z).toLngLat(); this.meter2coord = o[0] - l.lng } else { var u = this.mapService.meterToCoord(o, [e, n]), c = this.mapService.meterToCoord(o, [r === e ? r + .1 : r, i === n ? n + .1 : i]); this.meter2coord = (u + c) / 2, Boolean(this.meter2coord) || (this.meter2coord = 7.70681090738883) } } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = this.getShaders(), a = o.frag, s = o.vert, l = o.type; return [this.layer.buildLayerModel({ moduleName: "pointfill_" + l, vertexShader: s, fragmentShader: a, triangulation: HT, depth: { enable: !1 }, blend: this.getBlend(), stencil: Ca(n, i), cull: { enable: !0, face: Ma(this.mapService.version) } })] } }, { key: "getShaders", value: function () { return { frag: '\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include "sdf_2d"\n#pragma include "picking"\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius);\n\n  float outer_df = sdCircle(v_data.xy, 1.0);\n  float inner_df = sdCircle(v_data.xy, r);\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n\n  if(u_additive > 0.0) {\n    gl_FragColor *= opacity_t;\n  } else {\n    gl_FragColor.a *= opacity_t;\n  }\n\n  if(gl_FragColor.a > 0.0) {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n\n  vec2 extrude =  styleMappingMat[2].ba;\n  vec2 dir = normalize(extrude);\n  vec2 baseDir = vec2(1.0, 0.0);\n  float pi = 3.14159265359;\n  // full circle\n  // float rades = dot(dir, baseDir);\n  // float flag = sign(dir.y);\n  // float radar_v = (flag - 1.0) * -0.5 + flag * acos(rades)/pi/2.0;\n  \n  // half circle\n  float flag = sign(dir.y);\n  float rades = dot(dir, baseDir);\n  float radar_v = (flag - 1.0) * -0.5 * acos(rades)/pi;\n  // simple AA\n  if(radar_v > 0.99) {\n    radar_v = 1.0 - (radar_v - 0.99)/0.01;\n  }\n\n\n\n  gl_FragColor.a *= radar_v;\n}\n', vert: 'attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\nuniform float u_speed: 1.0;\nuniform float u_time;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\nuniform float u_globel;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_isMeter;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_opacity : 1;\nuniform float u_stroke_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\nuniform vec2 u_offsets;\n\nuniform float u_blur : 0.0;\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  float newSize = setPickingSize(a_Size);\n\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // empty - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1] - a_Extrude.x - a_Extrude.y\n    0.0, 0.0, 0.0, 0.0  // \n  );\n\n  float time = u_time * u_speed;\n  mat2 rotateMatrix = mat2( \n    cos(time), sin(time), \n    -sin(time), cos(time)\n  );\n  styleMappingMat[2].ba = rotateMatrix * a_Extrude.xy;\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> empty -> empty ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // TODO: billboard\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, u_blur);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // 不以米为实际单位\n    offset = project_pixel(offset);\n  } else {\n    // 以米为实际单位\n    antialiasblur *= pow(19.0 - u_Zoom, 2.0);\n    antialiasblur = max(antialiasblur, -0.01);\n    // offset *= 0.5;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n  v_data = vec4(extrude.x, extrude.y, antialiasblur,shape_type);\n\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n  }\n\n  if(u_globel > 0.0) {\n    gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1, 1.0);\n  }\n\n  setPickingColor(a_PickingColor);\n}\n', type: "radar" } } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "animateOption2Array", value: function (t) { return [t.enable ? 0 : 1, t.speed || 1, t.rings || 3, 0] } }, { key: "registerBuiltinAttributes", value: function () { var t = this; this.styleAttributeService.registerStyleAttribute({ name: "extrude", type: bx.Attribute, descriptor: { name: "a_Extrude", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r) { var i, o = r % 4 * 3; return [(i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0])[o], i[o + 1], i[o + 2]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (e, n, r, i) { var o = e.size, a = void 0 === o ? 5 : o; return Array.isArray(a) ? [a[0] * t.meter2coord] : [a * t.meter2coord] } } }), this.styleAttributeService.registerStyleAttribute({ name: "shape", type: bx.Attribute, descriptor: { name: "a_Shape", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (e, n, r, i) { var o = e.shape, a = void 0 === o ? 2 : o; return [t.layer.getLayerConfig().shape2d.indexOf(a)] } } }) } }]), n }(UC); function AO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } function MO(t) { var e = t.coordinates; return { vertices: Fd(e), indices: [0], size: e.length } } var OO = function (e) { Ur(r, e); var n = AO(r); function r() { return Ar(this, r), n.apply(this, arguments) } return Or(r, [{ key: "getDefaultStyle", value: function () { return { blend: "additive" } } }, { key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.offsets, i = void 0 === r ? [0, 0] : r, o = t.blend, a = t.strokeOpacity, s = void 0 === a ? 1 : a, l = t.strokeWidth, u = void 0 === l ? 0 : l, c = t.stroke, p = void 0 === c ? "#fff" : c; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, offsets: i })) { this.judgeStyleAttributes({ opacity: n, offsets: i }); var h = this.layer.getEncodedData(), f = this.calDataFrame(this.cellLength, h, this.cellProperties), d = f.data, m = f.width, v = f.height; this.rowCount = v, this.dataTexture = this.cellLength > 0 && d.length > 0 ? this.createTexture2D({ flipY: !0, data: d, format: id.LUMINANCE, type: id.FLOAT, width: m, height: v }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_additive: "additive" === o ? 1 : 0, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1, u_offsets: this.isOffsetStatic(i) ? i : [0, 0], u_stroke_opacity: DE(s) ? s : 1, u_stroke_width: DE(u) ? u : 0, u_stroke_color: this.getStrokeColor(p) } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "simplepoint", vertexShader: '\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute float a_Size;\nattribute vec4 a_Color;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nuniform float u_stroke_width;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\nvarying float v_blur;\nvarying float v_innerRadius;\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "project"\nvoid main() {\n  v_color = a_Color;\n  v_blur = 1.0 - max(2.0/a_Size, 0.05);\n  v_innerRadius = max((a_Size - u_stroke_width) / a_Size, 0.0);\n\n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n  \n  // vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n  // vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n  // gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\\\n  // \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // vec2 offset = project_pixel((u_offsets));\n    gl_Position = u_Mvp * vec4(a_Position.xy + offset, a_Position.z, 1.0);\n  } else { // else\n    // vec2 offset = project_pixel(u_offsets);\n    vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n  }\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n', fragmentShader: '\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nuniform float u_additive;\n\nuniform float u_stroke_opacity : 1;\n\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\nvarying vec4 v_color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\nvarying float v_blur;\nvarying float v_innerRadius;\n\n#pragma include "picking"\nvoid main() {\n  vec2 center = vec2(0.5);\n\n  float opacity = styleMappingMat[0][0];\n  // Tip: 片元到中心点的距离 0 - 1\n  float fragmengTocenter = distance(center, gl_PointCoord) * 2.0;\n  // Tip: 片元的剪切成圆形\n  float circleClipOpacity = 1.0 - smoothstep(v_blur, 1.0, fragmengTocenter);\n\n\n  if(v_innerRadius < 0.99) {\n    // 当存在 stroke 且 stroke > 0.01\n    float blurWidth = (1.0 - v_blur)/2.0;\n    vec4 stroke = vec4(u_stroke_color.rgb, u_stroke_opacity);\n    if(fragmengTocenter > v_innerRadius + blurWidth) {\n      gl_FragColor = stroke;\n    } else if(fragmengTocenter > v_innerRadius - blurWidth){\n      float mixR = (fragmengTocenter - (v_innerRadius - blurWidth)) / (blurWidth * 2.0);\n      gl_FragColor = mix(v_color, stroke, mixR);\n    } else {\n      gl_FragColor = v_color;\n    }\n  } else {\n    // 当不存在 stroke 或 stroke <= 0.01\n    gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n\n  \n\n  \n  \n  if(u_additive > 0.0) {\n    gl_FragColor *= circleClipOpacity;\n  } else {\n    gl_FragColor.a *= circleClipOpacity;\n  }\n\n}\n', triangulation: MO, depth: { enable: !1 }, primitive: id.POINTS, blend: this.getBlend(), stencil: Ca(n, i) })] } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 1 : i; return Array.isArray(o) ? [o[0]] : [o] } } }) } }, { key: "defaultStyleOptions", value: function () { return { blend: t.BlendType.additive } } }]), r }(UC); function kO(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return IO(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IO(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function IO(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var PO = function () { function t(e, n, r) { Ar(this, t), kr(this, "boxCells", []), kr(this, "xCellCount", void 0), kr(this, "yCellCount", void 0), kr(this, "boxKeys", void 0), kr(this, "bboxes", void 0), kr(this, "width", void 0), kr(this, "height", void 0), kr(this, "xScale", void 0), kr(this, "yScale", void 0), kr(this, "boxUid", void 0); var i = this.boxCells; this.xCellCount = Math.ceil(e / r), this.yCellCount = Math.ceil(n / r); for (var o = 0; o < this.xCellCount * this.yCellCount; o++)i.push([]); this.boxKeys = [], this.bboxes = [], this.width = e, this.height = n, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / n, this.boxUid = 0 } return Or(t, [{ key: "insert", value: function (t, e, n, r, i) { this.forEachCell(e, n, r, i, this.insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(n), this.bboxes.push(r), this.bboxes.push(i) } }, { key: "query", value: function (t, e, n, r, i) { return this.queryHitTest(t, e, n, r, !1, i) } }, { key: "hitTest", value: function (t, e, n, r, i) { return this.queryHitTest(t, e, n, r, !0, i) } }, { key: "insertBoxCell", value: function (t, e, n, r, i, o) { this.boxCells[i].push(o) } }, { key: "queryHitTest", value: function (t, e, n, r, i, o) { if (n < 0 || t > this.width || r < 0 || e > this.height) return !i && []; var a = []; if (t <= 0 && e <= 0 && this.width <= n && this.height <= r) { if (i) return !0; for (var s = 0; s < this.boxKeys.length; s++)a.push({ key: this.boxKeys[s], x1: this.bboxes[4 * s], y1: this.bboxes[4 * s + 1], x2: this.bboxes[4 * s + 2], y2: this.bboxes[4 * s + 3] }); return o ? a.filter(o) : a } var l = { hitTest: i, seenUids: { box: {}, circle: {} } }; return this.forEachCell(t, e, n, r, this.queryCell, a, l, o), i ? a.length > 0 : a } }, { key: "queryCell", value: function (t, e, n, r, i, o, a, s) { var l = a.seenUids, u = this.boxCells[i]; if (null !== u) { var c, p = this.bboxes, h = kO(u); try { for (h.s(); !(c = h.n()).done;) { var f = c.value; if (!l.box[f]) { l.box[f] = !0; var d = 4 * f; if (t <= p[d + 2] && e <= p[d + 3] && n >= p[d + 0] && r >= p[d + 1] && (!s || s(this.boxKeys[f]))) { if (a.hitTest) return o.push(!0), !0; o.push({ key: this.boxKeys[f], x1: p[d], y1: p[d + 1], x2: p[d + 2], y2: p[d + 3] }) } } } } catch (t) { h.e(t) } finally { h.f() } } return !1 } }, { key: "forEachCell", value: function (t, e, n, r, i, o, a, s) { for (var l = this.convertToXCellCoord(t), u = this.convertToYCellCoord(e), c = this.convertToXCellCoord(n), p = this.convertToYCellCoord(r), h = l; h <= c; h++)for (var f = u; f <= p; f++) { var d = this.xCellCount * f + h; if (i.call(this, t, e, n, r, d, o, a, s)) return } } }, { key: "convertToXCellCoord", value: function (t) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))) } }, { key: "convertToYCellCoord", value: function (t) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))) } }]), t }(), LO = PO, RO = function () { function t(e, n) { Ar(this, t), kr(this, "width", void 0), kr(this, "height", void 0), kr(this, "grid", void 0), kr(this, "viewportPadding", 100), kr(this, "screenRightBoundary", void 0), kr(this, "screenBottomBoundary", void 0), kr(this, "gridRightBoundary", void 0), kr(this, "gridBottomBoundary", void 0), this.width = e, this.height = n, this.viewportPadding = Math.max(e, n), this.grid = new LO(e + this.viewportPadding, n + this.viewportPadding, 25), this.screenRightBoundary = e + this.viewportPadding, this.screenBottomBoundary = n + this.viewportPadding, this.gridRightBoundary = e + 2 * this.viewportPadding, this.gridBottomBoundary = n + 2 * this.viewportPadding } return Or(t, [{ key: "placeCollisionBox", value: function (t) { var e = t.x1 + t.anchorPointX + this.viewportPadding, n = t.y1 + t.anchorPointY + this.viewportPadding, r = t.x2 + t.anchorPointX + this.viewportPadding, i = t.y2 + t.anchorPointY + this.viewportPadding; return !this.isInsideGrid(e, n, r, i) || this.grid.hitTest(e, n, r, i) ? { box: [] } : { box: [e, n, r, i] } } }, { key: "insertCollisionBox", value: function (t, e) { var n = { featureIndex: e }; this.grid.insert(n, t[0], t[1], t[2], t[3]) } }, { key: "project", value: function (t, e, n) { var r = function (t, e, n, r) { var i = new rs(4); return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i }(e, n, 0, 1), i = tl(); return el(i, r, ss.apply(Ms, Fd(t))), { x: (i[0] / i[3] + 1) / 2 * this.width + this.viewportPadding, y: (-i[1] / i[3] + 1) / 2 * this.height + this.viewportPadding } } }, { key: "isInsideGrid", value: function (t, e, n, r) { return n >= 0 && t < this.gridRightBoundary && r >= 0 && e < this.gridBottomBoundary } }]), t }(); function DO(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return NO(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return NO(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function NO(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function zO(t) { var e = .5, n = .5; switch (t) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0; break; default: e = .5 }switch (t) { case "bottom": case "bottom-right": case "bottom-left": n = 1; break; case "top": case "top-right": case "top-left": n = 0; break; default: n = .5 }return { horizontalAlign: e, verticalAlign: n } } function FO(t, e, n, r, i) { if (i) { var o = t[r], a = o.glyph; if (a) for (var s = e[a].advance * o.scale, l = (t[r].x + s) * i, u = n; u <= r; u++)t[u].x -= l } } function BO(t, e, n, r, i, o, a) { var s, l = (e - n) * i, u = (-r * a + .5) * o, c = DO(t); try { for (c.s(); !(s = c.n()).done;) { var p = s.value; p.x += l, p.y += u } } catch (t) { c.e(t) } finally { c.f() } } function jO(t, e, n, r, i, o, a) { var s = 0, l = -8, u = 0, c = t.positionedGlyphs, p = "right" === o ? 1 : "left" === o ? 0 : .5, h = c.length; n.forEach((function (t) { if (t.split("").forEach((function (t) { var n = e[t]; n && (c.push({ glyph: t, x: s, y: l + 0, vertical: !1, scale: 1, metrics: n }), s += n.advance + a) })), c.length !== h) { var n = s - a; u = Math.max(n, u), FO(c, e, h, c.length - 1, p) } s = 0, l -= r + 5 })); var f = zO(i), d = f.horizontalAlign, m = f.verticalAlign; BO(c, p, d, m, u, r, n.length); var v = l - -8; t.top += -m * v, t.bottom = t.top - v, t.left += -d * u, t.right = t.left + u } function UO(t, e, n, r, i, o, a) { var s = 0, l = -8, u = 0, c = t.positionedGlyphs, p = "right" === o ? 1 : "left" === o ? 0 : .5, h = c.length; n.forEach((function (t) { var n = e[t]; if (n && (c.push({ glyph: t, x: n.advance / 2, y: l + 0, vertical: !1, scale: 1, metrics: n }), s += n.advance + a), c.length !== h) { var i = s - a; u = Math.max(i, u), FO(c, e, h, c.length - 1, p) } s = 0, l -= r + 5 })); var f = zO(i), d = f.horizontalAlign, m = f.verticalAlign; BO(c, p, d, m, u, r, n.length); var v = l - -8; t.top += -m * v, t.bottom = t.top - v, t.left += -d * u, t.right = t.left + u } function VO(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return GO(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GO(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function GO(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function HO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var WO = '#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke_color : [0, 0, 0, 1];\nuniform float u_stroke_width : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\nvoid main() {\n  // get style data mapping\n  float opacity = styleMappingMat[0][0];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  // float fontScale = u_font_size / FONT_SIZE;\n\n  // lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  lowp float buff = (6.0 - strokeWidth / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  // gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke_color.rgb, u_stroke_color.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), vec4(textrueStroke.rgb, textrueStroke.a * opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', XO = '#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\nattribute float a_Rotate;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_raisingHeight: 0.0;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\nuniform float u_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n#pragma include "styleMappingCalStrokeWidth"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n   styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n   vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n  \n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // 文本缩放比例\n  float fontScale = a_Size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  highp float angle_sin = sin(a_Rotate);\n  highp float angle_cos = cos(a_Rotate);\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  \n  // gl_Position = vec4(projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n\n  float raiseHeight = u_raisingHeight;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  vec4 projected_position;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n   projected_position  = u_Mvp * (vec4(a_Position.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  } else { // else\n   projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  }\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n'; function qO(t) { var e = this, n = t.id, r = [], i = []; if (!e.glyphInfoMap || !e.glyphInfoMap[n]) return { vertices: [], indices: [], size: 7 }; var o = e.glyphInfoMap[n].centroid, a = 2 === o.length ? [o[0], o[1], 0] : o; return e.glyphInfoMap[n].glyphQuads.forEach((function (t, e) { r.push.apply(r, Fd(a).concat([t.tex.x, t.tex.y + t.tex.height, t.tl.x, t.tl.y], Fd(a), [t.tex.x + t.tex.width, t.tex.y + t.tex.height, t.tr.x, t.tr.y], Fd(a), [t.tex.x + t.tex.width, t.tex.y, t.br.x, t.br.y], Fd(a), [t.tex.x, t.tex.y, t.bl.x, t.bl.y])), i.push(0 + 4 * e, 1 + 4 * e, 2 + 4 * e, 2 + 4 * e, 3 + 4 * e, 0 + 4 * e) })), { vertices: r, indices: i, size: 7 } } var ZO = function (t) { Ur(n, t); var e = HO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "glyphInfo", void 0), kr(Gr(t), "glyphInfoMap", {}), kr(Gr(t), "texture", void 0), kr(Gr(t), "currentZoom", -1), kr(Gr(t), "extent", void 0), kr(Gr(t), "textureHeight", 0), kr(Gr(t), "textCount", 0), kr(Gr(t), "preTextStyle", {}), kr(Gr(t), "buildModels", (function () { var e = t.layer.getLayerConfig(), n = e.mask, r = void 0 !== n && n, i = e.maskInside, o = void 0 === i || i; return t.initGlyph(), t.updateTexture(), t.filterGlyphs(), t.reBuildModel(), [t.layer.buildLayerModel({ moduleName: "pointText", vertexShader: XO, fragmentShader: WO, triangulation: qO.bind(Gr(t)), depth: { enable: !1 }, blend: t.getBlend(), stencil: Ca(r, o) })] })), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.stroke, i = void 0 === r ? "#fff" : r, o = t.strokeWidth, a = void 0 === o ? 0 : o, s = t.textAnchor, l = void 0 === s ? "center" : s, u = t.textAllowOverlap, c = void 0 !== u && u, p = t.halo, h = void 0 === p ? .5 : p, f = t.gamma, d = void 0 === f ? 2 : f, m = t.raisingHeight, v = void 0 === m ? 0 : m, y = this.fontService, g = y.canvas, _ = y.mapping; if (Object.keys(_).length !== this.textCount && (this.updateTexture(), this.textCount = Object.keys(_).length), this.preTextStyle = { textAnchor: l, textAllowOverlap: c }, this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n, strokeWidth: a, stroke: i })) { this.judgeStyleAttributes({ opacity: n, strokeWidth: a, stroke: i }); var x = this.layer.getEncodedData(), b = this.calDataFrame(this.cellLength, x, this.cellProperties), w = b.data, S = b.width, E = b.height; this.rowCount = E, this.dataTexture = this.cellLength > 0 && w.length > 0 ? this.createTexture2D({ flipY: !0, data: w, format: id.LUMINANCE, type: id.FLOAT, width: S, height: E }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_raisingHeight: Number(v), u_opacity: DE(n) ? n : 1, u_stroke_width: DE(a) ? a : 0, u_stroke_color: this.getStrokeColor(i), u_sdf_map: this.texture, u_halo_blur: h, u_gamma_scale: d, u_sdf_map_size: [g.width, g.height] } } }, { key: "initModels", value: function () { this.layer.on("remapping", this.buildModels), this.extent = this.textExtent(); var t = this.layer.getLayerConfig(), e = t.textAnchor, n = void 0 === e ? "center" : e, r = t.textAllowOverlap, i = void 0 === r || r; return this.preTextStyle = { textAnchor: n, textAllowOverlap: i }, this.buildModels() } }, { key: "needUpdate", value: function () { var t = this.layer.getLayerConfig().textAllowOverlap, e = void 0 !== t && t, n = this.mapService.getZoom(), r = this.mapService.getBounds(), i = Fo(this.extent, r); return (!e && (Math.abs(this.currentZoom - n) > 1 || !i) || e !== this.preTextStyle.textAllowOverlap) && (this.reBuildModel(), !0) } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy(), this.layer.off("remapping", this.buildModels) } }, { key: "registerBuiltinAttributes", value: function () { this.styleAttributeService.registerStyleAttribute({ name: "rotate", type: bx.Attribute, descriptor: { name: "a_Rotate", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.rotate, o = void 0 === i ? 0 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "textOffsets", type: bx.Attribute, descriptor: { name: "a_textOffsets", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { return [n[5], n[6]] } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 12 : i; return Array.isArray(o) ? [o[0]] : [o] } } }), this.styleAttributeService.registerStyleAttribute({ name: "textUv", type: bx.Attribute, descriptor: { name: "a_tex", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, e, n, r) { return [n[3], n[4]] } } }) } }, { key: "textExtent", value: function () { return zo(this.mapService.getBounds(), .5) } }, { key: "initTextFont", value: function () { var t = this.layer.getLayerConfig(), e = t.fontWeight, n = void 0 === e ? "400" : e, r = t.fontFamily, i = void 0 === r ? "sans-serif" : r, o = this.layer.getEncodedData(), a = []; o.forEach((function (t) { var e, n = t.shape, r = void 0 === n ? "" : n, i = VO(r = r.toString()); try { for (i.s(); !(e = i.n()).done;) { var o = e.value; -1 === a.indexOf(o) && a.push(o) } } catch (t) { i.e(t) } finally { i.f() } })), this.fontService.setFontOptions({ characterSet: a, fontWeight: n, fontFamily: i, iconfont: !1 }) } }, { key: "initIconFontTex", value: function () { var t = this.layer.getLayerConfig(), e = t.fontWeight, n = void 0 === e ? "400" : e, r = t.fontFamily, i = void 0 === r ? "sans-serif" : r, o = this.layer.getEncodedData(), a = []; o.forEach((function (t) { var e = t.shape, n = void 0 === e ? "" : e; n = "".concat(n), -1 === a.indexOf(n) && a.push(n) })), this.fontService.setFontOptions({ characterSet: a, fontWeight: n, fontFamily: i, iconfont: !0 }) } }, { key: "generateGlyphLayout", value: function (t) { var e = this, n = this.fontService.mapping, r = this.layer.getLayerConfig(), i = r.spacing, o = void 0 === i ? 2 : i, a = r.textAnchor, s = void 0 === a ? "center" : a, l = this.layer.getEncodedData(); this.glyphInfo = l.map((function (r) { var i = r.shape, a = void 0 === i ? "" : i, l = r.id, u = r.size, c = void 0 === u ? 1 : u, p = r.textOffset, h = void 0 === p ? [0, 0] : p, f = function (t, e, n, r, i, o) { var a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : [0, 0], s = arguments.length > 7 ? arguments[7] : void 0, l = t.split("\n"), u = [], c = { positionedGlyphs: u, top: a[1], bottom: a[1], left: a[0], right: a[0], lineCount: l.length, text: t }; return s ? UO(c, e, l, n, r, i, o) : jO(c, e, l, n, r, i, o), !!u.length && c }(a.toString(), n, c, s, "left", o, h, t), d = function (t) { var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0], r = arguments.length > 2 ? arguments[2] : void 0, i = t.positionedGlyphs, o = [], a = DO(void 0 === i ? [] : i); try { for (a.s(); !(e = a.n()).done;) { var s = e.value, l = s.metrics, u = 4, c = l.advance * s.scale / 2, p = r ? [s.x + c, s.y] : [0, 0], h = r ? [0, 0] : [s.x + c + n[0], s.y + n[1]], f = (0 - u) * s.scale - c + h[0], d = (0 - u) * s.scale + h[1], m = f + l.width * s.scale, v = d + l.height * s.scale, y = { x: f, y: d }, g = { x: m, y: d }, _ = { x: f, y: v }, x = { x: m, y: v }; o.push({ tl: y, tr: g, bl: _, br: x, tex: l, glyphOffset: p }) } } catch (t) { a.e(t) } finally { a.f() } return o }(f, h, !1); return r.shaping = f, r.glyphQuads = d, r.centroid = kT(r.coordinates), r.originCentroid = "GAODE2.x" === r.version ? kT(r.originCoordinates) : r.originCentroid = r.centroid, e.glyphInfoMap[l] = { shaping: f, glyphQuads: d, centroid: kT(r.coordinates) }, r })) } }, { key: "filterGlyphs", value: function () { var t = this, e = this.layer.getLayerConfig(), n = e.padding, r = void 0 === n ? [4, 4] : n, i = e.textAllowOverlap; if (!(void 0 !== i && i)) { this.glyphInfoMap = {}, this.currentZoom = this.mapService.getZoom(), this.extent = this.textExtent(); var o = this.rendererService.getViewportSize(), a = o.width, s = o.height, l = new RO(a, s), u = this.glyphInfo.filter((function (e) { var n = e.shaping, i = e.id, o = void 0 === i ? 0 : i, a = "GAODE2.x" === e.version ? e.originCentroid : e.centroid, s = e.size / 24, u = t.mapService.lngLatToContainer(a), c = l.placeCollisionBox({ x1: n.left * s - r[0], x2: n.right * s + r[0], y1: n.top * s - r[1], y2: n.bottom * s + r[1], anchorPointX: u.x, anchorPointY: u.y }).box; return !(!c || !c.length) && (l.insertCollisionBox(c, o), !0) })); u.forEach((function (e) { t.glyphInfoMap[e.id] = e })) } } }, { key: "initGlyph", value: function () { var t = this.layer.getLayerConfig().iconfont, e = void 0 !== t && t; e ? this.initIconFontTex() : this.initTextFont(), this.generateGlyphLayout(e) } }, { key: "updateTexture", value: function () { var t = this.rendererService.createTexture2D, e = this.fontService.canvas; this.textureHeight = e.height, this.texture && this.texture.destroy(), this.texture = t({ data: e, mag: id.LINEAR, min: id.LINEAR, width: e.width, height: e.height }) } }, { key: "reBuildModel", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; this.filterGlyphs(), this.layer.models = [this.layer.buildLayerModel({ moduleName: "pointText", vertexShader: XO, fragmentShader: WO, triangulation: qO.bind(this), depth: { enable: !1 }, blend: this.getBlend(), stencil: Ca(n, i) })] } }]), n }(UC), YO = { fillImage: yO, fill: mO, radar: TO, image: bO, normal: EO, simplePoint: OO, extrude: pO, text: ZO, icon: _O }; function KO(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return QO(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return QO(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function QO(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function JO(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var $O = function (t) { Ur(n, t); var e = JO(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "type", "PointLayer"), t } return Or(n, [{ key: "buildModels", value: function () { var t = this.getModelType(); this.layerModel = new YO[t](this), this.models = this.layerModel.initModels() } }, { key: "rebuildModels", value: function () { this.models = this.layerModel.buildModels() } }, { key: "getModelTypeWillEmptyData", value: function () { if (this.shapeOption) { var t = this.shapeOption, e = t.field, n = t.values, r = this.getLayerConfig(), i = r.shape2d; r.shape3d; var o = this.iconService.getIconMap(); if (e && -1 !== (null == i ? void 0 : i.indexOf(e))) return "fill"; if (n && n instanceof Array) { var a, s = KO(n); try { for (s.s(); !(a = s.n()).done;) { var l = a.value; if ("string" == typeof l && o.hasOwnProperty(l)) return "image" } } catch (t) { s.e(t) } finally { s.f() } } } return "normal" } }, { key: "getConfigSchema", value: function () { return { properties: { opacity: { type: "number", minimum: 0, maximum: 1 } } } } }, { key: "getDefaultConfig", value: function () { return { fillImage: {}, normal: { blend: "additive" }, radar: {}, simplePoint: {}, fill: { blend: "normal" }, extrude: {}, image: {}, icon: {}, text: { blend: "normal" } }[this.getModelType()] } }, { key: "getModelType", value: function () { if (this.layerType && ["fillImage", "fill", "radar", "image", "normal", "simplePoint", "extrude", "text", "icon"].includes(this.layerType)) return this.layerType; var t = this.getEncodedData(), e = this.getLayerConfig(), n = e.shape2d, r = e.shape3d, i = this.iconService.getIconMap(), o = t.find((function (t) { return t.hasOwnProperty("shape") })); if (o) { var a = o.shape; return "dot" === a ? "normal" : "simple" === a ? "simplePoint" : "radar" === a ? "radar" : "fillImage" === a ? "fillImage" : -1 !== (null == n ? void 0 : n.indexOf(a)) ? "fill" : -1 !== (null == r ? void 0 : r.indexOf(a)) ? "extrude" : i.hasOwnProperty(a) ? "image" : "" !== this.fontService.getGlyph(a) ? "icon" : "text" } return this.getModelTypeWillEmptyData() } }]), n }(tC); function tk(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ek = function (t) { Ur(n, t); var e = tk(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.heightfixed, i = void 0 !== r && r, o = t.raisingHeight, a = void 0 === o ? 0 : o, s = t.sourceColor, l = t.targetColor; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n })) { this.judgeStyleAttributes({ opacity: n }); var u = this.layer.getEncodedData(), c = this.calDataFrame(this.cellLength, u, this.cellProperties), p = c.data, h = c.width, f = c.height; this.rowCount = f, this.dataTexture = this.cellLength > 0 && p.length > 0 ? this.createTexture2D({ flipY: !0, data: p, format: id.LUMINANCE, type: id.FLOAT, width: h, height: f }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } var d = [1, 1, 1, 1], m = [1, 1, 1, 1]; return s && l && (d = xa(s), m = xa(l)), { u_heightfixed: Number(i), u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_raisingHeight: Number(a), u_opacity: DE(n) ? n : 1, u_sourceColor: d, u_targetColor: m, u_texture: this.texture } } }, { key: "initModels", value: function () { return this.loadTexture(), this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r, o = this.getShaders(), a = o.frag, s = o.vert, l = o.type; return [this.layer.buildLayerModel({ moduleName: l, vertexShader: s, fragmentShader: a, triangulation: $T, stencil: Ca(n, i), cull: { enable: !0, face: id.BACK } })] } }, { key: "getShaders", value: function () { var t = this.layer.getLayerConfig(), e = t.pickLight; return t.mapTexture ? { frag: 'uniform sampler2D u_texture;\nuniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n// varying vec4 v_Color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float isSide = styleMappingMat[0][3];\n  \n  float topU = styleMappingMat[2][2];\n  float topV = styleMappingMat[2][3];\n\n  float sidey = styleMappingMat[3][0];\n  if(isSide < 1.0) {\n    gl_FragColor = mix(u_targetColor, u_sourceColor, sidey);\n  } else {\n    gl_FragColor = texture2D(u_texture, vec2(topU, topV));\n  }\n\n  // gl_FragColor = v_Color;\n  \n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: 'precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\n// varying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // 默认不固定\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - a_Position.z(judge side by a_Position.z)\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1] - u - v\n    0.0, 0.0, 0.0, 0.0  // sidey\n  );\n  \n  styleMappingMat[0][3] = a_Position.z;\n  styleMappingMat[2][2] = a_uvs[0];\n  styleMappingMat[2][3] = 1.0 - a_uvs[1];\n  styleMappingMat[3][0] = a_uvs[2];\n\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // project_pos.z += 500000.0; // amap1\n\n  // project_pos.z += (500000.0 * 4.0)/pow(2.0, 21.0 - u_Zoom); // mapbox\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  // float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  // v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n', type: "polygonExtrudeTexture" } : e ? { frag: 'uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n#pragma include "picking"\nvarying float v_lightWeight;\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  // gl_FragColor.a *= u_opacity;\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColorWithLight(gl_FragColor, v_lightWeight);\n}\n', vert: 'precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // 默认不固定\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvarying float v_lightWeight;\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  v_lightWeight = lightWeight;\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n', type: "polygonExtrude" } : { frag: 'uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  // gl_FragColor.a *= u_opacity;\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', vert: 'precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // 默认不固定\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // project_pos.z += 500000.0; // amap1\n\n  // project_pos.z += (500000.0 * 4.0)/pow(2.0, 21.0 - u_Zoom); // mapbox\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n', type: "polygonExtrude" } } }, { key: "clearModels", value: function () { var t, e; null === (t = this.dataTexture) || void 0 === t || t.destroy(), null === (e = this.texture) || void 0 === e || e.destroy() } }, { key: "registerBuiltinAttributes", value: function () { if (this.layer.getLayerConfig().mapTexture) { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = r - e, a = i - n; this.styleAttributeService.registerStyleAttribute({ name: "uvs", type: bx.Attribute, descriptor: { name: "a_uvs", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, r, i, s, l) { var u = i[0], c = i[1]; return [(u - e) / o, (c - n) / a, i[4]] } } }) } this.styleAttributeService.registerStyleAttribute({ name: "normal", type: bx.Attribute, descriptor: { name: "a_Normal", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return i } } }), this.styleAttributeService.registerStyleAttribute({ name: "size", type: bx.Attribute, descriptor: { name: "a_Size", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { var i = t.size, o = void 0 === i ? 10 : i; return Array.isArray(o) ? [o[0]] : [o] } } }) } }, { key: "loadTexture", value: function () { var t = this, e = this.layer.getLayerConfig().mapTexture, n = this.rendererService.createTexture2D; if (this.texture = n({ height: 0, width: 0 }), e) { var r = new Image; r.crossOrigin = "", r.src = e, r.onload = function () { t.texture = n({ data: r, width: r.width, height: r.height, wrapS: id.CLAMP_TO_EDGE, wrapT: id.CLAMP_TO_EDGE, min: id.LINEAR, mag: id.LINEAR }), t.layerService.updateLayerRenderList(), t.layerService.renderLayers() } } } }]), n }(UC); function nk(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var rk = function (t) { Ur(n, t); var e = nk(n); function n() { return Ar(this, n), e.apply(this, arguments) } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.opacityLinear, i = void 0 === r ? { enable: !1, dir: "in" } : r; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n })) { this.judgeStyleAttributes({ opacity: n }); var o = this.layer.getEncodedData(), a = this.calDataFrame(this.cellLength, o, this.cellProperties), s = a.data, l = a.width, u = a.height; this.rowCount = u, this.dataTexture = this.cellLength > 0 && s.length > 0 ? this.createTexture2D({ flipY: !0, data: s, format: id.LUMINANCE, type: id.FLOAT, width: l, height: u }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1, u_opacitylinear: Number(i.enable), u_dir: "in" === i.dir ? 1 : 0 } } }, { key: "initModels", value: function () { return this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.opacityLinear, n = void 0 === e ? { enable: !1, dir: "in" } : e, r = t.mask, i = void 0 !== r && r, o = t.maskInside, a = void 0 === o || o; return [this.layer.buildLayerModel({ moduleName: "polygon", vertexShader: n.enable ? 'attribute vec4 a_Color;\nattribute vec3 a_Position;\n\n\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nuniform float u_opacitylinear: 0.0;\n\nattribute vec3 a_linear;\nvarying vec3 v_linear;\nvarying vec2 v_pos;\n\nvoid main() {\n  if(u_opacitylinear > 0.0) {\n    v_linear = a_linear;\n    v_pos = a_Position.xy;\n  }\n  \n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}' : 'attribute vec4 a_Color;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n\n', fragmentShader: n.enable ? 'uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\nuniform float u_opacitylinear: 0.0;\nuniform float u_dir: 1.0;\nvarying vec3 v_linear;\nvarying vec2 v_pos;\n\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  \n  if(u_opacitylinear > 0.0) {\n    gl_FragColor.a *= u_dir == 1.0 ? 1.0 - length(v_pos - v_linear.xy)/v_linear.z : length(v_pos - v_linear.xy)/v_linear.z;\n  }\n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n' : 'uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n', triangulation: n.enable ? QT : KT, blend: this.getBlend(), depth: { enable: !1 }, cull: { enable: !0, face: id.BACK }, stencil: Ca(i, a) })] } }, { key: "clearModels", value: function () { var t; null === (t = this.dataTexture) || void 0 === t || t.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = this.layer.getLayerConfig().opacityLinear; (void 0 === t ? { enable: !1, dir: "in" } : t).enable && this.styleAttributeService.registerStyleAttribute({ name: "linear", type: bx.Attribute, descriptor: { name: "a_linear", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 3, update: function (t, e, n, r, i) { return [n[3], n[4], n[5]] } } }) } }]), n }(UC); function ik(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ok = function (t) { Ur(n, t); var e = ik(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture1", void 0), kr(Gr(t), "texture2", void 0), kr(Gr(t), "texture3", void 0), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.watercolor, i = void 0 === r ? "#6D99A8" : r, o = t.watercolor2, a = void 0 === o ? "#0F121C" : o; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n })) { this.judgeStyleAttributes({ opacity: n }); var s = this.layer.getEncodedData(), l = this.calDataFrame(this.cellLength, s, this.cellProperties), u = l.data, c = l.width, p = l.height; this.rowCount = p, this.dataTexture = this.cellLength > 0 && u.length > 0 ? this.createTexture2D({ flipY: !0, data: u, format: id.LUMINANCE, type: id.FLOAT, width: c, height: p }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_texture1: this.texture1, u_texture2: this.texture2, u_texture3: this.texture3, u_watercolor: xa(i), u_watercolor2: xa(a), u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_opacity: DE(n) ? n : 1 } } }, { key: "getAnimateUniforms", value: function () { return { u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.loadTexture(), this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "polygon_ocean", vertexShader: 'attribute vec4 a_Color;\nattribute vec2 a_uv;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  v_uv = a_uv;\n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n\n', fragmentShader: "\nuniform float u_time;\nuniform float u_opacity: 1.0;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include \"picking\"\n\nfloat coast2water_fadedepth = 0.10;\nfloat large_waveheight      = .750; // change to adjust the \"heavy\" waves\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\nfloat water_glossylight_fact= 120.; // range [1..200]\nfloat particle_amount       = 70.;\n// vec3 watercolor             = vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\n// vec3 watercolor2            = vec3(0.06, 0.07, 0.11); // deep-water color (RGB, should be darker than the low-water color)\nuniform vec4 u_watercolor;\nuniform vec4 u_watercolor2;\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\n\nuniform sampler2D u_texture1;\nuniform sampler2D u_texture2;\nuniform sampler2D u_texture3;\n\n  \n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\n// 2d noise function\nfloat noise1( in vec2 x ) {\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise(vec2 p) {\n    return texture2D(u_texture2,p*vec2(1./256.)).x;\n}\n\nvec4 highness(vec2 p) {\n    vec4 t = texture2D(u_texture1,fract(p));\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\n}\n\nfloat height_map( vec2 p ) {\n    vec4 height=highness(p);\n    /*\n    height = -0.5+\n        0.5*smoothstep(-100.,0.,-height)+\n        2.75*smoothstep(0.,2.,height)+\n        1.75*smoothstep(2.,4.,height)+\n        2.75*smoothstep(4.,16.,height)+\n        1.5*smoothstep(16.,1000.,height);\n    */\n\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n    //p = p*6.;\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\n    f += 0.2500*noise( p ); p = m*p*1.32;\n    f += 0.1666*noise( p ); p = m*p*1.11;\n    f += 0.0834*noise( p ); p = m*p*1.12;\n    f += 0.0634*noise( p ); p = m*p*1.13;\n    f += 0.0444*noise( p ); p = m*p*1.14;\n    f += 0.0274*noise( p ); p = m*p*1.15;\n    f += 0.0134*noise( p ); p = m*p*1.16;\n    f += 0.0104*noise( p ); p = m*p*1.17;\n    f += 0.0084*noise( p );\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\n        const float FLAT_LEVEL = 0.92525;\n        //f = f*0.25+height*0.75;\n    if (f<FLAT_LEVEL)\n        f = f;\n    else\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\n    return clamp(f, 0., 10.);\n}\n\nvec3 plasma_quintic( float x ) {\n    x = clamp( x, 0.0, 1.0);\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n    return vec3(\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\nvec4 color(vec2 p){\n    vec4 c1 = vec4(1.7,1.6,.9,1);\n    vec4 c2 = vec4(.2,.94,.1,1);\n    vec4 c3 = vec4(.3,.2,.0,1);\n    vec4 c4 = vec4(.99,.99,1.6,1);\n    vec4 v = highness(p);\n    float los = smoothstep(0.1,1.1,v.b);\n    float his = smoothstep(3.5,6.5,v.b);\n    float ces = smoothstep(1.,5.,v.a);\n    vec4 lo = mix(c1,c2,los);\n    vec4 hi = mix(c3,c4,his);\n    vec4 ce = mix(lo,hi,ces);\n\n    return vec4(plasma_quintic(ces),1).ragb;\n}\n\nvec3 terrain_map( vec2 p )\n{\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture2D(u_texture3, fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height ) {\n    vec2 p2 = p*large_wavesize;\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\n\n    // coarse crossing 'ocean' waves...\n    float f = 0.6000*noise( p );\n    f += 0.2500*noise( p*m );\n    f += 0.1666*noise( p*m*m );\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\n\n    p *= small_wavesize;\n    f = 0.;\n    float amp = 1.0, s = .5;\n    for (int i=0; i<9; i++)\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\n    \n    return wave+f*small_waveheight;\n}\n\nfloat nautic(vec2 p) {\n    p *= 18.;\n    float f = 0.;\n    float amp = 1.0, s = .5;\n    for (int i=0; i<3; i++)\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\n    return pow(1.-f, 5.);\n}\n\nfloat particles(vec2 p) {\n    p *= 200.;\n    float f = 0.;\n    float amp = 1.0, s = 1.5;\n    for (int i=0; i<3; i++)\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\n    return pow(f*.35, 7.)*particle_amount;\n}\n\nfloat test_shadow( vec2 xy, float height) {\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n    for (int j=1; j<25; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n    return hit;\n}\n\nvec3 CalcTerrain(vec2 uv, float height) {\n    vec3 col = terrain_map( uv );\n    vec2 iResolution = vec2(512.);\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\n    vec3 r0 = vec3(uv, height);\n    vec3 rd = normalize( light - r0 );\n    float grad = dot(norm, rd);\n    col *= grad+pow(grad, 8.);\n    float terrainshade = test_shadow( uv, height );\n    col = mix(col*.25, col, terrainshade);\n    return col;\n}\n\n\nvoid main() {\n  vec3 watercolor = u_watercolor.rgb;\n  vec3 watercolor2 = u_watercolor2.rgb;\n  vec2 uv = v_uv;\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\n  float height = height_map( uv );\n  vec3 col;\n\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\n    if (height > level)\n    {\n        col = CalcTerrain(uv, height);\n    }\n    if (height <= level)\n    {\n        vec2 dif = vec2(.0, .01);\n        vec2 pos = uv*15. + vec2(u_time*.01);\n        float h1 = water_map(pos-dif,waveheight);\n        float h2 = water_map(pos+dif,waveheight);\n        float h3 = water_map(pos-dif.yx,waveheight);\n        float h4 = water_map(pos+dif.yx,waveheight);\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n        uv += normwater.xy*.002*(level-height);\n        \n        col = CalcTerrain(uv, height);\n\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n        vec3 r0 = vec3(uv, WATER_LEVEL);\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n        float watershade  = test_shadow( uv, level );\n        watercolor *= 2.2+watershade;\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\n        watercolor /= (1.+specular1*1.25);\n        watercolor += watershade*specular2*water_specularcolor;\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\n        \n        col = mix(col, watercolor, coastfade);\n    }\n    \n\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = vec4(col, opacity);\n\n  // gl_FragColor = v_Color;\n  \n}\n", triangulation: KT, depth: { enable: !1 }, stencil: Ca(n, i) })] } }, { key: "clearModels", value: function () { var t, e, n, r; null === (t = this.texture1) || void 0 === t || t.destroy(), null === (e = this.texture2) || void 0 === e || e.destroy(), null === (n = this.texture3) || void 0 === n || n.destroy(), null === (r = this.dataTexture) || void 0 === r || r.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = r - e, a = i - n; this.styleAttributeService.registerStyleAttribute({ name: "oceanUv", type: bx.Attribute, descriptor: { name: "a_uv", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, r, i, s, l) { var u = Lr(i, 2), c = u[0], p = u[1]; return [(c - e) / o, (p - n) / a] } } }) } }, { key: "loadTexture", value: function () { var t, e, n, r = this, i = this.rendererService.createTexture2D, o = { height: 0, width: 0 }; function a(t) { return i({ data: t, width: t.width, height: t.height, wrapS: id.MIRRORED_REPEAT, wrapT: id.MIRRORED_REPEAT, min: id.LINEAR, mag: id.LINEAR }) } this.texture1 = i(o), this.texture2 = i(o), this.texture3 = i(o), t = function (t) { r.texture1 = a(t[0]), r.texture2 = a(t[1]), r.texture3 = a(t[2]), r.layerService.updateLayerRenderList(), r.layerService.renderLayers() }, e = 0, n = [], ["https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ", "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ", "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ"].map((function (r) { var i = new Image; i.crossOrigin = "", i.src = r, n.push(i), i.onload = function () { 3 == ++e && t(n) } })) } }]), n }(UC); function ak(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var sk = function (t) { Ur(n, t); var e = ak(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "texture", void 0), t } return Or(n, [{ key: "getUninforms", value: function () { var t = this.layer.getLayerConfig(), e = t.opacity, n = void 0 === e ? 1 : e, r = t.speed, i = void 0 === r ? .5 : r; if (this.dataTextureTest && this.dataTextureNeedUpdate({ opacity: n })) { this.judgeStyleAttributes({ opacity: n }); var o = this.layer.getEncodedData(), a = this.calDataFrame(this.cellLength, o, this.cellProperties), s = a.data, l = a.width, u = a.height; this.rowCount = u, this.dataTexture = this.cellLength > 0 && s.length > 0 ? this.createTexture2D({ flipY: !0, data: s, format: id.LUMINANCE, type: id.FLOAT, width: l, height: u }) : this.createTexture2D({ flipY: !0, data: [1], format: id.LUMINANCE, type: id.FLOAT, width: 1, height: 1 }) } return { u_texture: this.texture, u_dataTexture: this.dataTexture, u_cellTypeLayout: this.getCellTypeLayout(), u_speed: i, u_opacity: DE(n) ? n : 1 } } }, { key: "getAnimateUniforms", value: function () { return { u_time: this.layer.getLayerAnimateTime() } } }, { key: "initModels", value: function () { return this.loadTexture(), this.buildModels() } }, { key: "buildModels", value: function () { var t = this.layer.getLayerConfig(), e = t.mask, n = void 0 !== e && e, r = t.maskInside, i = void 0 === r || r; return [this.layer.buildLayerModel({ moduleName: "polygon_water", vertexShader: 'attribute vec4 a_Color;\nattribute vec2 a_uv;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // 用于将在顶点着色器中计算好的样式值传递给片元\n\n#pragma include "styleMapping"\n#pragma include "styleMappingCalOpacity"\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  v_uv = a_uv;\n  // cal style mapping - 数据纹理映射部分的计算\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // 当前的数据纹理有几行\n  float columnCount = u_cellTypeLayout[0][1]; // 当看到数据纹理有几列\n  float columnWidth = 1.0/columnCount;  // 列宽\n  float rowHeight = 1.0/rowCount;       // 行高\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // 第n个顶点\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // 起始点在第几行\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // 起始点在第几列\n  \n  // cell 固定顺序 opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // 按顺序从 cell 中取值、若没有则自动往下取值\n  float textureOffset = 0.0; // 在 cell 中取值的偏移量\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n\n', fragmentShader: '\nuniform sampler2D u_texture;\nuniform float u_time;\nuniform float u_speed: 1.0;\nuniform float u_opacity: 1.0;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nvarying mat4 styleMappingMat; // 传递从片元中传递的映射数据\n\n#pragma include "picking"\n\n  float rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\n  float water(vec3 p) {\n    float t = u_time * u_speed;\n    p.z += t * 2.; p.x += t * 2.;\n    vec3 c1 = texture2D(u_texture, p.xz / 30.).xyz;\n    p.z += t * 3.; p.x += t * 0.52;\n    vec3 c2 = texture2D(u_texture, p.xz / 30.).xyz;\n    p.z += t * 4.; p.x += t * 0.8;\n    vec3 c3 = texture2D(u_texture, p.xz / 30.).xyz;\n    c1 += c2 - c3;\n    float z = (c1.x + c1.y + c1.z) / 3.;\n    return p.y + z / 4.;\n  }\n\n  float map(vec3 p) {\n    float d = 100.0;\n    d = water(p);\n    return d;\n  }\n\n  float intersect(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i <= 100; i++) {\n      float h = map(ro + rd * d);\n      if (h < 0.1) return  d;\n      d += h;\n    }\n    return 0.0;\n  }\n  \n  vec3 norm(vec3 p) {\n    float eps = .1;\n    return normalize(vec3(\n      map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n      map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n      map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n    ));\n  } \n\n  float calSpc() {\n    vec3 l1 = normalize(vec3(1, 1, 1));\n    vec3 ro = vec3(-3, 20, -8);\n    vec3 rc = vec3(0, 0, 0);\n    vec3 ww = normalize(rc - ro);\n    vec3 uu = normalize(cross(vec3(0,1,0), ww));\n    vec3 vv = normalize(cross(rc - ro, uu));\n    vec3 rd = normalize(uu * v_uv.x + vv * v_uv.y + ww);\n    float d = intersect(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = norm(p);\n    float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n    return spc;\n  }\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n\n  float spc = calSpc();\n  gl_FragColor += spc * 0.4;\n}\n', triangulation: KT, depth: { enable: !1 }, stencil: Ca(n, i) })] } }, { key: "clearModels", value: function () { var t, e; null === (t = this.texture) || void 0 === t || t.destroy(), null === (e = this.dataTexture) || void 0 === e || e.destroy() } }, { key: "registerBuiltinAttributes", value: function () { var t = Lr(this.layer.getSource().extent, 4), e = t[0], n = t[1], r = t[2], i = t[3], o = r - e, a = i - n; this.styleAttributeService.registerStyleAttribute({ name: "waterUv", type: bx.Attribute, descriptor: { name: "a_uv", buffer: { usage: id.STATIC_DRAW, data: [], type: id.FLOAT }, size: 2, update: function (t, r, i, s, l) { var u = Lr(i, 2), c = u[0], p = u[1]; return [(c - e) / o, (p - n) / a] } } }) } }, { key: "loadTexture", value: function () { var t = this, e = this.layer.getLayerConfig().waterTexture, n = this.rendererService.createTexture2D; this.texture = n({ height: 0, width: 0 }); var r = new Image; r.crossOrigin = "", e ? (console.warn("L7 recommend：https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ"), r.src = e) : r.src = "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ", r.onload = function () { t.texture = n({ data: r, width: r.width, height: r.height, wrapS: id.MIRRORED_REPEAT, wrapT: id.MIRRORED_REPEAT, min: id.LINEAR, mag: id.LINEAR }), t.layerService.updateLayerRenderList(), t.layerService.renderLayers() } } }]), n }(UC), lk = { fill: rk, line: eO, extrude: ek, text: ZO, point_fill: mO, point_image: bO, point_normal: EO, point_extrude: pO, water: sk, ocean: ok }; function uk(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var n, r = Wr(t); if (e) { var i = Wr(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return Hr(this, n) } } var ck, pk, hk, fk, dk, mk, vk, yk, gk, _k = function (t) { Ur(n, t); var e = uk(n); function n() { var t; Ar(this, n); for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return kr(Gr(t = e.call.apply(e, [this].concat(i))), "type", "PolygonLayer"), t } return Or(n, [{ key: "buildModels", value: function () { var t = this.getModelType(); this.layerModel = new lk[t](this), this.models = this.layerModel.initModels() } }, { key: "rebuildModels", value: function () { this.models = this.layerModel.buildModels() } }, { key: "getConfigSchema", value: function () { return { properties: { opacity: { type: "number", minimum: 0, maximum: 1 } } } } }, { key: "getModelType", value: function () { var t, e = this.styleAttributeService.getLayerStyleAttribute("shape"), n = null == e || null === (t = e.scale) || void 0 === t ? void 0 : t.field; return "fill" === n ? "fill" : "extrude" === n ? "extrude" : "water" === n ? "water" : "ocean" === n ? "ocean" : "line" === n ? "line" : this.getPointModelType() } }, { key: "getPointModelType", value: function () { var t = this.getEncodedData(), e = this.getLayerConfig(), n = e.shape2d, r = e.shape3d, i = this.iconService.getIconMap(), o = t.find((function (t) { return t.hasOwnProperty("shape") })); if (o) { var a = o.shape; return "dot" === a ? "point_normal" : -1 !== (null == n ? void 0 : n.indexOf(a)) ? "point_fill" : -1 !== (null == r ? void 0 : r.indexOf(a)) ? "point_extrude" : i.hasOwnProperty(a) ? "point_image" : "text" } return "fill" } }]), n }(tC); function xk(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } var bk, wk = (ck = ut.injectable(), pk = ut.inject(Tr.IGlobalConfigService), hk = ut.inject(Tr.IMapService), fk = ut.inject(Tr.IFontService), ck((mk = function () { function t() { Ar(this, t), Ef(this, "configService", vk, this), Ef(this, "mapService", yk, this), Ef(this, "fontService", gk, this) } return Or(t, [{ key: "apply", value: function (t, e) { var n = this, r = e.styleAttributeService; t.hooks.init.tap("DataMappingPlugin", (function () { n.generateMaping(t, { styleAttributeService: r }) })), t.hooks.beforeRenderData.tap("DataMappingPlugin", (function () { return t.dataState.dataMappingNeedUpdate = !1, n.generateMaping(t, { styleAttributeService: r }), !0 })), t.hooks.beforeRender.tap("DataMappingPlugin", (function () { if (!t.layerModelNeedUpdate) { var e = t.getBottomColor(), i = r.getLayerStyleAttributes() || [], o = r.getLayerStyleAttribute("filter"), a = t.getSource().data.dataArray, s = i.filter((function (t) { return t.needRemapping })), l = a; null != o && o.needRemapping && null != o && o.scale && (l = a.filter((function (t) { return n.applyAttributeMapping(o, t, e)[0] }))), s.length && (null != o && o.needRemapping ? (t.setEncodedData(n.mapping(i, l, void 0, e, t)), o.needRemapping = !1) : t.setEncodedData(n.mapping(s, l, t.getEncodedData(), e, t)), t.emit("remapping", null)) } })) } }, { key: "generateMaping", value: function (t, e) { var n = this, r = e.styleAttributeService, i = t.getBottomColor(), o = r.getLayerStyleAttributes() || [], a = r.getLayerStyleAttribute("filter"), s = t.getSource().data.dataArray, l = s; null != a && a.scale && (l = s.filter((function (t) { return n.applyAttributeMapping(a, t, i)[0] }))), t.setEncodedData(this.mapping(o, l, void 0, i, t)), t.emit("dataUpdate", null) } }, { key: "getArrowPoints", value: function (t, e) { var n = Bo([e[0] - t[0], e[1] - t[1]]); return [t[0] + 1e-4 * n[0], t[1] + 1e-4 * n[1]] } }, { key: "mapping", value: function (t, e, n, r, i) { var o = this, a = (null == i ? void 0 : i.getLayerConfig()).arrow, s = void 0 === a ? { enable: !1 } : a, l = e.map((function (e, i) { var a = n ? n[i] : {}, l = function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? xk(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : xk(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ id: e._id, coordinates: e.coordinates }, a); if (t.filter((function (t) { return void 0 !== t.scale })).forEach((function (t) { var n = o.applyAttributeMapping(t, e, r); t.needRemapping = !1, "color" === t.name && (n = n.map((function (t) { return xa(t) }))), l[t.name] = Array.isArray(n) && 1 === n.length ? n[0] : n, "shape" === t.name && (l.shape = o.fontService.getIconFontKey(l[t.name])) })), "line" === l.shape && s.enable) { var u = l.coordinates, c = o.getArrowPoints(u[0], u[1]); l.coordinates.splice(1, 0, c, c) } return l })); return this.adjustData2Amap2Coordinates(l), this.adjustData2SimpleCoordinates(l), l } }, { key: "adjustData2Amap2Coordinates", value: function (t) { var e = this; t.length > 0 && this.mapService.version === lA["GAODE2.x"] && ("number" == typeof t[0].coordinates[0] ? t.filter((function (t) { return !t.originCoordinates })).map((function (t) { t.version = lA["GAODE2.x"], t.originCoordinates = sE(t.coordinates), t.coordinates = e.mapService.lngLatToCoord(t.coordinates) })) : t.filter((function (t) { return !t.originCoordinates })).map((function (t) { t.version = lA["GAODE2.x"], t.originCoordinates = sE(t.coordinates), t.coordinates = e.mapService.lngLatToCoords(t.coordinates) }))) } }, { key: "adjustData2SimpleCoordinates", value: function (t) { var e = this; t.length > 0 && this.mapService.version === lA.SIMPLE && t.map((function (t) { t.simpleCoordinate || (t.coordinates = e.unProjectCoordinates(t.coordinates), t.simpleCoordinate = !0) })) } }, { key: "unProjectCoordinates", value: function (t) { var e = this; if ("number" == typeof t[0]) return this.mapService.simpleMapCoord.unproject(t); if (t[0] && t[0][0] instanceof Array) { var n = []; return t.map((function (t) { var r = []; t.map((function (t) { r.push(e.mapService.simpleMapCoord.unproject(t)) })), n.push(r) })), n } var r = []; return t.map((function (t) { r.push(e.mapService.simpleMapCoord.unproject(t)) })), r } }, { key: "applyAttributeMapping", value: function (t, e, n) { var r; if (!t.scale) return []; var i = (null == t || null === (r = t.scale) || void 0 === r ? void 0 : r.scalers) || [], o = []; i.forEach((function (n) { var r, i = n.field; (e.hasOwnProperty(i) || "variable" === (null === (r = t.scale) || void 0 === r ? void 0 : r.type)) && o.push(e[i]) })); var a = t.mapping ? t.mapping(o) : []; return "color" !== t.name || function (t) { return "string" == typeof t && !!sa(t) }(a[0]) ? a : [n] } }]), t }(), vk = Cf(mk.prototype, "configService", [pk], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), yk = Cf(mk.prototype, "mapService", [hk], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), gk = Cf(mk.prototype, "fontService", [fk], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), dk = mk)) || dk), Sk = ut.injectable()(bk = function () { function t() { Ar(this, t), kr(this, "mapService", void 0) } return Or(t, [{ key: "apply", value: function (t) { var e = this; this.mapService = t.getContainer().get(Tr.IMapService), t.hooks.init.tap("DataSourcePlugin", (function () { if (!t.getSource()) { var n = t.sourceOption || { data: kE, options: IE }, r = n.data, i = n.options; t.setSource(new yE(r, i)) } e.updateClusterData(t) })), t.hooks.beforeRenderData.tap("DataSourcePlugin", (function () { var n = e.updateClusterData(t), r = t.dataState.dataSourceNeedUpdate; return t.dataState.dataSourceNeedUpdate = !1, n || r })) } }, { key: "updateClusterData", value: function (t) { var e = t.getSource(), n = e.cluster, r = e.clusterOptions, i = r.zoom, o = void 0 === i ? 0 : i; r.maxZoom; var a = this.mapService.getZoom() - 1, s = t.dataState.dataSourceNeedUpdate; return !(!n || !(s || Math.abs(t.clusterZoom - a) >= 1)) && (o !== Math.floor(a) && e.updateClusterData(Math.floor(a)), t.clusterZoom = a, !0) } }]), t }()) || bk; function Ek(t, e) { return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN } function Ck(t) { var e; return 1 === t.length && (e = t, t = function (t, n) { return Ek(e(t), n) }), { left: function (e, n, r, i) { for (null == r && (r = 0), null == i && (i = e.length); r < i;) { var o = r + i >>> 1; t(e[o], n) < 0 ? r = o + 1 : i = o } return r }, right: function (e, n, r, i) { for (null == r && (r = 0), null == i && (i = e.length); r < i;) { var o = r + i >>> 1; t(e[o], n) > 0 ? i = o : r = o + 1 } return r } } } var Tk = Ck(Ek).right; function Ak(t) { return null === t ? NaN : +t } var Mk = Math.sqrt(50), Ok = Math.sqrt(10), kk = Math.sqrt(2); function Ik(t, e, n) { var r, i, o, a, s = -1; if (n = +n, (t = +t) === (e = +e) && n > 0) return [t]; if ((r = e < t) && (i = t, t = e, e = i), 0 === (a = Pk(t, e, n)) || !isFinite(a)) return []; if (a > 0) for (t = Math.ceil(t / a), e = Math.floor(e / a), o = new Array(i = Math.ceil(e - t + 1)); ++s < i;)o[s] = (t + s) * a; else for (t = Math.floor(t * a), e = Math.ceil(e * a), o = new Array(i = Math.ceil(t - e + 1)); ++s < i;)o[s] = (t - s) / a; return r && o.reverse(), o } function Pk(t, e, n) { var r = (e - t) / Math.max(0, n), i = Math.floor(Math.log(r) / Math.LN10), o = r / Math.pow(10, i); return i >= 0 ? (o >= Mk ? 10 : o >= Ok ? 5 : o >= kk ? 2 : 1) * Math.pow(10, i) : -Math.pow(10, -i) / (o >= Mk ? 10 : o >= Ok ? 5 : o >= kk ? 2 : 1) } function Lk(t, e, n) { var r = Math.abs(e - t) / Math.max(0, n), i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)), o = r / i; return o >= Mk ? i *= 10 : o >= Ok ? i *= 5 : o >= kk && (i *= 2), e < t ? -i : i } function Rk(t, e, n) { if (null == n && (n = Ak), r = t.length) { if ((e = +e) <= 0 || r < 2) return +n(t[0], 0, t); if (e >= 1) return +n(t[r - 1], r - 1, t); var r, i = (r - 1) * e, o = Math.floor(i), a = +n(t[o], o, t); return a + (+n(t[o + 1], o + 1, t) - a) * (i - o) } } function Dk(t, e) { switch (arguments.length) { case 0: break; case 1: this.range(t); break; default: this.range(e).domain(t) }return this } var Nk = "$"; function zk() { } function Fk(t, e) { var n = new zk; if (t instanceof zk) t.each((function (t, e) { n.set(e, t) })); else if (Array.isArray(t)) { var r, i = -1, o = t.length; if (null == e) for (; ++i < o;)n.set(i, t[i]); else for (; ++i < o;)n.set(e(r = t[i], i, t), r) } else if (t) for (var a in t) n.set(a, t[a]); return n } function Bk() { } zk.prototype = Fk.prototype = { constructor: zk, has: function (t) { return Nk + t in this }, get: function (t) { return this[Nk + t] }, set: function (t, e) { return this[Nk + t] = e, this }, remove: function (t) { var e = Nk + t; return e in this && delete this[e] }, clear: function () { for (var t in this) t[0] === Nk && delete this[t] }, keys: function () { var t = []; for (var e in this) e[0] === Nk && t.push(e.slice(1)); return t }, values: function () { var t = []; for (var e in this) e[0] === Nk && t.push(this[e]); return t }, entries: function () { var t = []; for (var e in this) e[0] === Nk && t.push({ key: e.slice(1), value: this[e] }); return t }, size: function () { var t = 0; for (var e in this) e[0] === Nk && ++t; return t }, empty: function () { for (var t in this) if (t[0] === Nk) return !1; return !0 }, each: function (t) { for (var e in this) e[0] === Nk && t(this[e], e.slice(1), this) } }; var jk = Fk.prototype; Bk.prototype = { constructor: Bk, has: jk.has, add: function (t) { return this[Nk + (t += "")] = t, this }, remove: jk.remove, clear: jk.clear, values: jk.keys, size: jk.size, empty: jk.empty, each: jk.each }; var Uk = Array.prototype, Vk = Uk.map, Gk = Uk.slice, Hk = { name: "implicit" }; function Wk() { var t = Fk(), e = [], n = [], r = Hk; function i(i) { var o = i + "", a = t.get(o); if (!a) { if (r !== Hk) return r; t.set(o, a = e.push(i)) } return n[(a - 1) % n.length] } return i.domain = function (n) { if (!arguments.length) return e.slice(); e = [], t = Fk(); for (var r, o, a = -1, s = n.length; ++a < s;)t.has(o = (r = n[a]) + "") || t.set(o, e.push(r)); return i }, i.range = function (t) { return arguments.length ? (n = Gk.call(t), i) : n.slice() }, i.unknown = function (t) { return arguments.length ? (r = t, i) : r }, i.copy = function () { return Wk(e, n).unknown(r) }, Dk.apply(i, arguments), i } function Xk(t) { return function () { return t } } function qk(t) { return 1 == (t = +t) ? Zk : function (e, n) { return n - e ? function (t, e, n) { return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function (r) { return Math.pow(t + r * e, n) } }(e, n, t) : Xk(isNaN(e) ? n : e) } } function Zk(t, e) { var n = e - t; return n ? function (t, e) { return function (n) { return t + n * e } }(t, n) : Xk(isNaN(t) ? e : t) } var Yk = function t(e) { var n = qk(e); function r(t, e) { var r = n((t = pa(t)).r, (e = pa(e)).r), i = n(t.g, e.g), o = n(t.b, e.b), a = Zk(t.opacity, e.opacity); return function (e) { return t.r = r(e), t.g = i(e), t.b = o(e), t.opacity = a(e), t + "" } } return r.gamma = t, r }(1); function Kk(t, e) { e || (e = []); var n, r = t ? Math.min(e.length, t.length) : 0, i = e.slice(); return function (o) { for (n = 0; n < r; ++n)i[n] = t[n] * (1 - o) + e[n] * o; return i } } function Qk(t, e) { var n, r = e ? e.length : 0, i = t ? Math.min(r, t.length) : 0, o = new Array(i), a = new Array(r); for (n = 0; n < i; ++n)o[n] = iI(t[n], e[n]); for (; n < r; ++n)a[n] = e[n]; return function (t) { for (n = 0; n < i; ++n)a[n] = o[n](t); return a } } function Jk(t, e) { var n = new Date; return t = +t, e = +e, function (r) { return n.setTime(t * (1 - r) + e * r), n } } function $k(t, e) { return t = +t, e = +e, function (n) { return t * (1 - n) + e * n } } function tI(t, e) { var n, r = {}, i = {}; for (n in null !== t && "object" == typeof t || (t = {}), null !== e && "object" == typeof e || (e = {}), e) n in t ? r[n] = iI(t[n], e[n]) : i[n] = e[n]; return function (t) { for (n in r) i[n] = r[n](t); return i } } var eI = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, nI = new RegExp(eI.source, "g"); function rI(t, e) { var n, r, i, o = eI.lastIndex = nI.lastIndex = 0, a = -1, s = [], l = []; for (t += "", e += ""; (n = eI.exec(t)) && (r = nI.exec(e));)(i = r.index) > o && (i = e.slice(o, i), s[a] ? s[a] += i : s[++a] = i), (n = n[0]) === (r = r[0]) ? s[a] ? s[a] += r : s[++a] = r : (s[++a] = null, l.push({ i: a, x: $k(n, r) })), o = nI.lastIndex; return o < e.length && (i = e.slice(o), s[a] ? s[a] += i : s[++a] = i), s.length < 2 ? l[0] ? function (t) { return function (e) { return t(e) + "" } }(l[0].x) : function (t) { return function () { return t } }(e) : (e = l.length, function (t) { for (var n, r = 0; r < e; ++r)s[(n = l[r]).i] = n.x(t); return s.join("") }) } function iI(t, e) { var n, r, i = typeof e; return null == e || "boolean" === i ? Xk(e) : ("number" === i ? $k : "string" === i ? (n = sa(e)) ? (e = n, Yk) : rI : e instanceof sa ? Yk : e instanceof Date ? Jk : (r = e, !ArrayBuffer.isView(r) || r instanceof DataView ? Array.isArray(e) ? Qk : "function" != typeof e.valueOf && "function" != typeof e.toString || isNaN(e) ? tI : $k : Kk))(t, e) } function oI(t, e) { return t = +t, e = +e, function (n) { return Math.round(t * (1 - n) + e * n) } } function aI(t) { return +t } var sI = [0, 1]; function lI(t) { return t } function uI(t, e) { return (e -= t = +t) ? function (n) { return (n - t) / e } : (n = isNaN(e) ? NaN : .5, function () { return n }); var n } function cI(t) { var e, n = t[0], r = t[t.length - 1]; return n > r && (e = n, n = r, r = e), function (t) { return Math.max(n, Math.min(r, t)) } } function pI(t, e, n) { var r = t[0], i = t[1], o = e[0], a = e[1]; return i < r ? (r = uI(i, r), o = n(a, o)) : (r = uI(r, i), o = n(o, a)), function (t) { return o(r(t)) } } function hI(t, e, n) { var r = Math.min(t.length, e.length) - 1, i = new Array(r), o = new Array(r), a = -1; for (t[r] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++a < r;)i[a] = uI(t[a], t[a + 1]), o[a] = n(e[a], e[a + 1]); return function (e) { var n = Tk(t, e, 1, r) - 1; return o[n](i[n](e)) } } function fI(t, e) { return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown()) } function dI() { var t, e, n, r, i, o, a = sI, s = sI, l = iI, u = lI; function c() { return r = Math.min(a.length, s.length) > 2 ? hI : pI, i = o = null, p } function p(e) { return isNaN(e = +e) ? n : (i || (i = r(a.map(t), s, l)))(t(u(e))) } return p.invert = function (n) { return u(e((o || (o = r(s, a.map(t), $k)))(n))) }, p.domain = function (t) { return arguments.length ? (a = Vk.call(t, aI), u === lI || (u = cI(a)), c()) : a.slice() }, p.range = function (t) { return arguments.length ? (s = Gk.call(t), c()) : s.slice() }, p.rangeRound = function (t) { return s = Gk.call(t), l = oI, c() }, p.clamp = function (t) { return arguments.length ? (u = t ? cI(a) : lI, p) : u !== lI }, p.interpolate = function (t) { return arguments.length ? (l = t, c()) : l }, p.unknown = function (t) { return arguments.length ? (n = t, p) : n }, function (n, r) { return t = n, e = r, c() } } function mI(t, e) { return dI()(t, e) } function vI(t, e) { if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null; var n, r = t.slice(0, n); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(n + 1)] } function yI(t) { return (t = vI(Math.abs(t))) ? t[1] : NaN } var gI, _I = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i; function xI(t) { if (!(e = _I.exec(t))) throw new Error("invalid format: " + t); var e; return new bI({ fill: e[1], align: e[2], sign: e[3], symbol: e[4], zero: e[5], width: e[6], comma: e[7], precision: e[8] && e[8].slice(1), trim: e[9], type: e[10] }) } function bI(t) { this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + "" } function wI(t, e) { var n = vI(t, e); if (!n) return t + ""; var r = n[0], i = n[1]; return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0") } xI.prototype = bI.prototype, bI.prototype.toString = function () { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type }; var SI = { "%": function (t, e) { return (100 * t).toFixed(e) }, b: function (t) { return Math.round(t).toString(2) }, c: function (t) { return t + "" }, d: function (t) { return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10) }, e: function (t, e) { return t.toExponential(e) }, f: function (t, e) { return t.toFixed(e) }, g: function (t, e) { return t.toPrecision(e) }, o: function (t) { return Math.round(t).toString(8) }, p: function (t, e) { return wI(100 * t, e) }, r: wI, s: function (t, e) { var n = vI(t, e); if (!n) return t + ""; var r = n[0], i = n[1], o = i - (gI = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1, a = r.length; return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + vI(t, Math.max(0, e + o - 1))[0] }, X: function (t) { return Math.round(t).toString(16).toUpperCase() }, x: function (t) { return Math.round(t).toString(16) } }; function EI(t) { return t } var CI, TI, AI, MI = Array.prototype.map, OI = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]; function kI(t) { var e, n, r = void 0 === t.grouping || void 0 === t.thousands ? EI : (e = MI.call(t.grouping, Number), n = t.thousands + "", function (t, r) { for (var i = t.length, o = [], a = 0, s = e[0], l = 0; i > 0 && s > 0 && (l + s + 1 > r && (s = Math.max(1, r - l)), o.push(t.substring(i -= s, i + s)), !((l += s + 1) > r));)s = e[a = (a + 1) % e.length]; return o.reverse().join(n) }), i = void 0 === t.currency ? "" : t.currency[0] + "", o = void 0 === t.currency ? "" : t.currency[1] + "", a = void 0 === t.decimal ? "." : t.decimal + "", s = void 0 === t.numerals ? EI : function (t) { return function (e) { return e.replace(/[0-9]/g, (function (e) { return t[+e] })) } }(MI.call(t.numerals, String)), l = void 0 === t.percent ? "%" : t.percent + "", u = void 0 === t.minus ? "-" : t.minus + "", c = void 0 === t.nan ? "NaN" : t.nan + ""; function p(t) { var e = (t = xI(t)).fill, n = t.align, p = t.sign, h = t.symbol, f = t.zero, d = t.width, m = t.comma, v = t.precision, y = t.trim, g = t.type; "n" === g ? (m = !0, g = "g") : SI[g] || (void 0 === v && (v = 12), y = !0, g = "g"), (f || "0" === e && "=" === n) && (f = !0, e = "0", n = "="); var _ = "$" === h ? i : "#" === h && /[boxX]/.test(g) ? "0" + g.toLowerCase() : "", x = "$" === h ? o : /[%p]/.test(g) ? l : "", b = SI[g], w = /[defgprs%]/.test(g); function S(t) { var i, o, l, h = _, S = x; if ("c" === g) S = b(t) + S, t = ""; else { var E = (t = +t) < 0 || 1 / t < 0; if (t = isNaN(t) ? c : b(Math.abs(t), v), y && (t = function (t) { t: for (var e, n = t.length, r = 1, i = -1; r < n; ++r)switch (t[r]) { case ".": i = e = r; break; case "0": 0 === i && (i = r), e = r; break; default: if (!+t[r]) break t; i > 0 && (i = 0) }return i > 0 ? t.slice(0, i) + t.slice(e + 1) : t }(t)), E && 0 == +t && "+" !== p && (E = !1), h = (E ? "(" === p ? p : u : "-" === p || "(" === p ? "" : p) + h, S = ("s" === g ? OI[8 + gI / 3] : "") + S + (E && "(" === p ? ")" : ""), w) for (i = -1, o = t.length; ++i < o;)if (48 > (l = t.charCodeAt(i)) || l > 57) { S = (46 === l ? a + t.slice(i + 1) : t.slice(i)) + S, t = t.slice(0, i); break } } m && !f && (t = r(t, 1 / 0)); var C = h.length + t.length + S.length, T = C < d ? new Array(d - C + 1).join(e) : ""; switch (m && f && (t = r(T + t, T.length ? d - S.length : 1 / 0), T = ""), n) { case "<": t = h + t + S + T; break; case "=": t = h + T + t + S; break; case "^": t = T.slice(0, C = T.length >> 1) + h + t + S + T.slice(C); break; default: t = T + h + t + S }return s(t) } return v = void 0 === v ? 6 : /[gprs]/.test(g) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v)), S.toString = function () { return t + "" }, S } return { format: p, formatPrefix: function (t, e) { var n = p(((t = xI(t)).type = "f", t)), r = 3 * Math.max(-8, Math.min(8, Math.floor(yI(e) / 3))), i = Math.pow(10, -r), o = OI[8 + r / 3]; return function (t) { return n(i * t) + o } } } } function II(t, e, n, r) { var i, o = Lk(t, e, n); switch ((r = xI(null == r ? ",f" : r)).type) { case "s": var a = Math.max(Math.abs(t), Math.abs(e)); return null != r.precision || isNaN(i = function (t, e) { return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(yI(e) / 3))) - yI(Math.abs(t))) }(o, a)) || (r.precision = i), AI(r, a); case "": case "e": case "g": case "p": case "r": null != r.precision || isNaN(i = function (t, e) { return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, yI(e) - yI(t)) + 1 }(o, Math.max(Math.abs(t), Math.abs(e)))) || (r.precision = i - ("e" === r.type)); break; case "f": case "%": null != r.precision || isNaN(i = function (t) { return Math.max(0, -yI(Math.abs(t))) }(o)) || (r.precision = i - 2 * ("%" === r.type)) }return TI(r) } function PI(t) { var e = t.domain; return t.ticks = function (t) { var n = e(); return Ik(n[0], n[n.length - 1], null == t ? 10 : t) }, t.tickFormat = function (t, n) { var r = e(); return II(r[0], r[r.length - 1], null == t ? 10 : t, n) }, t.nice = function (n) { null == n && (n = 10); var r, i = e(), o = 0, a = i.length - 1, s = i[o], l = i[a]; return l < s && (r = s, s = l, l = r, r = o, o = a, a = r), (r = Pk(s, l, n)) > 0 ? r = Pk(s = Math.floor(s / r) * r, l = Math.ceil(l / r) * r, n) : r < 0 && (r = Pk(s = Math.ceil(s * r) / r, l = Math.floor(l * r) / r, n)), r > 0 ? (i[o] = Math.floor(s / r) * r, i[a] = Math.ceil(l / r) * r, e(i)) : r < 0 && (i[o] = Math.ceil(s * r) / r, i[a] = Math.floor(l * r) / r, e(i)), t }, t } function LI(t, e) { var n, r = 0, i = (t = t.slice()).length - 1, o = t[r], a = t[i]; return a < o && (n = r, r = i, i = n, n = o, o = a, a = n), t[r] = e.floor(o), t[i] = e.ceil(a), t } function RI(t) { return Math.log(t) } function DI(t) { return Math.exp(t) } function NI(t) { return -Math.log(-t) } function zI(t) { return -Math.exp(-t) } function FI(t) { return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t } function BI(t) { return function (e) { return -t(-e) } } function jI(t) { var e, n, r = t(RI, DI), i = r.domain, o = 10; function a() { return e = function (t) { return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), function (e) { return Math.log(e) / t }) }(o), n = function (t) { return 10 === t ? FI : t === Math.E ? Math.exp : function (e) { return Math.pow(t, e) } }(o), i()[0] < 0 ? (e = BI(e), n = BI(n), t(NI, zI)) : t(RI, DI), r } return r.base = function (t) { return arguments.length ? (o = +t, a()) : o }, r.domain = function (t) { return arguments.length ? (i(t), a()) : i() }, r.ticks = function (t) { var r, a = i(), s = a[0], l = a[a.length - 1]; (r = l < s) && (h = s, s = l, l = h); var u, c, p, h = e(s), f = e(l), d = null == t ? 10 : +t, m = []; if (!(o % 1) && f - h < d) { if (h = Math.round(h) - 1, f = Math.round(f) + 1, s > 0) { for (; h < f; ++h)for (c = 1, u = n(h); c < o; ++c)if (!((p = u * c) < s)) { if (p > l) break; m.push(p) } } else for (; h < f; ++h)for (c = o - 1, u = n(h); c >= 1; --c)if (!((p = u * c) < s)) { if (p > l) break; m.push(p) } } else m = Ik(h, f, Math.min(f - h, d)).map(n); return r ? m.reverse() : m }, r.tickFormat = function (t, i) { if (null == i && (i = 10 === o ? ".0e" : ","), "function" != typeof i && (i = TI(i)), t === 1 / 0) return i; null == t && (t = 10); var a = Math.max(1, o * t / r.ticks().length); return function (t) { var r = t / n(Math.round(e(t))); return r * o < o - .5 && (r *= o), r <= a ? i(t) : "" } }, r.nice = function () { return i(LI(i(), { floor: function (t) { return n(Math.floor(e(t))) }, ceil: function (t) { return n(Math.ceil(e(t))) } })) }, r } function UI(t) { return function (e) { return e < 0 ? -Math.pow(-e, t) : Math.pow(e, t) } } function VI(t) { return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t) } function GI(t) { return t < 0 ? -t * t : t * t } function HI(t) { var e = t(lI, lI), n = 1; function r() { return 1 === n ? t(lI, lI) : .5 === n ? t(VI, GI) : t(UI(n), UI(1 / n)) } return e.exponent = function (t) { return arguments.length ? (n = +t, r()) : n }, PI(e) } CI = kI({ decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""], minus: "-" }), TI = CI.format, AI = CI.formatPrefix; var WI = new Date, XI = new Date; function qI(t, e, n, r) { function i(e) { return t(e = 0 === arguments.length ? new Date : new Date(+e)), e } return i.floor = function (e) { return t(e = new Date(+e)), e }, i.ceil = function (n) { return t(n = new Date(n - 1)), e(n, 1), t(n), n }, i.round = function (t) { var e = i(t), n = i.ceil(t); return t - e < n - t ? e : n }, i.offset = function (t, n) { return e(t = new Date(+t), null == n ? 1 : Math.floor(n)), t }, i.range = function (n, r, o) { var a, s = []; if (n = i.ceil(n), o = null == o ? 1 : Math.floor(o), !(n < r && o > 0)) return s; do { s.push(a = new Date(+n)), e(n, o), t(n) } while (a < n && n < r); return s }, i.filter = function (n) { return qI((function (e) { if (e >= e) for (; t(e), !n(e);)e.setTime(e - 1) }), (function (t, r) { if (t >= t) if (r < 0) for (; ++r <= 0;)for (; e(t, -1), !n(t);); else for (; --r >= 0;)for (; e(t, 1), !n(t);); })) }, n && (i.count = function (e, r) { return WI.setTime(+e), XI.setTime(+r), t(WI), t(XI), Math.floor(n(WI, XI)) }, i.every = function (t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? i.filter(r ? function (e) { return r(e) % t == 0 } : function (e) { return i.count(0, e) % t == 0 }) : i : null }), i } var ZI = qI((function () { }), (function (t, e) { t.setTime(+t + e) }), (function (t, e) { return e - t })); ZI.every = function (t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? qI((function (e) { e.setTime(Math.floor(e / t) * t) }), (function (e, n) { e.setTime(+e + n * t) }), (function (e, n) { return (n - e) / t })) : ZI : null }; var YI = ZI, KI = 1e3, QI = 6e4, JI = 36e5, $I = 864e5, tP = 6048e5, eP = qI((function (t) { t.setTime(t - t.getMilliseconds()) }), (function (t, e) { t.setTime(+t + e * KI) }), (function (t, e) { return (e - t) / KI }), (function (t) { return t.getUTCSeconds() })), nP = eP, rP = qI((function (t) { t.setTime(t - t.getMilliseconds() - t.getSeconds() * KI) }), (function (t, e) { t.setTime(+t + e * QI) }), (function (t, e) { return (e - t) / QI }), (function (t) { return t.getMinutes() })), iP = rP, oP = qI((function (t) { t.setTime(t - t.getMilliseconds() - t.getSeconds() * KI - t.getMinutes() * QI) }), (function (t, e) { t.setTime(+t + e * JI) }), (function (t, e) { return (e - t) / JI }), (function (t) { return t.getHours() })), aP = oP, sP = qI((function (t) { t.setHours(0, 0, 0, 0) }), (function (t, e) { t.setDate(t.getDate() + e) }), (function (t, e) { return (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * QI) / $I }), (function (t) { return t.getDate() - 1 })), lP = sP; function uP(t) { return qI((function (e) { e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0) }), (function (t, e) { t.setDate(t.getDate() + 7 * e) }), (function (t, e) { return (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * QI) / tP })) } var cP = uP(0), pP = uP(1); uP(2), uP(3); var hP = uP(4); uP(5), uP(6); var fP = qI((function (t) { t.setDate(1), t.setHours(0, 0, 0, 0) }), (function (t, e) { t.setMonth(t.getMonth() + e) }), (function (t, e) { return e.getMonth() - t.getMonth() + 12 * (e.getFullYear() - t.getFullYear()) }), (function (t) { return t.getMonth() })), dP = fP, mP = qI((function (t) { t.setMonth(0, 1), t.setHours(0, 0, 0, 0) }), (function (t, e) { t.setFullYear(t.getFullYear() + e) }), (function (t, e) { return e.getFullYear() - t.getFullYear() }), (function (t) { return t.getFullYear() })); mP.every = function (t) { return isFinite(t = Math.floor(t)) && t > 0 ? qI((function (e) { e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0) }), (function (e, n) { e.setFullYear(e.getFullYear() + n * t) })) : null }; var vP = mP, yP = qI((function (t) { t.setUTCHours(0, 0, 0, 0) }), (function (t, e) { t.setUTCDate(t.getUTCDate() + e) }), (function (t, e) { return (e - t) / $I }), (function (t) { return t.getUTCDate() - 1 })), gP = yP; function _P(t) { return qI((function (e) { e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0) }), (function (t, e) { t.setUTCDate(t.getUTCDate() + 7 * e) }), (function (t, e) { return (e - t) / tP })) } var xP = _P(0), bP = _P(1); _P(2), _P(3); var wP = _P(4); _P(5), _P(6); var SP = qI((function (t) { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0) }), (function (t, e) { t.setUTCFullYear(t.getUTCFullYear() + e) }), (function (t, e) { return e.getUTCFullYear() - t.getUTCFullYear() }), (function (t) { return t.getUTCFullYear() })); SP.every = function (t) { return isFinite(t = Math.floor(t)) && t > 0 ? qI((function (e) { e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0) }), (function (e, n) { e.setUTCFullYear(e.getUTCFullYear() + n * t) })) : null }; var EP = SP; function CP(t) { if (0 <= t.y && t.y < 100) { var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return e.setFullYear(t.y), e } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L) } function TP(t) { if (0 <= t.y && t.y < 100) { var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return e.setUTCFullYear(t.y), e } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)) } function AP(t, e, n) { return { y: t, m: e, d: n, H: 0, M: 0, S: 0, L: 0 } } var MP, OP, kP = { "-": "", _: " ", 0: "0" }, IP = /^\s*\d+/, PP = /^%/, LP = /[\\^$*+?|[\]().{}]/g; function RP(t, e, n) { var r = t < 0 ? "-" : "", i = (r ? -t : t) + "", o = i.length; return r + (o < n ? new Array(n - o + 1).join(e) + i : i) } function DP(t) { return t.replace(LP, "\\$&") } function NP(t) { return new RegExp("^(?:" + t.map(DP).join("|") + ")", "i") } function zP(t) { for (var e = {}, n = -1, r = t.length; ++n < r;)e[t[n].toLowerCase()] = n; return e } function FP(t, e, n) { var r = IP.exec(e.slice(n, n + 1)); return r ? (t.w = +r[0], n + r[0].length) : -1 } function BP(t, e, n) { var r = IP.exec(e.slice(n, n + 1)); return r ? (t.u = +r[0], n + r[0].length) : -1 } function jP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.U = +r[0], n + r[0].length) : -1 } function UP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.V = +r[0], n + r[0].length) : -1 } function VP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.W = +r[0], n + r[0].length) : -1 } function GP(t, e, n) { var r = IP.exec(e.slice(n, n + 4)); return r ? (t.y = +r[0], n + r[0].length) : -1 } function HP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1 } function WP(t, e, n) { var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(n, n + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1 } function XP(t, e, n) { var r = IP.exec(e.slice(n, n + 1)); return r ? (t.q = 3 * r[0] - 3, n + r[0].length) : -1 } function qP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.m = r[0] - 1, n + r[0].length) : -1 } function ZP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.d = +r[0], n + r[0].length) : -1 } function YP(t, e, n) { var r = IP.exec(e.slice(n, n + 3)); return r ? (t.m = 0, t.d = +r[0], n + r[0].length) : -1 } function KP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.H = +r[0], n + r[0].length) : -1 } function QP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.M = +r[0], n + r[0].length) : -1 } function JP(t, e, n) { var r = IP.exec(e.slice(n, n + 2)); return r ? (t.S = +r[0], n + r[0].length) : -1 } function $P(t, e, n) { var r = IP.exec(e.slice(n, n + 3)); return r ? (t.L = +r[0], n + r[0].length) : -1 } function tL(t, e, n) { var r = IP.exec(e.slice(n, n + 6)); return r ? (t.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1 } function eL(t, e, n) { var r = PP.exec(e.slice(n, n + 1)); return r ? n + r[0].length : -1 } function nL(t, e, n) { var r = IP.exec(e.slice(n)); return r ? (t.Q = +r[0], n + r[0].length) : -1 } function rL(t, e, n) { var r = IP.exec(e.slice(n)); return r ? (t.s = +r[0], n + r[0].length) : -1 } function iL(t, e) { return RP(t.getDate(), e, 2) } function oL(t, e) { return RP(t.getHours(), e, 2) } function aL(t, e) { return RP(t.getHours() % 12 || 12, e, 2) } function sL(t, e) { return RP(1 + lP.count(vP(t), t), e, 3) } function lL(t, e) { return RP(t.getMilliseconds(), e, 3) } function uL(t, e) { return lL(t, e) + "000" } function cL(t, e) { return RP(t.getMonth() + 1, e, 2) } function pL(t, e) { return RP(t.getMinutes(), e, 2) } function hL(t, e) { return RP(t.getSeconds(), e, 2) } function fL(t) { var e = t.getDay(); return 0 === e ? 7 : e } function dL(t, e) { return RP(cP.count(vP(t) - 1, t), e, 2) } function mL(t) { var e = t.getDay(); return e >= 4 || 0 === e ? hP(t) : hP.ceil(t) } function vL(t, e) { return t = mL(t), RP(hP.count(vP(t), t) + (4 === vP(t).getDay()), e, 2) } function yL(t) { return t.getDay() } function gL(t, e) { return RP(pP.count(vP(t) - 1, t), e, 2) } function _L(t, e) { return RP(t.getFullYear() % 100, e, 2) } function xL(t, e) { return RP((t = mL(t)).getFullYear() % 100, e, 2) } function bL(t, e) { return RP(t.getFullYear() % 1e4, e, 4) } function wL(t, e) { var n = t.getDay(); return RP((t = n >= 4 || 0 === n ? hP(t) : hP.ceil(t)).getFullYear() % 1e4, e, 4) } function SL(t) { var e = t.getTimezoneOffset(); return (e > 0 ? "-" : (e *= -1, "+")) + RP(e / 60 | 0, "0", 2) + RP(e % 60, "0", 2) } function EL(t, e) { return RP(t.getUTCDate(), e, 2) } function CL(t, e) { return RP(t.getUTCHours(), e, 2) } function TL(t, e) { return RP(t.getUTCHours() % 12 || 12, e, 2) } function AL(t, e) { return RP(1 + gP.count(EP(t), t), e, 3) } function ML(t, e) { return RP(t.getUTCMilliseconds(), e, 3) } function OL(t, e) { return ML(t, e) + "000" } function kL(t, e) { return RP(t.getUTCMonth() + 1, e, 2) } function IL(t, e) { return RP(t.getUTCMinutes(), e, 2) } function PL(t, e) { return RP(t.getUTCSeconds(), e, 2) } function LL(t) { var e = t.getUTCDay(); return 0 === e ? 7 : e } function RL(t, e) { return RP(xP.count(EP(t) - 1, t), e, 2) } function DL(t) { var e = t.getUTCDay(); return e >= 4 || 0 === e ? wP(t) : wP.ceil(t) } function NL(t, e) { return t = DL(t), RP(wP.count(EP(t), t) + (4 === EP(t).getUTCDay()), e, 2) } function zL(t) { return t.getUTCDay() } function FL(t, e) { return RP(bP.count(EP(t) - 1, t), e, 2) } function BL(t, e) { return RP(t.getUTCFullYear() % 100, e, 2) } function jL(t, e) { return RP((t = DL(t)).getUTCFullYear() % 100, e, 2) } function UL(t, e) { return RP(t.getUTCFullYear() % 1e4, e, 4) } function VL(t, e) { var n = t.getUTCDay(); return RP((t = n >= 4 || 0 === n ? wP(t) : wP.ceil(t)).getUTCFullYear() % 1e4, e, 4) } function GL() { return "+0000" } function HL() { return "%" } function WL(t) { return +t } function XL(t) { return Math.floor(+t / 1e3) } !function (t) { MP = function (t) { var e = t.dateTime, n = t.date, r = t.time, i = t.periods, o = t.days, a = t.shortDays, s = t.months, l = t.shortMonths, u = NP(i), c = zP(i), p = NP(o), h = zP(o), f = NP(a), d = zP(a), m = NP(s), v = zP(s), y = NP(l), g = zP(l), _ = { a: function (t) { return a[t.getDay()] }, A: function (t) { return o[t.getDay()] }, b: function (t) { return l[t.getMonth()] }, B: function (t) { return s[t.getMonth()] }, c: null, d: iL, e: iL, f: uL, g: xL, G: wL, H: oL, I: aL, j: sL, L: lL, m: cL, M: pL, p: function (t) { return i[+(t.getHours() >= 12)] }, q: function (t) { return 1 + ~~(t.getMonth() / 3) }, Q: WL, s: XL, S: hL, u: fL, U: dL, V: vL, w: yL, W: gL, x: null, X: null, y: _L, Y: bL, Z: SL, "%": HL }, x = { a: function (t) { return a[t.getUTCDay()] }, A: function (t) { return o[t.getUTCDay()] }, b: function (t) { return l[t.getUTCMonth()] }, B: function (t) { return s[t.getUTCMonth()] }, c: null, d: EL, e: EL, f: OL, g: jL, G: VL, H: CL, I: TL, j: AL, L: ML, m: kL, M: IL, p: function (t) { return i[+(t.getUTCHours() >= 12)] }, q: function (t) { return 1 + ~~(t.getUTCMonth() / 3) }, Q: WL, s: XL, S: PL, u: LL, U: RL, V: NL, w: zL, W: FL, x: null, X: null, y: BL, Y: UL, Z: GL, "%": HL }, b = { a: function (t, e, n) { var r = f.exec(e.slice(n)); return r ? (t.w = d[r[0].toLowerCase()], n + r[0].length) : -1 }, A: function (t, e, n) { var r = p.exec(e.slice(n)); return r ? (t.w = h[r[0].toLowerCase()], n + r[0].length) : -1 }, b: function (t, e, n) { var r = y.exec(e.slice(n)); return r ? (t.m = g[r[0].toLowerCase()], n + r[0].length) : -1 }, B: function (t, e, n) { var r = m.exec(e.slice(n)); return r ? (t.m = v[r[0].toLowerCase()], n + r[0].length) : -1 }, c: function (t, n, r) { return E(t, e, n, r) }, d: ZP, e: ZP, f: tL, g: HP, G: GP, H: KP, I: KP, j: YP, L: $P, m: qP, M: QP, p: function (t, e, n) { var r = u.exec(e.slice(n)); return r ? (t.p = c[r[0].toLowerCase()], n + r[0].length) : -1 }, q: XP, Q: nL, s: rL, S: JP, u: BP, U: jP, V: UP, w: FP, W: VP, x: function (t, e, r) { return E(t, n, e, r) }, X: function (t, e, n) { return E(t, r, e, n) }, y: HP, Y: GP, Z: WP, "%": eL }; function w(t, e) { return function (n) { var r, i, o, a = [], s = -1, l = 0, u = t.length; for (n instanceof Date || (n = new Date(+n)); ++s < u;)37 === t.charCodeAt(s) && (a.push(t.slice(l, s)), null != (i = kP[r = t.charAt(++s)]) ? r = t.charAt(++s) : i = "e" === r ? " " : "0", (o = e[r]) && (r = o(n, i)), a.push(r), l = s + 1); return a.push(t.slice(l, s)), a.join("") } } function S(t, e) { return function (n) { var r, i, o = AP(1900, void 0, 1); if (E(o, t, n += "", 0) != n.length) return null; if ("Q" in o) return new Date(o.Q); if ("s" in o) return new Date(1e3 * o.s + ("L" in o ? o.L : 0)); if (e && !("Z" in o) && (o.Z = 0), "p" in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = "q" in o ? o.q : 0), "V" in o) { if (o.V < 1 || o.V > 53) return null; "w" in o || (o.w = 1), "Z" in o ? (i = (r = TP(AP(o.y, 0, 1))).getUTCDay(), r = i > 4 || 0 === i ? bP.ceil(r) : bP(r), r = gP.offset(r, 7 * (o.V - 1)), o.y = r.getUTCFullYear(), o.m = r.getUTCMonth(), o.d = r.getUTCDate() + (o.w + 6) % 7) : (i = (r = CP(AP(o.y, 0, 1))).getDay(), r = i > 4 || 0 === i ? pP.ceil(r) : pP(r), r = lP.offset(r, 7 * (o.V - 1)), o.y = r.getFullYear(), o.m = r.getMonth(), o.d = r.getDate() + (o.w + 6) % 7) } else ("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), i = "Z" in o ? TP(AP(o.y, 0, 1)).getUTCDay() : CP(AP(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (i + 5) % 7 : o.w + 7 * o.U - (i + 6) % 7); return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, TP(o)) : CP(o) } } function E(t, e, n, r) { for (var i, o, a = 0, s = e.length, l = n.length; a < s;) { if (r >= l) return -1; if (37 === (i = e.charCodeAt(a++))) { if (i = e.charAt(a++), !(o = b[i in kP ? e.charAt(a++) : i]) || (r = o(t, n, r)) < 0) return -1 } else if (i != n.charCodeAt(r++)) return -1 } return r } return _.x = w(n, _), _.X = w(r, _), _.c = w(e, _), x.x = w(n, x), x.X = w(r, x), x.c = w(e, x), { format: function (t) { var e = w(t += "", _); return e.toString = function () { return t }, e }, parse: function (t) { var e = S(t += "", !1); return e.toString = function () { return t }, e }, utcFormat: function (t) { var e = w(t += "", x); return e.toString = function () { return t }, e }, utcParse: function (t) { var e = S(t += "", !0); return e.toString = function () { return t }, e } } }(t), OP = MP.format }({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] }); var qL, ZL, YL, KL, QL, JL, $L = 1e3, tR = 6e4, eR = 36e5, nR = 864e5, rR = 2592e6, iR = 31536e6; function oR(t) { return new Date(t) } function aR(t) { return t instanceof Date ? +t : +new Date(+t) } function sR(t, e, n, r, i, o, a, s, l) { var u = mI(lI, lI), c = u.invert, p = u.domain, h = l(".%L"), f = l(":%S"), d = l("%I:%M"), m = l("%I %p"), v = l("%a %d"), y = l("%b %d"), g = l("%B"), _ = l("%Y"), x = [[a, 1, $L], [a, 5, 5e3], [a, 15, 15e3], [a, 30, 3e4], [o, 1, tR], [o, 5, 3e5], [o, 15, 9e5], [o, 30, 18e5], [i, 1, eR], [i, 3, 108e5], [i, 6, 216e5], [i, 12, 432e5], [r, 1, nR], [r, 2, 1728e5], [n, 1, 6048e5], [e, 1, rR], [e, 3, 7776e6], [t, 1, iR]]; function b(s) { return (a(s) < s ? h : o(s) < s ? f : i(s) < s ? d : r(s) < s ? m : e(s) < s ? n(s) < s ? v : y : t(s) < s ? g : _)(s) } function w(e, n, r, i) { if (null == e && (e = 10), "number" == typeof e) { var o = Math.abs(r - n) / e, a = Ck((function (t) { return t[2] })).right(x, o); a === x.length ? (i = Lk(n / iR, r / iR, e), e = t) : a ? (i = (a = x[o / x[a - 1][2] < x[a][2] / o ? a - 1 : a])[1], e = a[0]) : (i = Math.max(Lk(n, r, e), 1), e = s) } return null == i ? e : e.every(i) } return u.invert = function (t) { return new Date(c(t)) }, u.domain = function (t) { return arguments.length ? p(Vk.call(t, aR)) : p().map(oR) }, u.ticks = function (t, e) { var n, r = p(), i = r[0], o = r[r.length - 1], a = o < i; return a && (n = i, i = o, o = n), n = (n = w(t, i, o, e)) ? n.range(i, o + 1) : [], a ? n.reverse() : n }, u.tickFormat = function (t, e) { return null == e ? b : l(e) }, u.nice = function (t, e) { var n = p(); return (t = w(t, n[0], n[n.length - 1], e)) ? p(LI(n, t)) : u }, u.copy = function () { return fI(u, sR(t, e, n, r, i, o, a, s, l)) }, u } var lR, uR, cR, pR, hR, fR, dR, mR = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/, vR = (kr(qL = {}, _x.LINEAR, (function t() { var e = mI(lI, lI); return e.copy = function () { return fI(e, t()) }, Dk.apply(e, arguments), PI(e) })), kr(qL, _x.POWER, (function t() { var e = HI(dI()); return e.copy = function () { return fI(e, t()).exponent(e.exponent()) }, Dk.apply(e, arguments), e })), kr(qL, _x.LOG, (function t() { var e = jI(dI()).domain([1, 10]); return e.copy = function () { return fI(e, t()).base(e.base()) }, Dk.apply(e, arguments), e })), kr(qL, _x.IDENTITY, (function t(e) { var n; function r(t) { return isNaN(t = +t) ? n : t } return r.invert = r, r.domain = r.range = function (t) { return arguments.length ? (e = Vk.call(t, aI), r) : e.slice() }, r.unknown = function (t) { return arguments.length ? (n = t, r) : n }, r.copy = function () { return t(e).unknown(n) }, e = arguments.length ? Vk.call(e, aI) : [0, 1], PI(r) })), kr(qL, _x.TIME, (function () { return Dk.apply(sR(vP, dP, cP, lP, aP, iP, nP, YI, OP).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments) })), kr(qL, _x.QUANTILE, (function t() { var e, n = [], r = [], i = []; function o() { var t = 0, e = Math.max(1, r.length); for (i = new Array(e - 1); ++t < e;)i[t - 1] = Rk(n, t / e); return a } function a(t) { return isNaN(t = +t) ? e : r[Tk(i, t)] } return a.invertExtent = function (t) { var e = r.indexOf(t); return e < 0 ? [NaN, NaN] : [e > 0 ? i[e - 1] : n[0], e < i.length ? i[e] : n[n.length - 1]] }, a.domain = function (t) { if (!arguments.length) return n.slice(); n = []; for (var e, r = 0, i = t.length; r < i; ++r)null == (e = t[r]) || isNaN(e = +e) || n.push(e); return n.sort(Ek), o() }, a.range = function (t) { return arguments.length ? (r = Gk.call(t), o()) : r.slice() }, a.unknown = function (t) { return arguments.length ? (e = t, a) : e }, a.quantiles = function () { return i.slice() }, a.copy = function () { return t().domain(n).range(r).unknown(e) }, Dk.apply(a, arguments) })), kr(qL, _x.QUANTIZE, (function t() { var e, n = 0, r = 1, i = 1, o = [.5], a = [0, 1]; function s(t) { return t <= t ? a[Tk(o, t, 0, i)] : e } function l() { var t = -1; for (o = new Array(i); ++t < i;)o[t] = ((t + 1) * r - (t - i) * n) / (i + 1); return s } return s.domain = function (t) { return arguments.length ? (n = +t[0], r = +t[1], l()) : [n, r] }, s.range = function (t) { return arguments.length ? (i = (a = Gk.call(t)).length - 1, l()) : a.slice() }, s.invertExtent = function (t) { var e = a.indexOf(t); return e < 0 ? [NaN, NaN] : e < 1 ? [n, o[0]] : e >= i ? [o[i - 1], r] : [o[e - 1], o[e]] }, s.unknown = function (t) { return arguments.length ? (e = t, s) : s }, s.thresholds = function () { return o.slice() }, s.copy = function () { return t().domain([n, r]).range(a).unknown(e) }, Dk.apply(PI(s), arguments) })), kr(qL, _x.THRESHOLD, (function t() { var e, n = [.5], r = [0, 1], i = 1; function o(t) { return t <= t ? r[Tk(n, t, 0, i)] : e } return o.domain = function (t) { return arguments.length ? (n = Gk.call(t), i = Math.min(n.length, r.length - 1), o) : n.slice() }, o.range = function (t) { return arguments.length ? (r = Gk.call(t), i = Math.min(n.length, r.length - 1), o) : r.slice() }, o.invertExtent = function (t) { var e = r.indexOf(t); return [n[e - 1], n[e]] }, o.unknown = function (t) { return arguments.length ? (e = t, o) : e }, o.copy = function () { return t().domain(n).range(r).unknown(e) }, Dk.apply(o, arguments) })), kr(qL, _x.CAT, Wk), qL), yR = (ZL = ut.injectable(), YL = ut.inject(Tr.IGlobalConfigService), ZL((QL = function () { function t() { Ar(this, t), Ef(this, "configService", JL, this), kr(this, "scaleCache", {}), kr(this, "scaleOptions", {}) } return Or(t, [{ key: "apply", value: function (t, e) { var n = this, r = e.styleAttributeService; t.hooks.init.tap("FeatureScalePlugin", (function () { n.scaleOptions = t.getScaleOptions(); var e = r.getLayerStyleAttributes(), i = t.getSource().data.dataArray; 0 !== i.length && n.caculateScalesForAttributes(e || [], i) })), t.hooks.beforeRenderData.tap("FeatureScalePlugin", (function () { n.scaleOptions = t.getScaleOptions(); var e = r.getLayerStyleAttributes(), i = t.getSource().data.dataArray; return n.caculateScalesForAttributes(e || [], i), t.layerModelNeedUpdate = !0, !0 })), t.hooks.beforeRender.tap("FeatureScalePlugin", (function () { if (!t.layerModelNeedUpdate) { n.scaleOptions = t.getScaleOptions(); var e = r.getLayerStyleAttributes(); if (e) { var i = t.getSource().data.dataArray; if (0 === i.length) return; var o = e.filter((function (t) { return t.needRescale })); o.length && n.caculateScalesForAttributes(o, i) } } })) } }, { key: "isNumber", value: function (t) { return !isNaN(parseFloat(t)) && isFinite(t) } }, { key: "caculateScalesForAttributes", value: function (t, e) { var n = this; this.scaleCache = {}, t.forEach((function (t) { if (t.scale) { var r = t.scale, i = t.name; r.names = n.parseFields(t.scale.field || []); var o = []; r.names.forEach((function (r) { o.push(n.getOrCreateScale(r, t, e)) })), o.some((function (t) { return t.type === xx.VARIABLE })) ? (r.type = xx.VARIABLE, o.forEach((function (t) { var e; if (!r.callback) if (r.values && "text" !== r.values) { var n; if ("linear" === (null === (n = t.option) || void 0 === n ? void 0 : n.type) && r.values.length > 2) { var o = t.scale.ticks(r.values.length); "color" === i && t.scale.domain(o) } t.scale.range(r.values) } else "cat" === (null === (e = t.option) || void 0 === e ? void 0 : e.type) && t.scale.range(t.option.domain) }))) : (r.type = xx.CONSTANT, r.defaultValues = o.map((function (t, e) { return t.scale(r.names[e]) }))), r.scalers = o.map((function (t) { return { field: t.field, func: t.scale, option: t.option } })), t.needRescale = !1 } })) } }, { key: "getOrCreateScale", value: function (t, e, n) { var r;[t, e.name].join("_"); var i = null === (r = e.scale) || void 0 === r ? void 0 : r.values; return this.createScale(t, e.name, i, n) } }, { key: "parseFields", value: function (t) { return Array.isArray(t) ? t : Xb(t) ? t.split("*") : [t] } }, { key: "createScale", value: function (t, e, n, r) { var i, o, a = this.scaleOptions[e] && (null === (i = this.scaleOptions[e]) || void 0 === i ? void 0 : i.field) === t ? this.scaleOptions[e] : this.scaleOptions[t], s = { field: t, scale: void 0, type: xx.VARIABLE, option: a }; if (!r || !r.length) return a && a.type ? s.scale = this.createDefaultScale(a) : (s.scale = Wk([t]), s.type = xx.CONSTANT), s; var l = null === (o = r.find((function (e) { return !Wd(e[t]) }))) || void 0 === o ? void 0 : o[t]; if (this.isNumber(t) || Wd(l) && !a) s.scale = Wk([t]), s.type = xx.CONSTANT; else { var u = a && a.type || this.getDefaultType(l); "text" === n && (u = _x.CAT); var c = this.createDefaultScaleConfig(u, t, r); Object.assign(c, a), s.scale = this.createDefaultScale(c), s.option = c } return s } }, { key: "getDefaultType", value: function (t) { var e = _x.LINEAR; return "string" == typeof t && (e = mR.test(t) ? _x.TIME : _x.CAT), e } }, { key: "createDefaultScaleConfig", value: function (t, e, n) { var r = { type: t }, i = (null == n ? void 0 : n.map((function (t) { return t[e] }))) || []; return t !== _x.CAT && t !== _x.QUANTILE ? r.domain = function (t, e) { var n, r, i, o = t.length, a = -1; if (null == e) { for (; ++a < o;)if (null != (n = t[a]) && n >= n) for (r = i = n; ++a < o;)null != (n = t[a]) && (r > n && (r = n), i < n && (i = n)) } else for (; ++a < o;)if (null != (n = e(t[a], a, t)) && n >= n) for (r = i = n; ++a < o;)null != (n = e(t[a], a, t)) && (r > n && (r = n), i < n && (i = n)); return [r, i] }(i) : t === _x.CAT ? r.domain = Hv(i) : t === _x.QUANTILE && (r.domain = i), r } }, { key: "createDefaultScale", value: function (t) { var e = t.type, n = t.domain, r = vR[e](); return n && r.domain(n), r } }]), t }(), JL = Cf(QL.prototype, "configService", [YL], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), KL = QL)) || KL); function gR(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } var _R, xR, bR, wR = (lR = ut.injectable(), uR = ut.inject(Tr.ICameraService), cR = ut.inject(Tr.IRendererService), lR((hR = function () { function t() { Ar(this, t), Ef(this, "cameraService", fR, this), Ef(this, "rendererService", dR, this) } return Or(t, [{ key: "apply", value: function (t) { t.hooks.beforeRender.tap("LayerAnimateStylePlugin", (function () { t.models.forEach((function (e) { e.addUniforms(function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? gR(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : gR(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({}, t.layerModel.getAnimateUniforms())) })) })) } }]), t }(), fR = Cf(hR.prototype, "cameraService", [uR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), dR = Cf(hR.prototype, "rendererService", [cR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), pR = hR)) || pR), SR = ut.injectable()(_R = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t) { t.hooks.init.tap("LayerModelPlugin", (function () { t.prepareBuildModel(), t.buildModels(), t.styleNeedUpdate = !1 })), t.hooks.beforeRenderData.tap("DataSourcePlugin", (function () { return t.prepareBuildModel(), t.clearModels(), t.buildModels(), t.layerModelNeedUpdate = !1, !1 })) } }]), t }()) || _R, ER = ut.injectable()(xR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t) { t.hooks.afterInit.tap("LayerStylePlugin", (function () { t.updateLayerConfig({}); var e = t.getLayerConfig(), n = e.autoFit, r = e.fitBoundsOptions; n && setTimeout((function () { t.fitBounds(r) }), 100) })) } }]), t }()) || xR, CR = ["type"]; function TR(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function AR(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? TR(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : TR(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var MR = { directional: { lights: "u_DirectionalLights", num: "u_NumOfDirectionalLights" }, spot: { lights: "u_SpotLights", num: "u_NumOfSpotLights" } }, OR = { type: "directional", direction: [1, 10.5, 12], ambient: [.2, .2, .2], diffuse: [.6, .6, .6], specular: [.1, .1, .1] }, kR = { direction: [0, 0, 0], ambient: [0, 0, 0], diffuse: [0, 0, 0], specular: [0, 0, 0] }, IR = { position: [0, 0, 0], direction: [0, 0, 0], ambient: [0, 0, 0], diffuse: [0, 0, 0], specular: [0, 0, 0], constant: 1, linear: 0, quadratic: 0, angle: 14, exponent: 40, blur: 5 }; var PR, LR, RR, DR, NR, zR, FR, BR, jR, UR, VR, GR, HR, WR, XR, qR, ZR, YR, KR, QR, JR = ut.injectable()(bR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t) { t.hooks.beforeRender.tap("LightingPlugin", (function () { t.getLayerConfig().enableLighting && t.models.forEach((function (t) { return t.addUniforms(AR({}, (n = { u_DirectionalLights: new Array(3).fill(AR({}, kR)), u_NumOfDirectionalLights: 0, u_SpotLights: new Array(3).fill(AR({}, IR)), u_NumOfSpotLights: 0 }, e && e.length || (e = [OR]), e.forEach((function (t, e) { var r = t.type, i = void 0 === r ? "directional" : r, o = zd(t, CR), a = MR[i].lights, s = MR[i].num, l = n[s]; n[a][l] = AR(AR({}, n[a][l]), o), n[s]++ })), n))); var e, n })) })) } }]), t }()) || bR, $R = (PR = ut.injectable(), LR = ut.inject(Tr.IGlobalConfigService), PR((DR = function () { function t() { Ar(this, t), Ef(this, "configService", NR, this), kr(this, "enabled", void 0) } return Or(t, [{ key: "apply", value: function (t, e) { var n = this, r = e.rendererService, i = e.postProcessingPassFactory, o = e.normalPassFactory; t.hooks.init.tap("MultiPassRendererPlugin", (function () { var e = t.getLayerConfig(), r = e.enableMultiPassRenderer, a = e.passes, s = void 0 === a ? [] : a; n.enabled = !!r && !1 !== t.getLayerConfig().enableMultiPassRenderer, n.enabled && (t.multiPassRenderer = UE(t, s, i, o), t.multiPassRenderer.setRenderFlag(!0)) })), t.hooks.beforeRender.tap("MultiPassRendererPlugin", (function () { if (n.enabled) { var e = r.getViewportSize(), i = e.width, o = e.height; t.multiPassRenderer.resize(i, o) } })) } }]), t }(), NR = Cf(DR.prototype, "configService", [LR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), RR = DR)) || RR), tD = 1, eD = 2, nD = ut.injectable()(zR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t, e) { e.rendererService; var n = e.styleAttributeService; t.hooks.init.tap("PixelPickingPlugin", (function () { n.registerStyleAttribute({ name: "pickingColor", type: bx.Attribute, descriptor: { name: "a_PickingColor", buffer: { data: [], type: id.FLOAT }, size: 3, update: function (t, e) { return wa(t.id) } } }) })), t.hooks.beforePickingEncode.tap("PixelPickingPlugin", (function () { t.getLayerConfig().enablePicking && t.isVisible() && t.models.forEach((function (t) { return t.addUniforms({ u_PickingStage: tD }) })) })), t.hooks.afterPickingEncode.tap("PixelPickingPlugin", (function () { t.getLayerConfig().enablePicking && t.isVisible() && t.models.forEach((function (t) { return t.addUniforms({ u_PickingStage: eD }) })) })), t.hooks.beforeHighlight.tap("PixelPickingPlugin", (function (e) { var n = t.getLayerConfig(), r = n.highlightColor, i = n.activeMix, o = void 0 === i ? 0 : i, a = "string" == typeof r ? xa(r) : r || [1, 0, 0, 1]; t.updateLayerConfig({ pickedFeatureID: ba(new Uint8Array(e)) }), t.models.forEach((function (t) { return t.addUniforms({ u_PickingStage: eD, u_PickingColor: e, u_HighlightColor: a.map((function (t) { return 255 * t })), u_activeMix: o }) })) })), t.hooks.beforeSelect.tap("PixelPickingPlugin", (function (e) { var n = t.getLayerConfig(), r = n.selectColor, i = n.selectMix, o = void 0 === i ? 0 : i, a = "string" == typeof r ? xa(r) : r || [1, 0, 0, 1]; t.updateLayerConfig({ pickedFeatureID: ba(new Uint8Array(e)) }), t.models.forEach((function (t) { return t.addUniforms({ u_PickingStage: eD, u_PickingColor: e, u_HighlightColor: a.map((function (t) { return 255 * t })), u_activeMix: o, u_CurrentSelectedId: e, u_SelectColor: a.map((function (t) { return 255 * t })), u_EnableSelect: 1 }) })) })) } }]), t }()) || zR, rD = ut.injectable()(FR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t, e) { var n = this, r = e.styleAttributeService; t.hooks.init.tap("RegisterStyleAttributePlugin", (function () { n.registerBuiltinAttributes(r) })) } }, { key: "registerBuiltinAttributes", value: function (t) { t.registerStyleAttribute({ name: "position", type: bx.Attribute, descriptor: { name: "a_Position", buffer: { data: [], type: id.FLOAT }, size: 3, update: function (t, e, n) { return 2 === n.length ? [n[0], n[1], 0] : [n[0], n[1], n[2]] } } }), t.registerStyleAttribute({ name: "filter", type: bx.Attribute, descriptor: { name: "filter", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e) { return t.filter ? [1] : [0] } } }), t.registerStyleAttribute({ name: "color", type: bx.Attribute, descriptor: { name: "a_Color", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 4, update: function (t, e) { var n = t.color; return n && n.length ? n : [1, 1, 1, 1] } } }), t.registerStyleAttribute({ name: "vertexId", type: bx.Attribute, descriptor: { name: "a_vertexId", buffer: { usage: id.DYNAMIC_DRAW, data: [], type: id.FLOAT }, size: 1, update: function (t, e, n, r) { return [e] } } }) } }]), t }()) || FR, iD = (BR = ut.injectable(), jR = ut.inject(Tr.ICameraService), UR = ut.inject(Tr.ICoordinateSystemService), VR = ut.inject(Tr.IRendererService), GR = ut.inject(Tr.IMapService), BR((WR = function () { function t() { Ar(this, t), Ef(this, "cameraService", XR, this), Ef(this, "coordinateSystemService", qR, this), Ef(this, "rendererService", ZR, this), Ef(this, "mapService", YR, this) } return Or(t, [{ key: "apply", value: function (t) { var e = this, n = this.mapService.version, r = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], i = [0, 0]; t.hooks.beforeRender.tap("ShaderUniformPlugin", (function () { e.coordinateSystemService.refresh(), "GAODE2.x" === n && (r = e.mapService.map.customCoords.getMVPMatrix(), i = e.mapService.getCustomCoordCenter()); var o = e.rendererService.getViewportSize(), a = o.width, s = o.height; t.models.forEach((function (n) { var o; n.addUniforms((kr(o = {}, Ox, e.cameraService.getProjectionMatrix()), kr(o, kx, e.cameraService.getViewMatrix()), kr(o, Ix, e.cameraService.getViewProjectionMatrix()), kr(o, Px, e.cameraService.getZoom()), kr(o, Lx, e.cameraService.getZoomScale()), kr(o, Rx, e.cameraService.getFocalDistance()), kr(o, Dx, e.cameraService.getCameraPosition()), kr(o, Df, e.coordinateSystemService.getCoordinateSystem()), kr(o, Nf, e.coordinateSystemService.getViewportCenter()), kr(o, zf, e.coordinateSystemService.getViewportCenterProjection()), kr(o, Ff, e.coordinateSystemService.getPixelsPerDegree()), kr(o, Bf, e.coordinateSystemService.getPixelsPerDegree2()), kr(o, jf, e.coordinateSystemService.getPixelsPerMeter()), kr(o, Uf, r), kr(o, "u_SceneCenterMKT", i), kr(o, "u_ViewportSize", [a, s]), kr(o, "u_ModelMatrix", e.cameraService.getModelMatrix()), kr(o, "u_DevicePixelRatio", oo.devicePixelRatio), kr(o, "u_PickingBuffer", t.getLayerConfig().pickingBuffer || 0), kr(o, "u_shaderPick", Number(t.getShaderPickStat())), o)) })) })) } }]), t }(), XR = Cf(WR.prototype, "cameraService", [jR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), qR = Cf(WR.prototype, "coordinateSystemService", [UR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), ZR = Cf(WR.prototype, "rendererService", [VR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), YR = Cf(WR.prototype, "mapService", [GR], { configurable: !0, enumerable: !0, writable: !0, initializer: null }), HR = WR)) || HR), oD = ut.injectable()(KR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t) { t.hooks.beforeRender.tap("UpdateModelPlugin", (function () { t.layerModel && t.layerModel.needUpdate() })) } }]), t }()) || KR, aD = ut.injectable()(QR = function () { function t() { Ar(this, t) } return Or(t, [{ key: "apply", value: function (t, e) { var n = this, r = e.styleAttributeService; t.hooks.init.tap("UpdateStyleAttributePlugin", (function () { n.initStyleAttribute(t, { styleAttributeService: r }) })), t.hooks.beforeRender.tap("UpdateStyleAttributePlugin", (function () { t.layerModelNeedUpdate || n.updateStyleAtrribute(t, { styleAttributeService: r }) })) } }, { key: "updateStyleAtrribute", value: function (t, e) { var n = e.styleAttributeService, r = n.getLayerStyleAttributes() || [], i = n.getLayerStyleAttribute("filter"); if (n.getLayerStyleAttribute("shape"), i && i.needRegenerateVertices) return t.layerModelNeedUpdate = !0, void r.forEach((function (t) { return t.needRegenerateVertices = !1 })); r.filter((function (t) { return t.needRegenerateVertices })).forEach((function (e) { n.updateAttributeByFeatureRange(e.name, t.getEncodedData(), e.featureRange.startIndex, e.featureRange.endIndex), e.needRegenerateVertices = !1 })) } }, { key: "initStyleAttribute", value: function (t, e) { var n = e.styleAttributeService; (n.getLayerStyleAttributes() || []).filter((function (t) { return t.needRegenerateVertices })).forEach((function (e) { n.updateAttributeByFeatureRange(e.name, t.getEncodedData(), e.featureRange.startIndex, e.featureRange.endIndex), e.needRegenerateVertices = !1 })) } }]), t }()) || QR; yx.bind(Tr.ILayerPlugin).to(Sk).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(rD).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(yR).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(wk).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(ER).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(aD).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(oD).inRequestScope(), yx.bind(Tr.ILayerPlugin).to($R).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(iD).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(wR).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(JR).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(nD).inRequestScope(), yx.bind(Tr.ILayerPlugin).to(SR).inRequestScope(); var sD = { exports: {} }, lD = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, uD = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", cD = { 5: uD, "5module": uD + " export import", 6: uD + " const class extends export import super" }, pD = /^in(stanceof)?$/, hD = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", fD = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", dD = new RegExp("[" + hD + "]"), mD = new RegExp("[" + hD + fD + "]"); hD = fD = null; var vD = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], yD = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239]; function gD(t, e) { for (var n = 65536, r = 0; r < e.length; r += 2) { if ((n += e[r]) > t) return !1; if ((n += e[r + 1]) >= t) return !0 } } function _D(t, e) { return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && dD.test(String.fromCharCode(t)) : !1 !== e && gD(t, vD))) } function xD(t, e) { return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && mD.test(String.fromCharCode(t)) : !1 !== e && (gD(t, vD) || gD(t, yD))))) } var bD = function (t, e) { void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null }; function wD(t, e) { return new bD(t, { beforeExpr: !0, binop: e }) } var SD = { beforeExpr: !0 }, ED = { startsExpr: !0 }, CD = {}; function TD(t, e) { return void 0 === e && (e = {}), e.keyword = t, CD[t] = new bD(t, e) } var AD = { num: new bD("num", ED), regexp: new bD("regexp", ED), string: new bD("string", ED), name: new bD("name", ED), eof: new bD("eof"), bracketL: new bD("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new bD("]"), braceL: new bD("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new bD("}"), parenL: new bD("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new bD(")"), comma: new bD(",", SD), semi: new bD(";", SD), colon: new bD(":", SD), dot: new bD("."), question: new bD("?", SD), questionDot: new bD("?."), arrow: new bD("=>", SD), template: new bD("template"), invalidTemplate: new bD("invalidTemplate"), ellipsis: new bD("...", SD), backQuote: new bD("`", ED), dollarBraceL: new bD("${", { beforeExpr: !0, startsExpr: !0 }), eq: new bD("=", { beforeExpr: !0, isAssign: !0 }), assign: new bD("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new bD("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new bD("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: wD("||", 1), logicalAND: wD("&&", 2), bitwiseOR: wD("|", 3), bitwiseXOR: wD("^", 4), bitwiseAND: wD("&", 5), equality: wD("==/!=/===/!==", 6), relational: wD("</>/<=/>=", 7), bitShift: wD("<</>>/>>>", 8), plusMin: new bD("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: wD("%", 10), star: wD("*", 10), slash: wD("/", 10), starstar: new bD("**", { beforeExpr: !0 }), coalesce: wD("??", 1), _break: TD("break"), _case: TD("case", SD), _catch: TD("catch"), _continue: TD("continue"), _debugger: TD("debugger"), _default: TD("default", SD), _do: TD("do", { isLoop: !0, beforeExpr: !0 }), _else: TD("else", SD), _finally: TD("finally"), _for: TD("for", { isLoop: !0 }), _function: TD("function", ED), _if: TD("if"), _return: TD("return", SD), _switch: TD("switch"), _throw: TD("throw", SD), _try: TD("try"), _var: TD("var"), _const: TD("const"), _while: TD("while", { isLoop: !0 }), _with: TD("with"), _new: TD("new", { beforeExpr: !0, startsExpr: !0 }), _this: TD("this", ED), _super: TD("super", ED), _class: TD("class", ED), _extends: TD("extends", SD), _export: TD("export"), _import: TD("import", ED), _null: TD("null", ED), _true: TD("true", ED), _false: TD("false", ED), _in: TD("in", { beforeExpr: !0, binop: 7 }), _instanceof: TD("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: TD("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: TD("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: TD("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, MD = /\r\n?|\n|\u2028|\u2029/, OD = new RegExp(MD.source, "g"); function kD(t, e) { return 10 === t || 13 === t || !e && (8232 === t || 8233 === t) } var ID = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, PD = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, LD = Object.prototype, RD = LD.hasOwnProperty, DD = LD.toString; function ND(t, e) { return RD.call(t, e) } var zD = Array.isArray || function (t) { return "[object Array]" === DD.call(t) }; function FD(t) { return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$") } var BD = function (t, e) { this.line = t, this.column = e }; BD.prototype.offset = function (t) { return new BD(this.line, this.column + t) }; var jD = function (t, e, n) { this.start = e, this.end = n, null !== t.sourceFile && (this.source = t.sourceFile) }; function UD(t, e) { for (var n = 1, r = 0; ;) { OD.lastIndex = r; var i = OD.exec(t); if (!(i && i.index < e)) return new BD(n, e - r); ++n, r = i.index + i[0].length } } var VD = { ecmaVersion: 10, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: !1, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }; function GD(t) { var e = {}; for (var n in VD) e[n] = t && ND(t, n) ? t[n] : VD[n]; if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5), zD(e.onToken)) { var r = e.onToken; e.onToken = function (t) { return r.push(t) } } return zD(e.onComment) && (e.onComment = function (t, e) { return function (n, r, i, o, a, s) { var l = { type: n ? "Block" : "Line", value: r, start: i, end: o }; t.locations && (l.loc = new jD(this, a, s)), t.ranges && (l.range = [i, o]), e.push(l) } }(e, e.onComment)), e } function HD(t, e) { return 2 | (t ? 4 : 0) | (e ? 8 : 0) } var WD = function (t, e, n) { this.options = t = GD(t), this.sourceFile = t.sourceFile, this.keywords = FD(cD[t.ecmaVersion >= 6 ? 6 : "module" === t.sourceType ? "5module" : 5]); var r = ""; if (!0 !== t.allowReserved) { for (var i = t.ecmaVersion; !(r = lD[i]); i--); "module" === t.sourceType && (r += " await") } this.reservedWords = FD(r); var o = (r ? r + " " : "") + lD.strict; this.reservedWordsStrict = FD(o), this.reservedWordsStrictBind = FD(o + " " + lD.strictBind), this.input = String(e), this.containsEsc = !1, n ? (this.pos = n, this.lineStart = this.input.lastIndexOf("\n", n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(MD).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = AD.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = "module" === t.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, 0 === this.pos && t.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null }, XD = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 } }; WD.prototype.parse = function () { var t = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(t) }, XD.inFunction.get = function () { return (2 & this.currentVarScope().flags) > 0 }, XD.inGenerator.get = function () { return (8 & this.currentVarScope().flags) > 0 }, XD.inAsync.get = function () { return (4 & this.currentVarScope().flags) > 0 }, XD.allowSuper.get = function () { return (64 & this.currentThisScope().flags) > 0 }, XD.allowDirectSuper.get = function () { return (128 & this.currentThisScope().flags) > 0 }, XD.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) }, WD.prototype.inNonArrowFunction = function () { return (2 & this.currentThisScope().flags) > 0 }, WD.extend = function () { for (var t = [], e = arguments.length; e--;)t[e] = arguments[e]; for (var n = this, r = 0; r < t.length; r++)n = t[r](n); return n }, WD.parse = function (t, e) { return new this(e, t).parse() }, WD.parseExpressionAt = function (t, e, n) { var r = new this(n, t, e); return r.nextToken(), r.parseExpression() }, WD.tokenizer = function (t, e) { return new this(e, t) }, Object.defineProperties(WD.prototype, XD); var qD = WD.prototype, ZD = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/; function YD() { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 } qD.strictDirective = function (t) { for (; ;) { PD.lastIndex = t, t += PD.exec(this.input)[0].length; var e = ZD.exec(this.input.slice(t)); if (!e) return !1; if ("use strict" === (e[1] || e[2])) { PD.lastIndex = t + e[0].length; var n = PD.exec(this.input), r = n.index + n[0].length, i = this.input.charAt(r); return ";" === i || "}" === i || MD.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || "!" === i && "=" === this.input.charAt(r + 1)) } t += e[0].length, PD.lastIndex = t, t += PD.exec(this.input)[0].length, ";" === this.input[t] && t++ } }, qD.eat = function (t) { return this.type === t && (this.next(), !0) }, qD.isContextual = function (t) { return this.type === AD.name && this.value === t && !this.containsEsc }, qD.eatContextual = function (t) { return !!this.isContextual(t) && (this.next(), !0) }, qD.expectContextual = function (t) { this.eatContextual(t) || this.unexpected() }, qD.canInsertSemicolon = function () { return this.type === AD.eof || this.type === AD.braceR || MD.test(this.input.slice(this.lastTokEnd, this.start)) }, qD.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }, qD.semicolon = function () { this.eat(AD.semi) || this.insertSemicolon() || this.unexpected() }, qD.afterTrailingComma = function (t, e) { if (this.type === t) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0 }, qD.expect = function (t) { this.eat(t) || this.unexpected() }, qD.unexpected = function (t) { this.raise(null != t ? t : this.start, "Unexpected token") }, qD.checkPatternErrors = function (t, e) { if (t) { t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element"); var n = e ? t.parenthesizedAssign : t.parenthesizedBind; n > -1 && this.raiseRecoverable(n, "Parenthesized pattern") } }, qD.checkExpressionErrors = function (t, e) { if (!t) return !1; var n = t.shorthandAssign, r = t.doubleProto; if (!e) return n >= 0 || r >= 0; n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property") }, qD.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }, qD.isSimpleAssignTarget = function (t) { return "ParenthesizedExpression" === t.type ? this.isSimpleAssignTarget(t.expression) : "Identifier" === t.type || "MemberExpression" === t.type }; var KD = WD.prototype; KD.parseTopLevel = function (t) { var e = {}; for (t.body || (t.body = []); this.type !== AD.eof;) { var n = this.parseStatement(null, !0, e); t.body.push(n) } if (this.inModule) for (var r = 0, i = Object.keys(this.undefinedExports); r < i.length; r += 1) { var o = i[r]; this.raiseRecoverable(this.undefinedExports[o].start, "Export '" + o + "' is not defined") } return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program") }; var QD = { kind: "loop" }, JD = { kind: "switch" }; KD.isLet = function (t) { if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1; PD.lastIndex = this.pos; var e = PD.exec(this.input), n = this.pos + e[0].length, r = this.input.charCodeAt(n); if (91 === r) return !0; if (t) return !1; if (123 === r) return !0; if (_D(r, !0)) { for (var i = n + 1; xD(this.input.charCodeAt(i), !0);)++i; var o = this.input.slice(n, i); if (!pD.test(o)) return !0 } return !1 }, KD.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1; PD.lastIndex = this.pos; var t = PD.exec(this.input), e = this.pos + t[0].length; return !(MD.test(this.input.slice(this.pos, e)) || "function" !== this.input.slice(e, e + 8) || e + 8 !== this.input.length && xD(this.input.charAt(e + 8))) }, KD.parseStatement = function (t, e, n) { var r, i = this.type, o = this.startNode(); switch (this.isLet(t) && (i = AD._var, r = "let"), i) { case AD._break: case AD._continue: return this.parseBreakContinueStatement(o, i.keyword); case AD._debugger: return this.parseDebuggerStatement(o); case AD._do: return this.parseDoStatement(o); case AD._for: return this.parseForStatement(o); case AD._function: return t && (this.strict || "if" !== t && "label" !== t) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(o, !1, !t); case AD._class: return t && this.unexpected(), this.parseClass(o, !0); case AD._if: return this.parseIfStatement(o); case AD._return: return this.parseReturnStatement(o); case AD._switch: return this.parseSwitchStatement(o); case AD._throw: return this.parseThrowStatement(o); case AD._try: return this.parseTryStatement(o); case AD._const: case AD._var: return r = r || this.value, t && "var" !== r && this.unexpected(), this.parseVarStatement(o, r); case AD._while: return this.parseWhileStatement(o); case AD._with: return this.parseWithStatement(o); case AD.braceL: return this.parseBlock(!0, o); case AD.semi: return this.parseEmptyStatement(o); case AD._export: case AD._import: if (this.options.ecmaVersion > 10 && i === AD._import) { PD.lastIndex = this.pos; var a = PD.exec(this.input), s = this.pos + a[0].length, l = this.input.charCodeAt(s); if (40 === l || 46 === l) return this.parseExpressionStatement(o, this.parseExpression()) } return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === AD._import ? this.parseImport(o) : this.parseExport(o, n); default: if (this.isAsyncFunction()) return t && this.unexpected(), this.next(), this.parseFunctionStatement(o, !0, !t); var u = this.value, c = this.parseExpression(); return i === AD.name && "Identifier" === c.type && this.eat(AD.colon) ? this.parseLabeledStatement(o, u, c, t) : this.parseExpressionStatement(o, c) } }, KD.parseBreakContinueStatement = function (t, e) { var n = "break" === e; this.next(), this.eat(AD.semi) || this.insertSemicolon() ? t.label = null : this.type !== AD.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon()); for (var r = 0; r < this.labels.length; ++r) { var i = this.labels[r]; if (null == t.label || i.name === t.label.name) { if (null != i.kind && (n || "loop" === i.kind)) break; if (t.label && n) break } } return r === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, n ? "BreakStatement" : "ContinueStatement") }, KD.parseDebuggerStatement = function (t) { return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement") }, KD.parseDoStatement = function (t) { return this.next(), this.labels.push(QD), t.body = this.parseStatement("do"), this.labels.pop(), this.expect(AD._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(AD.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement") }, KD.parseForStatement = function (t) { this.next(); var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1; if (this.labels.push(QD), this.enterScope(0), this.expect(AD.parenL), this.type === AD.semi) return e > -1 && this.unexpected(e), this.parseFor(t, null); var n = this.isLet(); if (this.type === AD._var || this.type === AD._const || n) { var r = this.startNode(), i = n ? "let" : this.value; return this.next(), this.parseVar(r, !0, i), this.finishNode(r, "VariableDeclaration"), (this.type === AD._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === r.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === AD._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, r)) : (e > -1 && this.unexpected(e), this.parseFor(t, r)) } var o = new YD, a = this.parseExpression(!0, o); return this.type === AD._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === AD._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(a, !1, o), this.checkLVal(a), this.parseForIn(t, a)) : (this.checkExpressionErrors(o, !0), e > -1 && this.unexpected(e), this.parseFor(t, a)) }, KD.parseFunctionStatement = function (t, e, n) { return this.next(), this.parseFunction(t, tN | (n ? 0 : eN), !1, e) }, KD.parseIfStatement = function (t) { return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(AD._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement") }, KD.parseReturnStatement = function (t) { return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(AD.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement") }, KD.parseSwitchStatement = function (t) { var e; this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(AD.braceL), this.labels.push(JD), this.enterScope(0); for (var n = !1; this.type !== AD.braceR;)if (this.type === AD._case || this.type === AD._default) { var r = this.type === AD._case; e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), r ? e.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, e.test = null), this.expect(AD.colon) } else e || this.unexpected(), e.consequent.push(this.parseStatement(null)); return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement") }, KD.parseThrowStatement = function (t) { return this.next(), MD.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement") }; var $D = []; KD.parseTryStatement = function (t) { if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === AD._catch) { var e = this.startNode(); if (this.next(), this.eat(AD.parenL)) { e.param = this.parseBindingAtom(); var n = "Identifier" === e.param.type; this.enterScope(n ? 32 : 0), this.checkLVal(e.param, n ? 4 : 2), this.expect(AD.parenR) } else this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0); e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause") } return t.finalizer = this.eat(AD._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement") }, KD.parseVarStatement = function (t, e) { return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration") }, KD.parseWhileStatement = function (t) { return this.next(), t.test = this.parseParenExpression(), this.labels.push(QD), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement") }, KD.parseWithStatement = function (t) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement") }, KD.parseEmptyStatement = function (t) { return this.next(), this.finishNode(t, "EmptyStatement") }, KD.parseLabeledStatement = function (t, e, n, r) { for (var i = 0, o = this.labels; i < o.length; i += 1) { o[i].name === e && this.raise(n.start, "Label '" + e + "' is already declared") } for (var a = this.type.isLoop ? "loop" : this.type === AD._switch ? "switch" : null, s = this.labels.length - 1; s >= 0; s--) { var l = this.labels[s]; if (l.statementStart !== t.start) break; l.statementStart = this.start, l.kind = a } return this.labels.push({ name: e, kind: a, statementStart: this.start }), t.body = this.parseStatement(r ? -1 === r.indexOf("label") ? r + "label" : r : "label"), this.labels.pop(), t.label = n, this.finishNode(t, "LabeledStatement") }, KD.parseExpressionStatement = function (t, e) { return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement") }, KD.parseBlock = function (t, e, n) { for (void 0 === t && (t = !0), void 0 === e && (e = this.startNode()), e.body = [], this.expect(AD.braceL), t && this.enterScope(0); this.type !== AD.braceR;) { var r = this.parseStatement(null); e.body.push(r) } return n && (this.strict = !1), this.next(), t && this.exitScope(), this.finishNode(e, "BlockStatement") }, KD.parseFor = function (t, e) { return t.init = e, this.expect(AD.semi), t.test = this.type === AD.semi ? null : this.parseExpression(), this.expect(AD.semi), t.update = this.type === AD.parenR ? null : this.parseExpression(), this.expect(AD.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement") }, KD.parseForIn = function (t, e) { var n = this.type === AD._in; return this.next(), "VariableDeclaration" === e.type && null != e.declarations[0].init && (!n || this.options.ecmaVersion < 8 || this.strict || "var" !== e.kind || "Identifier" !== e.declarations[0].id.type) ? this.raise(e.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : "AssignmentPattern" === e.type && this.raise(e.start, "Invalid left-hand side in for-loop"), t.left = e, t.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(AD.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement") }, KD.parseVar = function (t, e, n) { for (t.declarations = [], t.kind = n; ;) { var r = this.startNode(); if (this.parseVarId(r, n), this.eat(AD.eq) ? r.init = this.parseMaybeAssign(e) : "const" !== n || this.type === AD._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? "Identifier" === r.id.type || e && (this.type === AD._in || this.isContextual("of")) ? r.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), t.declarations.push(this.finishNode(r, "VariableDeclarator")), !this.eat(AD.comma)) break } return t }, KD.parseVarId = function (t, e) { t.id = this.parseBindingAtom(), this.checkLVal(t.id, "var" === e ? 1 : 2, !1) }; var tN = 1, eN = 2; KD.parseFunction = function (t, e, n, r) { this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) && (this.type === AD.star && e & eN && this.unexpected(), t.generator = this.eat(AD.star)), this.options.ecmaVersion >= 8 && (t.async = !!r), e & tN && (t.id = 4 & e && this.type !== AD.name ? null : this.parseIdent(), !t.id || e & eN || this.checkLVal(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? 1 : 2 : 3)); var i = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos; return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(HD(t.async, t.generator)), e & tN || (t.id = this.type === AD.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, n, !1), this.yieldPos = i, this.awaitPos = o, this.awaitIdentPos = a, this.finishNode(t, e & tN ? "FunctionDeclaration" : "FunctionExpression") }, KD.parseFunctionParams = function (t) { this.expect(AD.parenL), t.params = this.parseBindingList(AD.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, KD.parseClass = function (t, e) { this.next(); var n = this.strict; this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t); var r = this.startNode(), i = !1; for (r.body = [], this.expect(AD.braceL); this.type !== AD.braceR;) { var o = this.parseClassElement(null !== t.superClass); o && (r.body.push(o), "MethodDefinition" === o.type && "constructor" === o.kind && (i && this.raise(o.start, "Duplicate constructor in the same class"), i = !0)) } return this.strict = n, this.next(), t.body = this.finishNode(r, "ClassBody"), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression") }, KD.parseClassElement = function (t) { var e = this; if (this.eat(AD.semi)) return null; var n = this.startNode(), r = function (t, r) { void 0 === r && (r = !1); var i = e.start, o = e.startLoc; return !!e.eatContextual(t) && (!(e.type === AD.parenL || r && e.canInsertSemicolon()) || (n.key && e.unexpected(), n.computed = !1, n.key = e.startNodeAt(i, o), n.key.name = t, e.finishNode(n.key, "Identifier"), !1)) }; n.kind = "method", n.static = r("static"); var i = this.eat(AD.star), o = !1; i || (this.options.ecmaVersion >= 8 && r("async", !0) ? (o = !0, i = this.options.ecmaVersion >= 9 && this.eat(AD.star)) : r("get") ? n.kind = "get" : r("set") && (n.kind = "set")), n.key || this.parsePropertyName(n); var a = n.key, s = !1; return n.computed || n.static || !("Identifier" === a.type && "constructor" === a.name || "Literal" === a.type && "constructor" === a.value) ? n.static && "Identifier" === a.type && "prototype" === a.name && this.raise(a.start, "Classes may not have a static property named prototype") : ("method" !== n.kind && this.raise(a.start, "Constructor can't have get/set modifier"), i && this.raise(a.start, "Constructor can't be a generator"), o && this.raise(a.start, "Constructor can't be an async method"), n.kind = "constructor", s = t), this.parseClassMethod(n, i, o, s), "get" === n.kind && 0 !== n.value.params.length && this.raiseRecoverable(n.value.start, "getter should have no params"), "set" === n.kind && 1 !== n.value.params.length && this.raiseRecoverable(n.value.start, "setter should have exactly one param"), "set" === n.kind && "RestElement" === n.value.params[0].type && this.raiseRecoverable(n.value.params[0].start, "Setter cannot use rest params"), n }, KD.parseClassMethod = function (t, e, n, r) { return t.value = this.parseMethod(e, n, r), this.finishNode(t, "MethodDefinition") }, KD.parseClassId = function (t, e) { this.type === AD.name ? (t.id = this.parseIdent(), e && this.checkLVal(t.id, 2, !1)) : (!0 === e && this.unexpected(), t.id = null) }, KD.parseClassSuper = function (t) { t.superClass = this.eat(AD._extends) ? this.parseExprSubscripts() : null }, KD.parseExport = function (t, e) { if (this.next(), this.eat(AD.star)) return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (t.exported = this.parseIdent(!0), this.checkExport(e, t.exported.name, this.lastTokStart)) : t.exported = null), this.expectContextual("from"), this.type !== AD.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration"); if (this.eat(AD._default)) { var n; if (this.checkExport(e, "default", this.lastTokStart), this.type === AD._function || (n = this.isAsyncFunction())) { var r = this.startNode(); this.next(), n && this.next(), t.declaration = this.parseFunction(r, 4 | tN, !1, n) } else if (this.type === AD._class) { var i = this.startNode(); t.declaration = this.parseClass(i, "nullableID") } else t.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(t, "ExportDefaultDeclaration") } if (this.shouldParseExportStatement()) t.declaration = this.parseStatement(null), "VariableDeclaration" === t.declaration.type ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null; else { if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from")) this.type !== AD.string && this.unexpected(), t.source = this.parseExprAtom(); else { for (var o = 0, a = t.specifiers; o < a.length; o += 1) { var s = a[o]; this.checkUnreserved(s.local), this.checkLocalExport(s.local) } t.source = null } this.semicolon() } return this.finishNode(t, "ExportNamedDeclaration") }, KD.checkExport = function (t, e, n) { t && (ND(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"), t[e] = !0) }, KD.checkPatternExport = function (t, e) { var n = e.type; if ("Identifier" === n) this.checkExport(t, e.name, e.start); else if ("ObjectPattern" === n) for (var r = 0, i = e.properties; r < i.length; r += 1) { var o = i[r]; this.checkPatternExport(t, o) } else if ("ArrayPattern" === n) for (var a = 0, s = e.elements; a < s.length; a += 1) { var l = s[a]; l && this.checkPatternExport(t, l) } else "Property" === n ? this.checkPatternExport(t, e.value) : "AssignmentPattern" === n ? this.checkPatternExport(t, e.left) : "RestElement" === n ? this.checkPatternExport(t, e.argument) : "ParenthesizedExpression" === n && this.checkPatternExport(t, e.expression) }, KD.checkVariableExport = function (t, e) { if (t) for (var n = 0, r = e; n < r.length; n += 1) { var i = r[n]; this.checkPatternExport(t, i.id) } }, KD.shouldParseExportStatement = function () { return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction() }, KD.parseExportSpecifiers = function (t) { var e = [], n = !0; for (this.expect(AD.braceL); !this.eat(AD.braceR);) { if (n) n = !1; else if (this.expect(AD.comma), this.afterTrailingComma(AD.braceR)) break; var r = this.startNode(); r.local = this.parseIdent(!0), r.exported = this.eatContextual("as") ? this.parseIdent(!0) : r.local, this.checkExport(t, r.exported.name, r.exported.start), e.push(this.finishNode(r, "ExportSpecifier")) } return e }, KD.parseImport = function (t) { return this.next(), this.type === AD.string ? (t.specifiers = $D, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === AD.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration") }, KD.parseImportSpecifiers = function () { var t = [], e = !0; if (this.type === AD.name) { var n = this.startNode(); if (n.local = this.parseIdent(), this.checkLVal(n.local, 2), t.push(this.finishNode(n, "ImportDefaultSpecifier")), !this.eat(AD.comma)) return t } if (this.type === AD.star) { var r = this.startNode(); return this.next(), this.expectContextual("as"), r.local = this.parseIdent(), this.checkLVal(r.local, 2), t.push(this.finishNode(r, "ImportNamespaceSpecifier")), t } for (this.expect(AD.braceL); !this.eat(AD.braceR);) { if (e) e = !1; else if (this.expect(AD.comma), this.afterTrailingComma(AD.braceR)) break; var i = this.startNode(); i.imported = this.parseIdent(!0), this.eatContextual("as") ? i.local = this.parseIdent() : (this.checkUnreserved(i.imported), i.local = i.imported), this.checkLVal(i.local, 2), t.push(this.finishNode(i, "ImportSpecifier")) } return t }, KD.adaptDirectivePrologue = function (t) { for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)t[e].directive = t[e].expression.raw.slice(1, -1) }, KD.isDirectiveCandidate = function (t) { return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && ('"' === this.input[t.start] || "'" === this.input[t.start]) }; var nN = WD.prototype; nN.toAssignable = function (t, e, n) { if (this.options.ecmaVersion >= 6 && t) switch (t.type) { case "Identifier": this.inAsync && "await" === t.name && this.raise(t.start, "Cannot use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": case "RestElement": break; case "ObjectExpression": t.type = "ObjectPattern", n && this.checkPatternErrors(n, !0); for (var r = 0, i = t.properties; r < i.length; r += 1) { var o = i[r]; this.toAssignable(o, e), "RestElement" !== o.type || "ArrayPattern" !== o.argument.type && "ObjectPattern" !== o.argument.type || this.raise(o.argument.start, "Unexpected token") } break; case "Property": "init" !== t.kind && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e); break; case "ArrayExpression": t.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(t.elements, e); break; case "SpreadElement": t.type = "RestElement", this.toAssignable(t.argument, e), "AssignmentPattern" === t.argument.type && this.raise(t.argument.start, "Rest elements cannot have a default value"); break; case "AssignmentExpression": "=" !== t.operator && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e); case "AssignmentPattern": break; case "ParenthesizedExpression": this.toAssignable(t.expression, e, n); break; case "ChainExpression": this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": if (!e) break; default: this.raise(t.start, "Assigning to rvalue") } else n && this.checkPatternErrors(n, !0); return t }, nN.toAssignableList = function (t, e) { for (var n = t.length, r = 0; r < n; r++) { var i = t[r]; i && this.toAssignable(i, e) } if (n) { var o = t[n - 1]; 6 === this.options.ecmaVersion && e && o && "RestElement" === o.type && "Identifier" !== o.argument.type && this.unexpected(o.argument.start) } return t }, nN.parseSpread = function (t) { var e = this.startNode(); return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement") }, nN.parseRestBinding = function () { var t = this.startNode(); return this.next(), 6 === this.options.ecmaVersion && this.type !== AD.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement") }, nN.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case AD.bracketL: var t = this.startNode(); return this.next(), t.elements = this.parseBindingList(AD.bracketR, !0, !0), this.finishNode(t, "ArrayPattern"); case AD.braceL: return this.parseObj(!0) }return this.parseIdent() }, nN.parseBindingList = function (t, e, n) { for (var r = [], i = !0; !this.eat(t);)if (i ? i = !1 : this.expect(AD.comma), e && this.type === AD.comma) r.push(null); else { if (n && this.afterTrailingComma(t)) break; if (this.type === AD.ellipsis) { var o = this.parseRestBinding(); this.parseBindingListItem(o), r.push(o), this.type === AD.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t); break } var a = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(a), r.push(a) } return r }, nN.parseBindingListItem = function (t) { return t }, nN.parseMaybeDefault = function (t, e, n) { if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(AD.eq)) return n; var r = this.startNodeAt(t, e); return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, "AssignmentPattern") }, nN.checkLVal = function (t, e, n) { switch (void 0 === e && (e = 0), t.type) { case "Identifier": 2 === e && "let" === t.name && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), n && (ND(n, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), n[t.name] = !0), 0 !== e && 5 !== e && this.declareName(t.name, e, t.start); break; case "ChainExpression": this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": e && this.raiseRecoverable(t.start, "Binding member expression"); break; case "ObjectPattern": for (var r = 0, i = t.properties; r < i.length; r += 1) { var o = i[r]; this.checkLVal(o, e, n) } break; case "Property": this.checkLVal(t.value, e, n); break; case "ArrayPattern": for (var a = 0, s = t.elements; a < s.length; a += 1) { var l = s[a]; l && this.checkLVal(l, e, n) } break; case "AssignmentPattern": this.checkLVal(t.left, e, n); break; case "RestElement": this.checkLVal(t.argument, e, n); break; case "ParenthesizedExpression": this.checkLVal(t.expression, e, n); break; default: this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue") } }; var rN = WD.prototype; rN.checkPropClash = function (t, e, n) { if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === t.type || this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) { var r, i = t.key; switch (i.type) { case "Identifier": r = i.name; break; case "Literal": r = String(i.value); break; default: return }var o = t.kind; if (this.options.ecmaVersion >= 6) "__proto__" === r && "init" === o && (e.proto && (n ? n.doubleProto < 0 && (n.doubleProto = i.start) : this.raiseRecoverable(i.start, "Redefinition of __proto__ property")), e.proto = !0); else { var a = e[r = "$" + r]; if (a) ("init" === o ? this.strict && a.init || a.get || a.set : a.init || a[o]) && this.raiseRecoverable(i.start, "Redefinition of property"); else a = e[r] = { init: !1, get: !1, set: !1 }; a[o] = !0 } } }, rN.parseExpression = function (t, e) { var n = this.start, r = this.startLoc, i = this.parseMaybeAssign(t, e); if (this.type === AD.comma) { var o = this.startNodeAt(n, r); for (o.expressions = [i]; this.eat(AD.comma);)o.expressions.push(this.parseMaybeAssign(t, e)); return this.finishNode(o, "SequenceExpression") } return i }, rN.parseMaybeAssign = function (t, e, n) { if (this.isContextual("yield")) { if (this.inGenerator) return this.parseYield(t); this.exprAllowed = !1 } var r = !1, i = -1, o = -1; e ? (i = e.parenthesizedAssign, o = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new YD, r = !0); var a = this.start, s = this.startLoc; this.type !== AD.parenL && this.type !== AD.name || (this.potentialArrowAt = this.start); var l = this.parseMaybeConditional(t, e); if (n && (l = n.call(this, l, a, s)), this.type.isAssign) { var u = this.startNodeAt(a, s); return u.operator = this.value, u.left = this.type === AD.eq ? this.toAssignable(l, !1, e) : l, r || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= u.left.start && (e.shorthandAssign = -1), this.checkLVal(l), this.next(), u.right = this.parseMaybeAssign(t), this.finishNode(u, "AssignmentExpression") } return r && this.checkExpressionErrors(e, !0), i > -1 && (e.parenthesizedAssign = i), o > -1 && (e.trailingComma = o), l }, rN.parseMaybeConditional = function (t, e) { var n = this.start, r = this.startLoc, i = this.parseExprOps(t, e); if (this.checkExpressionErrors(e)) return i; if (this.eat(AD.question)) { var o = this.startNodeAt(n, r); return o.test = i, o.consequent = this.parseMaybeAssign(), this.expect(AD.colon), o.alternate = this.parseMaybeAssign(t), this.finishNode(o, "ConditionalExpression") } return i }, rN.parseExprOps = function (t, e) { var n = this.start, r = this.startLoc, i = this.parseMaybeUnary(e, !1); return this.checkExpressionErrors(e) || i.start === n && "ArrowFunctionExpression" === i.type ? i : this.parseExprOp(i, n, r, -1, t) }, rN.parseExprOp = function (t, e, n, r, i) { var o = this.type.binop; if (null != o && (!i || this.type !== AD._in) && o > r) { var a = this.type === AD.logicalOR || this.type === AD.logicalAND, s = this.type === AD.coalesce; s && (o = AD.logicalAND.binop); var l = this.value; this.next(); var u = this.start, c = this.startLoc, p = this.parseExprOp(this.parseMaybeUnary(null, !1), u, c, o, i), h = this.buildBinary(e, n, t, p, l, a || s); return (a && this.type === AD.coalesce || s && (this.type === AD.logicalOR || this.type === AD.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(h, e, n, r, i) } return t }, rN.buildBinary = function (t, e, n, r, i, o) { var a = this.startNodeAt(t, e); return a.left = n, a.operator = i, a.right = r, this.finishNode(a, o ? "LogicalExpression" : "BinaryExpression") }, rN.parseMaybeUnary = function (t, e) { var n, r = this.start, i = this.startLoc; if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) n = this.parseAwait(), e = !0; else if (this.type.prefix) { var o = this.startNode(), a = this.type === AD.incDec; o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), a ? this.checkLVal(o.argument) : this.strict && "delete" === o.operator && "Identifier" === o.argument.type ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(o, a ? "UpdateExpression" : "UnaryExpression") } else { if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t)) return n; for (; this.type.postfix && !this.canInsertSemicolon();) { var s = this.startNodeAt(r, i); s.operator = this.value, s.prefix = !1, s.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(s, "UpdateExpression") } } return !e && this.eat(AD.starstar) ? this.buildBinary(r, i, n, this.parseMaybeUnary(null, !1), "**", !1) : n }, rN.parseExprSubscripts = function (t) { var e = this.start, n = this.startLoc, r = this.parseExprAtom(t); if ("ArrowFunctionExpression" === r.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return r; var i = this.parseSubscripts(r, e, n); return t && "MemberExpression" === i.type && (t.parenthesizedAssign >= i.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= i.start && (t.parenthesizedBind = -1)), i }, rN.parseSubscripts = function (t, e, n, r) { for (var i = this.options.ecmaVersion >= 8 && "Identifier" === t.type && "async" === t.name && this.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && this.potentialArrowAt === t.start, o = !1; ;) { var a = this.parseSubscript(t, e, n, r, i, o); if (a.optional && (o = !0), a === t || "ArrowFunctionExpression" === a.type) { if (o) { var s = this.startNodeAt(e, n); s.expression = a, a = this.finishNode(s, "ChainExpression") } return a } t = a } }, rN.parseSubscript = function (t, e, n, r, i, o) { var a = this.options.ecmaVersion >= 11, s = a && this.eat(AD.questionDot); r && s && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); var l = this.eat(AD.bracketL); if (l || s && this.type !== AD.parenL && this.type !== AD.backQuote || this.eat(AD.dot)) { var u = this.startNodeAt(e, n); u.object = t, u.property = l ? this.parseExpression() : this.parseIdent("never" !== this.options.allowReserved), u.computed = !!l, l && this.expect(AD.bracketR), a && (u.optional = s), t = this.finishNode(u, "MemberExpression") } else if (!r && this.eat(AD.parenL)) { var c = new YD, p = this.yieldPos, h = this.awaitPos, f = this.awaitIdentPos; this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0; var d = this.parseExprList(AD.parenR, this.options.ecmaVersion >= 8, !1, c); if (i && !s && !this.canInsertSemicolon() && this.eat(AD.arrow)) return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = h, this.awaitIdentPos = f, this.parseArrowExpression(this.startNodeAt(e, n), d, !0); this.checkExpressionErrors(c, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = h || this.awaitPos, this.awaitIdentPos = f || this.awaitIdentPos; var m = this.startNodeAt(e, n); m.callee = t, m.arguments = d, a && (m.optional = s), t = this.finishNode(m, "CallExpression") } else if (this.type === AD.backQuote) { (s || o) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions"); var v = this.startNodeAt(e, n); v.tag = t, v.quasi = this.parseTemplate({ isTagged: !0 }), t = this.finishNode(v, "TaggedTemplateExpression") } return t }, rN.parseExprAtom = function (t) { this.type === AD.slash && this.readRegexp(); var e, n = this.potentialArrowAt === this.start; switch (this.type) { case AD._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), e = this.startNode(), this.next(), this.type !== AD.parenL || this.allowDirectSuper || this.raise(e.start, "super() call outside constructor of a subclass"), this.type !== AD.dot && this.type !== AD.bracketL && this.type !== AD.parenL && this.unexpected(), this.finishNode(e, "Super"); case AD._this: return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression"); case AD.name: var r = this.start, i = this.startLoc, o = this.containsEsc, a = this.parseIdent(!1); if (this.options.ecmaVersion >= 8 && !o && "async" === a.name && !this.canInsertSemicolon() && this.eat(AD._function)) return this.parseFunction(this.startNodeAt(r, i), 0, !1, !0); if (n && !this.canInsertSemicolon()) { if (this.eat(AD.arrow)) return this.parseArrowExpression(this.startNodeAt(r, i), [a], !1); if (this.options.ecmaVersion >= 8 && "async" === a.name && this.type === AD.name && !o) return a = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(AD.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(r, i), [a], !0) } return a; case AD.regexp: var s = this.value; return (e = this.parseLiteral(s.value)).regex = { pattern: s.pattern, flags: s.flags }, e; case AD.num: case AD.string: return this.parseLiteral(this.value); case AD._null: case AD._true: case AD._false: return (e = this.startNode()).value = this.type === AD._null ? null : this.type === AD._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal"); case AD.parenL: var l = this.start, u = this.parseParenAndDistinguishExpression(n); return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (t.parenthesizedAssign = l), t.parenthesizedBind < 0 && (t.parenthesizedBind = l)), u; case AD.bracketL: return e = this.startNode(), this.next(), e.elements = this.parseExprList(AD.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression"); case AD.braceL: return this.parseObj(!1, t); case AD._function: return e = this.startNode(), this.next(), this.parseFunction(e, 0); case AD._class: return this.parseClass(this.startNode(), !1); case AD._new: return this.parseNew(); case AD.backQuote: return this.parseTemplate(); case AD._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected(); default: this.unexpected() } }, rN.parseExprImport = function () { var t = this.startNode(); this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"); var e = this.parseIdent(!0); switch (this.type) { case AD.parenL: return this.parseDynamicImport(t); case AD.dot: return t.meta = e, this.parseImportMeta(t); default: this.unexpected() } }, rN.parseDynamicImport = function (t) { if (this.next(), t.source = this.parseMaybeAssign(), !this.eat(AD.parenR)) { var e = this.start; this.eat(AD.comma) && this.eat(AD.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e) } return this.finishNode(t, "ImportExpression") }, rN.parseImportMeta = function (t) { this.next(); var e = this.containsEsc; return t.property = this.parseIdent(!0), "meta" !== t.property.name && this.raiseRecoverable(t.property.start, "The only valid meta property for import is 'import.meta'"), e && this.raiseRecoverable(t.start, "'import.meta' must not contain escaped characters"), "module" !== this.options.sourceType && this.raiseRecoverable(t.start, "Cannot use 'import.meta' outside a module"), this.finishNode(t, "MetaProperty") }, rN.parseLiteral = function (t) { var e = this.startNode(); return e.value = t, e.raw = this.input.slice(this.start, this.end), 110 === e.raw.charCodeAt(e.raw.length - 1) && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(e, "Literal") }, rN.parseParenExpression = function () { this.expect(AD.parenL); var t = this.parseExpression(); return this.expect(AD.parenR), t }, rN.parseParenAndDistinguishExpression = function (t) { var e, n = this.start, r = this.startLoc, i = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var o, a = this.start, s = this.startLoc, l = [], u = !0, c = !1, p = new YD, h = this.yieldPos, f = this.awaitPos; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== AD.parenR;) { if (u ? u = !1 : this.expect(AD.comma), i && this.afterTrailingComma(AD.parenR, !0)) { c = !0; break } if (this.type === AD.ellipsis) { o = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === AD.comma && this.raise(this.start, "Comma is not permitted after the rest element"); break } l.push(this.parseMaybeAssign(!1, p, this.parseParenItem)) } var d = this.start, m = this.startLoc; if (this.expect(AD.parenR), t && !this.canInsertSemicolon() && this.eat(AD.arrow)) return this.checkPatternErrors(p, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = h, this.awaitPos = f, this.parseParenArrowList(n, r, l); l.length && !c || this.unexpected(this.lastTokStart), o && this.unexpected(o), this.checkExpressionErrors(p, !0), this.yieldPos = h || this.yieldPos, this.awaitPos = f || this.awaitPos, l.length > 1 ? ((e = this.startNodeAt(a, s)).expressions = l, this.finishNodeAt(e, "SequenceExpression", d, m)) : e = l[0] } else e = this.parseParenExpression(); if (this.options.preserveParens) { var v = this.startNodeAt(n, r); return v.expression = e, this.finishNode(v, "ParenthesizedExpression") } return e }, rN.parseParenItem = function (t) { return t }, rN.parseParenArrowList = function (t, e, n) { return this.parseArrowExpression(this.startNodeAt(t, e), n) }; var iN = []; rN.parseNew = function () { this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new"); var t = this.startNode(), e = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(AD.dot)) { t.meta = e; var n = this.containsEsc; return t.property = this.parseIdent(!0), "target" !== t.property.name && this.raiseRecoverable(t.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(t.start, "'new.target' must not contain escaped characters"), this.inNonArrowFunction() || this.raiseRecoverable(t.start, "'new.target' can only be used in functions"), this.finishNode(t, "MetaProperty") } var r = this.start, i = this.startLoc, o = this.type === AD._import; return t.callee = this.parseSubscripts(this.parseExprAtom(), r, i, !0), o && "ImportExpression" === t.callee.type && this.raise(r, "Cannot use new with import()"), this.eat(AD.parenL) ? t.arguments = this.parseExprList(AD.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = iN, this.finishNode(t, "NewExpression") }, rN.parseTemplateElement = function (t) { var e = t.isTagged, n = this.startNode(); return this.type === AD.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = { raw: this.value, cooked: null }) : n.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), n.tail = this.type === AD.backQuote, this.finishNode(n, "TemplateElement") }, rN.parseTemplate = function (t) { void 0 === t && (t = {}); var e = t.isTagged; void 0 === e && (e = !1); var n = this.startNode(); this.next(), n.expressions = []; var r = this.parseTemplateElement({ isTagged: e }); for (n.quasis = [r]; !r.tail;)this.type === AD.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(AD.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(AD.braceR), n.quasis.push(r = this.parseTemplateElement({ isTagged: e })); return this.next(), this.finishNode(n, "TemplateLiteral") }, rN.isAsyncProp = function (t) { return !t.computed && "Identifier" === t.key.type && "async" === t.key.name && (this.type === AD.name || this.type === AD.num || this.type === AD.string || this.type === AD.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === AD.star) && !MD.test(this.input.slice(this.lastTokEnd, this.start)) }, rN.parseObj = function (t, e) { var n = this.startNode(), r = !0, i = {}; for (n.properties = [], this.next(); !this.eat(AD.braceR);) { if (r) r = !1; else if (this.expect(AD.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(AD.braceR)) break; var o = this.parseProperty(t, e); t || this.checkPropClash(o, i, e), n.properties.push(o) } return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression") }, rN.parseProperty = function (t, e) { var n, r, i, o, a = this.startNode(); if (this.options.ecmaVersion >= 9 && this.eat(AD.ellipsis)) return t ? (a.argument = this.parseIdent(!1), this.type === AD.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(a, "RestElement")) : (this.type === AD.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), a.argument = this.parseMaybeAssign(!1, e), this.type === AD.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(a, "SpreadElement")); this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (t || e) && (i = this.start, o = this.startLoc), t || (n = this.eat(AD.star))); var s = this.containsEsc; return this.parsePropertyName(a), !t && !s && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(a) ? (r = !0, n = this.options.ecmaVersion >= 9 && this.eat(AD.star), this.parsePropertyName(a, e)) : r = !1, this.parsePropertyValue(a, t, n, r, i, o, e, s), this.finishNode(a, "Property") }, rN.parsePropertyValue = function (t, e, n, r, i, o, a, s) { if ((n || r) && this.type === AD.colon && this.unexpected(), this.eat(AD.colon)) t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), t.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === AD.parenL) e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(n, r); else if (e || s || !(this.options.ecmaVersion >= 5) || t.computed || "Identifier" !== t.key.type || "get" !== t.key.name && "set" !== t.key.name || this.type === AD.comma || this.type === AD.braceR || this.type === AD.eq) this.options.ecmaVersion >= 6 && !t.computed && "Identifier" === t.key.type ? ((n || r) && this.unexpected(), this.checkUnreserved(t.key), "await" !== t.key.name || this.awaitIdentPos || (this.awaitIdentPos = i), t.kind = "init", e ? t.value = this.parseMaybeDefault(i, o, t.key) : this.type === AD.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), t.value = this.parseMaybeDefault(i, o, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected(); else { (n || r) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1); var l = "get" === t.kind ? 0 : 1; if (t.value.params.length !== l) { var u = t.value.start; "get" === t.kind ? this.raiseRecoverable(u, "getter should have no params") : this.raiseRecoverable(u, "setter should have exactly one param") } else "set" === t.kind && "RestElement" === t.value.params[0].type && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params") } }, rN.parsePropertyName = function (t) { if (this.options.ecmaVersion >= 6) { if (this.eat(AD.bracketL)) return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(AD.bracketR), t.key; t.computed = !1 } return t.key = this.type === AD.num || this.type === AD.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved) }, rN.initFunction = function (t) { t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1) }, rN.parseMethod = function (t, e, n) { var r = this.startNode(), i = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos; return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = t), this.options.ecmaVersion >= 8 && (r.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | HD(e, r.generator) | (n ? 128 : 0)), this.expect(AD.parenL), r.params = this.parseBindingList(AD.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1, !0), this.yieldPos = i, this.awaitPos = o, this.awaitIdentPos = a, this.finishNode(r, "FunctionExpression") }, rN.parseArrowExpression = function (t, e, n) { var r = this.yieldPos, i = this.awaitPos, o = this.awaitIdentPos; return this.enterScope(16 | HD(n, !1)), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1), this.yieldPos = r, this.awaitPos = i, this.awaitIdentPos = o, this.finishNode(t, "ArrowFunctionExpression") }, rN.parseFunctionBody = function (t, e, n) { var r = e && this.type !== AD.braceL, i = this.strict, o = !1; if (r) t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1); else { var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params); i && !a || (o = this.strictDirective(this.end)) && a && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"); var s = this.labels; this.labels = [], o && (this.strict = !0), this.checkParams(t, !i && !o && !e && !n && this.isSimpleParamList(t.params)), this.strict && t.id && this.checkLVal(t.id, 5), t.body = this.parseBlock(!1, void 0, o && !i), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = s } this.exitScope() }, rN.isSimpleParamList = function (t) { for (var e = 0, n = t; e < n.length; e += 1) { if ("Identifier" !== n[e].type) return !1 } return !0 }, rN.checkParams = function (t, e) { for (var n = {}, r = 0, i = t.params; r < i.length; r += 1) { var o = i[r]; this.checkLVal(o, 1, e ? null : n) } }, rN.parseExprList = function (t, e, n, r) { for (var i = [], o = !0; !this.eat(t);) { if (o) o = !1; else if (this.expect(AD.comma), e && this.afterTrailingComma(t)) break; var a = void 0; n && this.type === AD.comma ? a = null : this.type === AD.ellipsis ? (a = this.parseSpread(r), r && this.type === AD.comma && r.trailingComma < 0 && (r.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, r), i.push(a) } return i }, rN.checkUnreserved = function (t) { var e = t.start, n = t.end, r = t.name; (this.inGenerator && "yield" === r && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === r && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(r) && this.raise(e, "Unexpected keyword '" + r + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(e, n).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(r) && (this.inAsync || "await" !== r || this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + r + "' is reserved")) }, rN.parseIdent = function (t, e) { var n = this.startNode(); return this.type === AD.name ? n.name = this.value : this.type.keyword ? (n.name = this.type.keyword, "class" !== n.name && "function" !== n.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), this.next(!!t), this.finishNode(n, "Identifier"), t || (this.checkUnreserved(n), "await" !== n.name || this.awaitIdentPos || (this.awaitIdentPos = n.start)), n }, rN.parseYield = function (t) { this.yieldPos || (this.yieldPos = this.start); var e = this.startNode(); return this.next(), this.type === AD.semi || this.canInsertSemicolon() || this.type !== AD.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(AD.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression") }, rN.parseAwait = function () { this.awaitPos || (this.awaitPos = this.start); var t = this.startNode(); return this.next(), t.argument = this.parseMaybeUnary(null, !1), this.finishNode(t, "AwaitExpression") }; var oN = WD.prototype; oN.raise = function (t, e) { var n = UD(this.input, t); e += " (" + n.line + ":" + n.column + ")"; var r = new SyntaxError(e); throw r.pos = t, r.loc = n, r.raisedAt = this.pos, r }, oN.raiseRecoverable = oN.raise, oN.curPosition = function () { if (this.options.locations) return new BD(this.curLine, this.pos - this.lineStart) }; var aN = WD.prototype, sN = function (t) { this.flags = t, this.var = [], this.lexical = [], this.functions = [] }; aN.enterScope = function (t) { this.scopeStack.push(new sN(t)) }, aN.exitScope = function () { this.scopeStack.pop() }, aN.treatFunctionsAsVarInScope = function (t) { return 2 & t.flags || !this.inModule && 1 & t.flags }, aN.declareName = function (t, e, n) { var r = !1; if (2 === e) { var i = this.currentScope(); r = i.lexical.indexOf(t) > -1 || i.functions.indexOf(t) > -1 || i.var.indexOf(t) > -1, i.lexical.push(t), this.inModule && 1 & i.flags && delete this.undefinedExports[t] } else if (4 === e) { this.currentScope().lexical.push(t) } else if (3 === e) { var o = this.currentScope(); r = this.treatFunctionsAsVar ? o.lexical.indexOf(t) > -1 : o.lexical.indexOf(t) > -1 || o.var.indexOf(t) > -1, o.functions.push(t) } else for (var a = this.scopeStack.length - 1; a >= 0; --a) { var s = this.scopeStack[a]; if (s.lexical.indexOf(t) > -1 && !(32 & s.flags && s.lexical[0] === t) || !this.treatFunctionsAsVarInScope(s) && s.functions.indexOf(t) > -1) { r = !0; break } if (s.var.push(t), this.inModule && 1 & s.flags && delete this.undefinedExports[t], 3 & s.flags) break } r && this.raiseRecoverable(n, "Identifier '" + t + "' has already been declared") }, aN.checkLocalExport = function (t) { -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && (this.undefinedExports[t.name] = t) }, aN.currentScope = function () { return this.scopeStack[this.scopeStack.length - 1] }, aN.currentVarScope = function () { for (var t = this.scopeStack.length - 1; ; t--) { var e = this.scopeStack[t]; if (3 & e.flags) return e } }, aN.currentThisScope = function () { for (var t = this.scopeStack.length - 1; ; t--) { var e = this.scopeStack[t]; if (3 & e.flags && !(16 & e.flags)) return e } }; var lN = function (t, e, n) { this.type = "", this.start = e, this.end = 0, t.options.locations && (this.loc = new jD(t, n)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [e, 0]) }, uN = WD.prototype; function cN(t, e, n, r) { return t.type = e, t.end = n, this.options.locations && (t.loc.end = r), this.options.ranges && (t.range[1] = n), t } uN.startNode = function () { return new lN(this, this.start, this.startLoc) }, uN.startNodeAt = function (t, e) { return new lN(this, t, e) }, uN.finishNode = function (t, e) { return cN.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc) }, uN.finishNodeAt = function (t, e, n, r) { return cN.call(this, t, e, n, r) }; var pN = function (t, e, n, r, i) { this.token = t, this.isExpr = !!e, this.preserveSpace = !!n, this.override = r, this.generator = !!i }, hN = { b_stat: new pN("{", !1), b_expr: new pN("{", !0), b_tmpl: new pN("${", !1), p_stat: new pN("(", !1), p_expr: new pN("(", !0), q_tmpl: new pN("`", !0, !0, (function (t) { return t.tryReadTemplateToken() })), f_stat: new pN("function", !1), f_expr: new pN("function", !0), f_expr_gen: new pN("function", !0, !1, null, !0), f_gen: new pN("function", !1, !1, null, !0) }, fN = WD.prototype; fN.initialContext = function () { return [hN.b_stat] }, fN.braceIsBlock = function (t) { var e = this.curContext(); return e === hN.f_expr || e === hN.f_stat || (t !== AD.colon || e !== hN.b_stat && e !== hN.b_expr ? t === AD._return || t === AD.name && this.exprAllowed ? MD.test(this.input.slice(this.lastTokEnd, this.start)) : t === AD._else || t === AD.semi || t === AD.eof || t === AD.parenR || t === AD.arrow || (t === AD.braceL ? e === hN.b_stat : t !== AD._var && t !== AD._const && t !== AD.name && !this.exprAllowed) : !e.isExpr) }, fN.inGeneratorContext = function () { for (var t = this.context.length - 1; t >= 1; t--) { var e = this.context[t]; if ("function" === e.token) return e.generator } return !1 }, fN.updateContext = function (t) { var e, n = this.type; n.keyword && t === AD.dot ? this.exprAllowed = !1 : (e = n.updateContext) ? e.call(this, t) : this.exprAllowed = n.beforeExpr }, AD.parenR.updateContext = AD.braceR.updateContext = function () { if (1 !== this.context.length) { var t = this.context.pop(); t === hN.b_stat && "function" === this.curContext().token && (t = this.context.pop()), this.exprAllowed = !t.isExpr } else this.exprAllowed = !0 }, AD.braceL.updateContext = function (t) { this.context.push(this.braceIsBlock(t) ? hN.b_stat : hN.b_expr), this.exprAllowed = !0 }, AD.dollarBraceL.updateContext = function () { this.context.push(hN.b_tmpl), this.exprAllowed = !0 }, AD.parenL.updateContext = function (t) { var e = t === AD._if || t === AD._for || t === AD._with || t === AD._while; this.context.push(e ? hN.p_stat : hN.p_expr), this.exprAllowed = !0 }, AD.incDec.updateContext = function () { }, AD._function.updateContext = AD._class.updateContext = function (t) { !t.beforeExpr || t === AD.semi || t === AD._else || t === AD._return && MD.test(this.input.slice(this.lastTokEnd, this.start)) || (t === AD.colon || t === AD.braceL) && this.curContext() === hN.b_stat ? this.context.push(hN.f_stat) : this.context.push(hN.f_expr), this.exprAllowed = !1 }, AD.backQuote.updateContext = function () { this.curContext() === hN.q_tmpl ? this.context.pop() : this.context.push(hN.q_tmpl), this.exprAllowed = !1 }, AD.star.updateContext = function (t) { if (t === AD._function) { var e = this.context.length - 1; this.context[e] === hN.f_expr ? this.context[e] = hN.f_expr_gen : this.context[e] = hN.f_gen } this.exprAllowed = !0 }, AD.name.updateContext = function (t) { var e = !1; this.options.ecmaVersion >= 6 && t !== AD.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e }; var dN = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", mN = dN + " Extended_Pictographic", vN = { 9: dN, 10: mN, 11: "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic" }, yN = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", gN = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", _N = gN + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", xN = { 9: gN, 10: _N, 11: "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho" }, bN = {}; function wN(t) { var e = bN[t] = { binary: FD(vN[t] + " " + yN), nonBinary: { General_Category: FD(yN), Script: FD(xN[t]) } }; e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions } wN(9), wN(10), wN(11); var SN = WD.prototype, EN = function (t) { this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = bN[t.options.ecmaVersion >= 11 ? 11 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [] }; function CN(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) } function TN(t) { return 36 === t || t >= 40 && t <= 43 || 46 === t || 63 === t || t >= 91 && t <= 94 || t >= 123 && t <= 125 } function AN(t) { return t >= 65 && t <= 90 || t >= 97 && t <= 122 } function MN(t) { return AN(t) || 95 === t } function ON(t) { return MN(t) || kN(t) } function kN(t) { return t >= 48 && t <= 57 } function IN(t) { return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 } function PN(t) { return t >= 65 && t <= 70 ? t - 65 + 10 : t >= 97 && t <= 102 ? t - 97 + 10 : t - 48 } function LN(t) { return t >= 48 && t <= 55 } EN.prototype.reset = function (t, e, n) { var r = -1 !== n.indexOf("u"); this.start = 0 | t, this.source = e + "", this.flags = n, this.switchU = r && this.parser.options.ecmaVersion >= 6, this.switchN = r && this.parser.options.ecmaVersion >= 9 }, EN.prototype.raise = function (t) { this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t) }, EN.prototype.at = function (t, e) { void 0 === e && (e = !1); var n = this.source, r = n.length; if (t >= r) return -1; var i = n.charCodeAt(t); if (!e && !this.switchU || i <= 55295 || i >= 57344 || t + 1 >= r) return i; var o = n.charCodeAt(t + 1); return o >= 56320 && o <= 57343 ? (i << 10) + o - 56613888 : i }, EN.prototype.nextIndex = function (t, e) { void 0 === e && (e = !1); var n = this.source, r = n.length; if (t >= r) return r; var i, o = n.charCodeAt(t); return !e && !this.switchU || o <= 55295 || o >= 57344 || t + 1 >= r || (i = n.charCodeAt(t + 1)) < 56320 || i > 57343 ? t + 1 : t + 2 }, EN.prototype.current = function (t) { return void 0 === t && (t = !1), this.at(this.pos, t) }, EN.prototype.lookahead = function (t) { return void 0 === t && (t = !1), this.at(this.nextIndex(this.pos, t), t) }, EN.prototype.advance = function (t) { void 0 === t && (t = !1), this.pos = this.nextIndex(this.pos, t) }, EN.prototype.eat = function (t, e) { return void 0 === e && (e = !1), this.current(e) === t && (this.advance(e), !0) }, SN.validateRegExpFlags = function (t) { for (var e = t.validFlags, n = t.flags, r = 0; r < n.length; r++) { var i = n.charAt(r); -1 === e.indexOf(i) && this.raise(t.start, "Invalid regular expression flag"), n.indexOf(i, r + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag") } }, SN.validateRegExpPattern = function (t) { this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t)) }, SN.regexp_pattern = function (t) { t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape"); for (var e = 0, n = t.backReferenceNames; e < n.length; e += 1) { var r = n[e]; -1 === t.groupNames.indexOf(r) && t.raise("Invalid named capture referenced") } }, SN.regexp_disjunction = function (t) { for (this.regexp_alternative(t); t.eat(124);)this.regexp_alternative(t); this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets") }, SN.regexp_alternative = function (t) { for (; t.pos < t.source.length && this.regexp_eatTerm(t);); }, SN.regexp_eatTerm = function (t) { return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : !!(t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) && (this.regexp_eatQuantifier(t), !0) }, SN.regexp_eatAssertion = function (t) { var e = t.pos; if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36)) return !0; if (t.eat(92)) { if (t.eat(66) || t.eat(98)) return !0; t.pos = e } if (t.eat(40) && t.eat(63)) { var n = !1; if (this.options.ecmaVersion >= 9 && (n = t.eat(60)), t.eat(61) || t.eat(33)) return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !n, !0 } return t.pos = e, !1 }, SN.regexp_eatQuantifier = function (t, e) { return void 0 === e && (e = !1), !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0) }, SN.regexp_eatQuantifierPrefix = function (t, e) { return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e) }, SN.regexp_eatBracedQuantifier = function (t, e) { var n = t.pos; if (t.eat(123)) { var r = 0, i = -1; if (this.regexp_eatDecimalDigits(t) && (r = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (i = t.lastIntValue), t.eat(125))) return -1 !== i && i < r && !e && t.raise("numbers out of order in {} quantifier"), !0; t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = n } return !1 }, SN.regexp_eatAtom = function (t) { return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) }, SN.regexp_eatReverseSolidusAtomEscape = function (t) { var e = t.pos; if (t.eat(92)) { if (this.regexp_eatAtomEscape(t)) return !0; t.pos = e } return !1 }, SN.regexp_eatUncapturingGroup = function (t) { var e = t.pos; if (t.eat(40)) { if (t.eat(63) && t.eat(58)) { if (this.regexp_disjunction(t), t.eat(41)) return !0; t.raise("Unterminated group") } t.pos = e } return !1 }, SN.regexp_eatCapturingGroup = function (t) { if (t.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : 63 === t.current() && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(41)) return t.numCapturingParens += 1, !0; t.raise("Unterminated group") } return !1 }, SN.regexp_eatExtendedAtom = function (t) { return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t) }, SN.regexp_eatInvalidBracedQuantifier = function (t) { return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1 }, SN.regexp_eatSyntaxCharacter = function (t) { var e = t.current(); return !!TN(e) && (t.lastIntValue = e, t.advance(), !0) }, SN.regexp_eatPatternCharacters = function (t) { for (var e = t.pos, n = 0; -1 !== (n = t.current()) && !TN(n);)t.advance(); return t.pos !== e }, SN.regexp_eatExtendedPatternCharacter = function (t) { var e = t.current(); return !(-1 === e || 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || 91 === e || 94 === e || 124 === e) && (t.advance(), !0) }, SN.regexp_groupSpecifier = function (t) { if (t.eat(63)) { if (this.regexp_eatGroupName(t)) return -1 !== t.groupNames.indexOf(t.lastStringValue) && t.raise("Duplicate capture group name"), void t.groupNames.push(t.lastStringValue); t.raise("Invalid group") } }, SN.regexp_eatGroupName = function (t) { if (t.lastStringValue = "", t.eat(60)) { if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0; t.raise("Invalid capture group name") } return !1 }, SN.regexp_eatRegExpIdentifierName = function (t) { if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) { for (t.lastStringValue += CN(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t);)t.lastStringValue += CN(t.lastIntValue); return !0 } return !1 }, SN.regexp_eatRegExpIdentifierStart = function (t) { var e = t.pos, n = this.options.ecmaVersion >= 11, r = t.current(n); return t.advance(n), 92 === r && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (r = t.lastIntValue), function (t) { return _D(t, !0) || 36 === t || 95 === t }(r) ? (t.lastIntValue = r, !0) : (t.pos = e, !1) }, SN.regexp_eatRegExpIdentifierPart = function (t) { var e = t.pos, n = this.options.ecmaVersion >= 11, r = t.current(n); return t.advance(n), 92 === r && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (r = t.lastIntValue), function (t) { return xD(t, !0) || 36 === t || 95 === t || 8204 === t || 8205 === t }(r) ? (t.lastIntValue = r, !0) : (t.pos = e, !1) }, SN.regexp_eatAtomEscape = function (t) { return !!(this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t)) || (t.switchU && (99 === t.current() && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1) }, SN.regexp_eatBackReference = function (t) { var e = t.pos; if (this.regexp_eatDecimalEscape(t)) { var n = t.lastIntValue; if (t.switchU) return n > t.maxBackReference && (t.maxBackReference = n), !0; if (n <= t.numCapturingParens) return !0; t.pos = e } return !1 }, SN.regexp_eatKGroupName = function (t) { if (t.eat(107)) { if (this.regexp_eatGroupName(t)) return t.backReferenceNames.push(t.lastStringValue), !0; t.raise("Invalid named reference") } return !1 }, SN.regexp_eatCharacterEscape = function (t) { return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t) }, SN.regexp_eatCControlLetter = function (t) { var e = t.pos; if (t.eat(99)) { if (this.regexp_eatControlLetter(t)) return !0; t.pos = e } return !1 }, SN.regexp_eatZero = function (t) { return 48 === t.current() && !kN(t.lookahead()) && (t.lastIntValue = 0, t.advance(), !0) }, SN.regexp_eatControlEscape = function (t) { var e = t.current(); return 116 === e ? (t.lastIntValue = 9, t.advance(), !0) : 110 === e ? (t.lastIntValue = 10, t.advance(), !0) : 118 === e ? (t.lastIntValue = 11, t.advance(), !0) : 102 === e ? (t.lastIntValue = 12, t.advance(), !0) : 114 === e && (t.lastIntValue = 13, t.advance(), !0) }, SN.regexp_eatControlLetter = function (t) { var e = t.current(); return !!AN(e) && (t.lastIntValue = e % 32, t.advance(), !0) }, SN.regexp_eatRegExpUnicodeEscapeSequence = function (t, e) { void 0 === e && (e = !1); var n, r = t.pos, i = e || t.switchU; if (t.eat(117)) { if (this.regexp_eatFixedHexDigits(t, 4)) { var o = t.lastIntValue; if (i && o >= 55296 && o <= 56319) { var a = t.pos; if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) { var s = t.lastIntValue; if (s >= 56320 && s <= 57343) return t.lastIntValue = 1024 * (o - 55296) + (s - 56320) + 65536, !0 } t.pos = a, t.lastIntValue = o } return !0 } if (i && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && ((n = t.lastIntValue) >= 0 && n <= 1114111)) return !0; i && t.raise("Invalid unicode escape"), t.pos = r } return !1 }, SN.regexp_eatIdentityEscape = function (t) { if (t.switchU) return !!this.regexp_eatSyntaxCharacter(t) || !!t.eat(47) && (t.lastIntValue = 47, !0); var e = t.current(); return !(99 === e || t.switchN && 107 === e) && (t.lastIntValue = e, t.advance(), !0) }, SN.regexp_eatDecimalEscape = function (t) { t.lastIntValue = 0; var e = t.current(); if (e >= 49 && e <= 57) { do { t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance() } while ((e = t.current()) >= 48 && e <= 57); return !0 } return !1 }, SN.regexp_eatCharacterClassEscape = function (t) { var e = t.current(); if (function (t) { return 100 === t || 68 === t || 115 === t || 83 === t || 119 === t || 87 === t }(e)) return t.lastIntValue = -1, t.advance(), !0; if (t.switchU && this.options.ecmaVersion >= 9 && (80 === e || 112 === e)) { if (t.lastIntValue = -1, t.advance(), t.eat(123) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(125)) return !0; t.raise("Invalid property name") } return !1 }, SN.regexp_eatUnicodePropertyValueExpression = function (t) { var e = t.pos; if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) { var n = t.lastStringValue; if (this.regexp_eatUnicodePropertyValue(t)) { var r = t.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(t, n, r), !0 } } if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) { var i = t.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(t, i), !0 } return !1 }, SN.regexp_validateUnicodePropertyNameAndValue = function (t, e, n) { ND(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(n) || t.raise("Invalid property value") }, SN.regexp_validateUnicodePropertyNameOrValue = function (t, e) { t.unicodeProperties.binary.test(e) || t.raise("Invalid property name") }, SN.regexp_eatUnicodePropertyName = function (t) { var e = 0; for (t.lastStringValue = ""; MN(e = t.current());)t.lastStringValue += CN(e), t.advance(); return "" !== t.lastStringValue }, SN.regexp_eatUnicodePropertyValue = function (t) { var e = 0; for (t.lastStringValue = ""; ON(e = t.current());)t.lastStringValue += CN(e), t.advance(); return "" !== t.lastStringValue }, SN.regexp_eatLoneUnicodePropertyNameOrValue = function (t) { return this.regexp_eatUnicodePropertyValue(t) }, SN.regexp_eatCharacterClass = function (t) { if (t.eat(91)) { if (t.eat(94), this.regexp_classRanges(t), t.eat(93)) return !0; t.raise("Unterminated character class") } return !1 }, SN.regexp_classRanges = function (t) { for (; this.regexp_eatClassAtom(t);) { var e = t.lastIntValue; if (t.eat(45) && this.regexp_eatClassAtom(t)) { var n = t.lastIntValue; !t.switchU || -1 !== e && -1 !== n || t.raise("Invalid character class"), -1 !== e && -1 !== n && e > n && t.raise("Range out of order in character class") } } }, SN.regexp_eatClassAtom = function (t) { var e = t.pos; if (t.eat(92)) { if (this.regexp_eatClassEscape(t)) return !0; if (t.switchU) { var n = t.current(); (99 === n || LN(n)) && t.raise("Invalid class escape"), t.raise("Invalid escape") } t.pos = e } var r = t.current(); return 93 !== r && (t.lastIntValue = r, t.advance(), !0) }, SN.regexp_eatClassEscape = function (t) { var e = t.pos; if (t.eat(98)) return t.lastIntValue = 8, !0; if (t.switchU && t.eat(45)) return t.lastIntValue = 45, !0; if (!t.switchU && t.eat(99)) { if (this.regexp_eatClassControlLetter(t)) return !0; t.pos = e } return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) }, SN.regexp_eatClassControlLetter = function (t) { var e = t.current(); return !(!kN(e) && 95 !== e) && (t.lastIntValue = e % 32, t.advance(), !0) }, SN.regexp_eatHexEscapeSequence = function (t) { var e = t.pos; if (t.eat(120)) { if (this.regexp_eatFixedHexDigits(t, 2)) return !0; t.switchU && t.raise("Invalid escape"), t.pos = e } return !1 }, SN.regexp_eatDecimalDigits = function (t) { var e = t.pos, n = 0; for (t.lastIntValue = 0; kN(n = t.current());)t.lastIntValue = 10 * t.lastIntValue + (n - 48), t.advance(); return t.pos !== e }, SN.regexp_eatHexDigits = function (t) { var e = t.pos, n = 0; for (t.lastIntValue = 0; IN(n = t.current());)t.lastIntValue = 16 * t.lastIntValue + PN(n), t.advance(); return t.pos !== e }, SN.regexp_eatLegacyOctalEscapeSequence = function (t) { if (this.regexp_eatOctalDigit(t)) { var e = t.lastIntValue; if (this.regexp_eatOctalDigit(t)) { var n = t.lastIntValue; e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = 64 * e + 8 * n + t.lastIntValue : t.lastIntValue = 8 * e + n } else t.lastIntValue = e; return !0 } return !1 }, SN.regexp_eatOctalDigit = function (t) { var e = t.current(); return LN(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1) }, SN.regexp_eatFixedHexDigits = function (t, e) { var n = t.pos; t.lastIntValue = 0; for (var r = 0; r < e; ++r) { var i = t.current(); if (!IN(i)) return t.pos = n, !1; t.lastIntValue = 16 * t.lastIntValue + PN(i), t.advance() } return !0 }; var RN = function (t) { this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new jD(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]) }, DN = WD.prototype; function NN(t) { return "function" != typeof BigInt ? null : BigInt(t.replace(/_/g, "")) } function zN(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) } DN.next = function (t) { !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new RN(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, DN.getToken = function () { return this.next(), new RN(this) }, "undefined" != typeof Symbol && (DN[Symbol.iterator] = function () { var t = this; return { next: function () { var e = t.getToken(); return { done: e.type === AD.eof, value: e } } } }), DN.curContext = function () { return this.context[this.context.length - 1] }, DN.nextToken = function () { var t = this.curContext(); return t && t.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(AD.eof) : t.override ? t.override(this) : void this.readToken(this.fullCharCodeAtPos()) }, DN.readToken = function (t) { return _D(t, this.options.ecmaVersion >= 6) || 92 === t ? this.readWord() : this.getTokenFromCode(t) }, DN.fullCharCodeAtPos = function () { var t = this.input.charCodeAt(this.pos); return t <= 55295 || t >= 57344 ? t : (t << 10) + this.input.charCodeAt(this.pos + 1) - 56613888 }, DN.skipBlockComment = function () { var t, e = this.options.onComment && this.curPosition(), n = this.pos, r = this.input.indexOf("*/", this.pos += 2); if (-1 === r && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) for (OD.lastIndex = n; (t = OD.exec(this.input)) && t.index < this.pos;)++this.curLine, this.lineStart = t.index + t[0].length; this.options.onComment && this.options.onComment(!0, this.input.slice(n + 2, r), n, this.pos, e, this.curPosition()) }, DN.skipLineComment = function (t) { for (var e = this.pos, n = this.options.onComment && this.curPosition(), r = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !kD(r);)r = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, n, this.curPosition()) }, DN.skipSpace = function () { t: for (; this.pos < this.input.length;) { var t = this.input.charCodeAt(this.pos); switch (t) { case 32: case 160: ++this.pos; break; case 13: 10 === this.input.charCodeAt(this.pos + 1) && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break t }break; default: if (!(t > 8 && t < 14 || t >= 5760 && ID.test(String.fromCharCode(t)))) break t; ++this.pos } } }, DN.finishToken = function (t, e) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var n = this.type; this.type = t, this.value = e, this.updateContext(n) }, DN.readToken_dot = function () { var t = this.input.charCodeAt(this.pos + 1); if (t >= 48 && t <= 57) return this.readNumber(!0); var e = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && 46 === t && 46 === e ? (this.pos += 3, this.finishToken(AD.ellipsis)) : (++this.pos, this.finishToken(AD.dot)) }, DN.readToken_slash = function () { var t = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === t ? this.finishOp(AD.assign, 2) : this.finishOp(AD.slash, 1) }, DN.readToken_mult_modulo_exp = function (t) { var e = this.input.charCodeAt(this.pos + 1), n = 1, r = 42 === t ? AD.star : AD.modulo; return this.options.ecmaVersion >= 7 && 42 === t && 42 === e && (++n, r = AD.starstar, e = this.input.charCodeAt(this.pos + 2)), 61 === e ? this.finishOp(AD.assign, n + 1) : this.finishOp(r, n) }, DN.readToken_pipe_amp = function (t) { var e = this.input.charCodeAt(this.pos + 1); if (e === t) { if (this.options.ecmaVersion >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(AD.assign, 3); return this.finishOp(124 === t ? AD.logicalOR : AD.logicalAND, 2) } return 61 === e ? this.finishOp(AD.assign, 2) : this.finishOp(124 === t ? AD.bitwiseOR : AD.bitwiseAND, 1) }, DN.readToken_caret = function () { return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(AD.assign, 2) : this.finishOp(AD.bitwiseXOR, 1) }, DN.readToken_plus_min = function (t) { var e = this.input.charCodeAt(this.pos + 1); return e === t ? 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !MD.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(AD.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === e ? this.finishOp(AD.assign, 2) : this.finishOp(AD.plusMin, 1) }, DN.readToken_lt_gt = function (t) { var e = this.input.charCodeAt(this.pos + 1), n = 1; return e === t ? (n = 62 === t && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n) ? this.finishOp(AD.assign, n + 1) : this.finishOp(AD.bitShift, n)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === e && (n = 2), this.finishOp(AD.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken()) }, DN.readToken_eq_excl = function (t) { var e = this.input.charCodeAt(this.pos + 1); return 61 === e ? this.finishOp(AD.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === t && 62 === e && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(AD.arrow)) : this.finishOp(61 === t ? AD.eq : AD.prefix, 1) }, DN.readToken_question = function () { var t = this.options.ecmaVersion; if (t >= 11) { var e = this.input.charCodeAt(this.pos + 1); if (46 === e) { var n = this.input.charCodeAt(this.pos + 2); if (n < 48 || n > 57) return this.finishOp(AD.questionDot, 2) } if (63 === e) { if (t >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(AD.assign, 3); return this.finishOp(AD.coalesce, 2) } } return this.finishOp(AD.question, 1) }, DN.getTokenFromCode = function (t) { switch (t) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(AD.parenL); case 41: return ++this.pos, this.finishToken(AD.parenR); case 59: return ++this.pos, this.finishToken(AD.semi); case 44: return ++this.pos, this.finishToken(AD.comma); case 91: return ++this.pos, this.finishToken(AD.bracketL); case 93: return ++this.pos, this.finishToken(AD.bracketR); case 123: return ++this.pos, this.finishToken(AD.braceL); case 125: return ++this.pos, this.finishToken(AD.braceR); case 58: return ++this.pos, this.finishToken(AD.colon); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(AD.backQuote); case 48: var e = this.input.charCodeAt(this.pos + 1); if (120 === e || 88 === e) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (111 === e || 79 === e) return this.readRadixNumber(8); if (98 === e || 66 === e) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(t); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(t); case 124: case 38: return this.readToken_pipe_amp(t); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(t); case 60: case 62: return this.readToken_lt_gt(t); case 61: case 33: return this.readToken_eq_excl(t); case 63: return this.readToken_question(); case 126: return this.finishOp(AD.prefix, 1) }this.raise(this.pos, "Unexpected character '" + zN(t) + "'") }, DN.finishOp = function (t, e) { var n = this.input.slice(this.pos, this.pos + e); return this.pos += e, this.finishToken(t, n) }, DN.readRegexp = function () { for (var t, e, n = this.pos; ;) { this.pos >= this.input.length && this.raise(n, "Unterminated regular expression"); var r = this.input.charAt(this.pos); if (MD.test(r) && this.raise(n, "Unterminated regular expression"), t) t = !1; else { if ("[" === r) e = !0; else if ("]" === r && e) e = !1; else if ("/" === r && !e) break; t = "\\" === r } ++this.pos } var i = this.input.slice(n, this.pos); ++this.pos; var o = this.pos, a = this.readWord1(); this.containsEsc && this.unexpected(o); var s = this.regexpState || (this.regexpState = new EN(this)); s.reset(n, i, a), this.validateRegExpFlags(s), this.validateRegExpPattern(s); var l = null; try { l = new RegExp(i, a) } catch (t) { } return this.finishToken(AD.regexp, { pattern: i, flags: a, value: l }) }, DN.readInt = function (t, e, n) { for (var r = this.options.ecmaVersion >= 12 && void 0 === e, i = n && 48 === this.input.charCodeAt(this.pos), o = this.pos, a = 0, s = 0, l = 0, u = null == e ? 1 / 0 : e; l < u; ++l, ++this.pos) { var c = this.input.charCodeAt(this.pos), p = void 0; if (r && 95 === c) i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === s && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === l && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), s = c; else { if ((p = c >= 97 ? c - 97 + 10 : c >= 65 ? c - 65 + 10 : c >= 48 && c <= 57 ? c - 48 : 1 / 0) >= t) break; s = c, a = a * t + p } } return r && 95 === s && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === o || null != e && this.pos - o !== e ? null : a }, DN.readRadixNumber = function (t) { var e = this.pos; this.pos += 2; var n = this.readInt(t); return null == n && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (n = NN(this.input.slice(e, this.pos)), ++this.pos) : _D(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(AD.num, n) }, DN.readNumber = function (t) { var e = this.pos; t || null !== this.readInt(10, void 0, !0) || this.raise(e, "Invalid number"); var n = this.pos - e >= 2 && 48 === this.input.charCodeAt(e); n && this.strict && this.raise(e, "Invalid number"); var r = this.input.charCodeAt(this.pos); if (!n && !t && this.options.ecmaVersion >= 11 && 110 === r) { var i = NN(this.input.slice(e, this.pos)); return ++this.pos, _D(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(AD.num, i) } n && /[89]/.test(this.input.slice(e, this.pos)) && (n = !1), 46 !== r || n || (++this.pos, this.readInt(10), r = this.input.charCodeAt(this.pos)), 69 !== r && 101 !== r || n || (43 !== (r = this.input.charCodeAt(++this.pos)) && 45 !== r || ++this.pos, null === this.readInt(10) && this.raise(e, "Invalid number")), _D(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var o = function (t, e) { return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, "")) }(this.input.slice(e, this.pos), n); return this.finishToken(AD.num, o) }, DN.readCodePoint = function () { var t; if (123 === this.input.charCodeAt(this.pos)) { this.options.ecmaVersion < 6 && this.unexpected(); var e = ++this.pos; t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(e, "Code point out of bounds") } else t = this.readHexChar(4); return t }, DN.readString = function (t) { for (var e = "", n = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var r = this.input.charCodeAt(this.pos); if (r === t) break; 92 === r ? (e += this.input.slice(n, this.pos), e += this.readEscapedChar(!1), n = this.pos) : (kD(r, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return e += this.input.slice(n, this.pos++), this.finishToken(AD.string, e) }; var FN = {}; DN.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (t) { if (t !== FN) throw t; this.readInvalidTemplateToken() } this.inTemplateElement = !1 }, DN.invalidStringToken = function (t, e) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw FN; this.raise(t, e) }, DN.readTmplToken = function () { for (var t = "", e = this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var n = this.input.charCodeAt(this.pos); if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== AD.template && this.type !== AD.invalidTemplate ? (t += this.input.slice(e, this.pos), this.finishToken(AD.template, t)) : 36 === n ? (this.pos += 2, this.finishToken(AD.dollarBraceL)) : (++this.pos, this.finishToken(AD.backQuote)); if (92 === n) t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos; else if (kD(n)) { switch (t += this.input.slice(e, this.pos), ++this.pos, n) { case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos; case 10: t += "\n"; break; default: t += String.fromCharCode(n) }this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos } else ++this.pos } }, DN.readInvalidTemplateToken = function () { for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) { case "\\": ++this.pos; break; case "$": if ("{" !== this.input[this.pos + 1]) break; case "`": return this.finishToken(AD.invalidTemplate, this.input.slice(this.start, this.pos)) }this.raise(this.start, "Unterminated template") }, DN.readEscapedChar = function (t) { var e = this.input.charCodeAt(++this.pos); switch (++this.pos, e) { case 110: return "\n"; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return zN(this.readCodePoint()); case 116: return "\t"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; case 56: case 57: if (t) { var n = this.pos - 1; return this.invalidStringToken(n, "Invalid escape sequence in template string"), null } default: if (e >= 48 && e <= 55) { var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8); return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, e = this.input.charCodeAt(this.pos), "0" === r && 56 !== e && 57 !== e || !this.strict && !t || this.invalidStringToken(this.pos - 1 - r.length, t ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(i) } return kD(e) ? "" : String.fromCharCode(e) } }, DN.readHexChar = function (t) { var e = this.pos, n = this.readInt(16, t); return null === n && this.invalidStringToken(e, "Bad character escape sequence"), n }, DN.readWord1 = function () { this.containsEsc = !1; for (var t = "", e = !0, n = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var i = this.fullCharCodeAtPos(); if (xD(i, r)) this.pos += i <= 65535 ? 1 : 2; else { if (92 !== i) break; this.containsEsc = !0, t += this.input.slice(n, this.pos); var o = this.pos; 117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var a = this.readCodePoint(); (e ? _D : xD)(a, r) || this.invalidStringToken(o, "Invalid Unicode escape"), t += zN(a), n = this.pos } e = !1 } return t + this.input.slice(n, this.pos) }, DN.readWord = function () { var t = this.readWord1(), e = AD.name; return this.keywords.test(t) && (e = CD[t]), this.finishToken(e, t) }; function BN(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } function jN(t) { var e = "function" == typeof Map ? new Map : void 0; return jN = function (t) { if (null === t || (n = t, -1 === Function.toString.call(n).indexOf("[native code]"))) return t; var n; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== e) { if (e.has(t)) return e.get(t); e.set(t, r) } function r() { return VN(t, arguments, HN(this).constructor) } return r.prototype = Object.create(t.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), GN(r, t) }, jN(t) } function UN() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } } function VN(t, e, n) { return VN = UN() ? Reflect.construct : function (t, e, n) { var r = [null]; r.push.apply(r, e); var i = new (Function.bind.apply(t, r)); return n && GN(i, n.prototype), i }, VN.apply(null, arguments) } function GN(t, e) { return GN = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t }, GN(t, e) } function HN(t) { return HN = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, HN(t) } WD.acorn = { Parser: WD, version: "7.4.1", defaultOptions: VD, Position: BD, SourceLocation: jD, getLineInfo: UD, Node: lN, TokenType: bD, tokTypes: AD, keywordTypes: CD, TokContext: pN, tokContexts: hN, isIdentifierChar: xD, isIdentifierStart: _D, Token: RN, isNewLine: kD, lineBreak: MD, lineBreakG: OD, nonASCIIwhitespace: ID }; var WN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(jN(Error)), XN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(jN(SyntaxError)), qN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(jN(ReferenceError)), ZN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(jN(TypeError)), YN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(WN), KN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(XN), QN = function (t) { function e() { return t.apply(this, arguments) || this } return BN(e, t), e }(qN), JN = { UnknownError: [3001, "%0", YN], ExecutionTimeOutError: [3002, "Script execution timed out after %0ms", YN], NodeTypeSyntaxError: [1001, "Unknown node type: %0", QN], BinaryOperatorSyntaxError: [1002, "Unknown binary operator: %0", QN], LogicalOperatorSyntaxError: [1003, "Unknown logical operator: %0", QN], UnaryOperatorSyntaxError: [1004, "Unknown unary operator: %0", QN], UpdateOperatorSyntaxError: [1005, "Unknown update operator: %0", QN], ObjectStructureSyntaxError: [1006, "Unknown object structure: %0", QN], AssignmentExpressionSyntaxError: [1007, "Unknown assignment expression: %0", QN], VariableTypeSyntaxError: [1008, "Unknown variable type: %0", QN], ParamTypeSyntaxError: [1009, "Unknown param type: %0", QN], AssignmentTypeSyntaxError: [1010, "Unknown assignment type: %0", QN], FunctionUndefinedReferenceError: [2001, "%0 is not a function", qN], VariableUndefinedReferenceError: [2002, "%0 is not defined", qN], IsNotConstructor: [2003, "%0 is not a constructor", ZN] }; function $N() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } } function tz(t, e, n) { return tz = $N() ? Reflect.construct : function (t, e, n) { var r = [null]; r.push.apply(r, e); var i = new (Function.bind.apply(t, r)); return n && ez(i, n.prototype), i }, tz.apply(null, arguments) } function ez(t, e) { return ez = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t }, ez(t, e) } function nz(t, e) { Object.defineProperty(t, "name", { value: e, writable: !1, enumerable: !1, configurable: !0 }) } var rz = Object.prototype.hasOwnProperty, iz = Symbol("Break"), oz = Symbol("Continue"), az = Symbol("DefaultCase"), sz = Symbol("EmptyStatementReturn"), lz = Symbol("WithScopeName"), uz = Symbol("SuperScopeName"), cz = Symbol("RootScopeName"), pz = Symbol("GlobalScopeName"); function hz(t) { return "function" == typeof t } var fz = function () { function t(t) { this.interpreter = t } return t.prototype.generator = function () { var t = this.interpreter; return { getOptions: t.getOptions.bind(t), getCurrentScope: function () { return this.getCurrentScope() }.bind(t), getGlobalScope: function () { return this.getGlobalScope() }.bind(t), getCurrentContext: function () { return this.getCurrentContext() }.bind(t), getExecStartTime: t.getExecStartTime.bind(t) } }, t }(); function dz(t, e, n) { if (void 0 === n && (n = !0), !(t instanceof fz)) throw new Error("Illegal call"); if ("string" != typeof e) return e; if (e) { var r = t.generator(), i = { timeout: r.getOptions().timeout, _initEnv: function () { n || this.setCurrentContext(r.getCurrentContext()), this.execStartTime = r.getExecStartTime(), this.execEndTime = this.execStartTime } }, o = n ? r.getGlobalScope() : r.getCurrentScope(); return new Sz(o, i).evaluate(e) } } function mz(t) { if (!(t instanceof fz)) throw new Error("Illegal call"); for (var e = t.generator(), n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; var o = r.pop(), a = new Sz(e.getGlobalScope(), e.getOptions()), s = "\n\t\t    (function anonymous(" + r.join(",") + "){\n\t\t        " + o + "\n\t\t    });\n\t\t    "; return a.evaluate(s) } Object.defineProperty(dz, "__IS_EVAL_FUNC", { value: !0, writable: !1, enumerable: !1, configurable: !1 }), Object.defineProperty(mz, "__IS_FUNCTION_FUNC", { value: !0, writable: !1, enumerable: !1, configurable: !1 }); var vz = function (t) { this.value = t }, yz = function (t) { this.value = t }, gz = function (t) { this.value = t }, _z = function (t, e, n) { void 0 === e && (e = null), this.name = n, this.parent = e, this.data = t, this.labelStack = [] }; function xz() { } function bz(t, e) { return void 0 === t && (t = null), new _z(Object.create(null), t, e) } var wz = { NaN: NaN, Infinity: 1 / 0, undefined: void 0, Object: Object, Array: Array, String: String, Boolean: Boolean, Number: Number, Date: Date, RegExp: RegExp, Error: Error, URIError: URIError, TypeError: TypeError, RangeError: RangeError, SyntaxError: SyntaxError, ReferenceError: ReferenceError, Float32Array: Float32Array, Float64Array: Float64Array, Uint32Array: Uint32Array, Math: Math, parseInt: parseInt, parseFloat: parseFloat, isNaN: isNaN, isFinite: isFinite, decodeURI: decodeURI, decodeURIComponent: decodeURIComponent, encodeURI: encodeURI, encodeURIComponent: encodeURIComponent, escape: escape, unescape: unescape, eval: dz, Function: mz }; "undefined" != typeof JSON && (wz.JSON = JSON), "undefined" != typeof Promise && (wz.Promise = Promise), "undefined" != typeof Set && (wz.Set = Set), "undefined" != typeof Map && (wz.Map = Map), "undefined" != typeof Symbol && (wz.Symbol = Symbol), "undefined" != typeof Proxy && (wz.Proxy = Proxy), "undefined" != typeof WeakMap && (wz.WeakMap = WeakMap), "undefined" != typeof WeakSet && (wz.WeakSet = WeakSet), "undefined" != typeof Reflect && (wz.Reflect = Reflect); var Sz = function () {
        function t(e, n) { void 0 === e && (e = t.global), void 0 === n && (n = {}), this.sourceList = [], this.collectDeclVars = Object.create(null), this.collectDeclFuncs = Object.create(null), this.isVarDeclMode = !1, this.lastExecNode = null, this.isRunning = !1, this.options = { ecmaVersion: n.ecmaVersion || t.ecmaVersion, timeout: n.timeout || 0, rootContext: n.rootContext, globalContextInFunction: void 0 === n.globalContextInFunction ? t.globalContextInFunction : n.globalContextInFunction, _initEnv: n._initEnv }, this.context = e || Object.create(null), this.callStack = [], this.initEnvironment(this.context) } var e = t.prototype; return e.initEnvironment = function (t) { var e; if (t instanceof _z) e = t; else { var n = null, r = this.createSuperScope(t); this.options.rootContext && (n = new _z(function (t) { return Object.create(t) }(this.options.rootContext), r, cz)), e = new _z(t, n || r, pz) } this.globalScope = e, this.currentScope = this.globalScope, this.globalContext = e.data, this.currentContext = e.data, this.collectDeclVars = Object.create(null), this.collectDeclFuncs = Object.create(null), this.execStartTime = Date.now(), this.execEndTime = this.execStartTime; var i = this.options._initEnv; i && i.call(this) }, e.getExecStartTime = function () { return this.execStartTime }, e.getExecutionTime = function () { return this.execEndTime - this.execStartTime }, e.setExecTimeout = function (t) { void 0 === t && (t = 0), this.options.timeout = t }, e.getOptions = function () { return this.options }, e.getGlobalScope = function () { return this.globalScope }, e.getCurrentScope = function () { return this.currentScope }, e.getCurrentContext = function () { return this.currentContext }, e.isInterruptThrow = function (t) { return t instanceof YN || t instanceof QN || t instanceof KN }, e.createSuperScope = function (t) { var e = Object.assign({}, wz); return Object.keys(e).forEach((function (n) { n in t && delete e[n] })), new _z(e, null, uz) }, e.setCurrentContext = function (t) { this.currentContext = t }, e.setCurrentScope = function (t) { this.currentScope = t }, e.evaluate = function (e) { var n, r, i; if (void 0 === e && (e = ""), e) return r = e, i = { ranges: !0, locations: !0, ecmaVersion: this.options.ecmaVersion || t.ecmaVersion }, n = WD.parse(r, i), this.evaluateNode(n, e) }, e.appendCode = function (t) { return this.evaluate(t) }, e.evaluateNode = function (t, e) { var n = this; void 0 === e && (e = ""), this.value = void 0, this.source = e, this.sourceList.push(e), this.isRunning = !0, this.execStartTime = Date.now(), this.execEndTime = this.execStartTime, this.collectDeclVars = Object.create(null), this.collectDeclFuncs = Object.create(null); var r = this.getCurrentScope(), i = this.getCurrentContext(), o = r.labelStack.concat([]), a = this.callStack.concat([]); try { var s = this.createClosure(t); this.addDeclarationsToScope(this.collectDeclVars, this.collectDeclFuncs, this.getCurrentScope()), s() } catch (t) { throw t } finally { n.setCurrentScope(r), n.setCurrentContext(i), r.labelStack = o, n.callStack = a, this.execEndTime = Date.now() } return this.isRunning = !1, this.getValue() }, e.createErrorMessage = function (t, e, n) { var r = t[1].replace("%0", String(e)); return null !== n && (r += this.getNodePosition(n || this.lastExecNode)), r }, e.createError = function (t, e) { return new e(t) }, e.createThrowError = function (t, e) { return this.createError(t, e) }, e.createInternalThrowError = function (t, e, n) { return this.createError(this.createErrorMessage(t, e, n), t[2]) }, e.checkTimeout = function () { if (!this.isRunning) return !1; var t = this.options.timeout || 0; return Date.now() - this.execStartTime > t }, e.getNodePosition = function (t) { if (t) { return t.loc ? " [" + t.loc.start.line + ":" + t.loc.start.column + "]" : "" } return "" }, e.createClosure = function (t) { var e, n = this; switch (t.type) { case "BinaryExpression": e = this.binaryExpressionHandler(t); break; case "LogicalExpression": e = this.logicalExpressionHandler(t); break; case "UnaryExpression": e = this.unaryExpressionHandler(t); break; case "UpdateExpression": e = this.updateExpressionHandler(t); break; case "ObjectExpression": e = this.objectExpressionHandler(t); break; case "ArrayExpression": e = this.arrayExpressionHandler(t); break; case "CallExpression": e = this.callExpressionHandler(t); break; case "NewExpression": e = this.newExpressionHandler(t); break; case "MemberExpression": e = this.memberExpressionHandler(t); break; case "ThisExpression": e = this.thisExpressionHandler(t); break; case "SequenceExpression": e = this.sequenceExpressionHandler(t); break; case "Literal": e = this.literalHandler(t); break; case "Identifier": e = this.identifierHandler(t); break; case "AssignmentExpression": e = this.assignmentExpressionHandler(t); break; case "FunctionDeclaration": e = this.functionDeclarationHandler(t); break; case "VariableDeclaration": e = this.variableDeclarationHandler(t); break; case "BlockStatement": case "Program": e = this.programHandler(t); break; case "ExpressionStatement": e = this.expressionStatementHandler(t); break; case "EmptyStatement": e = this.emptyStatementHandler(t); break; case "ReturnStatement": e = this.returnStatementHandler(t); break; case "FunctionExpression": e = this.functionExpressionHandler(t); break; case "IfStatement": e = this.ifStatementHandler(t); break; case "ConditionalExpression": e = this.conditionalExpressionHandler(t); break; case "ForStatement": e = this.forStatementHandler(t); break; case "WhileStatement": e = this.whileStatementHandler(t); break; case "DoWhileStatement": e = this.doWhileStatementHandler(t); break; case "ForInStatement": e = this.forInStatementHandler(t); break; case "WithStatement": e = this.withStatementHandler(t); break; case "ThrowStatement": e = this.throwStatementHandler(t); break; case "TryStatement": e = this.tryStatementHandler(t); break; case "ContinueStatement": e = this.continueStatementHandler(t); break; case "BreakStatement": e = this.breakStatementHandler(t); break; case "SwitchStatement": e = this.switchStatementHandler(t); break; case "LabeledStatement": e = this.labeledStatementHandler(t); break; case "DebuggerStatement": e = this.debuggerStatementHandler(t); break; default: throw this.createInternalThrowError(JN.NodeTypeSyntaxError, t.type, t) }return function () { var r = n.options.timeout; if (r && r > 0 && n.checkTimeout()) throw n.createInternalThrowError(JN.ExecutionTimeOutError, r, null); return n.lastExecNode = t, e.apply(void 0, arguments) } }, e.binaryExpressionHandler = function (t) { var e = this, n = this.createClosure(t.left), r = this.createClosure(t.right); return function () { var i = n(), o = r(); switch (t.operator) { case "==": return i == o; case "!=": return i != o; case "===": return i === o; case "!==": return i !== o; case "<": return i < o; case "<=": return i <= o; case ">": return i > o; case ">=": return i >= o; case "<<": return i << o; case ">>": return i >> o; case ">>>": return i >>> o; case "+": return i + o; case "-": return i - o; case "*": return i * o; case "**": return Math.pow(i, o); case "/": return i / o; case "%": return i % o; case "|": return i | o; case "^": return i ^ o; case "&": return i & o; case "in": return i in o; case "instanceof": return i instanceof o; default: throw e.createInternalThrowError(JN.BinaryOperatorSyntaxError, t.operator, t) } } }, e.logicalExpressionHandler = function (t) { var e = this, n = this.createClosure(t.left), r = this.createClosure(t.right); return function () { switch (t.operator) { case "||": return n() || r(); case "&&": return n() && r(); default: throw e.createInternalThrowError(JN.LogicalOperatorSyntaxError, t.operator, t) } } }, e.unaryExpressionHandler = function (t) { var e, n = this; if ("delete" === t.operator) { var r = this.createObjectGetter(t.argument), i = this.createNameGetter(t.argument); return function () { return delete r()[i()] } } if ("typeof" === t.operator && "Identifier" === t.argument.type) { var o = this.createObjectGetter(t.argument), a = this.createNameGetter(t.argument); e = function () { return o()[a()] } } else e = this.createClosure(t.argument); return function () { var r = e(); switch (t.operator) { case "-": return -r; case "+": return +r; case "!": return !r; case "~": return ~r; case "void": return; case "typeof": return typeof r; default: throw n.createInternalThrowError(JN.UnaryOperatorSyntaxError, t.operator, t) } } }, e.updateExpressionHandler = function (t) { var e = this, n = this.createObjectGetter(t.argument), r = this.createNameGetter(t.argument); return function () { var i = n(), o = r(); switch (e.assertVariable(i, o, t), t.operator) { case "++": return t.prefix ? ++i[o] : i[o]++; case "--": return t.prefix ? --i[o] : i[o]--; default: throw e.createInternalThrowError(JN.UpdateOperatorSyntaxError, t.operator, t) } } }, e.objectExpressionHandler = function (t) { var e = this, n = []; var r = Object.create(null); return t.properties.forEach((function (t) { var i = t.kind, o = function (t) { return "Identifier" === t.type ? t.name : "Literal" === t.type ? t.value : this.throwError(JN.ObjectStructureSyntaxError, t.type, t) }(t.key); r[o] && "init" !== i || (r[o] = {}), r[o][i] = e.createClosure(t.value), n.push({ key: o, property: t }) })), function () { for (var t = {}, e = n.length, i = 0; i < e; i++) { var o = n[i], a = o.key, s = r[a], l = s.init ? s.init() : void 0, u = s.get ? s.get() : function () { }, c = s.set ? s.set() : function (t) { }; if ("set" in s || "get" in s) { var p = { configurable: !0, enumerable: !0, get: u, set: c }; Object.defineProperty(t, a, p) } else { var h = o.property, f = h.kind; "Identifier" !== h.key.type || "FunctionExpression" !== h.value.type || "init" !== f || h.value.id || nz(l, h.key.name), t[a] = l } } return t } }, e.arrayExpressionHandler = function (t) { var e = this, n = t.elements.map((function (t) { return t ? e.createClosure(t) : t })); return function () { for (var t = n.length, e = Array(t), r = 0; r < t; r++) { var i = n[r]; i && (e[r] = i()) } return e } }, e.safeObjectGet = function (t, e, n) { return t[e] }, e.createCallFunctionGetter = function (t) { var e = this; if ("MemberExpression" === t.type) { var n = this.createClosure(t.object), r = this.createMemberKeyGetter(t), i = this.source; return function () { var o = n(), a = r(), s = e.safeObjectGet(o, a, t); if (!s || !hz(s)) { var l = i.slice(t.start, t.end); throw e.createInternalThrowError(JN.FunctionUndefinedReferenceError, l, t) } return s.__IS_EVAL_FUNC ? function (t) { return s(new fz(e), t, !0) } : s.__IS_FUNCTION_FUNC ? function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return s.apply(void 0, [new fz(e)].concat(n)) } : s.bind(o) } } var o = this.createClosure(t); return function () { var n = ""; "Identifier" === t.type && (n = t.name); var r = o(); if (!r || !hz(r)) throw e.createInternalThrowError(JN.FunctionUndefinedReferenceError, n, t); if ("Identifier" === t.type && r.__IS_EVAL_FUNC && "eval" === n) return function (t) { var i = e.getScopeFromName(n, e.getCurrentScope()), o = i.name === uz || i.name === pz || i.name === cz; return r(new fz(e), t, !o) }; if (r.__IS_EVAL_FUNC) return function (t) { return r(new fz(e), t, !0) }; if (r.__IS_FUNCTION_FUNC) return function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return r.apply(void 0, [new fz(e)].concat(n)) }; var i = e.options.globalContextInFunction; if ("Identifier" === t.type) { var a = e.getIdentifierScope(t); a.name === lz && (i = a.data) } return r.bind(i) } }, e.callExpressionHandler = function (t) { var e = this, n = this.createCallFunctionGetter(t.callee), r = t.arguments.map((function (t) { return e.createClosure(t) })); return function () { return n().apply(void 0, r.map((function (t) { return t() }))) } }, e.functionExpressionHandler = function (t) { var e = this, n = this, r = this.source, i = this.collectDeclVars, o = this.collectDeclFuncs; this.collectDeclVars = Object.create(null), this.collectDeclFuncs = Object.create(null); var a = t.id ? t.id.name : "", s = t.params.length, l = t.params.map((function (t) { return e.createParamNameGetter(t) })), u = this.createClosure(t.body), c = this.collectDeclVars, p = this.collectDeclFuncs; return this.collectDeclVars = i, this.collectDeclFuncs = o, function () { var e = n.getCurrentScope(), i = function t() { for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; n.callStack.push("" + a); var s = n.getCurrentScope(), h = bz(e, "FunctionScope(" + a + ")"); n.setCurrentScope(h), n.addDeclarationsToScope(c, p, h), a && (h.data[a] = t), h.data.arguments = arguments, l.forEach((function (t, e) { h.data[t()] = i[e] })); var f = n.getCurrentContext(); n.setCurrentContext(this); var d = u(); if (n.setCurrentContext(f), n.setCurrentScope(s), n.callStack.pop(), d instanceof vz) return d.value }; return nz(i, a), Object.defineProperty(i, "length", { value: s, writable: !1, enumerable: !1, configurable: !0 }), Object.defineProperty(i, "toString", { value: function () { return r.slice(t.start, t.end) }, writable: !0, configurable: !0, enumerable: !1 }), Object.defineProperty(i, "valueOf", { value: function () { return r.slice(t.start, t.end) }, writable: !0, configurable: !0, enumerable: !1 }), i } }, e.newExpressionHandler = function (t) { var e = this, n = this.source, r = this.createClosure(t.callee), i = t.arguments.map((function (t) { return e.createClosure(t) })); return function () { var o = r(); if (!hz(o) || o.__IS_EVAL_FUNC) { var a = t.callee, s = n.slice(a.start, a.end); throw e.createInternalThrowError(JN.IsNotConstructor, s, t) } return o.__IS_FUNCTION_FUNC ? o.apply(void 0, [new fz(e)].concat(i.map((function (t) { return t() })))) : tz(o, i.map((function (t) { return t() }))) } }, e.memberExpressionHandler = function (t) { var e = this.createClosure(t.object), n = this.createMemberKeyGetter(t); return function () { return e()[n()] } }, e.thisExpressionHandler = function (t) { var e = this; return function () { return e.getCurrentContext() } }, e.sequenceExpressionHandler = function (t) { var e = this, n = t.expressions.map((function (t) { return e.createClosure(t) })); return function () { for (var t, e = n.length, r = 0; r < e; r++) { t = (0, n[r])() } return t } }, e.literalHandler = function (t) { return function () { return t.regex ? new RegExp(t.regex.pattern, t.regex.flags) : t.value } }, e.identifierHandler = function (t) { var e = this; return function () { var n = e.getCurrentScope(), r = e.getScopeDataFromName(t.name, n); return e.assertVariable(r, t.name, t), r[t.name] } }, e.getIdentifierScope = function (t) { var e = this.getCurrentScope(); return this.getScopeFromName(t.name, e) }, e.assignmentExpressionHandler = function (t) { var e = this; "Identifier" !== t.left.type || "FunctionExpression" !== t.right.type || t.right.id || (t.right.id = { type: "Identifier", name: t.left.name }); var n = this.createObjectGetter(t.left), r = this.createNameGetter(t.left), i = this.createClosure(t.right); return function () { var o = n(), a = r(), s = i(); switch ("=" !== t.operator && e.assertVariable(o, a, t), t.operator) { case "=": return o[a] = s; case "+=": return o[a] += s; case "-=": return o[a] -= s; case "*=": return o[a] *= s; case "**=": return o[a] = Math.pow(o[a], s); case "/=": return o[a] /= s; case "%=": return o[a] %= s; case "<<=": return o[a] <<= s; case ">>=": return o[a] >>= s; case ">>>=": return o[a] >>>= s; case "&=": return o[a] &= s; case "^=": return o[a] ^= s; case "|=": return o[a] |= s; default: throw e.createInternalThrowError(JN.AssignmentExpressionSyntaxError, t.type, t) } } }, e.functionDeclarationHandler = function (t) { if (t.id) { var e = this.functionExpressionHandler(t); Object.defineProperty(e, "isFunctionDeclareClosure", { value: !0, writable: !1, configurable: !1, enumerable: !1 }), this.funcDeclaration(t.id.name, e) } return function () { return sz } }, e.getVariableName = function (t) { if ("Identifier" === t.type) return t.name; throw this.createInternalThrowError(JN.VariableTypeSyntaxError, t.type, t) }, e.variableDeclarationHandler = function (t) { for (var e, n = this, r = [], i = 0; i < t.declarations.length; i++) { var o = t.declarations[i]; this.varDeclaration(this.getVariableName(o.id)), o.init && r.push({ type: "AssignmentExpression", operator: "=", left: o.id, right: o.init }) } return r.length && (e = this.createClosure({ type: "BlockStatement", body: r })), function () { if (e) { var t = n.isVarDeclMode; n.isVarDeclMode = !0, e(), n.isVarDeclMode = t } return sz } }, e.assertVariable = function (t, e, n) { if (t === this.globalScope.data && !(e in t)) throw this.createInternalThrowError(JN.VariableUndefinedReferenceError, e, n) }, e.programHandler = function (t) { var e = this, n = t.body.map((function (t) { return e.createClosure(t) })); return function () { for (var t = sz, r = 0; r < n.length; r++) { var i = n[r], o = e.setValue(i()); if (o !== sz && ((t = o) instanceof vz || t instanceof yz || t instanceof gz || t === iz || t === oz)) break } return t } }, e.expressionStatementHandler = function (t) { return this.createClosure(t.expression) }, e.emptyStatementHandler = function (t) { return function () { return sz } }, e.returnStatementHandler = function (t) { var e = t.argument ? this.createClosure(t.argument) : xz; return function () { return new vz(e()) } }, e.ifStatementHandler = function (t) {
            var e = this.createClosure(t.test), n = this.createClosure(t.consequent), r = t.alternate ? this.createClosure(t.alternate) :
                /*!important*/
                function () { return sz }; return function () { return e() ? n() : r() }
        }, e.conditionalExpressionHandler = function (t) { return this.ifStatementHandler(t) }, e.forStatementHandler = function (t) { var e = this, n = xz, r = t.test ? this.createClosure(t.test) : function () { return !0 }, i = xz, o = this.createClosure(t.body); return "ForStatement" === t.type && (n = t.init ? this.createClosure(t.init) : n, i = t.update ? this.createClosure(t.update) : xz), function (a) { var s, l = sz, u = "DoWhileStatement" === t.type; for (a && "LabeledStatement" === a.type && (s = a.label.name), n(); u || r(); i()) { u = !1; var c = e.setValue(o()); if (c !== sz && c !== oz) { if (c === iz) break; if ((l = c) instanceof gz && l.value === s) l = sz; else if (l instanceof vz || l instanceof yz || l instanceof gz) break } } return l } }, e.whileStatementHandler = function (t) { return this.forStatementHandler(t) }, e.doWhileStatementHandler = function (t) { return this.forStatementHandler(t) }, e.forInStatementHandler = function (t) { var e = this, n = t.left, r = this.createClosure(t.right), i = this.createClosure(t.body); return "VariableDeclaration" === t.left.type && (this.createClosure(t.left)(), n = t.left.declarations[0].id), function (t) { var o, a, s = sz; t && "LabeledStatement" === t.type && (o = t.label.name); var l = r(); for (a in l) { e.assignmentExpressionHandler({ type: "AssignmentExpression", operator: "=", left: n, right: { type: "Literal", value: a } })(); var u = e.setValue(i()); if (u !== sz && u !== oz) { if (u === iz) break; if ((s = u) instanceof gz && s.value === o) s = sz; else if (s instanceof vz || s instanceof yz || s instanceof gz) break } } return s } }, e.withStatementHandler = function (t) { var e = this, n = this.createClosure(t.object), r = this.createClosure(t.body); return function () { var t = n(), i = e.getCurrentScope(), o = new _z(t, i, lz); e.setCurrentScope(o); var a = e.setValue(r()); return e.setCurrentScope(i), a } }, e.throwStatementHandler = function (t) { var e = this, n = this.createClosure(t.argument); return function () { throw e.setValue(void 0), n() } }, e.tryStatementHandler = function (t) { var e = this, n = this.createClosure(t.block), r = t.handler ? this.catchClauseHandler(t.handler) : null, i = t.finalizer ? this.createClosure(t.finalizer) : null; return function () { var t, o, a = e.getCurrentScope(), s = e.getCurrentContext(), l = a.labelStack.concat([]), u = e.callStack.concat([]), c = sz, p = function () { e.setCurrentScope(a), e.setCurrentContext(s), a.labelStack = l, e.callStack = u }; try { (c = e.setValue(n())) instanceof vz && (t = c) } catch (n) { if (p(), e.isInterruptThrow(n)) throw n; if (r) try { (c = e.setValue(r(n))) instanceof vz && (t = c) } catch (t) { if (p(), e.isInterruptThrow(t)) throw t; o = t } } if (i) try { (c = i()) instanceof vz && (t = c) } catch (t) { if (p(), e.isInterruptThrow(t)) throw t; o = t } if (o) throw o; return t || c } }, e.catchClauseHandler = function (t) { var e = this, n = this.createParamNameGetter(t.param), r = this.createClosure(t.body); return function (t) { var i, o = e.getCurrentScope().data, a = n(), s = rz.call(o, a), l = o[a]; return o[a] = t, i = r(), s ? o[a] = l : delete o[a], i } }, e.continueStatementHandler = function (t) { return function () { return t.label ? new gz(t.label.name) : oz } }, e.breakStatementHandler = function (t) { return function () { return t.label ? new yz(t.label.name) : iz } }, e.switchStatementHandler = function (t) { var e = this, n = this.createClosure(t.discriminant), r = t.cases.map((function (t) { return e.switchCaseHandler(t) })); return function () { for (var t, i, o, a = n(), s = !1, l = 0; l < r.length; l++) { var u = r[l](), c = u.testClosure(); if (c !== az) { if (s || c === a) { if (s = !0, (i = e.setValue(u.bodyClosure())) === sz) continue; if (i === iz) break; if ((t = i) instanceof vz || t instanceof yz || t instanceof gz || t === oz) break } } else o = u } !s && o && ((i = e.setValue(o.bodyClosure())) === sz || i === iz || i === oz || (t = i)); return t } }, e.switchCaseHandler = function (t) { var e = t.test ? this.createClosure(t.test) : function () { return az }, n = this.createClosure({ type: "BlockStatement", body: t.consequent }); return function () { return { testClosure: e, bodyClosure: n } } }, e.labeledStatementHandler = function (t) { var e = this, n = t.label.name, r = this.createClosure(t.body); return function () { var i, o = e.getCurrentScope(); return o.labelStack.push(n), (i = r(t)) instanceof yz && i.value === n && (i = sz), o.labelStack.pop(), i } }, e.debuggerStatementHandler = function (t) { return function () { return sz } }, e.createParamNameGetter = function (t) { if ("Identifier" === t.type) return function () { return t.name }; throw this.createInternalThrowError(JN.ParamTypeSyntaxError, t.type, t) }, e.createObjectKeyGetter = function (t) { var e; return e = "Identifier" === t.type ? function () { return t.name } : this.createClosure(t), function () { return e() } }, e.createMemberKeyGetter = function (t) { return t.computed ? this.createClosure(t.property) : this.createObjectKeyGetter(t.property) }, e.createObjectGetter = function (t) { var e = this; switch (t.type) { case "Identifier": return function () { return e.getScopeDataFromName(t.name, e.getCurrentScope()) }; case "MemberExpression": return this.createClosure(t.object); default: throw this.createInternalThrowError(JN.AssignmentTypeSyntaxError, t.type, t) } }, e.createNameGetter = function (t) { switch (t.type) { case "Identifier": return function () { return t.name }; case "MemberExpression": return this.createMemberKeyGetter(t); default: throw this.createInternalThrowError(JN.AssignmentTypeSyntaxError, t.type, t) } }, e.varDeclaration = function (t) { this.collectDeclVars[t] = void 0 }, e.funcDeclaration = function (t, e) { this.collectDeclFuncs[t] = e }, e.addDeclarationsToScope = function (t, e, n) { var r = n.data; for (var i in e) { var o = e[i]; r[i] = o ? o() : o } for (var a in t) a in r || (r[a] = void 0) }, e.getScopeValue = function (t, e) { return this.getScopeFromName(t, e).data[t] }, e.getScopeDataFromName = function (t, e) { return this.getScopeFromName(t, e).data }, e.getScopeFromName = function (t, e) { var n = e; do { if (t in n.data) return n } while (n = n.parent); return this.globalScope }, e.setValue = function (t) { var e = this.callStack.length; return this.isVarDeclMode || e || t === sz || t === iz || t === oz || t instanceof yz || t instanceof gz || (this.value = t instanceof vz ? t.value : t), t }, e.getValue = function () { return this.value }, t
    }(); function Ez(t, e, n) { void 0 === e && (e = []), void 0 === n && (n = {}); var r = n.parsingContext, i = void 0 === n.timeout ? 0 : n.timeout, o = "\n    (function anonymous(" + e.join(",") + "){\n         " + t + "\n    });\n    "; return new Sz(r, { ecmaVersion: n.ecmaVersion, timeout: i, rootContext: n.rootContext, globalContextInFunction: n.globalContextInFunction }).evaluate(o) } function Cz(t, e, n) { return new Sz(e, n).evaluate(t) } Sz.version = "0.0.3", Sz.eval = dz, Sz.Function = mz, Sz.ecmaVersion = 5, Sz.globalContextInFunction = void 0, Sz.global = Object.create(null); var Tz = Cz, Az = function () { function t(t) { this._code = t } var e = t.prototype; return e.runInContext = function (t) { return Cz(this._code, t) }, e.runInNewContext = function (t) { return Cz(this._code, t) }, t }(), Mz = Object.freeze({ __proto__: null, createContext: function (t) { return void 0 === t && (t = Object.create(null)), t }, compileFunction: Ez, runInContext: Cz, runInNewContext: Tz, Script: Az }), Oz = function (t, e, n) { return Cz(t, e, n) }; var kz = Object.freeze({ __proto__: null, Interpreter: Sz, vm: Mz, evaluate: Oz, Function: function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var r = e.pop(); return Ez(r || "", e) }, default: Oz }), Iz = N(kz); !function (t, e) { t.exports = function (t) { var e = function (t) { return t instanceof Uint8Array || t instanceof Uint16Array || t instanceof Uint32Array || t instanceof Int8Array || t instanceof Int16Array || t instanceof Int32Array || t instanceof Float32Array || t instanceof Float64Array || t instanceof Uint8ClampedArray }, n = function (t, e) { for (var n = Object.keys(e), r = 0; r < n.length; ++r)t[n[r]] = e[n[r]]; return t }, r = "\n"; function i(t) { return "undefined" != typeof atob ? atob(t) : "base64:" + t } function o(t) { var e = new Error("(regl) " + t); throw console.error(e), e } function a(t, e) { t || o(e) } function s(t) { return t ? ": " + t : "" } function l(t, e, n) { t in e || o("unknown parameter (" + t + ")" + s(n) + ". possible values: " + Object.keys(e).join()) } function u(t, n) { e(t) || o("invalid parameter type" + s(n) + ". must be a typed array") } function c(t, e) { switch (e) { case "number": return "number" == typeof t; case "object": return "object" == typeof t; case "string": return "string" == typeof t; case "boolean": return "boolean" == typeof t; case "function": return "function" == typeof t; case "undefined": return void 0 === t; case "symbol": return "symbol" == typeof t } } function p(t, e, n) { c(t, e) || o("invalid parameter type" + s(n) + ". expected " + e + ", got " + typeof t) } function h(t, e) { t >= 0 && (0 | t) === t || o("invalid parameter type, (" + t + ")" + s(e) + ". must be a nonnegative integer") } function f(t, e, n) { e.indexOf(t) < 0 && o("invalid value" + s(n) + ". must be one of: " + e) } var d = ["gl", "canvas", "container", "attributes", "pixelRatio", "extensions", "optionalExtensions", "profile", "onDone"]; function m(t) { Object.keys(t).forEach((function (t) { d.indexOf(t) < 0 && o('invalid regl constructor argument "' + t + '". must be one of ' + d) })) } function v(t, e) { for (t += ""; t.length < e;)t = " " + t; return t } function y() { this.name = "unknown", this.lines = [], this.index = {}, this.hasErrors = !1 } function g(t, e) { this.number = t, this.line = e, this.errors = [] } function _(t, e, n) { this.file = t, this.line = e, this.message = n } function x() { var t = new Error, e = (t.stack || t).toString(), n = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(e); if (n) return n[1]; var r = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(e); return r ? r[1] : "unknown" } function b() { var t = new Error, e = (t.stack || t).toString(), n = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(e); if (n) return n[1]; var r = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(e); return r ? r[1] : "unknown" } function w(t, e) { var n = t.split("\n"), r = 1, o = 0, a = { unknown: new y, 0: new y }; a.unknown.name = a[0].name = e || x(), a.unknown.lines.push(new g(0, "")); for (var s = 0; s < n.length; ++s) { var l = n[s], u = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(l); if (u) switch (u[1]) { case "line": var c = /(\d+)(\s+\d+)?/.exec(u[2]); c && (r = 0 | c[1], c[2] && ((o = 0 | c[2]) in a || (a[o] = new y))); break; case "define": var p = /SHADER_NAME(_B64)?\s+(.*)$/.exec(u[2]); p && (a[o].name = p[1] ? i(p[2]) : p[2]) }a[o].lines.push(new g(r++, l)) } return Object.keys(a).forEach((function (t) { var e = a[t]; e.lines.forEach((function (t) { e.index[t.number] = t })) })), a } function S(t) { var e = []; return t.split("\n").forEach((function (t) { if (!(t.length < 5)) { var n = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(t); n ? e.push(new _(0 | n[1], 0 | n[2], n[3].trim())) : t.length > 0 && e.push(new _("unknown", 0, t)) } })), e } function E(t, e) { e.forEach((function (e) { var n = t[e.file]; if (n) { var r = n.index[e.line]; if (r) return r.errors.push(e), void (n.hasErrors = !0) } t.unknown.hasErrors = !0, t.unknown.lines[0].errors.push(e) })) } function C(t, e, n, i, o) { if (!t.getShaderParameter(e, t.COMPILE_STATUS)) { var s = t.getShaderInfoLog(e), l = i === t.FRAGMENT_SHADER ? "fragment" : "vertex"; P(n, "string", l + " shader source must be a string", o); var u = w(n, o), c = S(s); E(u, c), Object.keys(u).forEach((function (t) { var e = u[t]; if (e.hasErrors) { var n = [""], i = [""]; o("file number " + t + ": " + e.name + "\n", "color:red;text-decoration:underline;font-weight:bold"), e.lines.forEach((function (t) { if (t.errors.length > 0) { o(v(t.number, 4) + "|  ", "background-color:yellow; font-weight:bold"), o(t.line + r, "color:red; background-color:yellow; font-weight:bold"); var e = 0; t.errors.forEach((function (n) { var i = n.message, a = /^\s*'(.*)'\s*:\s*(.*)$/.exec(i); if (a) { var s = a[1]; i = a[2], "assign" === s && (s = "="), e = Math.max(t.line.indexOf(s, e), 0) } else e = 0; o(v("| ", 6)), o(v("^^^", e + 3) + r, "font-weight:bold"), o(v("| ", 6)), o(i + r, "font-weight:bold") })), o(v("| ", 6) + r) } else o(v(t.number, 4) + "|  "), o(t.line + r, "color:red") })), "undefined" == typeof document || window.chrome ? console.log(n.join("")) : (i[0] = n.join("%c"), console.log.apply(console, i)) } function o(t, e) { n.push(t), i.push(e || "") } })), a.raise("Error compiling " + l + " shader, " + u[0].name) } } function T(t, e, n, i, o) { if (!t.getProgramParameter(e, t.LINK_STATUS)) { var s = t.getProgramInfoLog(e), l = w(n, o), u = 'Error linking program with vertex shader, "' + w(i, o)[0].name + '", and fragment shader "' + l[0].name + '"'; "undefined" != typeof document ? console.log("%c" + u + r + "%c" + s, "color:red;text-decoration:underline;font-weight:bold", "color:red") : console.log(u + r + s), a.raise(u) } } function A(t) { t._commandRef = x() } function M(t, e, n, r) { function i(t) { return t ? r.id(t) : 0 } function o(t, e) { Object.keys(e).forEach((function (e) { t[r.id(e)] = !0 })) } A(t), t._fragId = i(t.static.frag), t._vertId = i(t.static.vert); var a = t._uniformSet = {}; o(a, e.static), o(a, e.dynamic); var s = t._attributeSet = {}; o(s, n.static), o(s, n.dynamic), t._hasCount = "count" in t.static || "count" in t.dynamic || "elements" in t.static || "elements" in t.dynamic } function O(t, e) { var n = b(); o(t + " in command " + (e || x()) + ("unknown" === n ? "" : " called from " + n)) } function k(t, e, n) { t || O(e, n || x()) } function I(t, e, n, r) { t in e || O("unknown parameter (" + t + ")" + s(n) + ". possible values: " + Object.keys(e).join(), r || x()) } function P(t, e, n, r) { c(t, e) || O("invalid parameter type" + s(n) + ". expected " + e + ", got " + typeof t, r || x()) } function L(t) { t() } function R(t, e, n) { t.texture ? f(t.texture._texture.internalformat, e, "unsupported texture format for attachment") : f(t.renderbuffer._renderbuffer.format, n, "unsupported renderbuffer format for attachment") } var D = 33071, N = 9728, z = 9984, F = 9985, B = 9986, j = 9987, U = 5121, V = 5122, G = 5123, H = 5124, W = 5125, X = 5126, q = 32819, Z = 32820, Y = 33635, K = 34042, Q = 36193, J = {}; function $(t, e) { return t === Z || t === q || t === Y ? 2 : t === K ? 4 : J[t] * e } function tt(t) { return !(t & t - 1 || !t) } function et(t, e, n) { var r, i = e.width, o = e.height, s = e.channels; a(i > 0 && i <= n.maxTextureSize && o > 0 && o <= n.maxTextureSize, "invalid texture shape"), t.wrapS === D && t.wrapT === D || a(tt(i) && tt(o), "incompatible wrap mode for texture, both width and height must be power of 2"), 1 === e.mipmask ? 1 !== i && 1 !== o && a(t.minFilter !== z && t.minFilter !== B && t.minFilter !== F && t.minFilter !== j, "min filter requires mipmap") : (a(tt(i) && tt(o), "texture must be a square power of 2 to support mipmapping"), a(e.mipmask === (i << 1) - 1, "missing or incomplete mipmap data")), e.type === X && (n.extensions.indexOf("oes_texture_float_linear") < 0 && a(t.minFilter === N && t.magFilter === N, "filter not supported, must enable oes_texture_float_linear"), a(!t.genMipmaps, "mipmap generation not supported with float textures")); var l = e.images; for (r = 0; r < 16; ++r)if (l[r]) { var u = i >> r, c = o >> r; a(e.mipmask & 1 << r, "missing mipmap data"); var p = l[r]; if (a(p.width === u && p.height === c, "invalid shape for mip images"), a(p.format === e.format && p.internalformat === e.internalformat && p.type === e.type, "incompatible type for mip image"), p.compressed); else if (p.data) { var h = Math.ceil($(p.type, s) * u / p.unpackAlignment) * p.unpackAlignment; a(p.data.byteLength === h * c, "invalid data for image, buffer size is inconsistent with image format") } else p.element || p.copy } else t.genMipmaps || a(0 == (e.mipmask & 1 << r), "extra mipmap data"); e.compressed && a(!t.genMipmaps, "mipmap generation for compressed images not supported") } function nt(t, e, n, r) { var i = t.width, o = t.height, s = t.channels; a(i > 0 && i <= r.maxTextureSize && o > 0 && o <= r.maxTextureSize, "invalid texture shape"), a(i === o, "cube map must be square"), a(e.wrapS === D && e.wrapT === D, "wrap mode not supported by cube map"); for (var l = 0; l < n.length; ++l) { var u = n[l]; a(u.width === i && u.height === o, "inconsistent cube map face shape"), e.genMipmaps && (a(!u.compressed, "can not generate mipmap for compressed textures"), a(1 === u.mipmask, "can not specify mipmaps and generate mipmaps")); for (var c = u.images, p = 0; p < 16; ++p) { var h = c[p]; if (h) { var f = i >> p, d = o >> p; a(u.mipmask & 1 << p, "missing mipmap data"), a(h.width === f && h.height === d, "invalid shape for mip images"), a(h.format === t.format && h.internalformat === t.internalformat && h.type === t.type, "incompatible type for mip image"), h.compressed || (h.data ? a(h.data.byteLength === f * d * Math.max($(h.type, s), h.unpackAlignment), "invalid data for image, buffer size is inconsistent with image format") : h.element || h.copy) } } } } J[5120] = J[U] = 1, J[V] = J[G] = J[Q] = J[Y] = J[q] = J[Z] = 2, J[H] = J[W] = J[X] = J[K] = 4; var rt = n(a, { optional: L, raise: o, commandRaise: O, command: k, parameter: l, commandParameter: I, constructor: m, type: p, commandType: P, isTypedArray: u, nni: h, oneOf: f, shaderError: C, linkError: T, callSite: b, saveCommandRef: A, saveDrawInfo: M, framebufferFormat: R, guessCommand: x, texture2D: et, textureCube: nt }), it = 0, ot = 0, at = 5, st = 6; function lt(t, e) { this.id = it++, this.type = t, this.data = e } function ut(t) { return t.replace(/\\/g, "\\\\").replace(/"/g, '\\"') } function ct(t) { if (0 === t.length) return []; var e = t.charAt(0), n = t.charAt(t.length - 1); if (t.length > 1 && e === n && ('"' === e || "'" === e)) return ['"' + ut(t.substr(1, t.length - 2)) + '"']; var r = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(t); if (r) return ct(t.substr(0, r.index)).concat(ct(r[1])).concat(ct(t.substr(r.index + r[0].length))); var i = t.split("."); if (1 === i.length) return ['"' + ut(t) + '"']; for (var o = [], a = 0; a < i.length; ++a)o = o.concat(ct(i[a])); return o } function pt(t) { return "[" + ct(t).join("][") + "]" } function ht(t, e) { return new lt(t, pt(e + "")) } function ft(t) { return "function" == typeof t && !t._reglType || t instanceof lt } function dt(t, e) { return "function" == typeof t ? new lt(ot, t) : "number" == typeof t || "boolean" == typeof t ? new lt(at, t) : Array.isArray(t) ? new lt(st, t.map((function (t, n) { return dt(t, e + "[" + n + "]") }))) : t instanceof lt ? t : void rt(!1, "invalid option type in uniform " + e) } var mt = { DynamicVariable: lt, define: ht, isDynamic: ft, unbox: dt, accessor: pt }, vt = { next: "function" == typeof requestAnimationFrame ? function (t) { return requestAnimationFrame(t) } : function (t) { return setTimeout(t, 16) }, cancel: "function" == typeof cancelAnimationFrame ? function (t) { return cancelAnimationFrame(t) } : clearTimeout }, yt = "undefined" != typeof my && my && "function" == typeof my.showToast && !0 !== my.isFRM ? function () { return +new Date } : "undefined" != typeof performance && performance.now ? function () { return performance.now() } : function () { return +new Date }; function gt() { var t = { "": 0 }, e = [""]; return { id: function (n) { var r = t[n]; return r || (r = t[n] = e.length, e.push(n), r) }, str: function (t) { return e[t] } } } function _t(t, e, r) { var i, o = document.createElement("canvas"); function a() { var e = window.innerWidth, n = window.innerHeight; if (t !== document.body) { var i = o.getBoundingClientRect(); e = i.right - i.left, n = i.bottom - i.top } o.width = r * e, o.height = r * n } function s() { i ? i.disconnect() : window.removeEventListener("resize", a), t.removeChild(o) } return n(o.style, { border: 0, margin: 0, padding: 0, top: 0, left: 0, width: "100%", height: "100%" }), t.appendChild(o), t === document.body && (o.style.position = "absolute", n(t.style, { margin: 0, padding: 0 })), t !== document.body && "function" == typeof ResizeObserver ? (i = new ResizeObserver((function () { setTimeout(a) }))).observe(t) : window.addEventListener("resize", a, !1), a(), { canvas: o, onDestroy: s } } function xt(t, e) { function n(n) { try { return t.getContext(n, e) } catch (t) { return null } } return n("webgl") || n("experimental-webgl") || n("webgl-experimental") } function bt(t) { return "string" == typeof t.nodeName && "function" == typeof t.appendChild && "function" == typeof t.getBoundingClientRect } function wt(t) { return "function" == typeof t.drawArrays || "function" == typeof t.drawElements } function St(t) { return "string" == typeof t ? t.split() : (rt(Array.isArray(t), "invalid extension array"), t) } function Et(t) { return "string" == typeof t ? (rt("undefined" != typeof document, "not supported outside of DOM"), document.querySelector(t)) : t } function Ct(t) { var e, n, r, i, o = t || {}, a = {}, s = [], l = [], u = "undefined" == typeof window ? 1 : window.devicePixelRatio, c = !1, p = function (t) { t && rt.raise(t) }, h = function () { }; if ("string" == typeof o ? (rt("undefined" != typeof document, "selector queries only supported in DOM environments"), e = document.querySelector(o), rt(e, "invalid query string for element")) : "object" == typeof o ? bt(o) ? e = o : wt(o) ? r = (i = o).canvas : (rt.constructor(o), "gl" in o ? i = o.gl : "canvas" in o ? r = Et(o.canvas) : "container" in o && (n = Et(o.container)), "attributes" in o && (a = o.attributes, rt.type(a, "object", "invalid context attributes")), "extensions" in o && (s = St(o.extensions)), "optionalExtensions" in o && (l = St(o.optionalExtensions)), "onDone" in o && (rt.type(o.onDone, "function", "invalid or missing onDone callback"), p = o.onDone), "profile" in o && (c = !!o.profile), "pixelRatio" in o && (u = +o.pixelRatio, rt(u > 0, "invalid pixel ratio"))) : rt.raise("invalid arguments to regl"), e && ("canvas" === e.nodeName.toLowerCase() ? r = e : n = e), !i) { if (!r) { rt("undefined" != typeof document, "must manually specify webgl context outside of DOM environments"); var f = _t(n || document.body, p, u); if (!f) return null; r = f.canvas, h = f.onDestroy } void 0 === a.premultipliedAlpha && (a.premultipliedAlpha = !0), i = xt(r, a) } return i ? { gl: i, canvas: r, container: n, extensions: s, optionalExtensions: l, pixelRatio: u, profile: c, onDone: p, onDestroy: h } : (h(), p("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null) } function Tt(t, e) { var n = {}; function r(t) { rt.type(t, "string", "extension name must be string"); var e, r = t.toLowerCase(); try { e = n[r] = i(t) } catch (t) { } return !!e } function i(e) { return t.getExtension(e) ? t.getExtension(e) : t.getExtension(e.toLowerCase()) ? t.getExtension(e.toLowerCase()) : null } for (var o = 0; o < e.extensions.length; ++o) { var a = e.extensions[o]; if (!r(a)) return e.onDestroy(), e.onDone('"' + a + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null } return e.optionalExtensions.forEach(r), { extensions: n, restore: function () { Object.keys(n).forEach((function (t) { if (n[t] && !r(t)) throw new Error("(regl): error restoring extension " + t) })) } } } function At(t, e) { for (var n = Array(t), r = 0; r < t; ++r)n[r] = e(r); return n } var Mt = 5120, Ot = 5121, kt = 5122, It = 5123, Pt = 5124, Lt = 5125, Rt = 5126; function Dt(t) { for (var e = 16; e <= 1 << 28; e *= 16)if (t <= e) return e; return 0 } function Nt(t) { var e, n; return e = (t > 65535) << 4, e |= n = ((t >>>= e) > 255) << 3, e |= n = ((t >>>= n) > 15) << 2, (e |= n = ((t >>>= n) > 3) << 1) | (t >>>= n) >> 1 } function zt() { var t = At(8, (function () { return [] })); function e(e) { var n = Dt(e), r = t[Nt(n) >> 2]; return r.length > 0 ? r.pop() : new ArrayBuffer(n) } function n(e) { t[Nt(e.byteLength) >> 2].push(e) } function r(t, n) { var r = null; switch (t) { case Mt: r = new Int8Array(e(n), 0, n); break; case Ot: r = new Uint8Array(e(n), 0, n); break; case kt: r = new Int16Array(e(2 * n), 0, n); break; case It: r = new Uint16Array(e(2 * n), 0, n); break; case Pt: r = new Int32Array(e(4 * n), 0, n); break; case Lt: r = new Uint32Array(e(4 * n), 0, n); break; case Rt: r = new Float32Array(e(4 * n), 0, n); break; default: return null }return r.length !== n ? r.subarray(0, n) : r } function i(t) { n(t.buffer) } return { alloc: e, free: n, allocType: r, freeType: i } } var Ft = zt(); Ft.zero = zt(); var Bt = 3408, jt = 3410, Ut = 3411, Vt = 3412, Gt = 3413, Ht = 3414, Wt = 3415, Xt = 33901, qt = 33902, Zt = 3379, Yt = 3386, Kt = 34921, Qt = 36347, Jt = 36348, $t = 35661, te = 35660, ee = 34930, ne = 36349, re = 34076, ie = 34024, oe = 7936, ae = 7937, se = 7938, le = 35724, ue = 34047, ce = 36063, pe = 34852, he = 3553, fe = 34067, de = 34069, me = 33984, ve = 6408, ye = 5126, ge = 5121, _e = 36160, xe = 36053, be = 36064, we = 16384, Se = function (t, e) { var n = 1; e.ext_texture_filter_anisotropic && (n = t.getParameter(ue)); var r = 1, i = 1; e.webgl_draw_buffers && (r = t.getParameter(pe), i = t.getParameter(ce)); var o = !!e.oes_texture_float; if (o) { var a = t.createTexture(); t.bindTexture(he, a), t.texImage2D(he, 0, ve, 1, 1, 0, ve, ye, null); var s = t.createFramebuffer(); if (t.bindFramebuffer(_e, s), t.framebufferTexture2D(_e, be, he, a, 0), t.bindTexture(he, null), t.checkFramebufferStatus(_e) !== xe) o = !1; else { t.viewport(0, 0, 1, 1), t.clearColor(1, 0, 0, 1), t.clear(we); var l = Ft.allocType(ye, 4); t.readPixels(0, 0, 1, 1, ve, ye, l), t.getError() ? o = !1 : (t.deleteFramebuffer(s), t.deleteTexture(a), o = 1 === l[0]), Ft.freeType(l) } } var u = !0; if ("undefined" == typeof navigator || !(/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))) { var c = t.createTexture(), p = Ft.allocType(ge, 36); t.activeTexture(me), t.bindTexture(fe, c), t.texImage2D(de, 0, ve, 3, 3, 0, ve, ge, p), Ft.freeType(p), t.bindTexture(fe, null), t.deleteTexture(c), u = !t.getError() } return { colorBits: [t.getParameter(jt), t.getParameter(Ut), t.getParameter(Vt), t.getParameter(Gt)], depthBits: t.getParameter(Ht), stencilBits: t.getParameter(Wt), subpixelBits: t.getParameter(Bt), extensions: Object.keys(e).filter((function (t) { return !!e[t] })), maxAnisotropic: n, maxDrawbuffers: r, maxColorAttachments: i, pointSizeDims: t.getParameter(Xt), lineWidthDims: t.getParameter(qt), maxViewportDims: t.getParameter(Yt), maxCombinedTextureUnits: t.getParameter($t), maxCubeMapSize: t.getParameter(re), maxRenderbufferSize: t.getParameter(ie), maxTextureUnits: t.getParameter(ee), maxTextureSize: t.getParameter(Zt), maxAttributes: t.getParameter(Kt), maxVertexUniforms: t.getParameter(Qt), maxVertexTextureUnits: t.getParameter(te), maxVaryingVectors: t.getParameter(Jt), maxFragmentUniforms: t.getParameter(ne), glsl: t.getParameter(le), renderer: t.getParameter(ae), vendor: t.getParameter(oe), version: t.getParameter(se), readFloat: o, npotTextureCube: u } }; function Ee(t) { return !!t && "object" == typeof t && Array.isArray(t.shape) && Array.isArray(t.stride) && "number" == typeof t.offset && t.shape.length === t.stride.length && (Array.isArray(t.data) || e(t.data)) } var Ce = function (t) { return Object.keys(t).map((function (e) { return t[e] })) }, Te = { shape: Pe, flatten: Ie }; function Ae(t, e, n) { for (var r = 0; r < e; ++r)n[r] = t[r] } function Me(t, e, n, r) { for (var i = 0, o = 0; o < e; ++o)for (var a = t[o], s = 0; s < n; ++s)r[i++] = a[s] } function Oe(t, e, n, r, i, o) { for (var a = o, s = 0; s < e; ++s)for (var l = t[s], u = 0; u < n; ++u)for (var c = l[u], p = 0; p < r; ++p)i[a++] = c[p] } function ke(t, e, n, r, i) { for (var o = 1, a = n + 1; a < e.length; ++a)o *= e[a]; var s = e[n]; if (e.length - n == 4) { var l = e[n + 1], u = e[n + 2], c = e[n + 3]; for (a = 0; a < s; ++a)Oe(t[a], l, u, c, r, i), i += o } else for (a = 0; a < s; ++a)ke(t[a], e, n + 1, r, i), i += o } function Ie(t, e, n, r) { var i = 1; if (e.length) for (var o = 0; o < e.length; ++o)i *= e[o]; else i = 0; var a = r || Ft.allocType(n, i); switch (e.length) { case 0: break; case 1: Ae(t, e[0], a); break; case 2: Me(t, e[0], e[1], a); break; case 3: Oe(t, e[0], e[1], e[2], a, 0); break; default: ke(t, e, 0, a, 0) }return a } function Pe(t) { for (var e = [], n = t; n.length; n = n[0])e.push(n.length); return e } var Le = { "[object Int8Array]": 5120, "[object Int16Array]": 5122, "[object Int32Array]": 5124, "[object Uint8Array]": 5121, "[object Uint8ClampedArray]": 5121, "[object Uint16Array]": 5123, "[object Uint32Array]": 5125, "[object Float32Array]": 5126, "[object Float64Array]": 5121, "[object ArrayBuffer]": 5121 }, Re = { int8: 5120, int16: 5122, int32: 5124, uint8: 5121, uint16: 5123, uint32: 5125, float: 5126, float32: 5126 }, De = { dynamic: 35048, stream: 35040, static: 35044 }, Ne = Te.flatten, ze = Te.shape, Fe = 35044, Be = 35040, je = 5121, Ue = 5126, Ve = []; function Ge(t) { return 0 | Le[Object.prototype.toString.call(t)] } function He(t, e) { for (var n = 0; n < e.length; ++n)t[n] = e[n] } function We(t, e, n, r, i, o, a) { for (var s = 0, l = 0; l < n; ++l)for (var u = 0; u < r; ++u)t[s++] = e[i * l + o * u + a] } function Xe(t, n, r, i) { var o = 0, a = {}; function s(e) { this.id = o++, this.buffer = t.createBuffer(), this.type = e, this.usage = Fe, this.byteLength = 0, this.dimension = 1, this.dtype = je, this.persistentData = null, r.profile && (this.stats = { size: 0 }) } s.prototype.bind = function () { t.bindBuffer(this.type, this.buffer) }, s.prototype.destroy = function () { f(this) }; var l = []; function u(t, e) { var n = l.pop(); return n || (n = new s(t)), n.bind(), h(n, e, Be, 0, 1, !1), n } function c(t) { l.push(t) } function p(e, n, r) { e.byteLength = n.byteLength, t.bufferData(e.type, n, r) } function h(t, n, r, i, o, a) { var s, l; if (t.usage = r, Array.isArray(n)) { if (t.dtype = i || Ue, n.length > 0) if (Array.isArray(n[0])) { s = ze(n); for (var u = 1, c = 1; c < s.length; ++c)u *= s[c]; t.dimension = u, p(t, l = Ne(n, s, t.dtype), r), a ? t.persistentData = l : Ft.freeType(l) } else if ("number" == typeof n[0]) { t.dimension = o; var h = Ft.allocType(t.dtype, n.length); He(h, n), p(t, h, r), a ? t.persistentData = h : Ft.freeType(h) } else e(n[0]) ? (t.dimension = n[0].length, t.dtype = i || Ge(n[0]) || Ue, p(t, l = Ne(n, [n.length, n[0].length], t.dtype), r), a ? t.persistentData = l : Ft.freeType(l)) : rt.raise("invalid buffer data") } else if (e(n)) t.dtype = i || Ge(n), t.dimension = o, p(t, n, r), a && (t.persistentData = new Uint8Array(new Uint8Array(n.buffer))); else if (Ee(n)) { s = n.shape; var f = n.stride, d = n.offset, m = 0, v = 0, y = 0, g = 0; 1 === s.length ? (m = s[0], v = 1, y = f[0], g = 0) : 2 === s.length ? (m = s[0], v = s[1], y = f[0], g = f[1]) : rt.raise("invalid shape"), t.dtype = i || Ge(n.data) || Ue, t.dimension = v; var _ = Ft.allocType(t.dtype, m * v); We(_, n.data, m, v, y, g, d), p(t, _, r), a ? t.persistentData = _ : Ft.freeType(_) } else n instanceof ArrayBuffer ? (t.dtype = je, t.dimension = o, p(t, n, r), a && (t.persistentData = new Uint8Array(new Uint8Array(n)))) : rt.raise("invalid buffer data") } function f(e) { n.bufferCount--, i(e); var r = e.buffer; rt(r, "buffer must not be deleted already"), t.deleteBuffer(r), e.buffer = null, delete a[e.id] } function d(i, o, l, u) { n.bufferCount++; var c = new s(o); function p(n) { var i = Fe, o = null, a = 0, s = 0, l = 1; return Array.isArray(n) || e(n) || Ee(n) || n instanceof ArrayBuffer ? o = n : "number" == typeof n ? a = 0 | n : n && (rt.type(n, "object", "buffer arguments must be an object, a number or an array"), "data" in n && (rt(null === o || Array.isArray(o) || e(o) || Ee(o), "invalid data for buffer"), o = n.data), "usage" in n && (rt.parameter(n.usage, De, "invalid buffer usage"), i = De[n.usage]), "type" in n && (rt.parameter(n.type, Re, "invalid buffer type"), s = Re[n.type]), "dimension" in n && (rt.type(n.dimension, "number", "invalid dimension"), l = 0 | n.dimension), "length" in n && (rt.nni(a, "buffer length must be a nonnegative integer"), a = 0 | n.length)), c.bind(), o ? h(c, o, i, s, l, u) : (a && t.bufferData(c.type, a, i), c.dtype = s || je, c.usage = i, c.dimension = l, c.byteLength = a), r.profile && (c.stats.size = c.byteLength * Ve[c.dtype]), p } function d(e, n) { rt(n + e.byteLength <= c.byteLength, "invalid buffer subdata call, buffer is too small.  Can't write data of size " + e.byteLength + " starting from offset " + n + " to a buffer of size " + c.byteLength), t.bufferSubData(c.type, n, e) } function m(t, n) { var r, i = 0 | (n || 0); if (c.bind(), e(t) || t instanceof ArrayBuffer) d(t, i); else if (Array.isArray(t)) { if (t.length > 0) if ("number" == typeof t[0]) { var o = Ft.allocType(c.dtype, t.length); He(o, t), d(o, i), Ft.freeType(o) } else if (Array.isArray(t[0]) || e(t[0])) { r = ze(t); var a = Ne(t, r, c.dtype); d(a, i), Ft.freeType(a) } else rt.raise("invalid buffer data") } else if (Ee(t)) { r = t.shape; var s = t.stride, l = 0, u = 0, h = 0, f = 0; 1 === r.length ? (l = r[0], u = 1, h = s[0], f = 0) : 2 === r.length ? (l = r[0], u = r[1], h = s[0], f = s[1]) : rt.raise("invalid shape"); var m = Array.isArray(t.data) ? c.dtype : Ge(t.data), v = Ft.allocType(m, l * u); We(v, t.data, l, u, h, f, t.offset), d(v, i), Ft.freeType(v) } else rt.raise("invalid data for buffer subdata"); return p } return a[c.id] = c, l || p(i), p._reglType = "buffer", p._buffer = c, p.subdata = m, r.profile && (p.stats = c.stats), p.destroy = function () { f(c) }, p } function m() { Ce(a).forEach((function (e) { e.buffer = t.createBuffer(), t.bindBuffer(e.type, e.buffer), t.bufferData(e.type, e.persistentData || e.byteLength, e.usage) })) } return r.profile && (n.getTotalBufferSize = function () { var t = 0; return Object.keys(a).forEach((function (e) { t += a[e].stats.size })), t }), { create: d, createStream: u, destroyStream: c, clear: function () { Ce(a).forEach(f), l.forEach(f) }, getBuffer: function (t) { return t && t._buffer instanceof s ? t._buffer : null }, restore: m, _initBuffer: h } } Ve[5120] = 1, Ve[5122] = 2, Ve[5124] = 4, Ve[5121] = 1, Ve[5123] = 2, Ve[5125] = 4, Ve[5126] = 4; var qe = { points: 0, point: 0, lines: 1, line: 1, triangles: 4, triangle: 4, "line loop": 2, "line strip": 3, "triangle strip": 5, "triangle fan": 6 }, Ze = 0, Ye = 1, Ke = 4, Qe = 5120, Je = 5121, $e = 5122, tn = 5123, en = 5124, nn = 5125, rn = 34963, on = 35040, an = 35044; function sn(t, n, r, i) { var o = {}, a = 0, s = { uint8: Je, uint16: tn }; function l(t) { this.id = a++, o[this.id] = this, this.buffer = t, this.primType = Ke, this.vertCount = 0, this.type = 0 } n.oes_element_index_uint && (s.uint32 = nn), l.prototype.bind = function () { this.buffer.bind() }; var u = []; function c(t) { var e = u.pop(); return e || (e = new l(r.create(null, rn, !0, !1)._buffer)), h(e, t, on, -1, -1, 0, 0), e } function p(t) { u.push(t) } function h(i, o, a, s, l, u, c) { var p; if (i.buffer.bind(), o) { var h = c; c || e(o) && (!Ee(o) || e(o.data)) || (h = n.oes_element_index_uint ? nn : tn), r._initBuffer(i.buffer, o, a, h, 3) } else t.bufferData(rn, u, a), i.buffer.dtype = p || Je, i.buffer.usage = a, i.buffer.dimension = 3, i.buffer.byteLength = u; if (p = c, !c) { switch (i.buffer.dtype) { case Je: case Qe: p = Je; break; case tn: case $e: p = tn; break; case nn: case en: p = nn; break; default: rt.raise("unsupported type for element array") }i.buffer.dtype = p } i.type = p, rt(p !== nn || !!n.oes_element_index_uint, "32 bit element buffers not supported, enable oes_element_index_uint first"); var f = l; f < 0 && (f = i.buffer.byteLength, p === tn ? f >>= 1 : p === nn && (f >>= 2)), i.vertCount = f; var d = s; if (s < 0) { d = Ke; var m = i.buffer.dimension; 1 === m && (d = Ze), 2 === m && (d = Ye), 3 === m && (d = Ke) } i.primType = d } function f(t) { i.elementsCount--, rt(null !== t.buffer, "must not double destroy elements"), delete o[t.id], t.buffer.destroy(), t.buffer = null } function d(t, n) { var o = r.create(null, rn, !0), a = new l(o._buffer); function u(t) { if (t) if ("number" == typeof t) o(t), a.primType = Ke, a.vertCount = 0 | t, a.type = Je; else { var n = null, r = an, i = -1, l = -1, c = 0, p = 0; Array.isArray(t) || e(t) || Ee(t) ? n = t : (rt.type(t, "object", "invalid arguments for elements"), "data" in t && (n = t.data, rt(Array.isArray(n) || e(n) || Ee(n), "invalid data for element buffer")), "usage" in t && (rt.parameter(t.usage, De, "invalid element buffer usage"), r = De[t.usage]), "primitive" in t && (rt.parameter(t.primitive, qe, "invalid element buffer primitive"), i = qe[t.primitive]), "count" in t && (rt("number" == typeof t.count && t.count >= 0, "invalid vertex count for elements"), l = 0 | t.count), "type" in t && (rt.parameter(t.type, s, "invalid buffer type"), p = s[t.type]), "length" in t ? c = 0 | t.length : (c = l, p === tn || p === $e ? c *= 2 : p !== nn && p !== en || (c *= 4))), h(a, n, r, i, l, c, p) } else o(), a.primType = Ke, a.vertCount = 0, a.type = Je; return u } return i.elementsCount++, u(t), u._reglType = "elements", u._elements = a, u.subdata = function (t, e) { return o.subdata(t, e), u }, u.destroy = function () { f(a) }, u } return { create: d, createStream: c, destroyStream: p, getElements: function (t) { return "function" == typeof t && t._elements instanceof l ? t._elements : null }, clear: function () { Ce(o).forEach(f) } } } var ln = new Float32Array(1), un = new Uint32Array(ln.buffer), cn = 5123; function pn(t) { for (var e = Ft.allocType(cn, t.length), n = 0; n < t.length; ++n)if (isNaN(t[n])) e[n] = 65535; else if (t[n] === 1 / 0) e[n] = 31744; else if (t[n] === -1 / 0) e[n] = 64512; else { ln[0] = t[n]; var r = un[0], i = r >>> 31 << 15, o = (r << 1 >>> 24) - 127, a = r >> 13 & 1023; if (o < -24) e[n] = i; else if (o < -14) { var s = -14 - o; e[n] = i + (a + 1024 >> s) } else e[n] = o > 15 ? i + 31744 : i + (o + 15 << 10) + a } return e } function hn(t) { return Array.isArray(t) || e(t) } var fn = function (t) { return !(t & t - 1 || !t) }, dn = 34467, mn = 3553, vn = 34067, yn = 34069, gn = 6408, _n = 6406, xn = 6407, bn = 6409, wn = 6410, Sn = 32854, En = 32855, Cn = 36194, Tn = 32819, An = 32820, Mn = 33635, On = 34042, kn = 6402, In = 34041, Pn = 35904, Ln = 35906, Rn = 36193, Dn = 33776, Nn = 33777, zn = 33778, Fn = 33779, Bn = 35986, jn = 35987, Un = 34798, Vn = 35840, Gn = 35841, Hn = 35842, Wn = 35843, Xn = 36196, qn = 5121, Zn = 5123, Yn = 5125, Kn = 5126, Qn = 10242, Jn = 10243, $n = 10497, tr = 33071, er = 33648, nr = 10240, rr = 10241, ir = 9728, or = 9729, ar = 9984, sr = 9985, lr = 9986, ur = 9987, cr = 33170, pr = 4352, hr = 4353, fr = 4354, dr = 34046, mr = 3317, vr = 37440, yr = 37441, gr = 37443, _r = 37444, xr = 33984, br = [ar, lr, sr, ur], wr = [0, bn, wn, xn, gn], Sr = {}; function Er(t) { return "[object " + t + "]" } Sr[bn] = Sr[_n] = Sr[kn] = 1, Sr[In] = Sr[wn] = 2, Sr[xn] = Sr[Pn] = 3, Sr[gn] = Sr[Ln] = 4; var Cr = Er("HTMLCanvasElement"), Tr = Er("OffscreenCanvas"), Ar = Er("CanvasRenderingContext2D"), Mr = Er("ImageBitmap"), Or = Er("HTMLImageElement"), kr = Er("HTMLVideoElement"), Ir = Object.keys(Le).concat([Cr, Tr, Ar, Mr, Or, kr]), Pr = []; Pr[qn] = 1, Pr[Kn] = 4, Pr[Rn] = 2, Pr[Zn] = 2, Pr[Yn] = 4; var Lr = []; function Rr(t) { return Array.isArray(t) && (0 === t.length || "number" == typeof t[0]) } function Dr(t) { return !!Array.isArray(t) && !(0 === t.length || !hn(t[0])) } function Nr(t) { return Object.prototype.toString.call(t) } function zr(t) { return Nr(t) === Cr } function Fr(t) { return Nr(t) === Tr } function Br(t) { return Nr(t) === Ar } function jr(t) { return Nr(t) === Mr } function Ur(t) { return Nr(t) === Or } function Vr(t) { return Nr(t) === kr } function Gr(t) { return !!("undefined" != typeof my && my && "function" == typeof my.showToast && !0 !== my.isFRM && t && t.getContext) } function Hr(t) { return !!("undefined" != typeof my && my && "function" == typeof my.showToast && !0 !== my.isFRM && t && "src" in t && "crossOrigin" in t) } function Wr(t) { if (!t) return !1; if (Gr(t) || Hr(t)) return !0; var e = Nr(t); return Ir.indexOf(e) >= 0 || Rr(t) || Dr(t) || Ee(t) } function Xr(t) { return 0 | Le[Object.prototype.toString.call(t)] } function qr(t, e) { var n = e.length; switch (t.type) { case qn: case Zn: case Yn: case Kn: var r = Ft.allocType(t.type, n); r.set(e), t.data = r; break; case Rn: t.data = pn(e); break; default: rt.raise("unsupported texture type, must specify a typed array") } } function Zr(t, e) { return Ft.allocType(t.type === Rn ? Kn : t.type, e) } function Yr(t, e) { t.type === Rn ? (t.data = pn(e), Ft.freeType(e)) : t.data = e } function Kr(t, e, n, r, i, o) { for (var a = t.width, s = t.height, l = t.channels, u = Zr(t, a * s * l), c = 0, p = 0; p < s; ++p)for (var h = 0; h < a; ++h)for (var f = 0; f < l; ++f)u[c++] = e[n * h + r * p + i * f + o]; Yr(t, u) } function Qr(t, e, n, r, i, o) { var a; if (a = void 0 !== Lr[t] ? Lr[t] : Sr[t] * Pr[e], o && (a *= 6), i) { for (var s = 0, l = n; l >= 1;)s += a * l * l, l /= 2; return s } return a * n * r } function Jr(t, r, i, o, a, s, l) { var u = { "don't care": pr, "dont care": pr, nice: fr, fast: hr }, c = { repeat: $n, clamp: tr, mirror: er }, p = { nearest: ir, linear: or }, h = n({ mipmap: ur, "nearest mipmap nearest": ar, "linear mipmap nearest": sr, "nearest mipmap linear": lr, "linear mipmap linear": ur }, p), f = { none: 0, browser: _r }, d = { uint8: qn, rgba4: Tn, rgb565: Mn, "rgb5 a1": An }, m = { alpha: _n, luminance: bn, "luminance alpha": wn, rgb: xn, rgba: gn, rgba4: Sn, "rgb5 a1": En, rgb565: Cn }, v = {}; r.ext_srgb && (m.srgb = Pn, m.srgba = Ln), r.oes_texture_float && (d.float32 = d.float = Kn), r.oes_texture_half_float && (d.float16 = d["half float"] = Rn), r.webgl_depth_texture && (n(m, { depth: kn, "depth stencil": In }), n(d, { uint16: Zn, uint32: Yn, "depth stencil": On })), r.webgl_compressed_texture_s3tc && n(v, { "rgb s3tc dxt1": Dn, "rgba s3tc dxt1": Nn, "rgba s3tc dxt3": zn, "rgba s3tc dxt5": Fn }), r.webgl_compressed_texture_atc && n(v, { "rgb atc": Bn, "rgba atc explicit alpha": jn, "rgba atc interpolated alpha": Un }), r.webgl_compressed_texture_pvrtc && n(v, { "rgb pvrtc 4bppv1": Vn, "rgb pvrtc 2bppv1": Gn, "rgba pvrtc 4bppv1": Hn, "rgba pvrtc 2bppv1": Wn }), r.webgl_compressed_texture_etc1 && (v["rgb etc1"] = Xn); var y = Array.prototype.slice.call(t.getParameter(dn) || new Uint32Array(0)); Object.keys(v).forEach((function (t) { var e = v[t]; y.indexOf(e) >= 0 && (m[t] = e) })); var g = Object.keys(m); i.textureFormats = g; var _ = []; Object.keys(m).forEach((function (t) { var e = m[t]; _[e] = t })); var x = []; Object.keys(d).forEach((function (t) { var e = d[t]; x[e] = t })); var b = []; Object.keys(p).forEach((function (t) { var e = p[t]; b[e] = t })); var w = []; Object.keys(h).forEach((function (t) { var e = h[t]; w[e] = t })); var S = []; Object.keys(c).forEach((function (t) { var e = c[t]; S[e] = t })); var E = g.reduce((function (t, e) { var n = m[e]; return n === bn || n === _n || n === bn || n === wn || n === kn || n === In || r.ext_srgb && (n === Pn || n === Ln) ? t[n] = n : n === En || e.indexOf("rgba") >= 0 ? t[n] = gn : t[n] = xn, t }), {}); function C() { this.internalformat = gn, this.format = gn, this.type = qn, this.compressed = !1, this.premultiplyAlpha = !1, this.flipY = !1, this.unpackAlignment = 1, this.colorSpace = _r, this.width = 0, this.height = 0, this.channels = 0 } function T(t, e) { t.internalformat = e.internalformat, t.format = e.format, t.type = e.type, t.compressed = e.compressed, t.premultiplyAlpha = e.premultiplyAlpha, t.flipY = e.flipY, t.unpackAlignment = e.unpackAlignment, t.colorSpace = e.colorSpace, t.width = e.width, t.height = e.height, t.channels = e.channels } function A(t, e) { if ("object" == typeof e && e) { if ("premultiplyAlpha" in e && (rt.type(e.premultiplyAlpha, "boolean", "invalid premultiplyAlpha"), t.premultiplyAlpha = e.premultiplyAlpha), "flipY" in e && (rt.type(e.flipY, "boolean", "invalid texture flip"), t.flipY = e.flipY), "alignment" in e && (rt.oneOf(e.alignment, [1, 2, 4, 8], "invalid texture unpack alignment"), t.unpackAlignment = e.alignment), "colorSpace" in e && (rt.parameter(e.colorSpace, f, "invalid colorSpace"), t.colorSpace = f[e.colorSpace]), "type" in e) { var n = e.type; rt(r.oes_texture_float || !("float" === n || "float32" === n), "you must enable the OES_texture_float extension in order to use floating point textures."), rt(r.oes_texture_half_float || !("half float" === n || "float16" === n), "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."), rt(r.webgl_depth_texture || !("uint16" === n || "uint32" === n || "depth stencil" === n), "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."), rt.parameter(n, d, "invalid texture type"), t.type = d[n] } var o = t.width, a = t.height, s = t.channels, l = !1; "shape" in e ? (rt(Array.isArray(e.shape) && e.shape.length >= 2, "shape must be an array"), o = e.shape[0], a = e.shape[1], 3 === e.shape.length && (s = e.shape[2], rt(s > 0 && s <= 4, "invalid number of channels"), l = !0), rt(o >= 0 && o <= i.maxTextureSize, "invalid width"), rt(a >= 0 && a <= i.maxTextureSize, "invalid height")) : ("radius" in e && (o = a = e.radius, rt(o >= 0 && o <= i.maxTextureSize, "invalid radius")), "width" in e && (o = e.width, rt(o >= 0 && o <= i.maxTextureSize, "invalid width")), "height" in e && (a = e.height, rt(a >= 0 && a <= i.maxTextureSize, "invalid height")), "channels" in e && (s = e.channels, rt(s > 0 && s <= 4, "invalid number of channels"), l = !0)), t.width = 0 | o, t.height = 0 | a, t.channels = 0 | s; var u = !1; if ("format" in e) { var c = e.format; rt(r.webgl_depth_texture || !("depth" === c || "depth stencil" === c), "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."), rt.parameter(c, m, "invalid texture format"); var p = t.internalformat = m[c]; t.format = E[p], c in d && ("type" in e || (t.type = d[c])), c in v && (t.compressed = !0), u = !0 } !l && u ? t.channels = Sr[t.format] : l && !u ? t.channels !== wr[t.format] && (t.format = t.internalformat = wr[t.channels]) : u && l && rt(t.channels === Sr[t.format], "number of channels inconsistent with specified format") } } function M(e) { t.pixelStorei(vr, e.flipY), t.pixelStorei(yr, e.premultiplyAlpha), t.pixelStorei(gr, e.colorSpace), t.pixelStorei(mr, e.unpackAlignment) } function O() { C.call(this), this.xOffset = 0, this.yOffset = 0, this.data = null, this.needsFree = !1, this.element = null, this.needsCopy = !1 } function k(t, n) { var r = null; if (Wr(n) ? r = n : n && (rt.type(n, "object", "invalid pixel data type"), A(t, n), "x" in n && (t.xOffset = 0 | n.x), "y" in n && (t.yOffset = 0 | n.y), Wr(n.data) && (r = n.data)), rt(!t.compressed || r instanceof Uint8Array, "compressed texture data must be stored in a uint8array"), n.copy) { rt(!r, "can not specify copy and data field for the same texture"); var o = a.viewportWidth, s = a.viewportHeight; t.width = t.width || o - t.xOffset, t.height = t.height || s - t.yOffset, t.needsCopy = !0, rt(t.xOffset >= 0 && t.xOffset < o && t.yOffset >= 0 && t.yOffset < s && t.width > 0 && t.width <= o && t.height > 0 && t.height <= s, "copy texture read out of bounds") } else if (r) { if (e(r)) t.channels = t.channels || 4, t.data = r, "type" in n || t.type !== qn || (t.type = Xr(r)); else if (Rr(r)) t.channels = t.channels || 4, qr(t, r), t.alignment = 1, t.needsFree = !0; else if (Ee(r)) { var l = r.data; Array.isArray(l) || t.type !== qn || (t.type = Xr(l)); var u, c, p, h, f, d, m = r.shape, v = r.stride; 3 === m.length ? (p = m[2], d = v[2]) : (rt(2 === m.length, "invalid ndarray pixel data, must be 2 or 3D"), p = 1, d = 1), u = m[0], c = m[1], h = v[0], f = v[1], t.alignment = 1, t.width = u, t.height = c, t.channels = p, t.format = t.internalformat = wr[p], t.needsFree = !0, Kr(t, l, h, f, d, r.offset) } else if (Gr(r) || zr(r) || Fr(r) || Br(r)) Gr(r) || zr(r) || Fr(r) ? t.element = r : t.element = r.canvas, t.width = t.element.width, t.height = t.element.height, t.channels = 4; else if (jr(r)) t.element = r, t.width = r.width, t.height = r.height, t.channels = 4; else if (Ur(r)) t.element = r, t.width = r.naturalWidth, t.height = r.naturalHeight, t.channels = 4; else if (Hr(r)) t.element = r, t.width = r.width, t.height = r.height, t.channels = 4; else if (Vr(r)) t.element = r, t.width = r.videoWidth, t.height = r.videoHeight, t.channels = 4; else if (Dr(r)) { var y = t.width || r[0].length, g = t.height || r.length, _ = t.channels; _ = hn(r[0][0]) ? _ || r[0][0].length : _ || 1; for (var x = Te.shape(r), b = 1, w = 0; w < x.length; ++w)b *= x[w]; var S = Zr(t, b); Te.flatten(r, x, "", S), Yr(t, S), t.alignment = 1, t.width = y, t.height = g, t.channels = _, t.format = t.internalformat = wr[_], t.needsFree = !0 } } else t.width = t.width || 1, t.height = t.height || 1, t.channels = t.channels || 4; t.type === Kn ? rt(i.extensions.indexOf("oes_texture_float") >= 0, "oes_texture_float extension not enabled") : t.type === Rn && rt(i.extensions.indexOf("oes_texture_half_float") >= 0, "oes_texture_half_float extension not enabled") } function I(e, n, r) { var i = e.element, a = e.data, s = e.internalformat, l = e.format, u = e.type, c = e.width, p = e.height; M(e), i ? t.texImage2D(n, r, l, l, u, i) : e.compressed ? t.compressedTexImage2D(n, r, s, c, p, 0, a) : e.needsCopy ? (o(), t.copyTexImage2D(n, r, l, e.xOffset, e.yOffset, c, p, 0)) : t.texImage2D(n, r, l, c, p, 0, l, u, a || null) } function P(e, n, r, i, a) { var s = e.element, l = e.data, u = e.internalformat, c = e.format, p = e.type, h = e.width, f = e.height; M(e), s ? t.texSubImage2D(n, a, r, i, c, p, s) : e.compressed ? t.compressedTexSubImage2D(n, a, r, i, u, h, f, l) : e.needsCopy ? (o(), t.copyTexSubImage2D(n, a, r, i, e.xOffset, e.yOffset, h, f)) : t.texSubImage2D(n, a, r, i, h, f, c, p, l) } var L = []; function R() { return L.pop() || new O } function D(t) { t.needsFree && Ft.freeType(t.data), O.call(t), L.push(t) } function N() { C.call(this), this.genMipmaps = !1, this.mipmapHint = pr, this.mipmask = 0, this.images = Array(16) } function z(t, e, n) { var r = t.images[0] = R(); t.mipmask = 1, r.width = t.width = e, r.height = t.height = n, r.channels = t.channels = 4 } function F(t, e) { var n = null; if (Wr(e)) T(n = t.images[0] = R(), t), k(n, e), t.mipmask = 1; else if (A(t, e), Array.isArray(e.mipmap)) for (var r = e.mipmap, i = 0; i < r.length; ++i)T(n = t.images[i] = R(), t), n.width >>= i, n.height >>= i, k(n, r[i]), t.mipmask |= 1 << i; else T(n = t.images[0] = R(), t), k(n, e), t.mipmask = 1; T(t, t.images[0]), !t.compressed || t.internalformat !== Dn && t.internalformat !== Nn && t.internalformat !== zn && t.internalformat !== Fn || rt(t.width % 4 == 0 && t.height % 4 == 0, "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4") } function B(t, e) { for (var n = t.images, r = 0; r < n.length; ++r) { if (!n[r]) return; I(n[r], e, r) } } var j = []; function U() { var t = j.pop() || new N; C.call(t), t.mipmask = 0; for (var e = 0; e < 16; ++e)t.images[e] = null; return t } function V(t) { for (var e = t.images, n = 0; n < e.length; ++n)e[n] && D(e[n]), e[n] = null; j.push(t) } function G() { this.minFilter = ir, this.magFilter = ir, this.wrapS = tr, this.wrapT = tr, this.anisotropic = 1, this.genMipmaps = !1, this.mipmapHint = pr } function H(t, e) { if ("min" in e) { var n = e.min; rt.parameter(n, h), t.minFilter = h[n], br.indexOf(t.minFilter) >= 0 && !("faces" in e) && (t.genMipmaps = !0) } if ("mag" in e) { var r = e.mag; rt.parameter(r, p), t.magFilter = p[r] } var o = t.wrapS, a = t.wrapT; if ("wrap" in e) { var s = e.wrap; "string" == typeof s ? (rt.parameter(s, c), o = a = c[s]) : Array.isArray(s) && (rt.parameter(s[0], c), rt.parameter(s[1], c), o = c[s[0]], a = c[s[1]]) } else { if ("wrapS" in e) { var l = e.wrapS; rt.parameter(l, c), o = c[l] } if ("wrapT" in e) { var f = e.wrapT; rt.parameter(f, c), a = c[f] } } if (t.wrapS = o, t.wrapT = a, "anisotropic" in e) { var d = e.anisotropic; rt("number" == typeof d && d >= 1 && d <= i.maxAnisotropic, "aniso samples must be between 1 and "), t.anisotropic = e.anisotropic } if ("mipmap" in e) { var m = !1; switch (typeof e.mipmap) { case "string": rt.parameter(e.mipmap, u, "invalid mipmap hint"), t.mipmapHint = u[e.mipmap], t.genMipmaps = !0, m = !0; break; case "boolean": m = t.genMipmaps = e.mipmap; break; case "object": rt(Array.isArray(e.mipmap), "invalid mipmap type"), t.genMipmaps = !1, m = !0; break; default: rt.raise("invalid mipmap type") }m && !("min" in e) && (t.minFilter = ar) } } function W(e, n) { t.texParameteri(n, rr, e.minFilter), t.texParameteri(n, nr, e.magFilter), t.texParameteri(n, Qn, e.wrapS), t.texParameteri(n, Jn, e.wrapT), r.ext_texture_filter_anisotropic && t.texParameteri(n, dr, e.anisotropic), e.genMipmaps && (t.hint(cr, e.mipmapHint), t.generateMipmap(n)) } var X = 0, q = {}, Z = i.maxTextureUnits, Y = Array(Z).map((function () { return null })); function K(e) { C.call(this), this.mipmask = 0, this.internalformat = gn, this.id = X++, this.refCount = 1, this.target = e, this.texture = t.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new G, l.profile && (this.stats = { size: 0 }) } function Q(e) { t.activeTexture(xr), t.bindTexture(e.target, e.texture) } function J() { var e = Y[0]; e ? t.bindTexture(e.target, e.texture) : t.bindTexture(mn, null) } function $(e) { var n = e.texture; rt(n, "must not double destroy texture"); var r = e.unit, i = e.target; r >= 0 && (t.activeTexture(xr + r), t.bindTexture(i, null), Y[r] = null), t.deleteTexture(n), e.texture = null, e.params = null, e.pixels = null, e.refCount = 0, delete q[e.id], s.textureCount-- } function tt(e, n) { var r = new K(mn); function o(t, e) { var n = r.texInfo; G.call(n); var a = U(); return "number" == typeof t ? z(a, 0 | t, "number" == typeof e ? 0 | e : 0 | t) : t ? (rt.type(t, "object", "invalid arguments to regl.texture"), H(n, t), F(a, t)) : z(a, 1, 1), n.genMipmaps && (a.mipmask = (a.width << 1) - 1), r.mipmask = a.mipmask, T(r, a), rt.texture2D(n, a, i), r.internalformat = a.internalformat, o.width = a.width, o.height = a.height, Q(r), B(a, mn), W(n, mn), J(), V(a), l.profile && (r.stats.size = Qr(r.internalformat, r.type, a.width, a.height, n.genMipmaps, !1)), o.format = _[r.internalformat], o.type = x[r.type], o.mag = b[n.magFilter], o.min = w[n.minFilter], o.wrapS = S[n.wrapS], o.wrapT = S[n.wrapT], o } function a(t, e, n, i) { rt(!!t, "must specify image data"); var a = 0 | e, s = 0 | n, l = 0 | i, u = R(); return T(u, r), u.width = 0, u.height = 0, k(u, t), u.width = u.width || (r.width >> l) - a, u.height = u.height || (r.height >> l) - s, rt(r.type === u.type && r.format === u.format && r.internalformat === u.internalformat, "incompatible format for texture.subimage"), rt(a >= 0 && s >= 0 && a + u.width <= r.width && s + u.height <= r.height, "texture.subimage write out of bounds"), rt(r.mipmask & 1 << l, "missing mipmap data"), rt(u.data || u.element || u.needsCopy, "missing image data"), Q(r), P(u, mn, a, s, l), J(), D(u), o } function u(e, n) { var i = 0 | e, a = 0 | n || i; if (i === r.width && a === r.height) return o; o.width = r.width = i, o.height = r.height = a, Q(r); for (var s = 0; r.mipmask >> s; ++s) { var u = i >> s, c = a >> s; if (!u || !c) break; t.texImage2D(mn, s, r.format, u, c, 0, r.format, r.type, null) } return J(), l.profile && (r.stats.size = Qr(r.internalformat, r.type, i, a, !1, !1)), o } return q[r.id] = r, s.textureCount++, o(e, n), o.subimage = a, o.resize = u, o._reglType = "texture2d", o._texture = r, l.profile && (o.stats = r.stats), o.destroy = function () { r.decRef() }, o } function et(e, n, r, o, a, u) { var c = new K(vn); q[c.id] = c, s.cubeCount++; var p = new Array(6); function h(t, e, n, r, o, a) { var s, u = c.texInfo; for (G.call(u), s = 0; s < 6; ++s)p[s] = U(); if ("number" != typeof t && t) if ("object" == typeof t) if (e) F(p[0], t), F(p[1], e), F(p[2], n), F(p[3], r), F(p[4], o), F(p[5], a); else if (H(u, t), A(c, t), "faces" in t) { var f = t.faces; for (rt(Array.isArray(f) && 6 === f.length, "cube faces must be a length 6 array"), s = 0; s < 6; ++s)rt("object" == typeof f[s] && !!f[s], "invalid input for cube map face"), T(p[s], c), F(p[s], f[s]) } else for (s = 0; s < 6; ++s)F(p[s], t); else rt.raise("invalid arguments to cube map"); else { var d = 0 | t || 1; for (s = 0; s < 6; ++s)z(p[s], d, d) } for (T(c, p[0]), rt.optional((function () { i.npotTextureCube || rt(fn(c.width) && fn(c.height), "your browser does not support non power or two texture dimensions") })), u.genMipmaps ? c.mipmask = (p[0].width << 1) - 1 : c.mipmask = p[0].mipmask, rt.textureCube(c, u, p, i), c.internalformat = p[0].internalformat, h.width = p[0].width, h.height = p[0].height, Q(c), s = 0; s < 6; ++s)B(p[s], yn + s); for (W(u, vn), J(), l.profile && (c.stats.size = Qr(c.internalformat, c.type, h.width, h.height, u.genMipmaps, !0)), h.format = _[c.internalformat], h.type = x[c.type], h.mag = b[u.magFilter], h.min = w[u.minFilter], h.wrapS = S[u.wrapS], h.wrapT = S[u.wrapT], s = 0; s < 6; ++s)V(p[s]); return h } function f(t, e, n, r, i) { rt(!!e, "must specify image data"), rt("number" == typeof t && t === (0 | t) && t >= 0 && t < 6, "invalid face"); var o = 0 | n, a = 0 | r, s = 0 | i, l = R(); return T(l, c), l.width = 0, l.height = 0, k(l, e), l.width = l.width || (c.width >> s) - o, l.height = l.height || (c.height >> s) - a, rt(c.type === l.type && c.format === l.format && c.internalformat === l.internalformat, "incompatible format for texture.subimage"), rt(o >= 0 && a >= 0 && o + l.width <= c.width && a + l.height <= c.height, "texture.subimage write out of bounds"), rt(c.mipmask & 1 << s, "missing mipmap data"), rt(l.data || l.element || l.needsCopy, "missing image data"), Q(c), P(l, yn + t, o, a, s), J(), D(l), h } function d(e) { var n = 0 | e; if (n !== c.width) { h.width = c.width = n, h.height = c.height = n, Q(c); for (var r = 0; r < 6; ++r)for (var i = 0; c.mipmask >> i; ++i)t.texImage2D(yn + r, i, c.format, n >> i, n >> i, 0, c.format, c.type, null); return J(), l.profile && (c.stats.size = Qr(c.internalformat, c.type, h.width, h.height, !1, !0)), h } } return h(e, n, r, o, a, u), h.subimage = f, h.resize = d, h._reglType = "textureCube", h._texture = c, l.profile && (h.stats = c.stats), h.destroy = function () { c.decRef() }, h } function nt() { for (var e = 0; e < Z; ++e)t.activeTexture(xr + e), t.bindTexture(mn, null), Y[e] = null; Ce(q).forEach($), s.cubeCount = 0, s.textureCount = 0 } function it() { for (var e = 0; e < Z; ++e) { var n = Y[e]; n && (n.bindCount = 0, n.unit = -1, Y[e] = null) } Ce(q).forEach((function (e) { e.texture = t.createTexture(), t.bindTexture(e.target, e.texture); for (var n = 0; n < 32; ++n)if (0 != (e.mipmask & 1 << n)) if (e.target === mn) t.texImage2D(mn, n, e.internalformat, e.width >> n, e.height >> n, 0, e.internalformat, e.type, null); else for (var r = 0; r < 6; ++r)t.texImage2D(yn + r, n, e.internalformat, e.width >> n, e.height >> n, 0, e.internalformat, e.type, null); W(e.texInfo, e.target) })) } function ot() { for (var e = 0; e < Z; ++e) { var n = Y[e]; n && (n.bindCount = 0, n.unit = -1, Y[e] = null), t.activeTexture(xr + e), t.bindTexture(mn, null), t.bindTexture(vn, null) } } return n(K.prototype, { bind: function () { var e = this; e.bindCount += 1; var n = e.unit; if (n < 0) { for (var r = 0; r < Z; ++r) { var i = Y[r]; if (i) { if (i.bindCount > 0) continue; i.unit = -1 } Y[r] = e, n = r; break } n >= Z && rt.raise("insufficient number of texture units"), l.profile && s.maxTextureUnits < n + 1 && (s.maxTextureUnits = n + 1), e.unit = n, t.activeTexture(xr + n), t.bindTexture(e.target, e.texture) } return n }, unbind: function () { this.bindCount -= 1 }, decRef: function () { --this.refCount <= 0 && $(this) } }), l.profile && (s.getTotalTextureSize = function () { var t = 0; return Object.keys(q).forEach((function (e) { t += q[e].stats.size })), t }), { create2D: tt, createCube: et, clear: nt, getTexture: function (t) { return null }, restore: it, refresh: ot } } Lr[Sn] = 2, Lr[En] = 2, Lr[Cn] = 2, Lr[In] = 4, Lr[Dn] = .5, Lr[Nn] = .5, Lr[zn] = 1, Lr[Fn] = 1, Lr[Bn] = .5, Lr[jn] = 1, Lr[Un] = 1, Lr[Vn] = .5, Lr[Gn] = .25, Lr[Hn] = .5, Lr[Wn] = .25, Lr[Xn] = .5; var $r = 36161, ti = 32854, ei = 32855, ni = 36194, ri = 33189, ii = 36168, oi = 34041, ai = 35907, si = 34836, li = 34842, ui = 34843, ci = []; function pi(t, e, n) { return ci[t] * e * n } ci[ti] = 2, ci[ei] = 2, ci[ni] = 2, ci[ri] = 2, ci[ii] = 1, ci[oi] = 4, ci[ai] = 4, ci[si] = 16, ci[li] = 8, ci[ui] = 6; var hi = function (t, e, n, r, i) { var o = { rgba4: ti, rgb565: ni, "rgb5 a1": ei, depth: ri, stencil: ii, "depth stencil": oi }; e.ext_srgb && (o.srgba = ai), e.ext_color_buffer_half_float && (o.rgba16f = li, o.rgb16f = ui), e.webgl_color_buffer_float && (o.rgba32f = si); var a = []; Object.keys(o).forEach((function (t) { var e = o[t]; a[e] = t })); var s = 0, l = {}; function u(t) { this.id = s++, this.refCount = 1, this.renderbuffer = t, this.format = ti, this.width = 0, this.height = 0, i.profile && (this.stats = { size: 0 }) } function c(e) { var n = e.renderbuffer; rt(n, "must not double destroy renderbuffer"), t.bindRenderbuffer($r, null), t.deleteRenderbuffer(n), e.renderbuffer = null, e.refCount = 0, delete l[e.id], r.renderbufferCount-- } function p(e, s) { var c = new u(t.createRenderbuffer()); function p(e, r) { var s = 0, l = 0, u = ti; if ("object" == typeof e && e) { var h = e; if ("shape" in h) { var f = h.shape; rt(Array.isArray(f) && f.length >= 2, "invalid renderbuffer shape"), s = 0 | f[0], l = 0 | f[1] } else "radius" in h && (s = l = 0 | h.radius), "width" in h && (s = 0 | h.width), "height" in h && (l = 0 | h.height); "format" in h && (rt.parameter(h.format, o, "invalid renderbuffer format"), u = o[h.format]) } else "number" == typeof e ? (s = 0 | e, l = "number" == typeof r ? 0 | r : s) : e ? rt.raise("invalid arguments to renderbuffer constructor") : s = l = 1; if (rt(s > 0 && l > 0 && s <= n.maxRenderbufferSize && l <= n.maxRenderbufferSize, "invalid renderbuffer size"), s !== c.width || l !== c.height || u !== c.format) return p.width = c.width = s, p.height = c.height = l, c.format = u, t.bindRenderbuffer($r, c.renderbuffer), t.renderbufferStorage($r, u, s, l), rt(0 === t.getError(), "invalid render buffer format"), i.profile && (c.stats.size = pi(c.format, c.width, c.height)), p.format = a[c.format], p } function h(e, r) { var o = 0 | e, a = 0 | r || o; return o === c.width && a === c.height || (rt(o > 0 && a > 0 && o <= n.maxRenderbufferSize && a <= n.maxRenderbufferSize, "invalid renderbuffer size"), p.width = c.width = o, p.height = c.height = a, t.bindRenderbuffer($r, c.renderbuffer), t.renderbufferStorage($r, c.format, o, a), rt(0 === t.getError(), "invalid render buffer format"), i.profile && (c.stats.size = pi(c.format, c.width, c.height))), p } return l[c.id] = c, r.renderbufferCount++, p(e, s), p.resize = h, p._reglType = "renderbuffer", p._renderbuffer = c, i.profile && (p.stats = c.stats), p.destroy = function () { c.decRef() }, p } function h() { Ce(l).forEach((function (e) { e.renderbuffer = t.createRenderbuffer(), t.bindRenderbuffer($r, e.renderbuffer), t.renderbufferStorage($r, e.format, e.width, e.height) })), t.bindRenderbuffer($r, null) } return u.prototype.decRef = function () { --this.refCount <= 0 && c(this) }, i.profile && (r.getTotalRenderbufferSize = function () { var t = 0; return Object.keys(l).forEach((function (e) { t += l[e].stats.size })), t }), { create: p, clear: function () { Ce(l).forEach(c) }, restore: h } }, fi = 36160, di = 36161, mi = 3553, vi = 34069, yi = 36064, gi = 36096, _i = 36128, xi = 33306, bi = 36053, wi = 36054, Si = 36055, Ei = 36057, Ci = 36061, Ti = 36193, Ai = 5121, Mi = 5126, Oi = 6407, ki = 6408, Ii = 6402, Pi = [Oi, ki], Li = []; Li[ki] = 4, Li[Oi] = 3; var Ri = []; Ri[Ai] = 1, Ri[Mi] = 4, Ri[Ti] = 2; var Di = 33189, Ni = 36168, zi = 34041, Fi = [32854, 32855, 36194, 35907, 34842, 34843, 34836], Bi = {}; function ji(t, e, r, i, o, a) { var s = { cur: null, next: null, dirty: !1, setFBO: null }, l = ["rgba"], u = ["rgba4", "rgb565", "rgb5 a1"]; e.ext_srgb && u.push("srgba"), e.ext_color_buffer_half_float && u.push("rgba16f", "rgb16f"), e.webgl_color_buffer_float && u.push("rgba32f"); var c = ["uint8"]; function p(t, e, n) { this.target = t, this.texture = e, this.renderbuffer = n; var r = 0, i = 0; e ? (r = e.width, i = e.height) : n && (r = n.width, i = n.height), this.width = r, this.height = i } function h(t) { t && (t.texture && t.texture._texture.decRef(), t.renderbuffer && t.renderbuffer._renderbuffer.decRef()) } function f(t, e, n) { if (t) if (t.texture) { var r = t.texture._texture, i = Math.max(1, r.width), o = Math.max(1, r.height); rt(i === e && o === n, "inconsistent width/height for supplied texture"), r.refCount += 1 } else { var a = t.renderbuffer._renderbuffer; rt(a.width === e && a.height === n, "inconsistent width/height for renderbuffer"), a.refCount += 1 } } function d(e, n) { n && (n.texture ? t.framebufferTexture2D(fi, e, n.target, n.texture._texture.texture, 0) : t.framebufferRenderbuffer(fi, e, di, n.renderbuffer._renderbuffer.renderbuffer)) } function m(t) { var e = mi, n = null, r = null, i = t; "object" == typeof t && (i = t.data, "target" in t && (e = 0 | t.target)), rt.type(i, "function", "invalid attachment data"); var o = i._reglType; return "texture2d" === o ? (n = i, rt(e === mi)) : "textureCube" === o ? (n = i, rt(e >= vi && e < vi + 6, "invalid cube map target")) : "renderbuffer" === o ? (r = i, e = di) : rt.raise("invalid regl object for attachment"), new p(e, n, r) } function v(t, e, n, r, a) { if (n) { var s = i.create2D({ width: t, height: e, format: r, type: a }); return s._texture.refCount = 0, new p(mi, s, null) } var l = o.create({ width: t, height: e, format: r }); return l._renderbuffer.refCount = 0, new p(di, null, l) } function y(t) { return t && (t.texture || t.renderbuffer) } function g(t, e, n) { t && (t.texture ? t.texture.resize(e, n) : t.renderbuffer && t.renderbuffer.resize(e, n), t.width = e, t.height = n) } e.oes_texture_half_float && c.push("half float", "float16"), e.oes_texture_float && c.push("float", "float32"); var _ = 0, x = {}; function b() { this.id = _++, x[this.id] = this, this.framebuffer = t.createFramebuffer(), this.width = 0, this.height = 0, this.colorAttachments = [], this.depthAttachment = null, this.stencilAttachment = null, this.depthStencilAttachment = null } function w(t) { t.colorAttachments.forEach(h), h(t.depthAttachment), h(t.stencilAttachment), h(t.depthStencilAttachment) } function S(e) { var n = e.framebuffer; rt(n, "must not double destroy framebuffer"), t.deleteFramebuffer(n), e.framebuffer = null, a.framebufferCount--, delete x[e.id] } function E(e) { var n; t.bindFramebuffer(fi, e.framebuffer); var i = e.colorAttachments; for (n = 0; n < i.length; ++n)d(yi + n, i[n]); for (n = i.length; n < r.maxColorAttachments; ++n)t.framebufferTexture2D(fi, yi + n, mi, null, 0); t.framebufferTexture2D(fi, xi, mi, null, 0), t.framebufferTexture2D(fi, gi, mi, null, 0), t.framebufferTexture2D(fi, _i, mi, null, 0), d(gi, e.depthAttachment), d(_i, e.stencilAttachment), d(xi, e.depthStencilAttachment); var o = t.checkFramebufferStatus(fi); t.isContextLost() || o === bi || rt.raise("framebuffer configuration not supported, status = " + Bi[o]), t.bindFramebuffer(fi, s.next ? s.next.framebuffer : null), s.cur = s.next, t.getError() } function C(t, i) { var o = new b; function p(t, n) { var i; rt(s.next !== o, "can not update framebuffer which is currently in use"); var a = 0, h = 0, d = !0, g = !0, _ = null, x = !0, b = "rgba", S = "uint8", C = 1, T = null, A = null, M = null, O = !1; if ("number" == typeof t) a = 0 | t, h = 0 | n || a; else if (t) { rt.type(t, "object", "invalid arguments for framebuffer"); var k = t; if ("shape" in k) { var I = k.shape; rt(Array.isArray(I) && I.length >= 2, "invalid shape for framebuffer"), a = I[0], h = I[1] } else "radius" in k && (a = h = k.radius), "width" in k && (a = k.width), "height" in k && (h = k.height); ("color" in k || "colors" in k) && (_ = k.color || k.colors, Array.isArray(_) && rt(1 === _.length || e.webgl_draw_buffers, "multiple render targets not supported")), _ || ("colorCount" in k && (C = 0 | k.colorCount, rt(C > 0, "invalid color buffer count")), "colorTexture" in k && (x = !!k.colorTexture, b = "rgba4"), "colorType" in k && (S = k.colorType, x ? (rt(e.oes_texture_float || !("float" === S || "float32" === S), "you must enable OES_texture_float in order to use floating point framebuffer objects"), rt(e.oes_texture_half_float || !("half float" === S || "float16" === S), "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects")) : "half float" === S || "float16" === S ? (rt(e.ext_color_buffer_half_float, "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"), b = "rgba16f") : "float" !== S && "float32" !== S || (rt(e.webgl_color_buffer_float, "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"), b = "rgba32f"), rt.oneOf(S, c, "invalid color type")), "colorFormat" in k && (b = k.colorFormat, l.indexOf(b) >= 0 ? x = !0 : u.indexOf(b) >= 0 ? x = !1 : rt.optional((function () { x ? rt.oneOf(k.colorFormat, l, "invalid color format for texture") : rt.oneOf(k.colorFormat, u, "invalid color format for renderbuffer") })))), ("depthTexture" in k || "depthStencilTexture" in k) && (O = !(!k.depthTexture && !k.depthStencilTexture), rt(!O || e.webgl_depth_texture, "webgl_depth_texture extension not supported")), "depth" in k && ("boolean" == typeof k.depth ? d = k.depth : (T = k.depth, g = !1)), "stencil" in k && ("boolean" == typeof k.stencil ? g = k.stencil : (A = k.stencil, d = !1)), "depthStencil" in k && ("boolean" == typeof k.depthStencil ? d = g = k.depthStencil : (M = k.depthStencil, d = !1, g = !1)) } else a = h = 1; var P = null, L = null, R = null, D = null; if (Array.isArray(_)) P = _.map(m); else if (_) P = [m(_)]; else for (P = new Array(C), i = 0; i < C; ++i)P[i] = v(a, h, x, b, S); rt(e.webgl_draw_buffers || P.length <= 1, "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."), rt(P.length <= r.maxColorAttachments, "too many color attachments, not supported"), a = a || P[0].width, h = h || P[0].height, T ? L = m(T) : d && !g && (L = v(a, h, O, "depth", "uint32")), A ? R = m(A) : g && !d && (R = v(a, h, !1, "stencil", "uint8")), M ? D = m(M) : !T && !A && g && d && (D = v(a, h, O, "depth stencil", "depth stencil")), rt(!!T + !!A + !!M <= 1, "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"); var N = null; for (i = 0; i < P.length; ++i)if (f(P[i], a, h), rt(!P[i] || P[i].texture && Pi.indexOf(P[i].texture._texture.format) >= 0 || P[i].renderbuffer && Fi.indexOf(P[i].renderbuffer._renderbuffer.format) >= 0, "framebuffer color attachment " + i + " is invalid"), P[i] && P[i].texture) { var z = Li[P[i].texture._texture.format] * Ri[P[i].texture._texture.type]; null === N ? N = z : rt(N === z, "all color attachments much have the same number of bits per pixel.") } return f(L, a, h), rt(!L || L.texture && L.texture._texture.format === Ii || L.renderbuffer && L.renderbuffer._renderbuffer.format === Di, "invalid depth attachment for framebuffer object"), f(R, a, h), rt(!R || R.renderbuffer && R.renderbuffer._renderbuffer.format === Ni, "invalid stencil attachment for framebuffer object"), f(D, a, h), rt(!D || D.texture && D.texture._texture.format === zi || D.renderbuffer && D.renderbuffer._renderbuffer.format === zi, "invalid depth-stencil attachment for framebuffer object"), w(o), o.width = a, o.height = h, o.colorAttachments = P, o.depthAttachment = L, o.stencilAttachment = R, o.depthStencilAttachment = D, p.color = P.map(y), p.depth = y(L), p.stencil = y(R), p.depthStencil = y(D), p.width = o.width, p.height = o.height, E(o), p } function h(t, e) { rt(s.next !== o, "can not resize a framebuffer which is currently in use"); var n = Math.max(0 | t, 1), r = Math.max(0 | e || n, 1); if (n === o.width && r === o.height) return p; for (var i = o.colorAttachments, a = 0; a < i.length; ++a)g(i[a], n, r); return g(o.depthAttachment, n, r), g(o.stencilAttachment, n, r), g(o.depthStencilAttachment, n, r), o.width = p.width = n, o.height = p.height = r, E(o), p } return a.framebufferCount++, p(t, i), n(p, { resize: h, _reglType: "framebuffer", _framebuffer: o, destroy: function () { S(o), w(o) }, use: function (t) { s.setFBO({ framebuffer: p }, t) } }) } function T(t) { var o = Array(6); function a(t) { var r; rt(o.indexOf(s.next) < 0, "can not update framebuffer which is currently in use"); var u, p = { color: null }, h = 0, f = null, d = "rgba", m = "uint8", v = 1; if ("number" == typeof t) h = 0 | t; else if (t) { rt.type(t, "object", "invalid arguments for framebuffer"); var y = t; if ("shape" in y) { var g = y.shape; rt(Array.isArray(g) && g.length >= 2, "invalid shape for framebuffer"), rt(g[0] === g[1], "cube framebuffer must be square"), h = g[0] } else "radius" in y && (h = 0 | y.radius), "width" in y ? (h = 0 | y.width, "height" in y && rt(y.height === h, "must be square")) : "height" in y && (h = 0 | y.height); ("color" in y || "colors" in y) && (f = y.color || y.colors, Array.isArray(f) && rt(1 === f.length || e.webgl_draw_buffers, "multiple render targets not supported")), f || ("colorCount" in y && (v = 0 | y.colorCount, rt(v > 0, "invalid color buffer count")), "colorType" in y && (rt.oneOf(y.colorType, c, "invalid color type"), m = y.colorType), "colorFormat" in y && (d = y.colorFormat, rt.oneOf(y.colorFormat, l, "invalid color format for texture"))), "depth" in y && (p.depth = y.depth), "stencil" in y && (p.stencil = y.stencil), "depthStencil" in y && (p.depthStencil = y.depthStencil) } else h = 1; if (f) if (Array.isArray(f)) for (u = [], r = 0; r < f.length; ++r)u[r] = f[r]; else u = [f]; else { u = Array(v); var _ = { radius: h, format: d, type: m }; for (r = 0; r < v; ++r)u[r] = i.createCube(_) } for (p.color = Array(u.length), r = 0; r < u.length; ++r) { var x = u[r]; rt("function" == typeof x && "textureCube" === x._reglType, "invalid cube map"), h = h || x.width, rt(x.width === h && x.height === h, "invalid cube map shape"), p.color[r] = { target: vi, data: u[r] } } for (r = 0; r < 6; ++r) { for (var b = 0; b < u.length; ++b)p.color[b].target = vi + r; r > 0 && (p.depth = o[0].depth, p.stencil = o[0].stencil, p.depthStencil = o[0].depthStencil), o[r] ? o[r](p) : o[r] = C(p) } return n(a, { width: h, height: h, color: u }) } function u(t) { var e, n = 0 | t; if (rt(n > 0 && n <= r.maxCubeMapSize, "invalid radius for cube fbo"), n === a.width) return a; var i = a.color; for (e = 0; e < i.length; ++e)i[e].resize(n); for (e = 0; e < 6; ++e)o[e].resize(n); return a.width = a.height = n, a } return a(t), n(a, { faces: o, resize: u, _reglType: "framebufferCube", destroy: function () { o.forEach((function (t) { t.destroy() })) } }) } function A() { s.cur = null, s.next = null, s.dirty = !0, Ce(x).forEach((function (e) { e.framebuffer = t.createFramebuffer(), E(e) })) } return n(s, { getFramebuffer: function (t) { if ("function" == typeof t && "framebuffer" === t._reglType) { var e = t._framebuffer; if (e instanceof b) return e } return null }, create: C, createCube: T, clear: function () { Ce(x).forEach(S) }, restore: A }) } Bi[bi] = "complete", Bi[wi] = "incomplete attachment", Bi[Ei] = "incomplete dimensions", Bi[Si] = "incomplete, missing attachment", Bi[Ci] = "unsupported"; var Ui = 5126, Vi = 34962, Gi = 34963, Hi = ["attributes", "elements", "offset", "count", "primitive", "instances"]; function Wi() { this.state = 0, this.x = 0, this.y = 0, this.z = 0, this.w = 0, this.buffer = null, this.size = 0, this.normalized = !1, this.type = Ui, this.offset = 0, this.stride = 0, this.divisor = 0 } function Xi(t, n, r, i, o, a, s) { for (var l = r.maxAttributes, u = new Array(l), c = 0; c < l; ++c)u[c] = new Wi; var p = 0, h = {}, f = { Record: Wi, scope: {}, state: u, currentVAO: null, targetVAO: null, restore: m() ? w : function () { }, createVAO: S, getVAO: y, destroyBuffer: d, setVAO: m() ? g : _, clear: m() ? x : function () { } }; function d(e) { for (var n = 0; n < u.length; ++n) { var r = u[n]; r.buffer === e && (t.disableVertexAttribArray(n), r.buffer = null) } } function m() { return n.oes_vertex_array_object } function v() { return n.angle_instanced_arrays } function y(t) { return "function" == typeof t && t._vao ? t._vao : null } function g(t) { if (t !== f.currentVAO) { var e = m(); t ? e.bindVertexArrayOES(t.vao) : e.bindVertexArrayOES(null), f.currentVAO = t } } function _(e) { if (e !== f.currentVAO) { if (e) e.bindAttrs(); else { for (var n = v(), r = 0; r < u.length; ++r) { var i = u[r]; i.buffer ? (t.enableVertexAttribArray(r), i.buffer.bind(), t.vertexAttribPointer(r, i.size, i.type, i.normalized, i.stride, i.offfset), n && i.divisor && n.vertexAttribDivisorANGLE(r, i.divisor)) : (t.disableVertexAttribArray(r), t.vertexAttrib4f(r, i.x, i.y, i.z, i.w)) } s.elements ? t.bindBuffer(Gi, s.elements.buffer.buffer) : t.bindBuffer(Gi, null) } f.currentVAO = e } } function x() { Ce(h).forEach((function (t) { t.destroy() })) } function b() { this.id = ++p, this.attributes = [], this.elements = null, this.ownsElements = !1, this.count = 0, this.offset = 0, this.instances = -1, this.primitive = 4; var t = m(); this.vao = t ? t.createVertexArrayOES() : null, h[this.id] = this, this.buffers = [] } function w() { m() && Ce(h).forEach((function (t) { t.refresh() })) } function S(t) { var r = new b; function s(t) { var i; if (Array.isArray(t)) i = t, r.elements && r.ownsElements && r.elements.destroy(), r.elements = null, r.ownsElements = !1, r.offset = 0, r.count = 0, r.instances = -1, r.primitive = 4; else { if (rt("object" == typeof t, "invalid arguments for create vao"), rt("attributes" in t, "must specify attributes for vao"), t.elements) { var u = t.elements; r.ownsElements ? "function" == typeof u && "elements" === u._reglType ? (r.elements.destroy(), r.ownsElements = !1) : (r.elements(u), r.ownsElements = !1) : a.getElements(t.elements) ? (r.elements = t.elements, r.ownsElements = !1) : (r.elements = a.create(t.elements), r.ownsElements = !0) } else r.elements = null, r.ownsElements = !1; i = t.attributes, r.offset = 0, r.count = -1, r.instances = -1, r.primitive = 4, r.elements && (r.count = r.elements._elements.vertCount, r.primitive = r.elements._elements.primType), "offset" in t && (r.offset = 0 | t.offset), "count" in t && (r.count = 0 | t.count), "instances" in t && (r.instances = 0 | t.instances), "primitive" in t && (rt(t.primitive in qe, "bad primitive type: " + t.primitive), r.primitive = qe[t.primitive]), rt.optional((function () { for (var e = Object.keys(t), n = 0; n < e.length; ++n)rt(Hi.indexOf(e[n]) >= 0, 'invalid option for vao: "' + e[n] + '" valid options are ' + Hi) })), rt(Array.isArray(i), "attributes must be an array") } rt(i.length < l, "too many attributes"), rt(i.length > 0, "must specify at least one attribute"); var c = {}, p = r.attributes; p.length = i.length; for (var h = 0; h < i.length; ++h) { var f, d = i[h], m = p[h] = new Wi, v = d.data || d; Array.isArray(v) || e(v) || Ee(v) ? (r.buffers[h] && (f = r.buffers[h], e(v) && f._buffer.byteLength >= v.byteLength ? f.subdata(v) : (f.destroy(), r.buffers[h] = null)), r.buffers[h] || (f = r.buffers[h] = o.create(d, Vi, !1, !0)), m.buffer = o.getBuffer(f), m.size = 0 | m.buffer.dimension, m.normalized = !1, m.type = m.buffer.dtype, m.offset = 0, m.stride = 0, m.divisor = 0, m.state = 1, c[h] = 1) : o.getBuffer(d) ? (m.buffer = o.getBuffer(d), m.size = 0 | m.buffer.dimension, m.normalized = !1, m.type = m.buffer.dtype, m.offset = 0, m.stride = 0, m.divisor = 0, m.state = 1) : o.getBuffer(d.buffer) ? (m.buffer = o.getBuffer(d.buffer), m.size = 0 | (+d.size || m.buffer.dimension), m.normalized = !!d.normalized || !1, "type" in d ? (rt.parameter(d.type, Re, "invalid buffer type"), m.type = Re[d.type]) : m.type = m.buffer.dtype, m.offset = 0 | (d.offset || 0), m.stride = 0 | (d.stride || 0), m.divisor = 0 | (d.divisor || 0), m.state = 1, rt(m.size >= 1 && m.size <= 4, "size must be between 1 and 4"), rt(m.offset >= 0, "invalid offset"), rt(m.stride >= 0 && m.stride <= 255, "stride must be between 0 and 255"), rt(m.divisor >= 0, "divisor must be positive"), rt(!m.divisor || !!n.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor")) : "x" in d ? (rt(h > 0, "first attribute must not be a constant"), m.x = +d.x || 0, m.y = +d.y || 0, m.z = +d.z || 0, m.w = +d.w || 0, m.state = 2) : rt(!1, "invalid attribute spec for location " + h) } for (var y = 0; y < r.buffers.length; ++y)!c[y] && r.buffers[y] && (r.buffers[y].destroy(), r.buffers[y] = null); return r.refresh(), s } return i.vaoCount += 1, s.destroy = function () { for (var t = 0; t < r.buffers.length; ++t)r.buffers[t] && r.buffers[t].destroy(); r.buffers.length = 0, r.ownsElements && (r.elements.destroy(), r.elements = null, r.ownsElements = !1), r.destroy() }, s._vao = r, s._reglType = "vao", s(t) } return b.prototype.bindAttrs = function () { for (var e = v(), n = this.attributes, r = 0; r < n.length; ++r) { var i = n[r]; i.buffer ? (t.enableVertexAttribArray(r), t.bindBuffer(Vi, i.buffer.buffer), t.vertexAttribPointer(r, i.size, i.type, i.normalized, i.stride, i.offset), e && i.divisor && e.vertexAttribDivisorANGLE(r, i.divisor)) : (t.disableVertexAttribArray(r), t.vertexAttrib4f(r, i.x, i.y, i.z, i.w)) } for (var o = n.length; o < l; ++o)t.disableVertexAttribArray(o); var s = a.getElements(this.elements); s ? t.bindBuffer(Gi, s.buffer.buffer) : t.bindBuffer(Gi, null) }, b.prototype.refresh = function () { var t = m(); t && (t.bindVertexArrayOES(this.vao), this.bindAttrs(), f.currentVAO = null, t.bindVertexArrayOES(null)) }, b.prototype.destroy = function () { if (this.vao) { var t = m(); this === f.currentVAO && (f.currentVAO = null, t.bindVertexArrayOES(null)), t.deleteVertexArrayOES(this.vao), this.vao = null } this.ownsElements && (this.elements.destroy(), this.elements = null, this.ownsElements = !1), h[this.id] && (delete h[this.id], i.vaoCount -= 1) }, f } var qi = 35632, Zi = 35633, Yi = 35718, Ki = 35721; function Qi(t, e, r, i) { var o = {}, a = {}; function s(t, e, n, r) { this.name = t, this.id = e, this.location = n, this.info = r } function l(t, e) { for (var n = 0; n < t.length; ++n)if (t[n].id === e.id) return void (t[n].location = e.location); t.push(e) } function u(n, r, i) { var s = n === qi ? o : a, l = s[r]; if (!l) { var u = e.str(r); l = t.createShader(n), t.shaderSource(l, u), t.compileShader(l), rt.shaderError(t, l, u, n, i), s[r] = l } return l } var c = {}, p = [], h = 0; function f(t, e) { this.id = h++, this.fragId = t, this.vertId = e, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, i.profile && (this.stats = { uniformsCount: 0, attributesCount: 0 }) } function d(n, r, o) { var a, c, p = u(qi, n.fragId), h = u(Zi, n.vertId), f = n.program = t.createProgram(); if (t.attachShader(f, p), t.attachShader(f, h), o) for (a = 0; a < o.length; ++a) { var d = o[a]; t.bindAttribLocation(f, d[0], d[1]) } t.linkProgram(f), rt.linkError(t, f, e.str(n.fragId), e.str(n.vertId), r); var m = t.getProgramParameter(f, Yi); i.profile && (n.stats.uniformsCount = m); var v = n.uniforms; for (a = 0; a < m; ++a)if (c = t.getActiveUniform(f, a)) if (c.size > 1) for (var y = 0; y < c.size; ++y) { var g = c.name.replace("[0]", "[" + y + "]"); l(v, new s(g, e.id(g), t.getUniformLocation(f, g), c)) } else l(v, new s(c.name, e.id(c.name), t.getUniformLocation(f, c.name), c)); var _ = t.getProgramParameter(f, Ki); i.profile && (n.stats.attributesCount = _); var x = n.attributes; for (a = 0; a < _; ++a)(c = t.getActiveAttrib(f, a)) && l(x, new s(c.name, e.id(c.name), t.getAttribLocation(f, c.name), c)) } function m() { o = {}, a = {}; for (var t = 0; t < p.length; ++t)d(p[t], null, p[t].attributes.map((function (t) { return [t.location, t.name] }))) } return i.profile && (r.getMaxUniformsCount = function () { var t = 0; return p.forEach((function (e) { e.stats.uniformsCount > t && (t = e.stats.uniformsCount) })), t }, r.getMaxAttributesCount = function () { var t = 0; return p.forEach((function (e) { e.stats.attributesCount > t && (t = e.stats.attributesCount) })), t }), { clear: function () { var e = t.deleteShader.bind(t); Ce(o).forEach(e), o = {}, Ce(a).forEach(e), a = {}, p.forEach((function (e) { t.deleteProgram(e.program) })), p.length = 0, c = {}, r.shaderCount = 0 }, program: function (e, i, s, l) { rt.command(e >= 0, "missing vertex shader", s), rt.command(i >= 0, "missing fragment shader", s); var u = c[i]; u || (u = c[i] = {}); var h = u[e]; if (h && (h.refCount++, !l)) return h; var m = new f(i, e); return r.shaderCount++, d(m, s, l), h || (u[e] = m), p.push(m), n(m, { destroy: function () { if (m.refCount--, m.refCount <= 0) { t.deleteProgram(m.program); var e = p.indexOf(m); p.splice(e, 1), r.shaderCount-- } u[m.vertId].refCount <= 0 && (t.deleteShader(a[m.vertId]), delete a[m.vertId], delete c[m.fragId][m.vertId]), Object.keys(c[m.fragId]).length || (t.deleteShader(o[m.fragId]), delete o[m.fragId], delete c[m.fragId]) } }) }, restore: m, shader: u, frag: -1, vert: -1 } } var Ji = 6408, $i = 5121, to = 3333, eo = 5126; function no(t, n, r, i, o, a, s) { function l(l) { var u; null === n.next ? (rt(o.preserveDrawingBuffer, 'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'), u = $i) : (rt(null !== n.next.colorAttachments[0].texture, "You cannot read from a renderbuffer"), u = n.next.colorAttachments[0].texture._texture.type, rt.optional((function () { a.oes_texture_float ? (rt(u === $i || u === eo, "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"), u === eo && rt(s.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")) : rt(u === $i, "Reading from a framebuffer is only allowed for the type 'uint8'") }))); var c = 0, p = 0, h = i.framebufferWidth, f = i.framebufferHeight, d = null; e(l) ? d = l : l && (rt.type(l, "object", "invalid arguments to regl.read()"), c = 0 | l.x, p = 0 | l.y, rt(c >= 0 && c < i.framebufferWidth, "invalid x offset for regl.read"), rt(p >= 0 && p < i.framebufferHeight, "invalid y offset for regl.read"), h = 0 | (l.width || i.framebufferWidth - c), f = 0 | (l.height || i.framebufferHeight - p), d = l.data || null), d && (u === $i ? rt(d instanceof Uint8Array, "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'") : u === eo && rt(d instanceof Float32Array, "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'")), rt(h > 0 && h + c <= i.framebufferWidth, "invalid width for read pixels"), rt(f > 0 && f + p <= i.framebufferHeight, "invalid height for read pixels"), r(); var m = h * f * 4; return d || (u === $i ? d = new Uint8Array(m) : u === eo && (d = d || new Float32Array(m))), rt.isTypedArray(d, "data buffer for regl.read() must be a typedarray"), rt(d.byteLength >= m, "data buffer for regl.read() too small"), t.pixelStorei(to, 4), t.readPixels(c, p, h, f, Ji, u, d), d } function u(t) { var e; return n.setFBO({ framebuffer: t.framebuffer }, (function () { e = l(t) })), e } function c(t) { return t && "framebuffer" in t ? u(t) : l(t) } return c } function ro(t) { return Array.prototype.slice.call(t) } function io(t) { return ro(t).join("") } function oo() { var e = 0, r = [], i = []; function o(t) { for (var n = 0; n < i.length; ++n)if (i[n] === t) return r[n]; var o = "g" + e++; return r.push(o), i.push(t), o } function a() { var t = []; function r() { t.push.apply(t, ro(arguments)) } var i = []; function o() { var n = "v" + e++; return i.push(n), arguments.length > 0 && (t.push(n, "="), t.push.apply(t, ro(arguments)), t.push(";")), n } return n(r, { def: o, toString: function () { return io([i.length > 0 ? "var " + i.join(",") + ";" : "", io(t)]) } }) } function s() { var t = a(), e = a(), r = t.toString, i = e.toString; function o(n, r) { e(n, r, "=", t.def(n, r), ";") } return n((function () { t.apply(t, ro(arguments)) }), { def: t.def, entry: t, exit: e, save: o, set: function (e, n, r) { o(e, n), t(e, n, "=", r, ";") }, toString: function () { return r() + i() } }) } function l() { var t = io(arguments), e = s(), r = s(), i = e.toString, o = r.toString; return n(e, { then: function () { return e.apply(e, ro(arguments)), this }, else: function () { return r.apply(r, ro(arguments)), this }, toString: function () { var e = o(); return e && (e = "else{" + e + "}"), io(["if(", t, "){", i(), "}", e]) } }) } var u = a(), c = {}; function p(t, e) { var r = []; function i() { var t = "a" + r.length; return r.push(t), t } e = e || 0; for (var o = 0; o < e; ++o)i(); var a = s(), l = a.toString; return c[t] = n(a, { arg: i, toString: function () { return io(["function(", r.join(), "){", l(), "}"]) } }) } function h() { var e = ['"use strict";', u, "return {"]; Object.keys(c).forEach((function (t) { e.push('"', t, '":', c[t].toString(), ",") })), e.push("}"); var n = io(e).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n"); return ("undefined" != typeof my && my && "function" == typeof my.showToast && !0 !== my.isFRM ? t.Function.apply(null, r.concat(n)) : Function.apply(null, r.concat(n))).apply(null, i) } return { global: u, link: o, block: a, proc: p, scope: s, cond: l, compile: h } } var ao = "xyzw".split(""), so = 5121, lo = 1, uo = 2, co = 0, po = 1, ho = 2, fo = 3, mo = 4, vo = 5, yo = 6, go = "dither", _o = "blend.enable", xo = "blend.color", bo = "blend.equation", wo = "blend.func", So = "depth.enable", Eo = "depth.func", Co = "depth.range", To = "depth.mask", Ao = "colorMask", Mo = "cull.enable", Oo = "cull.face", ko = "frontFace", Io = "lineWidth", Po = "polygonOffset.enable", Lo = "polygonOffset.offset", Ro = "sample.alpha", Do = "sample.enable", No = "sample.coverage", zo = "stencil.enable", Fo = "stencil.mask", Bo = "stencil.func", jo = "stencil.opFront", Uo = "stencil.opBack", Vo = "scissor.enable", Go = "scissor.box", Ho = "viewport", Wo = "profile", Xo = "framebuffer", qo = "vert", Zo = "frag", Yo = "elements", Ko = "primitive", Qo = "count", Jo = "offset", $o = "instances", ta = "vao", ea = "Width", na = "Height", ra = Xo + ea, ia = Xo + na, oa = Ho + ea, aa = Ho + na, sa = "drawingBuffer", la = sa + ea, ua = sa + na, ca = [wo, bo, Bo, jo, Uo, No, Ho, Go, Lo], pa = 34962, ha = 34963, fa = 3553, da = 34067, ma = 2884, va = 3042, ya = 3024, ga = 2960, _a = 2929, xa = 3089, ba = 32823, wa = 32926, Sa = 32928, Ea = 5126, Ca = 35664, Ta = 35665, Aa = 35666, Ma = 5124, Oa = 35667, ka = 35668, Ia = 35669, Pa = 35670, La = 35671, Ra = 35672, Da = 35673, Na = 35674, za = 35675, Fa = 35676, Ba = 35678, ja = 35680, Ua = 4, Va = 1028, Ga = 1029, Ha = 2304, Wa = 2305, Xa = 32775, qa = 32776, Za = 519, Ya = 7680, Ka = 0, Qa = 1, Ja = 32774, $a = 513, ts = 36160, es = 36064, ns = { 0: 0, 1: 1, zero: 0, one: 1, "src color": 768, "one minus src color": 769, "src alpha": 770, "one minus src alpha": 771, "dst color": 774, "one minus dst color": 775, "dst alpha": 772, "one minus dst alpha": 773, "constant color": 32769, "one minus constant color": 32770, "constant alpha": 32771, "one minus constant alpha": 32772, "src alpha saturate": 776 }, rs = ["constant color, constant alpha", "one minus constant color, constant alpha", "constant color, one minus constant alpha", "one minus constant color, one minus constant alpha", "constant alpha, constant color", "constant alpha, one minus constant color", "one minus constant alpha, constant color", "one minus constant alpha, one minus constant color"], is = { never: 512, less: 513, "<": 513, equal: 514, "=": 514, "==": 514, "===": 514, lequal: 515, "<=": 515, greater: 516, ">": 516, notequal: 517, "!=": 517, "!==": 517, gequal: 518, ">=": 518, always: 519 }, os = { 0: 0, zero: 0, keep: 7680, replace: 7681, increment: 7682, decrement: 7683, "increment wrap": 34055, "decrement wrap": 34056, invert: 5386 }, as = { frag: 35632, vert: 35633 }, ss = { cw: Ha, ccw: Wa }; function ls(t) { return Array.isArray(t) || e(t) || Ee(t) } function us(t) { return t.sort((function (t, e) { return t === Ho ? -1 : e === Ho ? 1 : t < e ? -1 : 1 })) } function cs(t, e, n, r) { this.thisDep = t, this.contextDep = e, this.propDep = n, this.append = r } function ps(t) { return t && !(t.thisDep || t.contextDep || t.propDep) } function hs(t) { return new cs(!1, !1, !1, t) } function fs(t, e) { var n = t.type; if (n === co) { var r = t.data.length; return new cs(!0, r >= 1, r >= 2, e) } if (n === mo) { var i = t.data; return new cs(i.thisDep, i.contextDep, i.propDep, e) } if (n === vo) return new cs(!1, !1, !1, e); if (n === yo) { for (var o = !1, a = !1, s = !1, l = 0; l < t.data.length; ++l) { var u = t.data[l]; if (u.type === po) s = !0; else if (u.type === ho) a = !0; else if (u.type === fo) o = !0; else if (u.type === co) { o = !0; var c = u.data; c >= 1 && (a = !0), c >= 2 && (s = !0) } else u.type === mo && (o = o || u.data.thisDep, a = a || u.data.contextDep, s = s || u.data.propDep) } return new cs(o, a, s, e) } return new cs(n === fo, n === ho, n === po, e) } var ds = new cs(!1, !1, !1, (function () { })); function ms(t, e, r, i, o, a, s, l, u, c, p, h, f, d, m) { var v = c.Record, y = { add: 32774, subtract: 32778, "reverse subtract": 32779 }; r.ext_blend_minmax && (y.min = Xa, y.max = qa); var g = r.angle_instanced_arrays, _ = r.webgl_draw_buffers, x = r.oes_vertex_array_object, b = { dirty: !0, profile: m.profile }, w = {}, S = [], E = {}, C = {}; function T(t) { return t.replace(".", "_") } function A(t, e, n) { var r = T(t); S.push(t), w[r] = b[r] = !!n, E[r] = e } function M(t, e, n) { var r = T(t); S.push(t), Array.isArray(n) ? (b[r] = n.slice(), w[r] = n.slice()) : b[r] = w[r] = n, C[r] = e } A(go, ya), A(_o, va), M(xo, "blendColor", [0, 0, 0, 0]), M(bo, "blendEquationSeparate", [Ja, Ja]), M(wo, "blendFuncSeparate", [Qa, Ka, Qa, Ka]), A(So, _a, !0), M(Eo, "depthFunc", $a), M(Co, "depthRange", [0, 1]), M(To, "depthMask", !0), M(Ao, Ao, [!0, !0, !0, !0]), A(Mo, ma), M(Oo, "cullFace", Ga), M(ko, ko, Wa), M(Io, Io, 1), A(Po, ba), M(Lo, "polygonOffset", [0, 0]), A(Ro, wa), A(Do, Sa), M(No, "sampleCoverage", [1, !1]), A(zo, ga), M(Fo, "stencilMask", -1), M(Bo, "stencilFunc", [Za, 0, -1]), M(jo, "stencilOpSeparate", [Va, Ya, Ya, Ya]), M(Uo, "stencilOpSeparate", [Ga, Ya, Ya, Ya]), A(Vo, xa), M(Go, "scissor", [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]), M(Ho, Ho, [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]); var O = { gl: t, context: f, strings: e, next: w, current: b, draw: h, elements: a, buffer: o, shader: p, attributes: c.state, vao: c, uniforms: u, framebuffer: l, extensions: r, timer: d, isBufferArgs: ls }, k = { primTypes: qe, compareFuncs: is, blendFuncs: ns, blendEquations: y, stencilOps: os, glTypes: Re, orientationType: ss }; rt.optional((function () { O.isArrayLike = hn })), _ && (k.backBuffer = [Ga], k.drawBuffer = At(i.maxDrawbuffers, (function (t) { return 0 === t ? [0] : At(t, (function (t) { return es + t })) }))); var I = 0; function P() { var t = oo(), n = t.link, r = t.global; t.id = I++, t.batchId = "0"; var i = n(O), o = t.shared = { props: "a0" }; Object.keys(O).forEach((function (t) { o[t] = r.def(i, ".", t) })), rt.optional((function () { t.CHECK = n(rt), t.commandStr = rt.guessCommand(), t.command = n(t.commandStr), t.assert = function (t, e, r) { t("if(!(", e, "))", this.CHECK, ".commandRaise(", n(r), ",", this.command, ");") }, k.invalidBlendCombinations = rs })); var a = t.next = {}, s = t.current = {}; Object.keys(C).forEach((function (t) { Array.isArray(b[t]) && (a[t] = r.def(o.next, ".", t), s[t] = r.def(o.current, ".", t)) })); var l = t.constants = {}; Object.keys(k).forEach((function (t) { l[t] = r.def(JSON.stringify(k[t])) })), t.invoke = function (e, r) { switch (r.type) { case co: var i = ["this", o.context, o.props, t.batchId]; return e.def(n(r.data), ".call(", i.slice(0, Math.max(r.data.length + 1, 4)), ")"); case po: return e.def(o.props, r.data); case ho: return e.def(o.context, r.data); case fo: return e.def("this", r.data); case mo: return r.data.append(t, e), r.data.ref; case vo: return r.data.toString(); case yo: return r.data.map((function (n) { return t.invoke(e, n) })) } }, t.attribCache = {}; var u = {}; return t.scopeAttrib = function (t) { var r = e.id(t); if (r in u) return u[r]; var i = c.scope[r]; return i || (i = c.scope[r] = new v), u[r] = n(i) }, t } function L(t) { var e, n = t.static, r = t.dynamic; if (Wo in n) { var i = !!n[Wo]; (e = hs((function (t, e) { return i }))).enable = i } else if (Wo in r) { var o = r[Wo]; e = fs(o, (function (t, e) { return t.invoke(e, o) })) } return e } function R(t, e) { var n = t.static, r = t.dynamic; if (Xo in n) { var i = n[Xo]; return i ? (i = l.getFramebuffer(i), rt.command(i, "invalid framebuffer object"), hs((function (t, e) { var n = t.link(i), r = t.shared; e.set(r.framebuffer, ".next", n); var o = r.context; return e.set(o, "." + ra, n + ".width"), e.set(o, "." + ia, n + ".height"), n }))) : hs((function (t, e) { var n = t.shared; e.set(n.framebuffer, ".next", "null"); var r = n.context; return e.set(r, "." + ra, r + "." + la), e.set(r, "." + ia, r + "." + ua), "null" })) } if (Xo in r) { var o = r[Xo]; return fs(o, (function (t, e) { var n = t.invoke(e, o), r = t.shared, i = r.framebuffer, a = e.def(i, ".getFramebuffer(", n, ")"); rt.optional((function () { t.assert(e, "!" + n + "||" + a, "invalid framebuffer object") })), e.set(i, ".next", a); var s = r.context; return e.set(s, "." + ra, a + "?" + a + ".width:" + s + "." + la), e.set(s, "." + ia, a + "?" + a + ".height:" + s + "." + ua), a })) } return null } function D(t, e, n) { var r = t.static, i = t.dynamic; function o(t) { if (t in r) { var o = r[t]; rt.commandType(o, "object", "invalid " + t, n.commandStr); var a, s, l = !0, u = 0 | o.x, c = 0 | o.y; return "width" in o ? (a = 0 | o.width, rt.command(a >= 0, "invalid " + t, n.commandStr)) : l = !1, "height" in o ? (s = 0 | o.height, rt.command(s >= 0, "invalid " + t, n.commandStr)) : l = !1, new cs(!l && e && e.thisDep, !l && e && e.contextDep, !l && e && e.propDep, (function (t, e) { var n = t.shared.context, r = a; "width" in o || (r = e.def(n, ".", ra, "-", u)); var i = s; return "height" in o || (i = e.def(n, ".", ia, "-", c)), [u, c, r, i] })) } if (t in i) { var p = i[t], h = fs(p, (function (e, n) { var r = e.invoke(n, p); rt.optional((function () { e.assert(n, r + "&&typeof " + r + '==="object"', "invalid " + t) })); var i = e.shared.context, o = n.def(r, ".x|0"), a = n.def(r, ".y|0"), s = n.def('"width" in ', r, "?", r, ".width|0:", "(", i, ".", ra, "-", o, ")"), l = n.def('"height" in ', r, "?", r, ".height|0:", "(", i, ".", ia, "-", a, ")"); return rt.optional((function () { e.assert(n, s + ">=0&&" + l + ">=0", "invalid " + t) })), [o, a, s, l] })); return e && (h.thisDep = h.thisDep || e.thisDep, h.contextDep = h.contextDep || e.contextDep, h.propDep = h.propDep || e.propDep), h } return e ? new cs(e.thisDep, e.contextDep, e.propDep, (function (t, e) { var n = t.shared.context; return [0, 0, e.def(n, ".", ra), e.def(n, ".", ia)] })) : null } var a = o(Ho); if (a) { var s = a; a = new cs(a.thisDep, a.contextDep, a.propDep, (function (t, e) { var n = s.append(t, e), r = t.shared.context; return e.set(r, "." + oa, n[2]), e.set(r, "." + aa, n[3]), n })) } return { viewport: a, scissor_box: o(Go) } } function N(t, e) { var n = t.static; if ("string" == typeof n[Zo] && "string" == typeof n[qo]) { if (Object.keys(e.dynamic).length > 0) return null; var r = e.static, i = Object.keys(r); if (i.length > 0 && "number" == typeof r[i[0]]) { for (var o = [], a = 0; a < i.length; ++a)rt("number" == typeof r[i[a]], "must specify all vertex attribute locations when using vaos"), o.push([0 | r[i[a]], i[a]]); return o } } return null } function z(t, n, r) { var i = t.static, o = t.dynamic; function a(t) { if (t in i) { var n = e.id(i[t]); rt.optional((function () { p.shader(as[t], n, rt.guessCommand()) })); var r = hs((function () { return n })); return r.id = n, r } if (t in o) { var a = o[t]; return fs(a, (function (e, n) { var r = e.invoke(n, a), i = n.def(e.shared.strings, ".id(", r, ")"); return rt.optional((function () { n(e.shared.shader, ".shader(", as[t], ",", i, ",", e.command, ");") })), i })) } return null } var s, l = a(Zo), u = a(qo), c = null; return ps(l) && ps(u) ? (c = p.program(u.id, l.id, null, r), s = hs((function (t, e) { return t.link(c) }))) : s = new cs(l && l.thisDep || u && u.thisDep, l && l.contextDep || u && u.contextDep, l && l.propDep || u && u.propDep, (function (t, e) { var n, r = t.shared.shader; n = l ? l.append(t, e) : e.def(r, ".", Zo); var i = r + ".program(" + (u ? u.append(t, e) : e.def(r, ".", qo)) + "," + n; return rt.optional((function () { i += "," + t.command })), e.def(i + ")") })), { frag: l, vert: u, progVar: s, program: c } } function F(t, e) { var n = t.static, r = t.dynamic, i = {}, o = !1; function s() { if (ta in n) { var t = n[ta]; return null !== t && null === c.getVAO(t) && (t = c.createVAO(t)), o = !0, i.vao = t, hs((function (e) { var n = c.getVAO(t); return n ? e.link(n) : "null" })) } if (ta in r) { o = !0; var e = r[ta]; return fs(e, (function (t, n) { var r = t.invoke(n, e); return n.def(t.shared.vao + ".getVAO(" + r + ")") })) } return null } var l = s(), u = !1; function p() { if (Yo in n) { var t = n[Yo]; if (i.elements = t, ls(t)) { var s = i.elements = a.create(t, !0); t = a.getElements(s), u = !0 } else t && (t = a.getElements(t), u = !0, rt.command(t, "invalid elements", e.commandStr)); var c = hs((function (e, n) { if (t) { var r = e.link(t); return e.ELEMENTS = r, r } return e.ELEMENTS = null, null })); return c.value = t, c } if (Yo in r) { u = !0; var p = r[Yo]; return fs(p, (function (t, e) { var n = t.shared, r = n.isBufferArgs, i = n.elements, o = t.invoke(e, p), a = e.def("null"), s = e.def(r, "(", o, ")"), l = t.cond(s).then(a, "=", i, ".createStream(", o, ");").else(a, "=", i, ".getElements(", o, ");"); return rt.optional((function () { t.assert(l.else, "!" + o + "||" + a, "invalid elements") })), e.entry(l), e.exit(t.cond(s).then(i, ".destroyStream(", a, ");")), t.ELEMENTS = a, a })) } return o ? new cs(l.thisDep, l.contextDep, l.propDep, (function (t, e) { return e.def(t.shared.vao + ".currentVAO?" + t.shared.elements + ".getElements(" + t.shared.vao + ".currentVAO.elements):null") })) : null } var h = p(); function f() { if (Ko in n) { var t = n[Ko]; return i.primitive = t, rt.commandParameter(t, qe, "invalid primitve", e.commandStr), hs((function (e, n) { return qe[t] })) } if (Ko in r) { var a = r[Ko]; return fs(a, (function (t, e) { var n = t.constants.primTypes, r = t.invoke(e, a); return rt.optional((function () { t.assert(e, r + " in " + n, "invalid primitive, must be one of " + Object.keys(qe)) })), e.def(n, "[", r, "]") })) } return u ? ps(h) ? h.value ? hs((function (t, e) { return e.def(t.ELEMENTS, ".primType") })) : hs((function () { return Ua })) : new cs(h.thisDep, h.contextDep, h.propDep, (function (t, e) { var n = t.ELEMENTS; return e.def(n, "?", n, ".primType:", Ua) })) : o ? new cs(l.thisDep, l.contextDep, l.propDep, (function (t, e) { return e.def(t.shared.vao + ".currentVAO?" + t.shared.vao + ".currentVAO.primitive:" + Ua) })) : null } function d(t, a) { if (t in n) { var s = 0 | n[t]; return a ? i.offset = s : i.instances = s, rt.command(!a || s >= 0, "invalid " + t, e.commandStr), hs((function (t, e) { return a && (t.OFFSET = s), s })) } if (t in r) { var c = r[t]; return fs(c, (function (e, n) { var r = e.invoke(n, c); return a && (e.OFFSET = r, rt.optional((function () { e.assert(n, r + ">=0", "invalid " + t) }))), r })) } if (a) { if (u) return hs((function (t, e) { return t.OFFSET = 0, 0 })); if (o) return new cs(l.thisDep, l.contextDep, l.propDep, (function (t, e) { return e.def(t.shared.vao + ".currentVAO?" + t.shared.vao + ".currentVAO.offset:0") })) } else if (o) return new cs(l.thisDep, l.contextDep, l.propDep, (function (t, e) { return e.def(t.shared.vao + ".currentVAO?" + t.shared.vao + ".currentVAO.instances:-1") })); return null } var m = d(Jo, !0); function v() { if (Qo in n) { var t = 0 | n[Qo]; return i.count = t, rt.command("number" == typeof t && t >= 0, "invalid vertex count", e.commandStr), hs((function () { return t })) } if (Qo in r) { var a = r[Qo]; return fs(a, (function (t, e) { var n = t.invoke(e, a); return rt.optional((function () { t.assert(e, "typeof " + n + '==="number"&&' + n + ">=0&&" + n + "===(" + n + "|0)", "invalid vertex count") })), n })) } if (u) { if (ps(h)) { if (h) return m ? new cs(m.thisDep, m.contextDep, m.propDep, (function (t, e) { var n = e.def(t.ELEMENTS, ".vertCount-", t.OFFSET); return rt.optional((function () { t.assert(e, n + ">=0", "invalid vertex offset/element buffer too small") })), n })) : hs((function (t, e) { return e.def(t.ELEMENTS, ".vertCount") })); var s = hs((function () { return -1 })); return rt.optional((function () { s.MISSING = !0 })), s } var c = new cs(h.thisDep || m.thisDep, h.contextDep || m.contextDep, h.propDep || m.propDep, (function (t, e) { var n = t.ELEMENTS; return t.OFFSET ? e.def(n, "?", n, ".vertCount-", t.OFFSET, ":-1") : e.def(n, "?", n, ".vertCount:-1") })); return rt.optional((function () { c.DYNAMIC = !0 })), c } if (o) { var p = new cs(l.thisDep, l.contextDep, l.propDep, (function (t, e) { return e.def(t.shared.vao, ".currentVAO?", t.shared.vao, ".currentVAO.count:-1") })); return p } return null } var y = f(), g = v(), _ = d($o, !1); return { elements: h, primitive: y, count: g, instances: _, offset: m, vao: l, vaoActive: o, elementsActive: u, static: i } } function B(t, e) { var n = t.static, r = t.dynamic, o = {}; return S.forEach((function (t) { var a = T(t); function s(e, i) { if (t in n) { var s = e(n[t]); o[a] = hs((function () { return s })) } else if (t in r) { var l = r[t]; o[a] = fs(l, (function (t, e) { return i(t, e, t.invoke(e, l)) })) } } switch (t) { case Mo: case _o: case go: case zo: case So: case Vo: case Po: case Ro: case Do: case To: return s((function (n) { return rt.commandType(n, "boolean", t, e.commandStr), n }), (function (e, n, r) { return rt.optional((function () { e.assert(n, "typeof " + r + '==="boolean"', "invalid flag " + t, e.commandStr) })), r })); case Eo: return s((function (n) { return rt.commandParameter(n, is, "invalid " + t, e.commandStr), is[n] }), (function (e, n, r) { var i = e.constants.compareFuncs; return rt.optional((function () { e.assert(n, r + " in " + i, "invalid " + t + ", must be one of " + Object.keys(is)) })), n.def(i, "[", r, "]") })); case Co: return s((function (t) { return rt.command(hn(t) && 2 === t.length && "number" == typeof t[0] && "number" == typeof t[1] && t[0] <= t[1], "depth range is 2d array", e.commandStr), t }), (function (t, e, n) { return rt.optional((function () { t.assert(e, t.shared.isArrayLike + "(" + n + ")&&" + n + ".length===2&&typeof " + n + '[0]==="number"&&typeof ' + n + '[1]==="number"&&' + n + "[0]<=" + n + "[1]", "depth range must be a 2d array") })), [e.def("+", n, "[0]"), e.def("+", n, "[1]")] })); case wo: return s((function (t) { rt.commandType(t, "object", "blend.func", e.commandStr); var n = "srcRGB" in t ? t.srcRGB : t.src, r = "srcAlpha" in t ? t.srcAlpha : t.src, i = "dstRGB" in t ? t.dstRGB : t.dst, o = "dstAlpha" in t ? t.dstAlpha : t.dst; return rt.commandParameter(n, ns, a + ".srcRGB", e.commandStr), rt.commandParameter(r, ns, a + ".srcAlpha", e.commandStr), rt.commandParameter(i, ns, a + ".dstRGB", e.commandStr), rt.commandParameter(o, ns, a + ".dstAlpha", e.commandStr), rt.command(-1 === rs.indexOf(n + ", " + i), "unallowed blending combination (srcRGB, dstRGB) = (" + n + ", " + i + ")", e.commandStr), [ns[n], ns[i], ns[r], ns[o]] }), (function (e, n, r) { var i = e.constants.blendFuncs; function o(o, a) { var s = n.def('"', o, a, '" in ', r, "?", r, ".", o, a, ":", r, ".", o); return rt.optional((function () { e.assert(n, s + " in " + i, "invalid " + t + "." + o + a + ", must be one of " + Object.keys(ns)) })), s } rt.optional((function () { e.assert(n, r + "&&typeof " + r + '==="object"', "invalid blend func, must be an object") })); var a = o("src", "RGB"), s = o("dst", "RGB"); rt.optional((function () { var t = e.constants.invalidBlendCombinations; e.assert(n, t + ".indexOf(" + a + '+", "+' + s + ") === -1 ", "unallowed blending combination for (srcRGB, dstRGB)") })); var l = n.def(i, "[", a, "]"), u = n.def(i, "[", o("src", "Alpha"), "]"); return [l, n.def(i, "[", s, "]"), u, n.def(i, "[", o("dst", "Alpha"), "]")] })); case bo: return s((function (n) { return "string" == typeof n ? (rt.commandParameter(n, y, "invalid " + t, e.commandStr), [y[n], y[n]]) : "object" == typeof n ? (rt.commandParameter(n.rgb, y, t + ".rgb", e.commandStr), rt.commandParameter(n.alpha, y, t + ".alpha", e.commandStr), [y[n.rgb], y[n.alpha]]) : void rt.commandRaise("invalid blend.equation", e.commandStr) }), (function (e, n, r) { var i = e.constants.blendEquations, o = n.def(), a = n.def(), s = e.cond("typeof ", r, '==="string"'); return rt.optional((function () { function n(t, n, r) { e.assert(t, r + " in " + i, "invalid " + n + ", must be one of " + Object.keys(y)) } n(s.then, t, r), e.assert(s.else, r + "&&typeof " + r + '==="object"', "invalid " + t), n(s.else, t + ".rgb", r + ".rgb"), n(s.else, t + ".alpha", r + ".alpha") })), s.then(o, "=", a, "=", i, "[", r, "];"), s.else(o, "=", i, "[", r, ".rgb];", a, "=", i, "[", r, ".alpha];"), n(s), [o, a] })); case xo: return s((function (t) { return rt.command(hn(t) && 4 === t.length, "blend.color must be a 4d array", e.commandStr), At(4, (function (e) { return +t[e] })) }), (function (t, e, n) { return rt.optional((function () { t.assert(e, t.shared.isArrayLike + "(" + n + ")&&" + n + ".length===4", "blend.color must be a 4d array") })), At(4, (function (t) { return e.def("+", n, "[", t, "]") })) })); case Fo: return s((function (t) { return rt.commandType(t, "number", a, e.commandStr), 0 | t }), (function (t, e, n) { return rt.optional((function () { t.assert(e, "typeof " + n + '==="number"', "invalid stencil.mask") })), e.def(n, "|0") })); case Bo: return s((function (n) { rt.commandType(n, "object", a, e.commandStr); var r = n.cmp || "keep", i = n.ref || 0, o = "mask" in n ? n.mask : -1; return rt.commandParameter(r, is, t + ".cmp", e.commandStr), rt.commandType(i, "number", t + ".ref", e.commandStr), rt.commandType(o, "number", t + ".mask", e.commandStr), [is[r], i, o] }), (function (t, e, n) { var r = t.constants.compareFuncs; return rt.optional((function () { function i() { t.assert(e, Array.prototype.join.call(arguments, ""), "invalid stencil.func") } i(n + "&&typeof ", n, '==="object"'), i('!("cmp" in ', n, ")||(", n, ".cmp in ", r, ")") })), [e.def('"cmp" in ', n, "?", r, "[", n, ".cmp]", ":", Ya), e.def(n, ".ref|0"), e.def('"mask" in ', n, "?", n, ".mask|0:-1")] })); case jo: case Uo: return s((function (n) { rt.commandType(n, "object", a, e.commandStr); var r = n.fail || "keep", i = n.zfail || "keep", o = n.zpass || "keep"; return rt.commandParameter(r, os, t + ".fail", e.commandStr), rt.commandParameter(i, os, t + ".zfail", e.commandStr), rt.commandParameter(o, os, t + ".zpass", e.commandStr), [t === Uo ? Ga : Va, os[r], os[i], os[o]] }), (function (e, n, r) { var i = e.constants.stencilOps; function o(o) { return rt.optional((function () { e.assert(n, '!("' + o + '" in ' + r + ")||(" + r + "." + o + " in " + i + ")", "invalid " + t + "." + o + ", must be one of " + Object.keys(os)) })), n.def('"', o, '" in ', r, "?", i, "[", r, ".", o, "]:", Ya) } return rt.optional((function () { e.assert(n, r + "&&typeof " + r + '==="object"', "invalid " + t) })), [t === Uo ? Ga : Va, o("fail"), o("zfail"), o("zpass")] })); case Lo: return s((function (t) { rt.commandType(t, "object", a, e.commandStr); var n = 0 | t.factor, r = 0 | t.units; return rt.commandType(n, "number", a + ".factor", e.commandStr), rt.commandType(r, "number", a + ".units", e.commandStr), [n, r] }), (function (e, n, r) { return rt.optional((function () { e.assert(n, r + "&&typeof " + r + '==="object"', "invalid " + t) })), [n.def(r, ".factor|0"), n.def(r, ".units|0")] })); case Oo: return s((function (t) { var n = 0; return "front" === t ? n = Va : "back" === t && (n = Ga), rt.command(!!n, a, e.commandStr), n }), (function (t, e, n) { return rt.optional((function () { t.assert(e, n + '==="front"||' + n + '==="back"', "invalid cull.face") })), e.def(n, '==="front"?', Va, ":", Ga) })); case Io: return s((function (t) { return rt.command("number" == typeof t && t >= i.lineWidthDims[0] && t <= i.lineWidthDims[1], "invalid line width, must be a positive number between " + i.lineWidthDims[0] + " and " + i.lineWidthDims[1], e.commandStr), t }), (function (t, e, n) { return rt.optional((function () { t.assert(e, "typeof " + n + '==="number"&&' + n + ">=" + i.lineWidthDims[0] + "&&" + n + "<=" + i.lineWidthDims[1], "invalid line width") })), n })); case ko: return s((function (t) { return rt.commandParameter(t, ss, a, e.commandStr), ss[t] }), (function (t, e, n) { return rt.optional((function () { t.assert(e, n + '==="cw"||' + n + '==="ccw"', "invalid frontFace, must be one of cw,ccw") })), e.def(n + '==="cw"?' + Ha + ":" + Wa) })); case Ao: return s((function (t) { return rt.command(hn(t) && 4 === t.length, "color.mask must be length 4 array", e.commandStr), t.map((function (t) { return !!t })) }), (function (t, e, n) { return rt.optional((function () { t.assert(e, t.shared.isArrayLike + "(" + n + ")&&" + n + ".length===4", "invalid color.mask") })), At(4, (function (t) { return "!!" + n + "[" + t + "]" })) })); case No: return s((function (t) { rt.command("object" == typeof t && t, a, e.commandStr); var n = "value" in t ? t.value : 1, r = !!t.invert; return rt.command("number" == typeof n && n >= 0 && n <= 1, "sample.coverage.value must be a number between 0 and 1", e.commandStr), [n, r] }), (function (t, e, n) { return rt.optional((function () { t.assert(e, n + "&&typeof " + n + '==="object"', "invalid sample.coverage") })), [e.def('"value" in ', n, "?+", n, ".value:1"), e.def("!!", n, ".invert")] })) } })), o } function j(t, e) { var n = t.static, r = t.dynamic, i = {}; return Object.keys(n).forEach((function (t) { var r, o = n[t]; if ("number" == typeof o || "boolean" == typeof o) r = hs((function () { return o })); else if ("function" == typeof o) { var a = o._reglType; "texture2d" === a || "textureCube" === a ? r = hs((function (t) { return t.link(o) })) : "framebuffer" === a || "framebufferCube" === a ? (rt.command(o.color.length > 0, 'missing color attachment for framebuffer sent to uniform "' + t + '"', e.commandStr), r = hs((function (t) { return t.link(o.color[0]) }))) : rt.commandRaise('invalid data for uniform "' + t + '"', e.commandStr) } else hn(o) ? r = hs((function (e) { return e.global.def("[", At(o.length, (function (n) { return rt.command("number" == typeof o[n] || "boolean" == typeof o[n], "invalid uniform " + t, e.commandStr), o[n] })), "]") })) : rt.commandRaise('invalid or missing data for uniform "' + t + '"', e.commandStr); r.value = o, i[t] = r })), Object.keys(r).forEach((function (t) { var e = r[t]; i[t] = fs(e, (function (t, n) { return t.invoke(n, e) })) })), i } function U(t, n) { var r = t.static, i = t.dynamic, a = {}; return Object.keys(r).forEach((function (t) { var i = r[t], s = e.id(t), l = new v; if (ls(i)) l.state = lo, l.buffer = o.getBuffer(o.create(i, pa, !1, !0)), l.type = 0; else { var u = o.getBuffer(i); if (u) l.state = lo, l.buffer = u, l.type = 0; else if (rt.command("object" == typeof i && i, "invalid data for attribute " + t, n.commandStr), "constant" in i) { var c = i.constant; l.buffer = "null", l.state = uo, "number" == typeof c ? l.x = c : (rt.command(hn(c) && c.length > 0 && c.length <= 4, "invalid constant for attribute " + t, n.commandStr), ao.forEach((function (t, e) { e < c.length && (l[t] = c[e]) }))) } else { u = ls(i.buffer) ? o.getBuffer(o.create(i.buffer, pa, !1, !0)) : o.getBuffer(i.buffer), rt.command(!!u, 'missing buffer for attribute "' + t + '"', n.commandStr); var p = 0 | i.offset; rt.command(p >= 0, 'invalid offset for attribute "' + t + '"', n.commandStr); var h = 0 | i.stride; rt.command(h >= 0 && h < 256, 'invalid stride for attribute "' + t + '", must be integer betweeen [0, 255]', n.commandStr); var f = 0 | i.size; rt.command(!("size" in i) || f > 0 && f <= 4, 'invalid size for attribute "' + t + '", must be 1,2,3,4', n.commandStr); var d = !!i.normalized, m = 0; "type" in i && (rt.commandParameter(i.type, Re, "invalid type for attribute " + t, n.commandStr), m = Re[i.type]); var y = 0 | i.divisor; rt.optional((function () { "divisor" in i && (rt.command(0 === y || g, 'cannot specify divisor for attribute "' + t + '", instancing not supported', n.commandStr), rt.command(y >= 0, 'invalid divisor for attribute "' + t + '"', n.commandStr)); var e = n.commandStr, r = ["buffer", "offset", "divisor", "normalized", "type", "size", "stride"]; Object.keys(i).forEach((function (n) { rt.command(r.indexOf(n) >= 0, 'unknown parameter "' + n + '" for attribute pointer "' + t + '" (valid parameters are ' + r + ")", e) })) })), l.buffer = u, l.state = lo, l.size = f, l.normalized = d, l.type = m || u.dtype, l.offset = p, l.stride = h, l.divisor = y } } a[t] = hs((function (t, e) { var n = t.attribCache; if (s in n) return n[s]; var r = { isStream: !1 }; return Object.keys(l).forEach((function (t) { r[t] = l[t] })), l.buffer && (r.buffer = t.link(l.buffer), r.type = r.type || r.buffer + ".dtype"), n[s] = r, r })) })), Object.keys(i).forEach((function (t) { var e = i[t]; function n(n, r) { var i = n.invoke(r, e), o = n.shared, a = n.constants, s = o.isBufferArgs, l = o.buffer; rt.optional((function () { n.assert(r, i + "&&(typeof " + i + '==="object"||typeof ' + i + '==="function")&&(' + s + "(" + i + ")||" + l + ".getBuffer(" + i + ")||" + l + ".getBuffer(" + i + ".buffer)||" + s + "(" + i + '.buffer)||("constant" in ' + i + "&&(typeof " + i + '.constant==="number"||' + o.isArrayLike + "(" + i + ".constant))))", 'invalid dynamic attribute "' + t + '"') })); var u = { isStream: r.def(!1) }, c = new v; c.state = lo, Object.keys(c).forEach((function (t) { u[t] = r.def("" + c[t]) })); var p = u.buffer, h = u.type; function f(t) { r(u[t], "=", i, ".", t, "|0;") } return r("if(", s, "(", i, ")){", u.isStream, "=true;", p, "=", l, ".createStream(", pa, ",", i, ");", h, "=", p, ".dtype;", "}else{", p, "=", l, ".getBuffer(", i, ");", "if(", p, "){", h, "=", p, ".dtype;", '}else if("constant" in ', i, "){", u.state, "=", uo, ";", "if(typeof " + i + '.constant === "number"){', u[ao[0]], "=", i, ".constant;", ao.slice(1).map((function (t) { return u[t] })).join("="), "=0;", "}else{", ao.map((function (t, e) { return u[t] + "=" + i + ".constant.length>" + e + "?" + i + ".constant[" + e + "]:0;" })).join(""), "}}else{", "if(", s, "(", i, ".buffer)){", p, "=", l, ".createStream(", pa, ",", i, ".buffer);", "}else{", p, "=", l, ".getBuffer(", i, ".buffer);", "}", h, '="type" in ', i, "?", a.glTypes, "[", i, ".type]:", p, ".dtype;", u.normalized, "=!!", i, ".normalized;"), f("size"), f("offset"), f("stride"), f("divisor"), r("}}"), r.exit("if(", u.isStream, "){", l, ".destroyStream(", p, ");", "}"), u } a[t] = fs(e, n) })), a } function V(t) { var e = t.static, n = t.dynamic, r = {}; return Object.keys(e).forEach((function (t) { var n = e[t]; r[t] = hs((function (t, e) { return "number" == typeof n || "boolean" == typeof n ? "" + n : t.link(n) })) })), Object.keys(n).forEach((function (t) { var e = n[t]; r[t] = fs(e, (function (t, n) { return t.invoke(n, e) })) })), r } function G(t, e, n, i, o) { var a = t.static, s = t.dynamic; rt.optional((function () { var t = [Xo, qo, Zo, Yo, Ko, Jo, Qo, $o, Wo, ta].concat(S); function e(e) { Object.keys(e).forEach((function (e) { rt.command(t.indexOf(e) >= 0, 'unknown parameter "' + e + '"', o.commandStr) })) } e(a), e(s) })); var l = N(t, e), u = R(t), p = D(t, u, o), h = F(t, o), f = B(t, o), d = z(t, o, l); function m(t) { var e = p[t]; e && (f[t] = e) } m(Ho), m(T(Go)); var v = Object.keys(f).length > 0, y = { framebuffer: u, draw: h, shader: d, state: f, dirty: v, scopeVAO: null, drawVAO: null, useVAO: !1, attributes: {} }; if (y.profile = L(t), y.uniforms = j(n, o), y.drawVAO = y.scopeVAO = h.vao, !y.drawVAO && d.program && !l && r.angle_instanced_arrays && h.static.elements) { var g = !0, _ = d.program.attributes.map((function (t) { var n = e.static[t]; return g = g && !!n, n })); if (g && _.length > 0) { var x = c.getVAO(c.createVAO({ attributes: _, elements: h.static.elements })); y.drawVAO = new cs(null, null, null, (function (t, e) { return t.link(x) })), y.useVAO = !0 } } return l ? y.useVAO = !0 : y.attributes = U(e, o), y.context = V(i), y } function H(t, e, n) { var r = t.shared.context, i = t.scope(); Object.keys(n).forEach((function (o) { e.save(r, "." + o); var a = n[o].append(t, e); Array.isArray(a) ? i(r, ".", o, "=[", a.join(), "];") : i(r, ".", o, "=", a, ";") })), e(i) } function W(t, e, n, r) { var i, o = t.shared, a = o.gl, s = o.framebuffer; _ && (i = e.def(o.extensions, ".webgl_draw_buffers")); var l, u = t.constants, c = u.drawBuffer, p = u.backBuffer; l = n ? n.append(t, e) : e.def(s, ".next"), r || e("if(", l, "!==", s, ".cur){"), e("if(", l, "){", a, ".bindFramebuffer(", ts, ",", l, ".framebuffer);"), _ && e(i, ".drawBuffersWEBGL(", c, "[", l, ".colorAttachments.length]);"), e("}else{", a, ".bindFramebuffer(", ts, ",null);"), _ && e(i, ".drawBuffersWEBGL(", p, ");"), e("}", s, ".cur=", l, ";"), r || e("}") } function X(t, e, n) { var r = t.shared, i = r.gl, o = t.current, a = t.next, s = r.current, l = r.next, u = t.cond(s, ".dirty"); S.forEach((function (e) { var r, c, p = T(e); if (!(p in n.state)) if (p in a) { r = a[p], c = o[p]; var h = At(b[p].length, (function (t) { return u.def(r, "[", t, "]") })); u(t.cond(h.map((function (t, e) { return t + "!==" + c + "[" + e + "]" })).join("||")).then(i, ".", C[p], "(", h, ");", h.map((function (t, e) { return c + "[" + e + "]=" + t })).join(";"), ";")) } else { r = u.def(l, ".", p); var f = t.cond(r, "!==", s, ".", p); u(f), p in E ? f(t.cond(r).then(i, ".enable(", E[p], ");").else(i, ".disable(", E[p], ");"), s, ".", p, "=", r, ";") : f(i, ".", C[p], "(", r, ");", s, ".", p, "=", r, ";") } })), 0 === Object.keys(n.state).length && u(s, ".dirty=false;"), e(u) } function q(t, e, n, r) { var i = t.shared, o = t.current, a = i.current, s = i.gl; us(Object.keys(n)).forEach((function (i) { var l = n[i]; if (!r || r(l)) { var u = l.append(t, e); if (E[i]) { var c = E[i]; ps(l) ? e(s, u ? ".enable(" : ".disable(", c, ");") : e(t.cond(u).then(s, ".enable(", c, ");").else(s, ".disable(", c, ");")), e(a, ".", i, "=", u, ";") } else if (hn(u)) { var p = o[i]; e(s, ".", C[i], "(", u, ");", u.map((function (t, e) { return p + "[" + e + "]=" + t })).join(";"), ";") } else e(s, ".", C[i], "(", u, ");", a, ".", i, "=", u, ";") } })) } function Z(t, e) { g && (t.instancing = e.def(t.shared.extensions, ".angle_instanced_arrays")) } function Y(t, e, n, r, i) { var o, a, s, l = t.shared, u = t.stats, c = l.current, p = l.timer, h = n.profile; function f() { return "undefined" != typeof my && my && "function" == typeof my.showToast && !0 !== my.isFRM || "undefined" == typeof performance ? "Date.now()" : "performance.now()" } function m(t) { t(o = e.def(), "=", f(), ";"), "string" == typeof i ? t(u, ".count+=", i, ";") : t(u, ".count++;"), d && (r ? t(a = e.def(), "=", p, ".getNumPendingQueries();") : t(p, ".beginQuery(", u, ");")) } function v(t) { t(u, ".cpuTime+=", f(), "-", o, ";"), d && (r ? t(p, ".pushScopeStats(", a, ",", p, ".getNumPendingQueries(),", u, ");") : t(p, ".endQuery();")) } function y(t) { var n = e.def(c, ".profile"); e(c, ".profile=", t, ";"), e.exit(c, ".profile=", n, ";") } if (h) { if (ps(h)) return void (h.enable ? (m(e), v(e.exit), y("true")) : y("false")); y(s = h.append(t, e)) } else s = e.def(c, ".profile"); var g = t.block(); m(g), e("if(", s, "){", g, "}"); var _ = t.block(); v(_), e.exit("if(", s, "){", _, "}") } function K(t, e, n, r, i) { var o = t.shared; function a(t) { switch (t) { case Ca: case Oa: case La: return 2; case Ta: case ka: case Ra: return 3; case Aa: case Ia: case Da: return 4; default: return 1 } } function s(n, r, i) { var a = o.gl, s = e.def(n, ".location"), l = e.def(o.attributes, "[", s, "]"), u = i.state, c = i.buffer, p = [i.x, i.y, i.z, i.w], h = ["buffer", "normalized", "offset", "stride"]; function f() { e("if(!", l, ".buffer){", a, ".enableVertexAttribArray(", s, ");}"); var n, o = i.type; if (n = i.size ? e.def(i.size, "||", r) : r, e("if(", l, ".type!==", o, "||", l, ".size!==", n, "||", h.map((function (t) { return l + "." + t + "!==" + i[t] })).join("||"), "){", a, ".bindBuffer(", pa, ",", c, ".buffer);", a, ".vertexAttribPointer(", [s, n, o, i.normalized, i.stride, i.offset], ");", l, ".type=", o, ";", l, ".size=", n, ";", h.map((function (t) { return l + "." + t + "=" + i[t] + ";" })).join(""), "}"), g) { var u = i.divisor; e("if(", l, ".divisor!==", u, "){", t.instancing, ".vertexAttribDivisorANGLE(", [s, u], ");", l, ".divisor=", u, ";}") } } function d() { e("if(", l, ".buffer){", a, ".disableVertexAttribArray(", s, ");", l, ".buffer=null;", "}if(", ao.map((function (t, e) { return l + "." + t + "!==" + p[e] })).join("||"), "){", a, ".vertexAttrib4f(", s, ",", p, ");", ao.map((function (t, e) { return l + "." + t + "=" + p[e] + ";" })).join(""), "}") } u === lo ? f() : u === uo ? d() : (e("if(", u, "===", lo, "){"), f(), e("}else{"), d(), e("}")) } r.forEach((function (r) { var o, l = r.name, u = n.attributes[l]; if (u) { if (!i(u)) return; o = u.append(t, e) } else { if (!i(ds)) return; var c = t.scopeAttrib(l); rt.optional((function () { t.assert(e, c + ".state", "missing attribute " + l) })), o = {}, Object.keys(new v).forEach((function (t) { o[t] = e.def(c, ".", t) })) } s(t.link(r), a(r.info.type), o) })) } function Q(t, n, r, i, o, a) { for (var s, l = t.shared, u = l.gl, c = 0; c < i.length; ++c) { var p, h = i[c], f = h.name, d = h.info.type, m = r.uniforms[f], v = t.link(h) + ".location"; if (m) { if (!o(m)) continue; if (ps(m)) { var y = m.value; if (rt.command(null != y, 'missing uniform "' + f + '"', t.commandStr), d === Ba || d === ja) { rt.command("function" == typeof y && (d === Ba && ("texture2d" === y._reglType || "framebuffer" === y._reglType) || d === ja && ("textureCube" === y._reglType || "framebufferCube" === y._reglType)), "invalid texture for uniform " + f, t.commandStr); var g = t.link(y._texture || y.color[0]._texture); n(u, ".uniform1i(", v, ",", g + ".bind());"), n.exit(g, ".unbind();") } else if (d === Na || d === za || d === Fa) { rt.optional((function () { rt.command(hn(y), "invalid matrix for uniform " + f, t.commandStr), rt.command(d === Na && 4 === y.length || d === za && 9 === y.length || d === Fa && 16 === y.length, "invalid length for matrix uniform " + f, t.commandStr) })); var _ = t.global.def("new Float32Array([" + Array.prototype.slice.call(y) + "])"), x = 2; d === za ? x = 3 : d === Fa && (x = 4), n(u, ".uniformMatrix", x, "fv(", v, ",false,", _, ");") } else { switch (d) { case Ea: rt.commandType(y, "number", "uniform " + f, t.commandStr), s = "1f"; break; case Ca: rt.command(hn(y) && 2 === y.length, "uniform " + f, t.commandStr), s = "2f"; break; case Ta: rt.command(hn(y) && 3 === y.length, "uniform " + f, t.commandStr), s = "3f"; break; case Aa: rt.command(hn(y) && 4 === y.length, "uniform " + f, t.commandStr), s = "4f"; break; case Pa: rt.commandType(y, "boolean", "uniform " + f, t.commandStr), s = "1i"; break; case Ma: rt.commandType(y, "number", "uniform " + f, t.commandStr), s = "1i"; break; case La: case Oa: rt.command(hn(y) && 2 === y.length, "uniform " + f, t.commandStr), s = "2i"; break; case Ra: case ka: rt.command(hn(y) && 3 === y.length, "uniform " + f, t.commandStr), s = "3i"; break; case Da: case Ia: rt.command(hn(y) && 4 === y.length, "uniform " + f, t.commandStr), s = "4i" }n(u, ".uniform", s, "(", v, ",", hn(y) ? Array.prototype.slice.call(y) : y, ");") } continue } p = m.append(t, n) } else { if (!o(ds)) continue; p = n.def(l.uniforms, "[", e.id(f), "]") } d === Ba ? (rt(!Array.isArray(p), "must specify a scalar prop for textures"), n("if(", p, "&&", p, '._reglType==="framebuffer"){', p, "=", p, ".color[0];", "}")) : d === ja && (rt(!Array.isArray(p), "must specify a scalar prop for cube maps"), n("if(", p, "&&", p, '._reglType==="framebufferCube"){', p, "=", p, ".color[0];", "}")), rt.optional((function () { function e(e, r) { t.assert(n, e, 'bad data or missing for uniform "' + f + '".  ' + r) } function r(t) { rt(!Array.isArray(p), "must not specify an array type for uniform"), e("typeof " + p + '==="' + t + '"', "invalid type, expected " + t) } function i(n, r) { Array.isArray(p) ? rt(p.length === n, "must have length " + n) : e(l.isArrayLike + "(" + p + ")&&" + p + ".length===" + n, "invalid vector, should have length " + n, t.commandStr) } function o(n) { rt(!Array.isArray(p), "must not specify a value type"), e("typeof " + p + '==="function"&&' + p + '._reglType==="texture' + (n === fa ? "2d" : "Cube") + '"', "invalid texture type", t.commandStr) } switch (d) { case Ma: r("number"); break; case Oa: i(2); break; case ka: i(3); break; case Ia: i(4); break; case Ea: r("number"); break; case Ca: i(2); break; case Ta: i(3); break; case Aa: i(4); break; case Pa: r("boolean"); break; case La: i(2); break; case Ra: i(3); break; case Da: case Na: i(4); break; case za: i(9); break; case Fa: i(16); break; case Ba: o(fa); break; case ja: o(da) } })); var b = 1; switch (d) { case Ba: case ja: var w = n.def(p, "._texture"); n(u, ".uniform1i(", v, ",", w, ".bind());"), n.exit(w, ".unbind();"); continue; case Ma: case Pa: s = "1i"; break; case Oa: case La: s = "2i", b = 2; break; case ka: case Ra: s = "3i", b = 3; break; case Ia: case Da: s = "4i", b = 4; break; case Ea: s = "1f"; break; case Ca: s = "2f", b = 2; break; case Ta: s = "3f", b = 3; break; case Aa: s = "4f", b = 4; break; case Na: s = "Matrix2fv"; break; case za: s = "Matrix3fv"; break; case Fa: s = "Matrix4fv" }if ("M" === s.charAt(0)) { n(u, ".uniform", s, "(", v, ","); var S = Math.pow(d - Na + 2, 2), E = t.global.def("new Float32Array(", S, ")"); Array.isArray(p) ? n("false,(", At(S, (function (t) { return E + "[" + t + "]=" + p[t] })), ",", E, ")") : n("false,(Array.isArray(", p, ")||", p, " instanceof Float32Array)?", p, ":(", At(S, (function (t) { return E + "[" + t + "]=" + p + "[" + t + "]" })), ",", E, ")"), n(");") } else if (b > 1) { for (var C = [], T = [], A = 0; A < b; ++A)Array.isArray(p) ? T.push(p[A]) : T.push(n.def(p + "[" + A + "]")), a && C.push(n.def()); a && n("if(!", t.batchId, "||", C.map((function (t, e) { return t + "!==" + T[e] })).join("||"), "){", C.map((function (t, e) { return t + "=" + T[e] + ";" })).join("")), n(u, ".uniform", s, "(", v, ",", T.join(","), ");"), a && n("}") } else { if (rt(!Array.isArray(p), "uniform value must not be an array"), a) { var M = n.def(); n("if(!", t.batchId, "||", M, "!==", p, "){", M, "=", p, ";") } n(u, ".uniform", s, "(", v, ",", p, ");"), a && n("}") } } } function J(t, e, n, r) { var i = t.shared, o = i.gl, a = i.draw, s = r.draw; function l() { var l, u = s.elements, c = e; return u ? ((u.contextDep && r.contextDynamic || u.propDep) && (c = n), l = u.append(t, c), s.elementsActive && c("if(" + l + ")" + o + ".bindBuffer(" + ha + "," + l + ".buffer.buffer);")) : (l = c.def(), c(l, "=", a, ".", Yo, ";", "if(", l, "){", o, ".bindBuffer(", ha, ",", l, ".buffer.buffer);}", "else if(", i.vao, ".currentVAO){", l, "=", t.shared.elements + ".getElements(" + i.vao, ".currentVAO.elements);", x ? "" : "if(" + l + ")" + o + ".bindBuffer(" + ha + "," + l + ".buffer.buffer);", "}")), l } function u() { var i, o = s.count, l = e; return o ? ((o.contextDep && r.contextDynamic || o.propDep) && (l = n), i = o.append(t, l), rt.optional((function () { o.MISSING && t.assert(e, "false", "missing vertex count"), o.DYNAMIC && t.assert(l, i + ">=0", "missing vertex count") }))) : (i = l.def(a, ".", Qo), rt.optional((function () { t.assert(l, i + ">=0", "missing vertex count") }))), i } var c = l(); function p(i) { var o = s[i]; return o ? o.contextDep && r.contextDynamic || o.propDep ? o.append(t, n) : o.append(t, e) : e.def(a, ".", i) } var h, f, d = p(Ko), m = p(Jo), v = u(); if ("number" == typeof v) { if (0 === v) return } else n("if(", v, "){"), n.exit("}"); g && (h = p($o), f = t.instancing); var y = c + ".type", _ = s.elements && ps(s.elements) && !s.vaoActive; function b() { function t() { n(f, ".drawElementsInstancedANGLE(", [d, v, y, m + "<<((" + y + "-" + so + ")>>1)", h], ");") } function e() { n(f, ".drawArraysInstancedANGLE(", [d, m, v, h], ");") } c && "null" !== c ? _ ? t() : (n("if(", c, "){"), t(), n("}else{"), e(), n("}")) : e() } function w() { function t() { n(o + ".drawElements(" + [d, v, y, m + "<<((" + y + "-" + so + ")>>1)"] + ");") } function e() { n(o + ".drawArrays(" + [d, m, v] + ");") } c && "null" !== c ? _ ? t() : (n("if(", c, "){"), t(), n("}else{"), e(), n("}")) : e() } g && ("number" != typeof h || h >= 0) ? "string" == typeof h ? (n("if(", h, ">0){"), b(), n("}else if(", h, "<0){"), w(), n("}")) : b() : w() } function $(t, e, n, r, i) { var o = P(), a = o.proc("body", i); return rt.optional((function () { o.commandStr = e.commandStr, o.command = o.link(e.commandStr) })), g && (o.instancing = a.def(o.shared.extensions, ".angle_instanced_arrays")), t(o, a, n, r), o.compile().body } function tt(t, e, n, r) { Z(t, e), n.useVAO ? n.drawVAO ? e(t.shared.vao, ".setVAO(", n.drawVAO.append(t, e), ");") : e(t.shared.vao, ".setVAO(", t.shared.vao, ".targetVAO);") : (e(t.shared.vao, ".setVAO(null);"), K(t, e, n, r.attributes, (function () { return !0 }))), Q(t, e, n, r.uniforms, (function () { return !0 }), !1), J(t, e, e, n) } function et(t, e) { var n = t.proc("draw", 1); Z(t, n), H(t, n, e.context), W(t, n, e.framebuffer), X(t, n, e), q(t, n, e.state), Y(t, n, e, !1, !0); var r = e.shader.progVar.append(t, n); if (n(t.shared.gl, ".useProgram(", r, ".program);"), e.shader.program) tt(t, n, e, e.shader.program); else { n(t.shared.vao, ".setVAO(null);"); var i = t.global.def("{}"), o = n.def(r, ".id"), a = n.def(i, "[", o, "]"); n(t.cond(a).then(a, ".call(this,a0);").else(a, "=", i, "[", o, "]=", t.link((function (n) { return $(tt, t, e, n, 1) })), "(", r, ");", a, ".call(this,a0);")) } Object.keys(e.state).length > 0 && n(t.shared.current, ".dirty=true;"), t.shared.vao && n(t.shared.vao, ".setVAO(null);") } function nt(t, e, n, r) { function i() { return !0 } t.batchId = "a1", Z(t, e), K(t, e, n, r.attributes, i), Q(t, e, n, r.uniforms, i, !1), J(t, e, e, n) } function it(t, e, n, r) { Z(t, e); var i = n.contextDep, o = e.def(), a = "a0", s = "a1", l = e.def(); t.shared.props = l, t.batchId = o; var u = t.scope(), c = t.scope(); function p(t) { return t.contextDep && i || t.propDep } function h(t) { return !p(t) } if (e(u.entry, "for(", o, "=0;", o, "<", s, ";++", o, "){", l, "=", a, "[", o, "];", c, "}", u.exit), n.needsContext && H(t, c, n.context), n.needsFramebuffer && W(t, c, n.framebuffer), q(t, c, n.state, p), n.profile && p(n.profile) && Y(t, c, n, !1, !0), r) n.useVAO ? n.drawVAO ? p(n.drawVAO) ? c(t.shared.vao, ".setVAO(", n.drawVAO.append(t, c), ");") : u(t.shared.vao, ".setVAO(", n.drawVAO.append(t, u), ");") : u(t.shared.vao, ".setVAO(", t.shared.vao, ".targetVAO);") : (u(t.shared.vao, ".setVAO(null);"), K(t, u, n, r.attributes, h), K(t, c, n, r.attributes, p)), Q(t, u, n, r.uniforms, h, !1), Q(t, c, n, r.uniforms, p, !0), J(t, u, c, n); else { var f = t.global.def("{}"), d = n.shader.progVar.append(t, c), m = c.def(d, ".id"), v = c.def(f, "[", m, "]"); c(t.shared.gl, ".useProgram(", d, ".program);", "if(!", v, "){", v, "=", f, "[", m, "]=", t.link((function (e) { return $(nt, t, n, e, 2) })), "(", d, ");}", v, ".call(this,a0[", o, "],", o, ");") } } function ot(t, e) { var n = t.proc("batch", 2); t.batchId = "0", Z(t, n); var r = !1, i = !0; Object.keys(e.context).forEach((function (t) { r = r || e.context[t].propDep })), r || (H(t, n, e.context), i = !1); var o = e.framebuffer, a = !1; function s(t) { return t.contextDep && r || t.propDep } o ? (o.propDep ? r = a = !0 : o.contextDep && r && (a = !0), a || W(t, n, o)) : W(t, n, null), e.state.viewport && e.state.viewport.propDep && (r = !0), X(t, n, e), q(t, n, e.state, (function (t) { return !s(t) })), e.profile && s(e.profile) || Y(t, n, e, !1, "a1"), e.contextDep = r, e.needsContext = i, e.needsFramebuffer = a; var l = e.shader.progVar; if (l.contextDep && r || l.propDep) it(t, n, e, null); else { var u = l.append(t, n); if (n(t.shared.gl, ".useProgram(", u, ".program);"), e.shader.program) it(t, n, e, e.shader.program); else { n(t.shared.vao, ".setVAO(null);"); var c = t.global.def("{}"), p = n.def(u, ".id"), h = n.def(c, "[", p, "]"); n(t.cond(h).then(h, ".call(this,a0,a1);").else(h, "=", c, "[", p, "]=", t.link((function (n) { return $(it, t, e, n, 2) })), "(", u, ");", h, ".call(this,a0,a1);")) } } Object.keys(e.state).length > 0 && n(t.shared.current, ".dirty=true;"), t.shared.vao && n(t.shared.vao, ".setVAO(null);") } function at(t, n) { var r = t.proc("scope", 3); t.batchId = "a2"; var i = t.shared, o = i.current; function a(e) { var o = n.shader[e]; o && r.set(i.shader, "." + e, o.append(t, r)) } H(t, r, n.context), n.framebuffer && n.framebuffer.append(t, r), us(Object.keys(n.state)).forEach((function (e) { var o = n.state[e].append(t, r); hn(o) ? o.forEach((function (n, i) { r.set(t.next[e], "[" + i + "]", n) })) : r.set(i.next, "." + e, o) })), Y(t, r, n, !0, !0), [Yo, Jo, Qo, $o, Ko].forEach((function (e) { var o = n.draw[e]; o && r.set(i.draw, "." + e, "" + o.append(t, r)) })), Object.keys(n.uniforms).forEach((function (o) { var a = n.uniforms[o].append(t, r); Array.isArray(a) && (a = "[" + a.join() + "]"), r.set(i.uniforms, "[" + e.id(o) + "]", a) })), Object.keys(n.attributes).forEach((function (e) { var i = n.attributes[e].append(t, r), o = t.scopeAttrib(e); Object.keys(new v).forEach((function (t) { r.set(o, "." + t, i[t]) })) })), n.scopeVAO && r.set(i.vao, ".targetVAO", n.scopeVAO.append(t, r)), a(qo), a(Zo), Object.keys(n.state).length > 0 && (r(o, ".dirty=true;"), r.exit(o, ".dirty=true;")), r("a1(", t.shared.context, ",a0,", t.batchId, ");") } function st(t) { if ("object" == typeof t && !hn(t)) { for (var e = Object.keys(t), n = 0; n < e.length; ++n)if (mt.isDynamic(t[e[n]])) return !0; return !1 } } function lt(t, e, n) { var r = e.static[n]; if (r && st(r)) { var i = t.global, o = Object.keys(r), a = !1, s = !1, l = !1, u = t.global.def("{}"); o.forEach((function (e) { var n = r[e]; if (mt.isDynamic(n)) { "function" == typeof n && (n = r[e] = mt.unbox(n)); var o = fs(n, null); a = a || o.thisDep, l = l || o.propDep, s = s || o.contextDep } else { switch (i(u, ".", e, "="), typeof n) { case "number": i(n); break; case "string": i('"', n, '"'); break; case "object": Array.isArray(n) && i("[", n.join(), "]"); break; default: i(t.link(n)) }i(";") } })), e.dynamic[n] = new mt.DynamicVariable(mo, { thisDep: a, contextDep: s, propDep: l, ref: u, append: c }), delete e.static[n] } function c(t, e) { o.forEach((function (n) { var i = r[n]; if (mt.isDynamic(i)) { var o = t.invoke(e, i); e(u, ".", n, "=", o, ";") } })) } } function ut(t, e, r, i, o) { var a = P(); a.stats = a.link(o), Object.keys(e.static).forEach((function (t) { lt(a, e, t) })), ca.forEach((function (e) { lt(a, t, e) })); var s = G(t, e, r, i, a); return et(a, s), at(a, s), ot(a, s), n(a.compile(), { destroy: function () { s.shader.program.destroy() } }) } return { next: w, current: b, procs: function () { var t = P(), e = t.proc("poll"), n = t.proc("refresh"), o = t.block(); e(o), n(o); var a, s = t.shared, l = s.gl, u = s.next, c = s.current; o(c, ".dirty=false;"), W(t, e), W(t, n, null, !0), g && (a = t.link(g)), r.oes_vertex_array_object && n(t.link(r.oes_vertex_array_object), ".bindVertexArrayOES(null);"); for (var p = 0; p < i.maxAttributes; ++p) { var h = n.def(s.attributes, "[", p, "]"), f = t.cond(h, ".buffer"); f.then(l, ".enableVertexAttribArray(", p, ");", l, ".bindBuffer(", pa, ",", h, ".buffer.buffer);", l, ".vertexAttribPointer(", p, ",", h, ".size,", h, ".type,", h, ".normalized,", h, ".stride,", h, ".offset);").else(l, ".disableVertexAttribArray(", p, ");", l, ".vertexAttrib4f(", p, ",", h, ".x,", h, ".y,", h, ".z,", h, ".w);", h, ".buffer=null;"), n(f), g && n(a, ".vertexAttribDivisorANGLE(", p, ",", h, ".divisor);") } return n(t.shared.vao, ".currentVAO=null;", t.shared.vao, ".setVAO(", t.shared.vao, ".targetVAO);"), Object.keys(E).forEach((function (r) { var i = E[r], a = o.def(u, ".", r), s = t.block(); s("if(", a, "){", l, ".enable(", i, ")}else{", l, ".disable(", i, ")}", c, ".", r, "=", a, ";"), n(s), e("if(", a, "!==", c, ".", r, "){", s, "}") })), Object.keys(C).forEach((function (r) { var i, a, s = C[r], p = b[r], h = t.block(); if (h(l, ".", s, "("), hn(p)) { var f = p.length; i = t.global.def(u, ".", r), a = t.global.def(c, ".", r), h(At(f, (function (t) { return i + "[" + t + "]" })), ");", At(f, (function (t) { return a + "[" + t + "]=" + i + "[" + t + "];" })).join("")), e("if(", At(f, (function (t) { return i + "[" + t + "]!==" + a + "[" + t + "]" })).join("||"), "){", h, "}") } else i = o.def(u, ".", r), a = o.def(c, ".", r), h(i, ");", c, ".", r, "=", i, ";"), e("if(", i, "!==", a, "){", h, "}"); n(h) })), t.compile() }(), compile: ut } } function vs() { return { vaoCount: 0, bufferCount: 0, elementsCount: 0, framebufferCount: 0, shaderCount: 0, textureCount: 0, cubeCount: 0, renderbufferCount: 0, maxTextureUnits: 0 } } var ys = 34918, gs = 34919, _s = 35007, xs = function (t, e) { if (!e.ext_disjoint_timer_query) return null; var n = []; function r() { return n.pop() || e.ext_disjoint_timer_query.createQueryEXT() } function i(t) { n.push(t) } var o = []; function a(t) { var n = r(); e.ext_disjoint_timer_query.beginQueryEXT(_s, n), o.push(n), f(o.length - 1, o.length, t) } function s() { e.ext_disjoint_timer_query.endQueryEXT(_s) } function l() { this.startQueryIndex = -1, this.endQueryIndex = -1, this.sum = 0, this.stats = null } var u = []; function c() { return u.pop() || new l } function p(t) { u.push(t) } var h = []; function f(t, e, n) { var r = c(); r.startQueryIndex = t, r.endQueryIndex = e, r.sum = 0, r.stats = n, h.push(r) } var d = [], m = []; function v() { var t, n, r = o.length; if (0 !== r) { m.length = Math.max(m.length, r + 1), d.length = Math.max(d.length, r + 1), d[0] = 0, m[0] = 0; var a = 0; for (t = 0, n = 0; n < o.length; ++n) { var s = o[n]; e.ext_disjoint_timer_query.getQueryObjectEXT(s, gs) ? (a += e.ext_disjoint_timer_query.getQueryObjectEXT(s, ys), i(s)) : o[t++] = s, d[n + 1] = a, m[n + 1] = t } for (o.length = t, t = 0, n = 0; n < h.length; ++n) { var l = h[n], u = l.startQueryIndex, c = l.endQueryIndex; l.sum += d[c] - d[u]; var f = m[u], v = m[c]; v === f ? (l.stats.gpuTime += l.sum / 1e6, p(l)) : (l.startQueryIndex = f, l.endQueryIndex = v, h[t++] = l) } h.length = t } } return { beginQuery: a, endQuery: s, pushScopeStats: f, update: v, getNumPendingQueries: function () { return o.length }, clear: function () { n.push.apply(n, o); for (var t = 0; t < n.length; t++)e.ext_disjoint_timer_query.deleteQueryEXT(n[t]); o.length = 0, n.length = 0 }, restore: function () { o.length = 0, n.length = 0 } } }, bs = 16384, ws = 256, Ss = 1024, Es = 34962, Cs = "webglcontextlost", Ts = "webglcontextrestored", As = 1, Ms = 2, Os = 3; function ks(t, e) { for (var n = 0; n < t.length; ++n)if (t[n] === e) return n; return -1 } function Is(t) { var e = Ct(t); if (!e) return null; var r = e.gl, i = r.getContextAttributes(), o = r.isContextLost(), a = Tt(r, e); if (!a) return null; var s = gt(), l = vs(), u = a.extensions, c = xs(r, u), p = yt(), h = r.drawingBufferWidth, f = r.drawingBufferHeight, d = { tick: 0, time: 0, viewportWidth: h, viewportHeight: f, framebufferWidth: h, framebufferHeight: f, drawingBufferWidth: h, drawingBufferHeight: f, pixelRatio: e.pixelRatio }, m = {}, v = { elements: null, primitive: 4, count: -1, offset: 0, instances: -1 }, y = Se(r, u), g = Xe(r, l, e, b), _ = sn(r, u, g, l), x = Xi(r, u, y, l, g, _, v); function b(t) { return x.destroyBuffer(t) } var w = Qi(r, s, l, e), S = Jr(r, u, y, (function () { T.procs.poll() }), d, l, e), E = hi(r, u, y, l, e), C = ji(r, u, y, S, E, l), T = ms(r, s, u, y, g, _, S, C, m, x, w, v, d, c, e), A = no(r, C, T.procs.poll, d, i, u, y), M = T.next, O = r.canvas, k = [], I = [], P = [], L = [e.onDestroy], R = null; function D() { if (0 === k.length) return c && c.update(), void (R = null); R = vt.next(D), Z(); for (var t = k.length - 1; t >= 0; --t) { var e = k[t]; e && e(d, null, 0) } r.flush(), c && c.update() } function N() { !R && k.length > 0 && (R = vt.next(D)) } function z() { R && (vt.cancel(D), R = null) } function F(t) { t.preventDefault(), o = !0, z(), I.forEach((function (t) { t() })) } function B(t) { r.getError(), o = !1, a.restore(), w.restore(), g.restore(), S.restore(), E.restore(), C.restore(), x.restore(), c && c.restore(), T.procs.refresh(), N(), P.forEach((function (t) { t() })) } var j = "undefined" != typeof my && !!my && "function" == typeof my.showToast && !0 !== my.isFRM; function U() { k.length = 0, z(), !j && O && (O.removeEventListener(Cs, F), O.removeEventListener(Ts, B)), w.clear(), C.clear(), E.clear(), x.clear(), S.clear(), _.clear(), g.clear(), c && c.clear(), L.forEach((function (t) { t() })) } function V(t) { function e(t) { var e = n({}, t); function r(t) { if (t in e) { var n = e[t]; delete e[t], Object.keys(n).forEach((function (r) { e[t + "." + r] = n[r] })) } } return delete e.uniforms, delete e.attributes, delete e.context, delete e.vao, "stencil" in e && e.stencil.op && (e.stencil.opBack = e.stencil.opFront = e.stencil.op, delete e.stencil.op), r("blend"), r("depth"), r("cull"), r("stencil"), r("polygonOffset"), r("scissor"), r("sample"), "vao" in t && (e.vao = t.vao), e } function r(t, e) { var n = {}, r = {}; return Object.keys(t).forEach((function (i) { var o = t[i]; if (mt.isDynamic(o)) r[i] = mt.unbox(o, i); else { if (e && Array.isArray(o)) for (var a = 0; a < o.length; ++a)if (mt.isDynamic(o[a])) return void (r[i] = mt.unbox(o, i)); n[i] = o } })), { dynamic: r, static: n } } rt(!!t, "invalid args to regl({...})"), rt.type(t, "object", "invalid args to regl({...})"); var i = r(t.context || {}, !0), a = r(t.uniforms || {}, !0), s = r(t.attributes || {}, !1), l = r(e(t), !1), u = { gpuTime: 0, cpuTime: 0, count: 0 }, c = T.compile(l, s, a, i, u), p = c.draw, h = c.batch, f = c.scope, d = []; function m(t) { for (; d.length < t;)d.push(null); return d } function v(t, e) { var n; if (o && rt.raise("context lost"), "function" == typeof t) return f.call(this, null, t, 0); if ("function" == typeof e) if ("number" == typeof t) for (n = 0; n < t; ++n)f.call(this, null, e, n); else { if (!Array.isArray(t)) return f.call(this, t, e, 0); for (n = 0; n < t.length; ++n)f.call(this, t[n], e, n) } else if ("number" == typeof t) { if (t > 0) return h.call(this, m(0 | t), 0 | t) } else { if (!Array.isArray(t)) return p.call(this, t); if (t.length) return h.call(this, t, t.length) } } return n(v, { stats: u, destroy: function () { c.destroy() } }) } !j && O && (O.addEventListener(Cs, F, !1), O.addEventListener(Ts, B, !1)); var G = C.setFBO = V({ framebuffer: mt.define.call(null, As, "framebuffer") }); function H(t, e) { var n = 0; T.procs.poll(); var i = e.color; i && (r.clearColor(+i[0] || 0, +i[1] || 0, +i[2] || 0, +i[3] || 0), n |= bs), "depth" in e && (r.clearDepth(+e.depth), n |= ws), "stencil" in e && (r.clearStencil(0 | e.stencil), n |= Ss), rt(!!n, "called regl.clear with no buffer specified"), r.clear(n) } function W(t) { if (rt("object" == typeof t && t, "regl.clear() takes an object as input"), "framebuffer" in t) if (t.framebuffer && "framebufferCube" === t.framebuffer_reglType) for (var e = 0; e < 6; ++e)G(n({ framebuffer: t.framebuffer.faces[e] }, t), H); else G(t, H); else H(null, t) } function X(t) { function e() { var e = ks(k, t); function n() { var t = ks(k, n); k[t] = k[k.length - 1], k.length -= 1, k.length <= 0 && z() } rt(e >= 0, "cannot cancel a frame twice"), k[e] = n } return rt.type(t, "function", "regl.frame() callback must be a function"), k.push(t), N(), { cancel: e } } function q() { var t = M.viewport, e = M.scissor_box; t[0] = t[1] = e[0] = e[1] = 0, d.viewportWidth = d.framebufferWidth = d.drawingBufferWidth = t[2] = e[2] = r.drawingBufferWidth, d.viewportHeight = d.framebufferHeight = d.drawingBufferHeight = t[3] = e[3] = r.drawingBufferHeight } function Z() { d.tick += 1, d.time = K(), q(), T.procs.poll() } function Y() { S.refresh(), q(), T.procs.refresh(), c && c.update() } function K() { return (yt() - p) / 1e3 } function Q(t, e) { var n; switch (rt.type(e, "function", "listener callback must be a function"), t) { case "frame": return X(e); case "lost": n = I; break; case "restore": n = P; break; case "destroy": n = L; break; default: rt.raise("invalid event, must be one of frame,lost,restore,destroy") }return n.push(e), { cancel: function () { for (var t = 0; t < n.length; ++t)if (n[t] === e) return n[t] = n[n.length - 1], void n.pop() } } } Y(); var J = n(V, { clear: W, prop: mt.define.bind(null, As), context: mt.define.bind(null, Ms), this: mt.define.bind(null, Os), draw: V({}), buffer: function (t) { return g.create(t, Es, !1, !1) }, elements: function (t) { return _.create(t, !1) }, texture: S.create2D, cube: S.createCube, renderbuffer: E.create, framebuffer: C.create, framebufferCube: C.createCube, vao: x.createVAO, attributes: i, frame: X, on: Q, limits: y, hasExtension: function (t) { return y.extensions.indexOf(t.toLowerCase()) >= 0 }, read: A, destroy: U, _gl: r, _refresh: Y, poll: function () { Z(), c && c.update() }, now: K, stats: l }); return e.onDone(null, J), J } return Is }(Iz) }(sD); var Pz, Lz, Rz, Dz, Nz, zz, Fz, Bz, jz, Uz, Vz, Gz, Hz, Wz, Xz = sD.exports, qz = function () { function t(e, n) { Ar(this, t), kr(this, "attribute", void 0), kr(this, "buffer", void 0); var r = n.buffer, i = n.offset, o = n.stride, a = n.normalized, s = n.size, l = n.divisor; this.buffer = r, this.attribute = { buffer: r.get(), offset: i || 0, stride: o || 0, normalized: a || !1, divisor: l || 0 }, s && (this.attribute.size = s) } return Or(t, [{ key: "get", value: function () { return this.attribute } }, { key: "updateBuffer", value: function (t) { this.buffer.subData(t) } }, { key: "destroy", value: function () { this.buffer.destroy() } }]), t }(), Zz = (kr(Pz = {}, id.POINTS, "points"), kr(Pz, id.LINES, "lines"), kr(Pz, id.LINE_LOOP, "line loop"), kr(Pz, id.LINE_STRIP, "line strip"), kr(Pz, id.TRIANGLES, "triangles"), kr(Pz, id.TRIANGLE_FAN, "triangle fan"), kr(Pz, id.TRIANGLE_STRIP, "triangle strip"), Pz), Yz = (kr(Lz = {}, id.STATIC_DRAW, "static"), kr(Lz, id.DYNAMIC_DRAW, "dynamic"), kr(Lz, id.STREAM_DRAW, "stream"), Lz), Kz = (kr(Rz = {}, id.BYTE, "int8"), kr(Rz, id.UNSIGNED_INT, "int16"), kr(Rz, id.INT, "int32"), kr(Rz, id.UNSIGNED_BYTE, "uint8"), kr(Rz, id.UNSIGNED_SHORT, "uint16"), kr(Rz, id.UNSIGNED_INT, "uint32"), kr(Rz, id.FLOAT, "float"), Rz), Qz = (kr(Dz = {}, id.ALPHA, "alpha"), kr(Dz, id.LUMINANCE, "luminance"), kr(Dz, id.LUMINANCE_ALPHA, "luminance alpha"), kr(Dz, id.RGB, "rgb"), kr(Dz, id.RGBA, "rgba"), kr(Dz, id.RGBA4, "rgba4"), kr(Dz, id.RGB5_A1, "rgb5 a1"), kr(Dz, id.RGB565, "rgb565"), kr(Dz, id.DEPTH_COMPONENT, "depth"), kr(Dz, id.DEPTH_STENCIL, "depth stencil"), Dz), Jz = (kr(Nz = {}, id.DONT_CARE, "dont care"), kr(Nz, id.NICEST, "nice"), kr(Nz, id.FASTEST, "fast"), Nz), $z = (kr(zz = {}, id.NEAREST, "nearest"), kr(zz, id.LINEAR, "linear"), kr(zz, id.LINEAR_MIPMAP_LINEAR, "mipmap"), kr(zz, id.NEAREST_MIPMAP_LINEAR, "nearest mipmap linear"), kr(zz, id.LINEAR_MIPMAP_NEAREST, "linear mipmap nearest"), kr(zz, id.NEAREST_MIPMAP_NEAREST, "nearest mipmap nearest"), zz), tF = (kr(Fz = {}, id.REPEAT, "repeat"), kr(Fz, id.CLAMP_TO_EDGE, "clamp"), kr(Fz, id.MIRRORED_REPEAT, "mirror"), Fz), eF = (kr(Bz = {}, id.NONE, "none"), kr(Bz, id.BROWSER_DEFAULT_WEBGL, "browser"), Bz), nF = (kr(jz = {}, id.NEVER, "never"), kr(jz, id.ALWAYS, "always"), kr(jz, id.LESS, "less"), kr(jz, id.LEQUAL, "lequal"), kr(jz, id.GREATER, "greater"), kr(jz, id.GEQUAL, "gequal"), kr(jz, id.EQUAL, "equal"), kr(jz, id.NOTEQUAL, "notequal"), jz), rF = (kr(Uz = {}, id.FUNC_ADD, "add"), kr(Uz, id.MIN_EXT, "min"), kr(Uz, id.MAX_EXT, "max"), kr(Uz, id.FUNC_SUBTRACT, "subtract"), kr(Uz, id.FUNC_REVERSE_SUBTRACT, "reverse subtract"), Uz), iF = (kr(Vz = {}, id.ZERO, "zero"), kr(Vz, id.ONE, "one"), kr(Vz, id.SRC_COLOR, "src color"), kr(Vz, id.ONE_MINUS_SRC_COLOR, "one minus src color"), kr(Vz, id.SRC_ALPHA, "src alpha"), kr(Vz, id.ONE_MINUS_SRC_ALPHA, "one minus src alpha"), kr(Vz, id.DST_COLOR, "dst color"), kr(Vz, id.ONE_MINUS_DST_COLOR, "one minus dst color"), kr(Vz, id.DST_ALPHA, "dst alpha"), kr(Vz, id.ONE_MINUS_DST_ALPHA, "one minus dst alpha"), kr(Vz, id.CONSTANT_COLOR, "constant color"), kr(Vz, id.ONE_MINUS_CONSTANT_COLOR, "one minus constant color"), kr(Vz, id.CONSTANT_ALPHA, "constant alpha"), kr(Vz, id.ONE_MINUS_CONSTANT_ALPHA, "one minus constant alpha"), kr(Vz, id.SRC_ALPHA_SATURATE, "src alpha saturate"), Vz), oF = (kr(Gz = {}, id.NEVER, "never"), kr(Gz, id.ALWAYS, "always"), kr(Gz, id.LESS, "less"), kr(Gz, id.LEQUAL, "lequal"), kr(Gz, id.GREATER, "greater"), kr(Gz, id.GEQUAL, "gequal"), kr(Gz, id.EQUAL, "equal"), kr(Gz, id.NOTEQUAL, "notequal"), Gz), aF = (kr(Hz = {}, id.ZERO, "zero"), kr(Hz, id.KEEP, "keep"), kr(Hz, id.REPLACE, "replace"), kr(Hz, id.INVERT, "invert"), kr(Hz, id.INCR, "increment"), kr(Hz, id.DECR, "decrement"), kr(Hz, id.INCR_WRAP, "increment wrap"), kr(Hz, id.DECR_WRAP, "decrement wrap"), Hz), sF = (kr(Wz = {}, id.FRONT, "front"), kr(Wz, id.BACK, "back"), Wz), lF = function () { function t(e, n) { Ar(this, t), kr(this, "buffer", void 0); var r = n.data, i = n.usage, o = n.type; this.buffer = e.buffer({ data: r, usage: Yz[i || id.STATIC_DRAW], type: Kz[o || id.UNSIGNED_BYTE] }) } return Or(t, [{ key: "get", value: function () { return this.buffer } }, { key: "destroy", value: function () { this.buffer.destroy() } }, { key: "subData", value: function (t) { var e = t.data, n = t.offset; this.buffer.subdata(e, n) } }]), t }(), uF = function () { function t(e, n) { Ar(this, t), kr(this, "elements", void 0); var r = n.data, i = n.usage, o = n.type, a = n.count; this.elements = e.elements({ data: r, usage: Yz[i || id.STATIC_DRAW], type: Kz[o || id.UNSIGNED_BYTE], count: a }) } return Or(t, [{ key: "get", value: function () { return this.elements } }, { key: "subData", value: function (t) { var e = t.data; this.elements.subdata(e) } }, { key: "destroy", value: function () { } }]), t }(), cF = function () { function t(e, n) { Ar(this, t), kr(this, "framebuffer", void 0); var r = n.width, i = n.height, o = n.color, a = n.colors; n.depth, n.stencil; var s = { width: r, height: i }; Array.isArray(a) && (s.colors = a.map((function (t) { return t.get() }))), o && "boolean" != typeof o && (s.color = o.get()), this.framebuffer = e.framebuffer(s) } return Or(t, [{ key: "get", value: function () { return this.framebuffer } }, { key: "destroy", value: function () { this.framebuffer.destroy() } }, { key: "resize", value: function (t) { var e = t.width, n = t.height; this.framebuffer.resize(e, n) } }]), t }(); function pF(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function hF(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? pF(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : pF(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var fF, dF = function () { function t(e, n) { Ar(this, t), kr(this, "reGl", void 0), kr(this, "destroyed", !1), kr(this, "drawCommand", void 0), kr(this, "drawPickCommand", void 0), kr(this, "drawParams", void 0), kr(this, "options", void 0), kr(this, "uniforms", {}), this.reGl = e; var r = n.vs, i = n.fs, o = n.attributes, a = n.uniforms, s = n.primitive, l = n.count, u = n.elements, c = n.depth, p = n.blend, h = n.stencil, f = n.cull, d = n.instances, m = {}; this.options = n, a && (this.uniforms = this.extractUniforms(a), Object.keys(a).forEach((function (t) { m[t] = e.prop(t) }))); var v = {}; Object.keys(o).forEach((function (t) { v[t] = o[t].get() })); var y = { attributes: v, frag: i, uniforms: m, vert: r, blend: {}, primitive: Zz[void 0 === s ? id.TRIANGLES : s] }; d && (y.instances = d), l && (y.count = l), u && (y.elements = u.get()), this.initDepthDrawParams({ depth: c }, y), this.initBlendDrawParams({ blend: p }, y), this.initStencilDrawParams({ stencil: h }, y), this.initCullDrawParams({ cull: f }, y), this.drawCommand = e(y); var g = sE(y); g.blend = hF(hF({}, g.blend), {}, { enable: !1 }), this.drawPickCommand = e(g), this.drawParams = y } return Or(t, [{ key: "addUniforms", value: function (t) { this.uniforms = hF(hF({}, this.uniforms), this.extractUniforms(t)) } }, { key: "draw", value: function (t, e) { if (!this.drawParams.attributes || 0 !== Object.keys(this.drawParams.attributes).length) { var n = hF(hF({}, this.uniforms), this.extractUniforms(t.uniforms || {})), r = {}; Object.keys(n).forEach((function (t) { var e = Vr(n[t]); "boolean" === e || "number" === e || Array.isArray(n[t]) || n[t].BYTES_PER_ELEMENT ? r[t] = n[t] : r[t] = n[t].get() })), e ? this.drawPickCommand(r) : this.drawCommand(r) } } }, { key: "destroy", value: function () { this.drawParams.elements.destroy(), this.options.attributes && Object.values(this.options.attributes).forEach((function (t) { t.destroy() })), this.destroyed = !0 } }, { key: "initDepthDrawParams", value: function (t, e) { var n = t.depth; n && (e.depth = { enable: void 0 === n.enable || !!n.enable, mask: void 0 === n.mask || !!n.mask, func: nF[n.func || id.LESS], range: n.range || [0, 1] }) } }, { key: "initBlendDrawParams", value: function (t, e) { var n = t.blend; if (n) { var r = n.enable, i = n.func, o = n.equation, a = n.color, s = void 0 === a ? [0, 0, 0, 0] : a; e.blend = { enable: !!r, func: { srcRGB: iF[i && i.srcRGB || id.SRC_ALPHA], srcAlpha: iF[i && i.srcAlpha || id.SRC_ALPHA], dstRGB: iF[i && i.dstRGB || id.ONE_MINUS_SRC_ALPHA], dstAlpha: iF[i && i.dstAlpha || id.ONE_MINUS_SRC_ALPHA] }, equation: { rgb: rF[o && o.rgb || id.FUNC_ADD], alpha: rF[o && o.alpha || id.FUNC_ADD] }, color: s } } } }, { key: "initStencilDrawParams", value: function (t, e) { var n = t.stencil; if (n) { var r = n.enable, i = n.mask, o = void 0 === i ? -1 : i, a = n.func, s = void 0 === a ? { cmp: id.ALWAYS, ref: 0, mask: -1 } : a, l = n.opFront, u = void 0 === l ? { fail: id.KEEP, zfail: id.KEEP, zpass: id.KEEP } : l, c = n.opBack, p = void 0 === c ? { fail: id.KEEP, zfail: id.KEEP, zpass: id.KEEP } : c; e.stencil = { enable: !!r, mask: o, func: hF(hF({}, s), {}, { cmp: oF[s.cmp] }), opFront: { fail: aF[u.fail], zfail: aF[u.zfail], zpass: aF[u.zpass] }, opBack: { fail: aF[p.fail], zfail: aF[p.zfail], zpass: aF[p.zpass] } } } } }, { key: "initCullDrawParams", value: function (t, e) { var n = t.cull; if (n) { var r = n.enable, i = n.face, o = void 0 === i ? id.BACK : i; e.cull = { enable: !!r, face: sF[o] } } } }, { key: "extractUniforms", value: function (t) { var e = this, n = {}; return Object.keys(t).forEach((function (r) { e.extractUniformsRecursively(r, t[r], n, "") })), n } }, { key: "extractUniformsRecursively", value: function (t, e, n, r) { var i = this; null === e || "number" == typeof e || "boolean" == typeof e || Array.isArray(e) && "number" == typeof e[0] || Up(e) || "" === e || "resize" in e ? n["".concat(r && r + ".").concat(t)] = e : (Op(e) && Object.keys(e).forEach((function (o) { i.extractUniformsRecursively(o, e[o], n, "".concat(r && r + ".").concat(t)) })), Array.isArray(e) && e.forEach((function (e, o) { Object.keys(e).forEach((function (a) { i.extractUniformsRecursively(a, e[a], n, "".concat(r && r + ".").concat(t, "[").concat(o, "]")) })) }))) } }]), t }(), mF = function () { function t(e, n) { Ar(this, t), kr(this, "texture", void 0), kr(this, "width", void 0), kr(this, "height", void 0), kr(this, "isDistroy", !1); var r = n.data, i = n.type, o = void 0 === i ? id.UNSIGNED_BYTE : i, a = n.width, s = n.height, l = n.flipY, u = void 0 !== l && l, c = n.format, p = void 0 === c ? id.RGBA : c, h = n.mipmap, f = void 0 !== h && h, d = n.wrapS, m = void 0 === d ? id.CLAMP_TO_EDGE : d, v = n.wrapT, y = void 0 === v ? id.CLAMP_TO_EDGE : v, g = n.aniso, _ = void 0 === g ? 0 : g, x = n.alignment, b = void 0 === x ? 1 : x, w = n.premultiplyAlpha, S = void 0 !== w && w, E = n.mag, C = void 0 === E ? id.NEAREST : E, T = n.min, A = void 0 === T ? id.NEAREST : T, M = n.colorSpace, O = void 0 === M ? id.BROWSER_DEFAULT_WEBGL : M, k = n.x, I = void 0 === k ? 0 : k, P = n.y, L = void 0 === P ? 0 : P, R = n.copy, D = void 0 !== R && R; this.width = a, this.height = s; var N = { width: a, height: s, type: Kz[o], format: Qz[p], wrapS: tF[m], wrapT: tF[y], mag: $z[C], min: $z[A], alignment: b, flipY: u, colorSpace: eF[O], premultiplyAlpha: S, aniso: _, x: I, y: L, copy: D }; r && (N.data = r), "number" == typeof f ? N.mipmap = Jz[f] : "boolean" == typeof f && (N.mipmap = f), this.texture = e.texture(N) } return Or(t, [{ key: "get", value: function () { return this.texture } }, { key: "update", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.texture(t) } }, { key: "bind", value: function () { this.texture._texture.bind() } }, { key: "resize", value: function (t) { var e = t.width, n = t.height; this.texture.resize(e, n), this.width = e, this.height = n } }, { key: "destroy", value: function () { var t; this.isDistroy || (null === (t = this.texture) || void 0 === t || t.destroy()); this.isDistroy = !0 } }]), t }(), vF = ut.injectable()(fF = function () { function t() { var e = this; Ar(this, t), kr(this, "extensionObject", void 0), kr(this, "gl", void 0), kr(this, "$container", void 0), kr(this, "canvas", void 0), kr(this, "width", void 0), kr(this, "height", void 0), kr(this, "isDirty", void 0), kr(this, "createModel", (function (t) { return new dF(e.gl, t) })), kr(this, "createAttribute", (function (t) { return new qz(e.gl, t) })), kr(this, "createBuffer", (function (t) { return new lF(e.gl, t) })), kr(this, "createElements", (function (t) { return new uF(e.gl, t) })), kr(this, "createTexture2D", (function (t) { return new mF(e.gl, t) })), kr(this, "createFramebuffer", (function (t) { return new cF(e.gl, t) })), kr(this, "useFramebuffer", (function (t, n) { e.gl({ framebuffer: t ? t.get() : null })(n) })), kr(this, "clear", (function (t) { var n = t.color, r = t.depth, i = t.stencil, o = t.framebuffer, a = void 0 === o ? null : o, s = { color: n, depth: r, stencil: i }; s.framebuffer = null === a ? a : a.get(), e.gl.clear(s) })), kr(this, "viewport", (function (t) { var n = t.x, r = t.y, i = t.width, o = t.height; e.gl._gl.viewport(n, r, i, o), e.width = i, e.height = o, e.gl._refresh() })), kr(this, "readPixels", (function (t) { var n = t.framebuffer, r = { x: t.x, y: t.y, width: t.width, height: t.height }; return n && (r.framebuffer = n.get()), e.gl.read(r) })), kr(this, "getViewportSize", (function () { return { width: e.gl._gl.drawingBufferWidth, height: e.gl._gl.drawingBufferHeight } })), kr(this, "getContainer", (function () { return ro ? e.canvas : null === (t = e.canvas) || void 0 === t ? void 0 : t.parentElement; var t })), kr(this, "getCanvas", (function () { return e.canvas })), kr(this, "getGLContext", (function () { return e.gl._gl })), kr(this, "destroy", (function () { e.canvas = null, e.gl.destroy(), e.gl = null })) } var e; return Or(t, [{ key: "init", value: (e = nd(gd.mark((function t(e, n) { var r = this; return gd.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return this.canvas = e, t.next = 3, new Promise((function (t, e) { Xz({ canvas: r.canvas, attributes: { alpha: !0, antialias: n.antialias, premultipliedAlpha: !0, preserveDrawingBuffer: n.preserveDrawingBuffer, stencil: n.stencil }, extensions: ["OES_element_index_uint", "OES_standard_derivatives", "ANGLE_instanced_arrays"], optionalExtensions: ["oes_texture_float_linear", "OES_texture_float", "EXT_texture_filter_anisotropic", "EXT_blend_minmax", "WEBGL_depth_texture"], profile: !0, onDone: function (n, r) { !n && r || e(n), t(r) } }) })); case 3: this.gl = t.sent, this.extensionObject = { OES_texture_float: this.testExtension("OES_texture_float") }; case 5: case "end": return t.stop() } }), t, this) }))), function (t, n) { return e.apply(this, arguments) }) }, { key: "getPointSizeRange", value: function () { return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE) } }, { key: "testExtension", value: function (t) { return !!this.getGLContext().getExtension(t) } }, { key: "setState", value: function () { this.gl({ cull: { enable: !1, face: "back" }, viewport: { x: 0, y: 0, height: this.width, width: this.height }, blend: { enable: !0, equation: "add" }, framebuffer: null }), this.gl._refresh() } }, { key: "setBaseState", value: function () { this.gl({ cull: { enable: !1, face: "back" }, viewport: { x: 0, y: 0, height: this.width, width: this.height }, blend: { enable: !1, equation: "add" }, framebuffer: null }), this.gl._refresh() } }, { key: "setCustomLayerDefaults", value: function () { var t = this.getGLContext(); t.disable(t.CULL_FACE) } }, { key: "setDirty", value: function (t) { this.isDirty = t } }, { key: "getDirty", value: function () { return this.isDirty } }]), t }()) || fF; function yF(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, r) } return n } function gF(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? yF(Object(n), !0).forEach((function (e) { kr(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : yF(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } var _F, xF, bF, wF, SF = function () { function t(e) { Ar(this, t), kr(this, "sceneService", void 0), kr(this, "mapService", void 0), kr(this, "controlService", void 0), kr(this, "layerService", void 0), kr(this, "iconService", void 0), kr(this, "markerService", void 0), kr(this, "popupService", void 0), kr(this, "fontService", void 0), kr(this, "interactionService", void 0), kr(this, "container", void 0); var n = e.id, r = e.map, i = e.canvas, o = e.hasBaseMap, a = function () { var t = new ut.Container; return t.parent = yx, t.bind(Tr.SceneID).toConstantValue("".concat(Cx++)), t.bind(Tr.IShaderModuleService).to(ey).inSingletonScope(), t.bind(Tr.ILayerService).to(Nd).inSingletonScope(), t.bind(Tr.ISceneService).to(mv).inSingletonScope(), t.bind(Tr.ICameraService).to(fl).inSingletonScope(), t.bind(Tr.ICoordinateSystemService).to(Gf).inSingletonScope(), t.bind(Tr.IInteractionService).to(td).inSingletonScope(), t.bind(Tr.IPickingService).to(Pd).inSingletonScope(), t.bind(Tr.IControlService).to(gl).inSingletonScope(), t.bind(Tr.IMarkerService).to(_l).inSingletonScope(), t.bind(Tr.IIconService).to(es).inSingletonScope(), t.bind(Tr.IFontService).to($a).inSingletonScope(), t.bind(Tr.IPopupService).to(xl).inSingletonScope(), t.bind(Tr.INormalPass).to(hy).whenTargetNamed("clear"), t.bind(Tr.INormalPass).to(by).whenTargetNamed("pixelPicking"), t.bind(Tr.INormalPass).to(ux).whenTargetNamed("render"), t.bind(Tr.INormalPass).to(vx).whenTargetNamed("taa"), t.bind(Tr.IFactoryNormalPass).toFactory((function (t) { return function (e) { return t.container.getNamed(Tr.INormalPass, e) } })), t.bind(Tr.IPostProcessingPass).to(L_).whenTargetNamed("copy"), t.bind(Tr.IPostProcessingPass).to(m_).whenTargetNamed("bloom"), t.bind(Tr.IPostProcessingPass).to(x_).whenTargetNamed("blurH"), t.bind(Tr.IPostProcessingPass).to(C_).whenTargetNamed("blurV"), t.bind(Tr.IPostProcessingPass).to(X_).whenTargetNamed("noise"), t.bind(Tr.IPostProcessingPass).to(ex).whenTargetNamed("sepia"), t.bind(Tr.IPostProcessingPass).to(k_).whenTargetNamed("colorHalftone"), t.bind(Tr.IPostProcessingPass).to(F_).whenTargetNamed("hexagonalPixelate"), t.bind(Tr.IPostProcessingPass).to(G_).whenTargetNamed("ink"), t.bind(Tr.IFactoryPostProcessingPass).toFactory((function (t) { return function (e) { var n = t.container.getNamed(Tr.IPostProcessingPass, e); return n.setName(e), n } })), t }(); this.container = a, r.setContainer(a, n, i, o), a.bind(Tr.IRendererService).to(vF).inSingletonScope(), this.sceneService = a.get(Tr.ISceneService), this.mapService = a.get(Tr.IMapService), this.iconService = a.get(Tr.IIconService), this.fontService = a.get(Tr.IFontService), this.controlService = a.get(Tr.IControlService), this.layerService = a.get(Tr.ILayerService), this.markerService = a.get(Tr.IMarkerService), this.interactionService = a.get(Tr.IInteractionService), this.popupService = a.get(Tr.IPopupService), ro ? this.sceneService.initMiniScene(e) : (this.initComponent(n), this.sceneService.init(e), this.initControl()) } return Or(t, [{ key: "map", get: function () { return this.mapService.map } }, { key: "loaded", get: function () { return this.sceneService.loaded } }, { key: "getServiceContainer", value: function () { return this.container } }, { key: "getSize", value: function () { return this.mapService.getSize() } }, { key: "getMinZoom", value: function () { return this.mapService.getMinZoom() } }, { key: "getMaxZoom", value: function () { return this.mapService.getMaxZoom() } }, { key: "getType", value: function () { return this.mapService.getType() } }, { key: "getMapContainer", value: function () { return this.mapService.getMapContainer() } }, { key: "getMapCanvasContainer", value: function () { return this.mapService.getMapCanvasContainer() } }, { key: "getMapService", value: function () { return this.mapService } }, { key: "exportPng", value: function (t) { return this.sceneService.exportPng(t) } }, { key: "exportMap", value: function (t) { return this.sceneService.exportPng(t) } }, { key: "registerRenderService", value: function (t) { var e = this; this.sceneService.loaded ? new t(this).init() : this.on("loaded", (function () { new t(e).init() })) } }, { key: "setBgColor", value: function (t) { this.mapService.setBgColor(t) } }, { key: "addLayer", value: function (t) { var e = Tx(this.container); t.setContainer(e, this.container), this.sceneService.addLayer(t); var n = t.getLayerConfig(); n.maskColor, n.maskOpacity } }, { key: "addMask", value: function (t, e) { var n = this.getLayer(e); if (n) { var r = Tx(this.container); t.setContainer(r, this.container), n.addMaskLayer(t), this.sceneService.addLayer(t) } else console.warn("parent layer not find!") } }, { key: "getLayers", value: function () { return this.layerService.getLayers() } }, { key: "getLayer", value: function (t) { return this.layerService.getLayer(t) } }, { key: "getLayerByName", value: function (t) { return this.layerService.getLayerByName(t) } }, { key: "removeLayer", value: function (t, e) { this.layerService.remove(t, e) } }, { key: "removeAllLayer", value: function () { this.layerService.removeAllLayers() } }, { key: "render", value: function () { this.sceneService.render() } }, { key: "setEnableRender", value: function (t) { this.layerService.setEnableRender(t) } }, { key: "addIconFont", value: function (t, e) { this.fontService.addIconFont(t, e) } }, { key: "addIconFonts", value: function (t) { var e = this; t.forEach((function (t) { var n = Lr(t, 2), r = n[0], i = n[1]; e.fontService.addIconFont(r, i) })) } }, { key: "addFontFace", value: function (t, e) { this.sceneService.addFontFace(t, e) } }, { key: "addImage", value: function (t, e) { ro ? this.iconService.addImageMini(t, e, this.sceneService) : this.iconService.addImage(t, e) } }, { key: "hasImage", value: function (t) { return this.iconService.hasImage(t) } }, { key: "removeImage", value: function (t) { this.iconService.removeImage(t) } }, { key: "addIconFontGlyphs", value: function (t, e) { this.fontService.addIconGlyphs(e) } }, { key: "addControl", value: function (t) { this.controlService.addControl(t, this.container) } }, { key: "removeControl", value: function (t) { this.controlService.removeControl(t) } }, { key: "getControlByName", value: function (t) { return this.controlService.getControlByName(t) } }, { key: "addMarker", value: function (t) { this.markerService.addMarker(t) } }, { key: "addMarkerLayer", value: function (t) { this.markerService.addMarkerLayer(t) } }, { key: "removeMarkerLayer", value: function (t) { this.markerService.removeMarkerLayer(t) } }, { key: "removeAllMakers", value: function () { this.markerService.removeAllMarkers() } }, { key: "addPopup", value: function (t) { this.popupService.addPopup(t) } }, { key: "on", value: function (t, e) { -1 === Nx.indexOf(t) ? this.mapService.on(t, e) : this.sceneService.on(t, e) } }, { key: "once", value: function (t, e) { -1 === Nx.indexOf(t) ? this.mapService.once(t, e) : this.sceneService.once(t, e) } }, { key: "off", value: function (t, e) { -1 === Nx.indexOf(t) ? this.mapService.off(t, e) : this.sceneService.off(t, e) } }, { key: "getZoom", value: function () { return this.mapService.getZoom() } }, { key: "getCenter", value: function (t) { return this.mapService.getCenter(t) } }, { key: "setCenter", value: function (t, e) { return this.mapService.setCenter(t, e) } }, { key: "getPitch", value: function () { return this.mapService.getPitch() } }, { key: "setPitch", value: function (t) { return this.mapService.setPitch(t) } }, { key: "getRotation", value: function () { return this.mapService.getRotation() } }, { key: "getBounds", value: function () { return this.mapService.getBounds() } }, { key: "setRotation", value: function (t) { this.mapService.setRotation(t) } }, { key: "zoomIn", value: function () { this.mapService.zoomIn() } }, { key: "zoomOut", value: function () { this.mapService.zoomOut() } }, { key: "panTo", value: function (t) { this.mapService.panTo(t) } }, { key: "panBy", value: function (t, e) { this.mapService.panBy(t, e) } }, { key: "getContainer", value: function () { return this.mapService.getContainer() } }, { key: "setZoom", value: function (t) { this.mapService.setZoom(t) } }, { key: "fitBounds", value: function (t, e) { var n = this.sceneService.getSceneConfig(), r = n.fitBoundsOptions, i = n.animate; this.mapService.fitBounds(t, e || gF(gF({}, r), {}, { animate: i })) } }, { key: "setZoomAndCenter", value: function (t, e) { this.mapService.setZoomAndCenter(t, e) } }, { key: "setMapStyle", value: function (t) { this.mapService.setMapStyle(t) } }, { key: "setMapStatus", value: function (t) { this.mapService.setMapStatus(t) } }, { key: "pixelToLngLat", value: function (t) { return this.mapService.pixelToLngLat(t) } }, { key: "lngLatToPixel", value: function (t) { return this.mapService.lngLatToPixel(t) } }, { key: "containerToLngLat", value: function (t) { return this.mapService.containerToLngLat(t) } }, { key: "lngLatToContainer", value: function (t) { return this.mapService.lngLatToContainer(t) } }, { key: "destroy", value: function () { this.sceneService.destroy() } }, { key: "registerPostProcessingPass", value: function (t, e) { this.container.bind(Tr.IPostProcessingPass).to(t).whenTargetNamed(e) } }, { key: "enableShaderPick", value: function () { this.layerService.enableShaderPick() } }, { key: "diasbleShaderPick", value: function () { this.layerService.disableShaderPick() } }, { key: "getPointSizeRange", value: function () { return this.sceneService.getPointSizeRange() } }, { key: "initComponent", value: function (t) { var e, n; this.controlService.init({ container: (e = t, n = e, "string" == typeof e && (n = oo.document.getElementById(e)), n) }, this.container), this.markerService.init(this.container), this.popupService.init(this.container) } }, { key: "initControl", value: function () { var t = this.sceneService.getSceneConfig(), e = t.logoVisible, n = t.logoPosition; e && this.addControl(new Wx({ position: n })) } }]), t }(); t.LineStyleType = void 0, (_F = t.LineStyleType || (t.LineStyleType = {}))[_F.solid = 0] = "solid", _F[_F.dash = 1] = "dash", t.LayerType = void 0, (xF = t.LayerType || (t.LayerType = {})).TextLayer = "textLayer", xF.DotLayer = "dotLayer", xF.IconLayer = "iconLayer", xF.DotDensity = "dotDensityLayer", xF.ColumnLayer = "columnLayer", xF.HeatmapLayer = "heatmapLayer", xF.GridLayer = "gridLayer", xF.HexbinLayer = "hexbinLayer", xF.LinesLayer = "linesLayer", xF.PathLayer = "pathLayer", xF.ArcLayer = "arcLayer", xF.AreaLayer = "areaLayer", xF.PrismLayer = "prismLayer", t.BaseMapType = void 0, (bF = t.BaseMapType || (t.BaseMapType = {})).Amap = "amap", bF.Mapbox = "mapbox", t.PlotType = void 0, (wF = t.PlotType || (t.PlotType = {})).Dot = "dot", wF.DotDensity = "dotDensity", wF.Heatmap = "heatmap", wF.Grid = "grid", wF.Hexbin = "hexbin", wF.Path = "path", wF.Flow = "flow", wF.Area = "area", wF.Choropleth = "choropleth"; var EF, CF, TF, AF, MF = function () { function t() { this._events = {} } return t.prototype.on = function (t, e, n) { return this._events[t] || (this._events[t] = []), this._events[t].push({ callback: e, once: !!n }), this }, t.prototype.once = function (t, e) { return this.on(t, e, !0), this }, t.prototype.emit = function (t) { for (var e = this, n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; var i = this._events[t] || [], o = this._events["*"] || [], a = function (r) { for (var i = r.length, o = 0; o < i; o++)if (r[o]) { var a = r[o], s = a.callback; a.once && (r.splice(o, 1), 0 === r.length && delete e._events[t], i--, o--), s.apply(e, n) } }; a(i), a(o) }, t.prototype.off = function (t, e) { if (t) if (e) { for (var n = this._events[t] || [], r = n.length, i = 0; i < r; i++)n[i].callback === e && (n.splice(i, 1), r--, i--); 0 === n.length && delete this._events[t] } else delete this._events[t]; else this._events = {}; return this }, t.prototype.getEvents = function () { return this._events }, t }(); function OF(t) { EF || (EF = document.createElement("table"), CF = document.createElement("tr"), TF = /^\s*<(\w+|!)[^>]*>/, AF = { tr: document.createElement("tbody"), tbody: EF, thead: EF, tfoot: EF, td: CF, th: CF, "*": document.createElement("div") }); var e = TF.test(t) && RegExp.$1; e && e in AF || (e = "*"); var n = AF[e]; t = t.replace(/(^\s*)|(\s*$)/g, ""), n.innerHTML = "" + t; var r = n.childNodes[0]; return n.removeChild(r), r } function kF(t, e) { if (t) for (var n in e) e.hasOwnProperty(n) && (t.style[n] = e[n]); return t } var IF, PF = '\n  "-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"', LF = "l7plot-tooltip", RF = "l7plot-tooltip__title", DF = "l7plot-tooltip__list", NF = "l7plot-tooltip__list-item", zF = "l7plot-tooltip__name", FF = "l7plot-tooltip__value", BF = '<div class="'.concat(LF, '">\n  <div class="').concat(RF, '"></div>\n  <ul class="').concat(DF, '"></ul>\n</div>'), jF = '<li class="'.concat(NF, '" data-index={index}>\n  <span class="').concat(zF, '">{name}</span>\n  <span class="').concat(FF, '">{value}</span>\n</li>'), UF = ((IF = {})["l7plot-tooltip"] = { visibility: "visible", zIndex: 999, transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)", backgroundColor: "rgba(255, 255, 255, 0.9)", boxShadow: "rgb(0 0 0 / 16%) 0px 6px 12px 0px", borderRadius: "2px", color: "rgb(87, 87, 87)", fontSize: "12px", fontFamily: PF, lineHeight: "20px", padding: "10px 10px 6px 10px" }, IF[RF] = { marginBottom: "4px" }, IF[DF] = { margin: "0px", listStyleType: "none", padding: "0px" }, IF[NF] = { listStyleType: "none", marginBottom: "4px", whiteSpace: "nowrap", display: "flex", justifyContent: "space-between" }, IF[zF] = {}, IF[FF] = { marginLeft: "30px" }, IF); function VF(t) { for (var e = t.childNodes, n = e.length - 1; n >= 0; n--)t.removeChild(e[n]) } var GF, HF, WF = function () { function t(t) { this.destroyed = !1, this.options = b({}, this.getDefaultOptions(), t), this.container = this.initContainer(), this.initDom(), this.applyStyles(), this.initEvent(), this.initCapture(), this.initVisible(), this.render() } return t.prototype.getDefaultOptions = function () { return { name: "", containerTpl: "<div></div>", visible: !0, capture: !0, domStyles: {} } }, t.prototype.getContainer = function () { return this.container }, t.prototype.getParentContainer = function () { var t, e = this.options.parent; if (!e) return t; if (f(e)) { var n = document.getElementById(e); if (!n) throw new Error("No parent id ".concat(e)); t = n } else t = e; return t }, t.prototype.initContainer = function () { var t = this.createDom(this.options.containerTpl), e = this.getParentContainer(); return e && e.appendChild(t), t }, t.prototype.initVisible = function () { this.options.visible ? this.show() : this.hide() }, t.prototype.initCapture = function () { this.setCapture(this.options.capture) }, t.prototype.update = function (t) { this.options = b({}, this.options, t), this.updateInner(t), this.afterUpdate(t) }, t.prototype.updateInner = function (t) { t.domStyles && this.applyStyles() }, t.prototype.afterUpdate = function (t) { t.capture && this.setCapture(t.capture) }, t.prototype.setCapture = function (t) { var e = t ? "auto" : "none"; this.container.style.pointerEvents = e }, t.prototype.applyStyles = function () { var t = this.options.domStyles; if (t) { var e = this.container; this.applyChildrenStyles(e, t); var n, r = this.options.className; if (r && (n = r, e.className.match(new RegExp("(\\s|^)".concat(n, "(\\s|$)"))))) kF(e, t[r]) } }, t.prototype.applyChildrenStyles = function (t, e) { c(e, (function (e, n) { c(t.getElementsByClassName(n), (function (t) { kF(t, e) })) })) }, t.prototype.applyStyle = function (t, e) { var n = this.options.domStyles; n && kF(e, n[t]) }, t.prototype.createDom = function (t) { return void 0 === t && (t = "<div></div>"), OF(t) }, t.prototype.removeDom = function () { var t = this.container; t && t.parentNode && t.parentNode.removeChild(t) }, t.prototype.destroy = function () { this.removeEvent(), this.removeDom(), this.destroyed = !0 }, t }(), XF = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return M(e, t), e.prototype.getDefaultOptions = function () { return b({}, t.prototype.getDefaultOptions.call(this), { id: "l7plot-tooltip", name: "l7plot-tooltip", title: "", showTitle: !0, items: [], containerTpl: BF, itemTpl: jF, domStyles: UF, className: LF }) }, e.prototype.initContainer = function () { var e = this.options.customContent; if (e) { var n = this.getHtmlContentNode(e), r = this.getParentContainer(); return r && r.appendChild(n), n } return t.prototype.initContainer.call(this) }, e.prototype.initDom = function () { this.cacheDoms() }, e.prototype.initEvent = function () { }, e.prototype.removeEvent = function () { }, e.prototype.cacheDoms = function () { var t = this.container, e = t.getElementsByClassName(RF)[0], n = t.getElementsByClassName(DF)[0]; this.titleDom = e, this.listDom = n }, e.prototype.render = function () { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (this.resetTitle(), this.renderItems()) }, e.prototype.show = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "visible" }) }, e.prototype.hide = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "hidden" }) }, e.prototype.updateInner = function (e) { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (e.title && this.resetTitle(), e.items && this.renderItems()), t.prototype.updateInner.call(this, e) }, e.prototype.renderCustomContent = function (t) { var e = this.container.parentNode, n = this.getHtmlContentNode(t), r = this.container; e && e.replaceChild(n, r), this.container = n, this.applyStyles() }, e.prototype.getHtmlContentNode = function (t) { var e = t(this.options.title || "", this.options.items); return f(e) ? this.createDom(e) : e }, e.prototype.resetTitle = function () { var t = this.options.title; this.options.showTitle && t ? (this.showTitle(), this.setTitle(t)) : this.hideTitle() }, e.prototype.showTitle = function () { var t = this.titleDom; t && kF(t, { display: "block" }) }, e.prototype.hideTitle = function () { var t = this.titleDom; t && kF(t, { display: "none" }) }, e.prototype.setTitle = function (t) { var e = this.titleDom; e && (e.innerHTML = t) }, e.prototype.renderItems = function () { var t = this; this.clearItemDoms(); var e = this.options.items, n = this.options.itemTpl || jF, r = this.listDom; r && (e.forEach((function (e) { var i = k({}, e), o = v(n, i), a = t.createDom(o); r.appendChild(a) })), this.applyChildrenStyles(r, this.options.domStyles)) }, e.prototype.clearItemDoms = function () { this.listDom && VF(this.listDom) }, e.prototype.clear = function () { this.setTitle(""), this.clearItemDoms() }, e }(WF), qF = "l7plot-legend l7plot-legend__category", ZF = "l7plot-legend__title", YF = "l7plot-legend__category-list", KF = "l7plot-legend__list-item", QF = "l7plot-legend__category-marker", JF = "l7plot-legend__category-value", $F = '<div class="'.concat(qF, '">\n  <div class="').concat(ZF, '"></div>\n  <ul class="').concat(YF, '"></ul>\n</div>'), tB = '<li class="'.concat(KF, '" data-index={index}>\n  <span class="').concat(QF, '" style="background:{color}"></span>\n  <span class="').concat(JF, '">{value}</span>\n</li>'), eB = ((GF = {})[qF] = { visibility: "visible", zIndex: 1, backgroundColor: "rgba(255, 255, 255, 0.9)", boxShadow: "rgb(0 0 0 / 16%) 0px 6px 12px 0px", borderRadius: "2px", color: "rgb(87, 87, 87)", fontFamily: PF, padding: "10px 10px 6px 10px", lineHeight: 1, fontSize: "12px" }, GF[ZF] = { fontSize: "13px", lineHeight: "19px", marginBottom: "8px" }, GF[YF] = { margin: "0px", listStyleType: "none", padding: "0px" }, GF[KF] = { listStyleType: "none", display: "flex", alignItems: "center", marginBottom: "2px" }, GF[QF] = { width: "10px", height: "10px" }, GF[JF] = { paddingLeft: "8px" }, GF), nB = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return M(e, t), e.prototype.getDefaultOptions = function () { return b({}, t.prototype.getDefaultOptions.call(this), { id: "l7plot-category-legend", name: "l7plot-category-legend", title: "", items: [], containerTpl: $F, itemTpl: tB, domStyles: eB, className: qF }) }, e.prototype.initContainer = function () { var e = this.options.customContent; if (e) { var n = this.getHtmlContentNode(e), r = this.getParentContainer(); return r && r.appendChild(n), n } return t.prototype.initContainer.call(this) }, e.prototype.initDom = function () { this.cacheDoms() }, e.prototype.initEvent = function () { }, e.prototype.removeEvent = function () { }, e.prototype.cacheDoms = function () { var t = this.container, e = t.getElementsByClassName(ZF)[0], n = t.getElementsByClassName(YF)[0]; this.titleDom = e, this.listDom = n }, e.prototype.render = function () { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (this.resetTitle(), this.renderItems()) }, e.prototype.show = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "visible" }) }, e.prototype.hide = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "hidden" }) }, e.prototype.updateInner = function (e) { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (e.title && this.resetTitle(), e.items && this.renderItems()), t.prototype.updateInner.call(this, e) }, e.prototype.renderCustomContent = function (t) { var e = this.container.parentNode, n = this.getHtmlContentNode(t), r = this.container; e && e.replaceChild(n, r), this.container = n, this.applyStyles() }, e.prototype.getHtmlContentNode = function (t) { var e = t(this.options.title || "", this.options.items); return f(e) ? this.createDom(e) : e }, e.prototype.resetTitle = function () { var t = this.options.title; t ? (this.showTitle(), this.setTitle(t)) : this.hideTitle() }, e.prototype.showTitle = function () { var t = this.titleDom; t && kF(t, { display: "block" }) }, e.prototype.hideTitle = function () { var t = this.titleDom; t && kF(t, { display: "none" }) }, e.prototype.setTitle = function (t) { var e = this.titleDom; e && (e.innerHTML = t) }, e.prototype.renderItems = function () { var t = this; this.clearItemDoms(); var e = this.options.items.length > 30 ? this.options.items.slice(0, 30) : this.options.items, n = this.options.itemTpl || tB, r = this.listDom; r && (e.forEach((function (e) { var i = "" === e.value ? "—" : Array.isArray(e.value) ? e.value.join(" - ") : e.value, o = k(k({}, e), { value: i }), a = v(n, o), s = t.createDom(a); r.appendChild(s) })), this.applyChildrenStyles(r, this.options.domStyles)) }, e.prototype.clearItemDoms = function () { this.listDom && VF(this.listDom) }, e.prototype.clear = function () { this.setTitle(""), this.clearItemDoms() }, e }(WF), rB = "l7plot-legend l7plot-legend__continue", iB = "l7plot-legend__title", oB = "l7plot-legend__ribbon-container", aB = "l7plot-legend__ribbon", sB = "l7plot-legend__gradient-bar", lB = "l7plot-legend__value-range", uB = '<div class="'.concat(rB, '">\n  <div class="').concat(iB, '"></div>\n  <div class="').concat(oB, '"></div>\n</div>'), cB = '<div class="'.concat(aB, '">\n  <span class="').concat(lB, '">{min}</span>\n  <div class="').concat(sB, '" style="background-image: {backgroundImage}"></div>\n  <span class="').concat(lB, '">{max}</span>\n</div>'), pB = ((HF = {})[rB] = { visibility: "visible", zIndex: 1, backgroundColor: "rgba(255, 255, 255, 0.9)", boxShadow: "rgb(0 0 0 / 16%) 0px 6px 12px 0px", borderRadius: "2px", color: "rgb(87, 87, 87)", fontFamily: PF, padding: "10px", lineHeight: 1, fontSize: "12px" }, HF[iB] = { fontSize: "13px", lineHeight: "19px", marginBottom: "8px" }, HF[aB] = { display: "flex", alignItems: "center" }, HF[sB] = { width: "140px", height: "14px", margin: "0px 5px" }, HF[lB] = { padding: "0px" }, HF), hB = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return M(e, t), e.prototype.getDefaultOptions = function () { return b({}, t.prototype.getDefaultOptions.call(this), { id: "l7plot-continue-legend", name: "l7plot-continue-legend", title: "", containerTpl: uB, ribbonTpl: cB, domStyles: pB, className: rB }) }, e.prototype.initContainer = function () { var e = this.options.customContent; if (e) { var n = this.getHtmlContentNode(e), r = this.getParentContainer(); return r && r.appendChild(n), n } return t.prototype.initContainer.call(this) }, e.prototype.initDom = function () { this.cacheDoms() }, e.prototype.initEvent = function () { }, e.prototype.removeEvent = function () { }, e.prototype.cacheDoms = function () { var t = this.container, e = t.getElementsByClassName(iB)[0], n = t.getElementsByClassName(oB)[0]; this.titleDom = e, this.ribbonContainerDom = n }, e.prototype.render = function () { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (this.resetTitle(), this.renderRibbon()) }, e.prototype.show = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "visible" }) }, e.prototype.hide = function () { var t = this.container; t && !this.destroyed && kF(t, { visibility: "hidden" }) }, e.prototype.updateInner = function (e) { this.options.customContent ? this.renderCustomContent(this.options.customContent) : (e.title && this.resetTitle(), e.colors && this.renderRibbon()), t.prototype.updateInner.call(this, e) }, e.prototype.renderCustomContent = function (t) { var e = this.container.parentNode, n = this.getHtmlContentNode(t), r = this.container; e && e.replaceChild(n, r), this.container = n, this.applyStyles() }, e.prototype.getHtmlContentNode = function (t) { var e = t(this.options.title || "", this.options.min, this.options.max, this.options.colors); return f(e) ? this.createDom(e) : e }, e.prototype.resetTitle = function () { var t = this.options.title; t ? (this.showTitle(), this.setTitle(t)) : this.hideTitle() }, e.prototype.showTitle = function () { var t = this.titleDom; t && kF(t, { display: "block" }) }, e.prototype.hideTitle = function () { var t = this.titleDom; t && kF(t, { display: "none" }) }, e.prototype.setTitle = function (t) { var e = this.titleDom; e && (e.innerHTML = t) }, e.prototype.renderRibbon = function () { this.clearRibbonContainerDoms(); var t = this.options, e = t.min, n = t.max, r = t.colors, i = t.ribbonTpl, o = void 0 === i ? cB : i, a = this.ribbonContainerDom; if (a) { var s = v(o, { min: e, max: n, backgroundImage: "linear-gradient(to right, ".concat(r.join(", "), ")") }), l = this.createDom(s); a.appendChild(l), this.applyChildrenStyles(a, this.options.domStyles) } }, e.prototype.clearRibbonContainerDoms = function () { this.ribbonContainerDom && VF(this.ribbonContainerDom) }, e.prototype.clear = function () { this.setTitle(""), this.clearRibbonContainerDoms() }, e }(WF), fB = "object" == typeof global && global && global.Object === Object && global, dB = "object" == typeof self && self && self.Object === Object && self, mB = fB || dB || Function("return this")(), vB = mB.Symbol, yB = Object.prototype, gB = yB.hasOwnProperty, _B = yB.toString, xB = vB ? vB.toStringTag : void 0; var bB = Object.prototype.toString; var wB = vB ? vB.toStringTag : void 0; function SB(t) { return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : wB && wB in Object(t) ? function (t) { var e = gB.call(t, xB), n = t[xB]; try { t[xB] = void 0; var r = !0 } catch (t) { } var i = _B.call(t); return r && (e ? t[xB] = n : delete t[xB]), i }(t) : function (t) { return bB.call(t) }(t) } function EB(t) { return "symbol" == typeof t || function (t) { return null != t && "object" == typeof t }(t) && "[object Symbol]" == SB(t) } var CB = Array.isArray, TB = vB ? vB.prototype : void 0, AB = TB ? TB.toString : void 0; function MB(t) { if ("string" == typeof t) return t; if (CB(t)) return function (t, e) { for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;)i[n] = e(t[n], n, t); return i }(t, MB) + ""; if (EB(t)) return AB ? AB.call(t) : ""; var e = t + ""; return "0" == e && 1 / t == -Infinity ? "-0" : e } var OB = /\s/; var kB = /^\s+/; function IB(t) { return t ? t.slice(0, function (t) { for (var e = t.length; e-- && OB.test(t.charAt(e));); return e }(t) + 1).replace(kB, "") : t } function PB(t) { var e = typeof t; return null != t && ("object" == e || "function" == e) } var LB = /^[-+]0x[0-9a-f]+$/i, RB = /^0b[01]+$/i, DB = /^0o[0-7]+$/i, NB = parseInt; function zB(t) { if ("number" == typeof t) return t; if (EB(t)) return NaN; if (PB(t)) { var e = "function" == typeof t.valueOf ? t.valueOf() : t; t = PB(e) ? e + "" : e } if ("string" != typeof t) return 0 === t ? t : +t; t = IB(t); var n = RB.test(t); return n || DB.test(t) ? NB(t.slice(2), n ? 2 : 8) : LB.test(t) ? NaN : +t } var FB = 1 / 0; function BB(t) { var e = function (t) { return t ? (t = zB(t)) === FB || t === -1 / 0 ? 17976931348623157e292 * (t < 0 ? -1 : 1) : t == t ? t : 0 : 0 === t ? t : 0 }(t), n = e % 1; return e == e ? n ? e - n : e : 0 } var jB = mB["__core-js_shared__"], UB = function () { var t = /[^.]+$/.exec(jB && jB.keys && jB.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(); var VB = Function.prototype.toString; var GB = /^\[object .+?Constructor\]$/, HB = Function.prototype, WB = Object.prototype, XB = HB.toString, qB = WB.hasOwnProperty, ZB = RegExp("^" + XB.call(qB).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function YB(t) { if (!PB(t) || (e = t, UB && UB in e)) return !1; var e, n = function (t) { if (!PB(t)) return !1; var e = SB(t); return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e }(t) ? ZB : GB; return n.test(function (t) { if (null != t) { try { return VB.call(t) } catch (t) { } try { return t + "" } catch (t) { } } return "" }(t)) } function KB(t, e) { var n = function (t, e) { return null == t ? void 0 : t[e] }(t, e); return YB(n) ? n : void 0 } var QB = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, JB = /^\w*$/; var $B = KB(Object, "create"); var tj = Object.prototype.hasOwnProperty; var ej = Object.prototype.hasOwnProperty; function nj(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } function rj(t, e) { for (var n, r, i = t.length; i--;)if ((n = t[i][0]) === (r = e) || n != n && r != r) return i; return -1 } nj.prototype.clear = function () { this.__data__ = $B ? $B(null) : {}, this.size = 0 }, nj.prototype.delete = function (t) { var e = this.has(t) && delete this.__data__[t]; return this.size -= e ? 1 : 0, e }, nj.prototype.get = function (t) { var e = this.__data__; if ($B) { var n = e[t]; return "__lodash_hash_undefined__" === n ? void 0 : n } return tj.call(e, t) ? e[t] : void 0 }, nj.prototype.has = function (t) { var e = this.__data__; return $B ? void 0 !== e[t] : ej.call(e, t) }, nj.prototype.set = function (t, e) { var n = this.__data__; return this.size += this.has(t) ? 0 : 1, n[t] = $B && void 0 === e ? "__lodash_hash_undefined__" : e, this }; var ij = Array.prototype.splice; function oj(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } oj.prototype.clear = function () { this.__data__ = [], this.size = 0 }, oj.prototype.delete = function (t) { var e = this.__data__, n = rj(e, t); return !(n < 0) && (n == e.length - 1 ? e.pop() : ij.call(e, n, 1), --this.size, !0) }, oj.prototype.get = function (t) { var e = this.__data__, n = rj(e, t); return n < 0 ? void 0 : e[n][1] }, oj.prototype.has = function (t) { return rj(this.__data__, t) > -1 }, oj.prototype.set = function (t, e) { var n = this.__data__, r = rj(n, t); return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this }; var aj = KB(mB, "Map"); function sj(t, e) { var n, r, i = t.__data__; return ("string" == (r = typeof (n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map } function lj(t) { var e = -1, n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } lj.prototype.clear = function () { this.size = 0, this.__data__ = { hash: new nj, map: new (aj || oj), string: new nj } }, lj.prototype.delete = function (t) { var e = sj(this, t).delete(t); return this.size -= e ? 1 : 0, e }, lj.prototype.get = function (t) { return sj(this, t).get(t) }, lj.prototype.has = function (t) { return sj(this, t).has(t) }, lj.prototype.set = function (t, e) { var n = sj(this, t), r = n.size; return n.set(t, e), this.size += n.size == r ? 0 : 1, this }; function uj(t, e) { if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError("Expected a function"); var n = function () { var r = arguments, i = e ? e.apply(this, r) : r[0], o = n.cache; if (o.has(i)) return o.get(i); var a = t.apply(this, r); return n.cache = o.set(i, a) || o, a }; return n.cache = new (uj.Cache || lj), n } uj.Cache = lj; var cj, pj, hj, fj = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, dj = /\\(\\)?/g, mj = (cj = function (t) { var e = []; return 46 === t.charCodeAt(0) && e.push(""), t.replace(fj, (function (t, n, r, i) { e.push(r ? i.replace(dj, "$1") : n || t) })), e }, pj = uj(cj, (function (t) { return 500 === hj.size && hj.clear(), t })), hj = pj.cache, pj), vj = mj; function yj(t) { return null == t ? "" : MB(t) } function gj(t, e) { return CB(t) ? t : function (t, e) { if (CB(t)) return !1; var n = typeof t; return !("number" != n && "symbol" != n && "boolean" != n && null != t && !EB(t)) || JB.test(t) || !QB.test(t) || null != e && t in Object(e) }(t, e) ? [t] : vj(yj(t)) } function _j(t) { if ("string" == typeof t || EB(t)) return t; var e = t + ""; return "0" == e && 1 / t == -Infinity ? "-0" : e } function xj(t, e, n) { var r = null == t ? void 0 : function (t, e) { for (var n = 0, r = (e = gj(e, t)).length; null != t && n < r;)t = t[_j(e[n++])]; return n && n == r ? t : void 0 }(t, e); return void 0 === r ? n : r } var bj = mB.isFinite, wj = Math.min; var Sj = function (t) { var e = Math[t]; return function (t, n) { if (t = zB(t), (n = null == n ? 0 : wj(BB(n), 292)) && bj(t)) { var r = (yj(t) + "e").split("e"); return +((r = (yj(e(r[0] + "e" + (+r[1] + n))) + "e").split("e"))[0] + "e" + (+r[1] - n)) } return e(t) } }("round"), Ej = Sj, Cj = (new Object).toString, Tj = function (t, e) { return Cj.call(t) === "[object " + e + "]" }, Aj = function (t) { return Tj(t, "Array") }, Mj = function (t) { if (!function (t) { return "object" == typeof t && null !== t }(t) || !Tj(t, "Object")) return !1; for (var e = t; null !== Object.getPrototypeOf(e);)e = Object.getPrototypeOf(e); return Object.getPrototypeOf(t) === e }, Oj = function (t, e, n, r) { for (var i in n = n || 0, r = r || 5, e) if (Object.prototype.hasOwnProperty.call(e, i)) { var o = e[i]; o ? Mj(o) ? (Mj(t[i]) || (t[i] = {}), n < r ? Oj(t[i], o, n + 1, r) : t[i] = e[i]) : Aj(o) ? (t[i] = [], t[i] = t[i].concat(o)) : t[i] = o : t[i] = o } }, kj = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; for (var r = 0; r < e.length; r += 1)Oj(t, e[r]); return t }, Ij = ["mousemove", "click"], Pj = function (e) { function n(t, n, r) { var i = e.call(this) || this; i.currentVisible = !1, i.interactionTriggerHander = function (t) { var e = t.feature, n = t.featureId, r = i.options, o = r.title, a = r.customTitle, s = r.items, l = r.customItems, u = "Feature" === e.type && e.geometry && e.properties ? e.properties : e, c = []; if (l) { var p = l(e); if (!Array.isArray(p)) throw new Error("customItems return array"); c = p } else s && s.forEach((function (t) { if (f(t)) { var e = t.split(".").pop() || t; void 0 !== (r = xj(u, t)) && c.push({ name: e, value: r }) } else { var r, i = t.field, o = t.alias, a = t.customValue, s = o || i.split(".").pop() || i; void 0 !== (r = xj(u, i)) && c.push({ name: s, value: a ? a(r, u, n) : r }) } })); var h = { title: a ? a(u) : o, items: c }; i.updateTooltip(t, h) }, i.interactionUntriggerHander = function () { i.hideTooltip() }, i.scene = t, i.interactionLayers = n, i.options = kj({}, i.getDefaultOptions(), r); var o = i.options, a = o.offsets, s = o.title, l = o.showTitle, u = o.customContent, c = o.domStyles, p = o.anchor, h = o.className; return i.marker = new $x({ offsets: a, anchor: p, draggable: !1 }), i.tooltipComponent = new XF({ title: s, showTitle: l, items: [], customContent: u, domStyles: c, className: h }), i.setComponent(), i.initInteractionEvent(), i } return M(n, e), n.prototype.getDefaultOptions = function () { return { showTitle: !0, showComponent: !0, items: [], offsets: [15, 0], trigger: "mousemove", anchor: t.TooltipAnchorType["TOP-LEFT"] } }, n.prototype.update = function (t) { this.marker.remove(), this.currentVisible = !1, this.options = kj({}, this.options, t); var e = this.options, n = e.offsets, r = e.showTitle, i = e.customContent, o = e.domStyles, a = e.anchor, s = e.className; this.marker = new $x({ offsets: n, anchor: a, draggable: !1 }), this.tooltipComponent.update({ showTitle: r, customContent: i, domStyles: o, className: s }), this.setComponent() }, n.prototype.initInteractionEvent = function () { var t = this, e = this.options.trigger || "mousemove"; if (!Ij.includes(e)) throw new Error("trigger is mousemove or click"); this.interactionLayers.forEach((function (n) { var r = n.layer; r.on(e, t.interactionTriggerHander), r.on("un".concat(e), t.interactionUntriggerHander) })) }, n.prototype.unBindInteractionEvent = function () { var t = this, e = this.options.trigger || "mousemove"; this.interactionLayers.forEach((function (n) { var r = n.layer; r.off(e, t.interactionTriggerHander), r.off("un".concat(e), t.interactionUntriggerHander) })) }, n.prototype.updateTooltip = function (t, e) { var n = t.lngLat, r = t.x, i = t.y; if (this.options.showComponent && (this.updateComponent(e), this.setPostion(n)), this.currentVisible) { var o = { type: "tooltip:change", data: e, lngLat: n, x: r, y: i }; this.emit("tooltip:change", o) } else { this.showTooltip(); var a = { type: "tooltip:show", data: e, lngLat: n, x: r, y: i }; this.emit("tooltip:show", a) } }, n.prototype.showTooltip = function () { this.currentVisible || (this.options.showComponent && this.scene.addMarker(this.marker), this.currentVisible = !0) }, n.prototype.hideTooltip = function () { if (this.currentVisible) { this.options.showComponent && this.marker.remove(), this.currentVisible = !1; this.emit("tooltip:hide", { type: "tooltip:hide" }) } }, n.prototype.updateComponent = function (t) { w(this.lastComponentOptions, t) || (this.tooltipComponent.update(t), this.lastComponentOptions = t) }, n.prototype.setComponent = function () { var t = this.tooltipComponent.getContainer(), e = window.document.createElement("div"); e.style.cursor = "auto", e.style.userSelect = "text", e.className = "l7plot-tooltip-container", ["mousemove", "mousedown", "mouseup", "click", "dblclick"].forEach((function (t) { e.addEventListener(t, (function (t) { return t.stopPropagation() })) })), e.appendChild(t), this.marker.setElement(e) }, n.prototype.setPostion = function (t) { this.marker.setLnglat(t) }, n.prototype.destroy = function () { this.unBindInteractionEvent(), this.off(), this.marker.remove(), this.tooltipComponent.destroy() }, n }(MF), Lj = function (t) { function e(e) { var n = t.call(this, e) || this; return n.legendComponents = [], n.options = e, n.legendComponents = n.initLegendComponents(e.items), n } return M(e, t), e.prototype.initLegendComponents = function (t) { for (var e = [], n = 0; n < t.length; n++) { var r = t[n]; if ("category" === r.type) { var i = new nB({ title: r.options.title, items: r.options.items, className: r.options.className, customContent: r.options.customContent, domStyles: r.options.domStyles }); e.push(i) } else if ("continue" === r.type) { i = new hB({ title: r.options.title, min: r.options.min, max: r.options.max, colors: r.options.colors, className: r.options.className, customContent: r.options.customContent, domStyles: r.options.domStyles }); e.push(i) } } return e }, e.prototype.getDefaultOptions = function () { return { position: "bottomleft" } }, e.prototype.onAdd = function () { var t = window.document.createElement("div"); return t.className = "l7plot-legend-container", this.legendComponents.forEach((function (e) { var n = e.getContainer(); t.appendChild(n) })), t }, e.prototype.onRemove = function () { this.legendComponents.forEach((function (t) { t.destroy() })) }, e }(Ux), Rj = function (t) { function e(e, n) { void 0 === e && (e = []), void 0 === n && (n = {}); var r = t.call(this) || this; return r.name = n.name ? n.name : T("layerGroup"), r.layers = e, r } return M(e, t), e.prototype.addTo = function (t) { var e = this; this.scene = t; var n = 0, r = this.layers.length; this.layers.forEach((function (i) { i.once("inited", (function (t) { n++, e.emit("inited", t), n === r && e.emit("inited-all") })), i.addTo(t) })) }, e.prototype.hasLayer = function (t) { return this.layers.some((function (e) { return e === t })) }, e.prototype.addLayer = function (t) { var e = this; this.layers.push(t), this.scene && (t.once("inited", (function (t) { return e.emit("inited", t) })), t.addTo(this.scene)) }, e.prototype.removeLayer = function (t) { var e = this.layers.findIndex((function (e) { return e === t })); return -1 !== e && (this.layers.splice(e, 1), this.scene && t.remove(this.scene), !0) }, e.prototype.getLayers = function () { return this.layers }, e.prototype.getInteractionLayers = function () { return this.layers.filter((function (t) { return t.interaction })) }, e.prototype.getLayer = function (t) { return this.layers.find((function (e) { return e.layer.id === t })) }, e.prototype.getLayerByName = function (t) { return this.layers.find((function (e) { return e.name === t })) }, e.prototype.removeAllLayer = function () { var t = this; this.layers.forEach((function (e) { t.scene && e.remove(t.scene) })), this.layers = [] }, e.prototype.isEmpty = function () { return 0 === this.layers.length }, e }(MF), Dj = [{ original: "loaded", adaptation: "scene-loaded" }, { original: "resize", adaptation: "resize" }, { original: "destroy", adaptation: "destroy" }, { original: "resize", adaptation: "resize" }], Nj = ["mapmove", "movestart", "moveend", "zoomchange", "zoomstart", "zoomend", "click", "dblclick", "contextmenu", "mousemove", "mousewheel", "mouseover", "mouseout", "mouseup", "mousedown", "dragstart", "dragging", "dragend"], zj = ["inited", "add", "remove", "dataUpdate", "click", "unclick", "contextmenu", "uncontextmenu", "mouseenter", "mousemove", "unmousemove", "mouseout", "mouseup", "unmouseup", "mousedown", "uncontextmenu", "unpick"], Fj = { map: { type: t.BaseMapType.Amap }, logo: !0 }, Bj = function (i) { function o(t) { var e = i.call(this) || this; return e.inited = !1, e.sceneLoaded = !1, e.layersLoaded = !1, e.loaded = !1, e.layerGroup = new Rj, e.options = kj({}, e.getDefaultOptions(), t), e.lastOptions = e.options, e } return M(o, i), o.prototype.getDefaultOptions = function () { return o.DefaultOptions }, o.prototype.createContainer = function (t) { var e = this.options, n = e.width, r = e.height, i = "string" == typeof t ? document.getElementById(t) : t; return i.style.position || (i.style.position = "relative"), n && (i.style.width || (i.style.width = "".concat(n, "px"))), r && (i.style.height || (i.style.height = "".concat(r, "px"))), i }, o.prototype.createTheme = function () { return u(this.options.theme) ? kj({}, at("default"), et(this.options.theme)) : at(this.options.theme) }, o.prototype.createMap = function () { var e = this.options.map ? this.options.map : Fj.map, n = e.type, r = I(e, ["type"]), i = Object.assign({ style: this.theme.mapStyle }, r); return n === t.BaseMapType.Amap ? new zA(i) : new TM(i) }, o.prototype.createScene = function () { var t = this.options, e = t.logo, n = t.antialias, r = t.preserveDrawingBuffer, i = y(e) ? { logoVisible: e } : { logoVisible: null == e ? void 0 : e.visible, logoPosition: null == e ? void 0 : e.position }, o = Object.assign({ antialias: n, preserveDrawingBuffer: r }, i), a = this.createMap(); return new SF(k({ id: this.container, map: a }, o)) }, o.prototype.registerResources = function () { var t = this; e.size && e.forEach((function (e, n) { !t.scene.hasImage(n) && t.scene.addImage(n, e) })), n.size && n.forEach((function (e, n) { t.scene.addFontFace(n, e) })), r.size && r.forEach((function (e, n) { t.scene.addIconFont(n, e) })) }, o.prototype.update = function (t) { this.updateOption(t), t.map && !w(this.lastOptions.map, this.options.map) && this.updateMap(t.map), this.render(), this.emit("update") }, o.prototype.updateOption = function (t) { this.lastOptions = this.options, this.options = kj({}, this.options, t) }, o.prototype.updateMap = function (t) { var e; if (this.scene) { var n = t.style, r = t.center, i = t.zoom, o = t.rotation, a = t.pitch; g(a) || this.scene.setPitch(a), g(o) || this.scene.setRotation(o), n && n !== (null === (e = this.lastOptions.map) || void 0 === e ? void 0 : e.style) && this.scene.setMapStyle(n), i && r && this.scene.setZoomAndCenter(i, r) } }, o.prototype.changeSize = function (t, e) { this.options.width === t && this.options.height === e || (this.container.style.width = "".concat(t, "px"), this.container.style.height = "".concat(e, "px"), this.options = Object.assign(this.options, { width: t, height: e })) }, o.prototype.on = function (t, e) { return this.proxyEventHander("on", t, e), this }, o.prototype.once = function (t, e) { return this.proxyEventHander("once", t, e), this }, o.prototype.off = function (t, e) { return this.proxyEventHander("off", t, e), this }, o.prototype.proxyEventHander = function (t, e, n) { var r = Dj.find((function (t) { return t.adaptation === e })); if (r) this.scene[t](r.original, n); else if (-1 !== Nj.indexOf(e)) this.scene[t](e, n); else if (e.includes("Layer:")) { var o = R(e.split(":"), 2), a = o[0], s = o[1]; if (!(this[a] && this[a][t]) || -1 === zj.indexOf(s)) throw new Error('No event name "'.concat(e, '"')); this[a][t](s, n) } else i.prototype[t].call(this, e, n) }, o.prototype.getScene = function () { return this.scene }, o.prototype.getMap = function () { var e, n; return (null === (e = this.options.map) || void 0 === e ? void 0 : e.type) === t.BaseMapType.Amap || (null === (n = this.options.map) || void 0 === n || n.type, t.BaseMapType.Mapbox), this.scene.map }, o.prototype.addLayer = function (t) { this.layerGroup.addLayer(t) }, o.prototype.getLayes = function () { return console.warn("Replace to use getLayers()"), this.getLayers() }, o.prototype.getLayers = function () { return this.layerGroup.getLayers() }, o.prototype.getLayerByName = function (t) { return this.layerGroup.getLayerByName(t) }, o.prototype.removeLayer = function (t) { return this.layerGroup.removeLayer(t) }, o.prototype.removeAllLayer = function () { this.layerGroup.removeAllLayer() }, o.prototype.zoomIn = function () { this.scene.zoomIn() }, o.prototype.zoomOut = function () { this.scene.zoomOut() }, o.prototype.setPitch = function (t) { this.scene.setPitch(t) }, o.prototype.fitBounds = function (t) { this.scene.fitBounds(t) }, o.prototype.setMapStatus = function (t) { this.scene.setMapStatus(t) }, o.prototype.setBgColor = function (t) { this.scene.setBgColor(t) }, o.prototype.initComponents = function () { this.initControls(), this.initTooltip() }, o.prototype.updateComponents = function () { this.updateControls(), this.initTooltip() }, o.prototype.initControls = function () { var t = this.options, e = t.zoom, n = t.scale, r = t.layerMenu, i = t.legend; n && this.addScaleControl(n), e && this.addZoomControl(e), r && this.addLayerMenuControl(r), i && this.addLegendControl(i) }, o.prototype.updateControls = function () { var t = this.options, e = t.zoom, n = t.scale, r = t.layerMenu, i = t.legend; w(this.lastOptions.zoom, e) || (e ? this.updateZoomControl(e) : this.removeZoomControl()), w(this.lastOptions.scale, n) || (n ? this.updateScaleControl(n) : this.removeScaleControl()), w(this.lastOptions.layerMenu, r) || (r ? this.updateLayerMenuControl(r) : this.removeLayerMenuControl()), w(this.lastOptions.legend, i) || (i ? this.updateLegendControl(i) : this.removeLegendControl()) }, o.prototype.addZoomControl = function (t) { this.zoomControl || (this.zoomControl = new Yx(t), this.scene.addControl(this.zoomControl)) }, o.prototype.updateZoomControl = function (t) { this.zoomControl ? (this.removeZoomControl(), this.addZoomControl(t)) : this.addZoomControl(t) }, o.prototype.removeZoomControl = function () { this.zoomControl && (this.zoomControl.remove(), this.zoomControl = void 0) }, o.prototype.addScaleControl = function (t) { this.scaleControl || (this.scaleControl = new qx(t), this.scene.addControl(this.scaleControl)) }, o.prototype.updateScaleControl = function (t) { this.scaleControl ? (this.removeScaleControl(), this.addScaleControl(t)) : this.addScaleControl(t) }, o.prototype.removeScaleControl = function () { this.scaleControl && (this.scaleControl.remove(), this.scaleControl = void 0) }, o.prototype.addLayerMenuControl = function (t) { if (!this.layerMenuControl) { var e = {}; this.layerGroup.getLayers().forEach((function (t) { var n = t.name, r = t.layer; e[n] = r })), this.layerMenuControl = new Gx(Object.assign({}, t, { baseLayers: {}, overlayers: e })), this.scene.addControl(this.layerMenuControl) } }, o.prototype.updateLayerMenuControl = function (t) { this.layerMenuControl ? (this.removeLayerMenuControl(), this.addLayerMenuControl(t)) : this.addLayerMenuControl(t) }, o.prototype.removeLayerMenuControl = function () { this.layerMenuControl && (this.layerMenuControl.remove(), this.layerMenuControl = void 0) }, o.prototype.getLegendOptions = function () { return {} }, o.prototype.addLegendControl = function (t) { if (!this.legendControl) { var e = this.theme.components.legend, n = kj({}, this.getLegendOptions(), t), r = n.type, i = n.position, o = I(n, ["type", "position"]), a = []; if ("category" === r) { var s = kj({}, { domStyles: e.category.domStyles }, o); a.push({ type: r, options: s }) } else if ("continue" === r) { var l = kj({}, { domStyles: e.continue.domStyles }, o); a.push({ type: r, options: l }) } a.length && (this.legendControl = new Lj({ position: i, items: a }), this.scene.addControl(this.legendControl)) } }, o.prototype.updateLegendControl = function (t) { this.legendControl ? (this.removeLegendControl(), this.addLegendControl(t)) : this.addLegendControl(t) }, o.prototype.removeLegendControl = function () { this.legendControl && (this.legendControl.remove(), this.legendControl = void 0) }, o.prototype.initTooltip = function () { var t = this; this.tooltip && this.tooltip.destroy(); var e = this.options.tooltip; if (e) { var n = kj({}, { domStyles: this.theme.components.tooltip.domStyles }, e), r = this.layerGroup.getInteractionLayers(); this.tooltip = new Pj(this.scene, r, n), this.tooltip.on("*", (function (e) { return t.emit(e.type, e) })) } }, o.prototype.exportPng = function (t) { return this.scene.exportPng(t) }, o.prototype.destroy = function () { var t; i.prototype.off.call(this, "*"), this.removeScaleControl(), this.removeZoomControl(), this.removeLayerMenuControl(), this.removeLegendControl(), null === (t = this.tooltip) || void 0 === t || t.destroy(), this.scene.destroy() }, o.DefaultOptions = Fj, o }(MF), jj = function () { function t() { } return t.aggregation = function (t, e) { var n = e.type, r = { type: void 0 === n ? "grid" : n, size: e.radius, method: e.method, field: e.field }; t.transforms ? (t.transforms = t.transforms.filter((function (t) { return t.type !== r.type })), t.transforms.push(r)) : t.transforms = [r] }, t }(), Uj = ["name", "zIndex", "visible", "minZoom", "maxZoom", "pickingBuffer", "autoFit", "blend"], Vj = function (e) { function n(t) { var n = e.call(this) || this; return n.options = kj({}, n.getDefaultOptions(), t), n.lastOptions = n.options, n } return M(n, e), n.prototype.getDefaultOptions = function () { return {} }, n.prototype.pickLayerConfig = function (t) { return E(t, Uj) }, n.prototype.addTo = function (t) { t.addLayer(this.layer) }, n.prototype.remove = function (t) { t.removeLayer(this.layer) }, n.prototype.update = function (t) { this.updateOption(t), this.updateConfig(t) }, n.prototype.updateOption = function (t) { this.lastOptions = this.options, this.options = kj({}, this.options, t) }, n.prototype.updateConfig = function (t) { g(t.zIndex) || w(this.lastOptions.zIndex, this.options.zIndex) || this.setIndex(t.zIndex), g(t.blend) || w(this.lastOptions.blend, this.options.blend) || this.setBlend(t.blend), g(t.minZoom) || w(this.lastOptions.minZoom, this.options.minZoom) || this.setMinZoom(t.minZoom), g(t.maxZoom) || w(this.lastOptions.maxZoom, this.options.maxZoom) || this.setMinZoom(t.maxZoom), g(t.visible) || w(this.lastOptions.visible, this.options.visible) || (t.visible ? this.show() : this.hide()) }, n.prototype.render = function () { this.layer.renderLayers() }, n.prototype.setSource = function (t) { if (t instanceof yE) this.layer.setSource(t); else { var e = t.data, n = t.aggregation, r = I(t, ["data", "aggregation"]); n && jj.aggregation(r, n), this.layer.getSource() ? this.layer.setData(e, r) : this.layer.source(e, r) } }, n.prototype.changeData = function (t) { this.setSource(t) }, n.prototype.setIndex = function (t) { this.layer.setIndex(t) }, n.prototype.setBlend = function (t) { this.layer.setBlend(t) }, n.prototype.setMinZoom = function (t) { this.layer.setMinZoom(t) }, n.prototype.setMaxZoom = function (t) { this.layer.setMaxZoom(t) }, n.prototype.show = function () { this.layer.inited && this.layer.show() }, n.prototype.hide = function () { this.layer.inited && this.layer.hide() }, n.prototype.toggleVisible = function () { this.isVisible() ? this.hide() : this.show() }, n.prototype.isVisible = function () { return this.layer.inited ? this.layer.isVisible() : this.options.visible }, n.prototype.fitBounds = function (t) { this.layer.fitBounds(t) }, n.prototype.on = function (t, n) { return -1 !== zj.indexOf(t) ? this.layer.on(t, n) : e.prototype.on.call(this, t, n), this }, n.prototype.once = function (t, n) { return -1 !== zj.indexOf(t) ? this.layer.once(t, n) : e.prototype.once.call(this, t, n), this }, n.prototype.off = function (t, n) { return -1 !== zj.indexOf(t) ? this.layer.off(t, n) : e.prototype.off.call(this, t, n), this }, n.LayerType = t.LayerType, n.LayerConfigkeys = Uj, n }(MF); function Gj(t, e) { return function () { for (var n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r]; var i = {}; return t.forEach((function (t, e) { i[t] = n[e] })), delete i[void 0], e(i) } } var Hj = function () { function t() { } return t.shape = function (e, n) { if (f(n)) e.shape(n); else if (s(n)) { var r = []; e.shape(r.join("*"), Gj(r, n)) } else if (u(n)) { var i = n.field ? n.field : ""; if (s(n.value)) { r = l(i) ? i : i.split("*"); e.shape(i, Gj(r, n.value)) } else e.shape(i, n.value); f(i) && n.scale && t.scale(e, i, n.scale) } }, t.size = function (e, n) { if (a(n, "Number")) e.size(n); else if (l(n)) e.size(n); else if (s(n)) { var r = []; e.size(r.join("*"), Gj(r, n)) } else if (u(n)) { var i = n.field ? n.field : ""; if (s(n.value)) { r = l(i) ? i : i.split("*"); e.size(i, Gj(r, n.value)) } else e.size(i, n.value); f(i) && n.scale && t.scale(e, i, n.scale) } }, t.color = function (e, n) { if (f(n)) e.color(n); else if (s(n)) { var r = []; e.color(r.join("*"), Gj(r, n)) } else if (u(n)) { var i = n.field ? n.field : ""; if (s(n.value)) { r = l(i) ? i : i.split("*"); e.color(i, Gj(r, n.value)) } else e.color(i, n.value); f(i) && n.scale && t.scale(e, i, n.scale) } }, t.style = function (t, e) { e && t.style(e) }, t.state = function (t, e) { var n = e.active, r = e.select; n && t.active(n), r && t.select(r) }, t.rotate = function (t, e) { f(e) || s(e) }, t.texture = function (t, e) { f(e) && t.texture(e) }, t.animate = function (t, e) { (y(e) || u(e)) && t.animate(e) }, t.scale = function (t, e, n) { t.scale(e, n) }, t.filter = function (t, e) { var n = e.field ? e.field : "", r = l(n) ? n : n.split("*"); t.filter(r.join("*"), Gj(r, e.value)) }, t }(); var Wj = { style: { fontSize: 12 } }, Xj = [], qj = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.TextLayer, n.interaction = !1; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new $O(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return Wj }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.field, r = e.content, i = e.style, o = void 0 === i ? {} : i, a = e.state, s = o.fontSize, l = o.fill, u = { field: n || r || "", value: "text" }; Hj.shape(t, u), s && Hj.size(t, s), l && Hj.color(t, l), o && Hj.style(t, o), a && Hj.state(t, a) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.DefaultOptions = Wj, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(Xj), e }(Vj), Zj = { autoFit: !1 }, Yj = function (e) { function n(t, n) { var r = this; if ("string" == typeof t || t instanceof Element) { if (void 0 === n) throw new Error("options is undefined"); (r = e.call(this, n) || this).container = r.createContainer(t), r.theme = r.createTheme(), r.scene = r.createScene(), r.registerResources(), r.initSource() } else r = e.call(this, t) || this; return r } return M(n, e), n.prototype.initSource = function () { this.source = this.createSource(), this.render(), this.inited = !0 }, n.prototype.initLayersEvent = function () { }, n.prototype.getDefaultOptions = function () { return n.DefaultOptions }, n.prototype.createSource = function () { var t = this.options.source, e = t.data, n = t.aggregation, r = I(t, ["data", "aggregation"]); return n && jj.aggregation(r, n), new yE(e, r) }, n.prototype.createLabelLayer = function (t, e, n) { var r = n || {}, i = r.visible, o = r.minZoom, a = r.maxZoom, s = r.zIndex; return new qj(k({ name: "labelLayer", visible: i, minZoom: o, maxZoom: a, zIndex: (void 0 === s ? 0 : s) + .1, source: t }, e)) }, n.prototype.updateLabelLayer = function (t, e, n, r) { e ? r ? r.update(k({}, e)) : (r = this.createLabelLayer(t, e, n), this.layerGroup.addLayer(r)) : !1 === e && r && this.layerGroup.removeLayer(r) }, n.prototype.render = function () { var t = this, e = this.createLayers(this.source); this.inited ? (this.layerGroup.removeAllLayer(), e.addTo(this.scene), this.layerGroup = e) : (this.layerGroup = e, this.scene.sceneService.loaded ? this.onSceneLoaded() : this.scene.once("loaded", (function () { t.onSceneLoaded() }))), this.initLayersEvent() }, n.prototype.onSceneLoaded = function () { var t = this; this.sceneLoaded = !0, this.layerGroup.isEmpty() ? this.onLayersLoaded() : this.layerGroup.once("inited-all", (function () { t.onLayersLoaded() })), this.layerGroup.addTo(this.scene) }, n.prototype.onLayersLoaded = function () { this.layersLoaded = !0, this.initComponents(), this.loaded = !0, this.emit("loaded") }, n.prototype.attachToScene = function (t, e) { this.scene = t, this.theme = e || at("default"), this.registerResources(), this.initSource() }, n.prototype.unattachFromScene = function () { var t; this.removeAllLayer(), null === (t = this.tooltip) || void 0 === t || t.destroy() }, n.prototype.addToScene = function (t) { this.attachToScene(t) }, n.prototype.removeFromScene = function () { var t; this.removeAllLayer(), this.removeScaleControl(), this.removeZoomControl(), this.removeLayerMenuControl(), this.removeLegendControl(), null === (t = this.tooltip) || void 0 === t || t.destroy() }, n.prototype.update = function (t) { if (this.updateOption(t), t.map && !w(this.lastOptions.map, this.options.map) && this.updateMap(t.map), this.scene.setEnableRender(!1), t.source && !w(this.lastOptions.source, this.options.source)) { var e = t.source, n = e.data, r = I(e, ["data"]); this.changeData(n, r) } this.scene.setEnableRender(!0), this.render(), this.updateComponents(), this.emit("update") }, n.prototype.changeData = function (t, e) { var n = this; this.options.source = kj({}, this.options.source, k({ data: t }, e)); var r = this.options.source, i = r.aggregation, o = I(r, ["aggregation"]); i && jj.aggregation(o, i), this.source.setData(this.options.source.data, o); var a = this.options.legend; a && setTimeout((function () { n.updateLegendControl(a) })), this.emit("change-data") }, n.DefaultOptions = Zj, n.PlotType = t.PlotType, n }(Bj), Kj = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json", x: "x", y: "y" } } }); var Qj = function (t) { return function (t) { return !Array.isArray(t[0].value) }(t) ? t : t.map((function (t) { return k(k({}, t), { value: [Ej(t.value[0], 2), Ej(t.value[1], 2)] }) })) }, Jj = { source: { data: [], parser: { type: "json", x: "x", y: "y" } }, shape: "circle", size: 12, color: "#5FD3A6" }, $j = ["shape", "color", "size", "style", "state", "animate"], tU = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.DotLayer, n.interaction = !0; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new $O(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return Jj }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.shape, r = e.color, i = e.size, o = e.style, a = e.state, s = e.animate; n && Hj.shape(t, n), i && Hj.size(t, i), r && Hj.color(t, r), o && Hj.style(t, o), a && Hj.state(t, a), s && Hj.animate(t, s) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.prototype.getColorLegendItems = function () { var t = this.layer.getLegendItems("color"); return Array.isArray(t) && 0 !== t.length ? Qj(t) : [] }, e.DefaultOptions = Jj, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat($j), e }(Vj), eU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Dot, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.dotLayer = new tU(k({ source: t }, E(this.options, tU.LayerOptionsKeys))); var e = new Rj([this.dotLayer]); return this.options.label && (this.labelLayer = this.createLabelLayer(t, this.options.label, this.options), e.addLayer(this.labelLayer)), e }, e.prototype.updateLayers = function (t) { var e = E(t, tU.LayerOptionsKeys); this.dotLayer.update(e), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.prototype.getLegendOptions = function () { var t = this.dotLayer.getColorLegendItems(); return 0 !== t.length ? { type: "category", items: t } : {} }, e.DefaultOptions = Kj, e }(Yj), nU = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json", x: "x", y: "y" } } }), rU = ["color", "size", "style", "state", "animate"], iU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = tU.LayerType.DotDensity, e.interaction = !1, e } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, tU.DefaultOptions, { shape: "dot", size: 1 }) }, e.LayerOptionsKeys = tU.LayerConfigkeys.concat(rU), e }(tU), oU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.DotDensity, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { return this.dotDensityLayer = new iU(k({ source: t }, E(this.options, iU.LayerOptionsKeys))), new Rj([this.dotDensityLayer]) }, e.prototype.updateLayers = function (t) { var e = E(t, iU.LayerOptionsKeys); this.dotDensityLayer.update(e) }, e.DefaultOptions = nU, e }(Yj), aU = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json", x: "x", y: "y" } } }); var sU = { source: { data: [], parser: { type: "json", x: "x", y: "y" } }, shape: "heatmap", size: { value: [0, 1] }, style: { intensity: 3, radius: 20, opacity: 1, colorsRamp: [{ color: "rgba(33,102,172,0.0)", position: 0 }, { color: "rgb(103,169,207)", position: .2 }, { color: "rgb(209,229,240)", position: .4 }, { color: "rgb(253,219,199)", position: .6 }, { color: "rgb(239,138,98)", position: .8 }, { color: "rgb(178,24,43,1.0)", position: 1 }] } }, lU = ["shape", "color", "size", "style", "state"], uU = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.HeatmapLayer, n.interaction = !1; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new jM(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return sU }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.shape, r = e.size, i = e.style, o = e.state; n && Hj.shape(t, n), r && Hj.size(t, r), i && ("colorsRamp" in i && (i.rampColors = function (t) { var e = t.colorsRamp, n = { colors: [], positions: [] }; return e.forEach((function (t) { var e = t.color, r = t.position; n.colors.push(e), n.positions.push(r) })), n }(i)), Hj.style(t, i)), o && Hj.state(t, o) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.DefaultOptions = sU, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(lU), e }(Vj), cU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Heatmap, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.heatmapLayer = new uU(k({ source: t }, E(this.options, uU.LayerOptionsKeys))); var e = new Rj([this.heatmapLayer]); return this.options.label && (this.labelLayer = this.createLabelLayer(this.source, this.options.label, this.options), e.addLayer(this.labelLayer)), e }, e.prototype.updateLayers = function (t) { var e = E(t, uU.LayerOptionsKeys); this.heatmapLayer.update(e), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.prototype.getLegendOptions = function () { var t, e = this.heatmapLayer.layer.getLegendItems("size"); return Array.isArray(e) && 0 !== e.length ? { type: "continue", min: e[0].value, max: e[e.length - 1].value, colors: null === (t = this.heatmapLayer.options.style) || void 0 === t ? void 0 : t.colorsRamp.map((function (t) { return t.color })) } : {} }, e.DefaultOptions = aU, e }(Yj), pU = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json", x: "x", y: "y" }, aggregation: { type: "grid", radius: 15e3, method: "sum" } } }); var hU = { source: { data: [], parser: { type: "json", x: "x", y: "y" }, aggregation: { type: "grid", field: "", radius: 15e3, method: "sum" } }, shape: "square", color: "#5FD3A6", style: { coverage: .9, angle: 0, opacity: 1 } }, fU = ["shape", "color", "size", "style", "state"], dU = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.GridLayer, n.interaction = !1; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new jM(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return hU }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.shape, r = e.color, i = e.size, o = e.style, a = e.state; n && Hj.shape(t, n), i && Hj.size(t, i), r && Hj.color(t, r), o && Hj.style(t, o), a && Hj.state(t, a) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.DefaultOptions = hU, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(fU), e }(Vj), mU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Grid, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.gridLayer = new dU(k({ source: t }, E(this.options, dU.LayerOptionsKeys))); var e = new Rj([this.gridLayer]); return this.options.label && (this.labelLayer = this.createLabelLayer(this.source, this.options.label, this.options), e.addLayer(this.labelLayer)), e }, e.prototype.updateLayers = function (t) { var e = E(t, dU.LayerOptionsKeys); this.gridLayer.update(e), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.DefaultOptions = pU, e }(Yj), vU = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json", x: "x", y: "y" }, aggregation: { type: "hexagon", radius: 15e3, method: "sum" } } }); var yU = { source: { data: [], parser: { type: "json", x: "x", y: "y" }, aggregation: { type: "hexagon", field: "", radius: 15e3, method: "sum" } }, shape: "hexagon", color: "#5FD3A6", style: { coverage: .9, angle: 0, opacity: 1 } }, gU = ["shape", "color", "size", "style", "state"], _U = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.HexbinLayer, n.interaction = !1; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new jM(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return yU }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.shape, r = e.color, i = e.size, o = e.style, a = e.state; n && Hj.shape(t, n), i && Hj.size(t, i), r && Hj.color(t, r), o && Hj.style(t, o), a && Hj.state(t, a) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.DefaultOptions = yU, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(gU), e }(Vj), xU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Hexbin, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.hexbinLayer = new _U(k({ source: t }, E(this.options, _U.LayerOptionsKeys))); var e = new Rj([this.hexbinLayer]); return this.options.label && (this.labelLayer = this.createLabelLayer(this.source, this.options.label, this.options), e.addLayer(this.labelLayer)), e }, e.prototype.updateLayers = function (t) { var e = E(t, _U.LayerOptionsKeys); this.hexbinLayer.update(e), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.DefaultOptions = vU, e }(Yj), bU = kj({}, Yj.DefaultOptions, { source: { data: { type: "FeatureCollection", features: [] }, parser: { type: "geojson" } } }); var wU = {}, SU = ["shape", "color", "size", "style", "state", "animate"], EU = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.LinesLayer, n.interaction = !0; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new uO(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return wU }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.shape, r = e.color, i = e.size, o = e.style, a = e.state, s = e.animate, l = e.texture; n && Hj.shape(t, n), i && Hj.size(t, i), r && Hj.color(t, r), o && Hj.style(t, o), a && Hj.state(t, a), s && Hj.animate(t, s), l && Hj.texture(t, l) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.prototype.getColorLegendItems = function () { var t = this.layer.getLegendItems("color"); return Array.isArray(t) && 0 !== t.length ? Qj(t) : [] }, e.DefaultOptions = wU, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(SU), e }(Vj), CU = ["color", "size", "style", "state", "animate"], TU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = EU.LayerType.PathLayer, e } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, EU.DefaultOptions, { shape: "line" }) }, e.LayerOptionsKeys = EU.LayerConfigkeys.concat(CU), e }(EU), AU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Path, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { return this.pathLayer = new TU(k({ source: t }, E(this.options, TU.LayerOptionsKeys))), new Rj([this.pathLayer]) }, e.prototype.updateLayers = function (t) { var e = E(t, TU.LayerOptionsKeys); this.pathLayer.update(e) }, e.prototype.getLegendOptions = function () { var t = this.pathLayer.getColorLegendItems(); return 0 !== t.length ? { type: "category", items: t } : {} }, e.DefaultOptions = bU, e }(Yj), MU = kj({}, Yj.DefaultOptions, { source: { data: [], parser: { type: "json" } }, shape: "arc" }), OU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = EU.LayerType.ArcLayer, e } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, EU.DefaultOptions, { shape: "arc" }) }, e }(EU), kU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Flow, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.flowLayer = new OU(k({ name: "flowLayer", source: t }, E(this.options, OU.LayerOptionsKeys))); var e = new Rj([this.flowLayer]); return this.options.radiation && (this.radiationLayer = this.createRadiationLayer(t), e.addLayer(this.radiationLayer)), this.options.label && (this.labelLayer = this.createLabelLayer(t, this.options.label), e.addLayer(this.labelLayer)), e }, e.prototype.parserPointData = function (t) { var e = []; return t.data.dataArray.forEach((function (t) { var n = R(t.coordinates, 2)[1]; e.push(k(k({}, t), { coordinates: n })) })), e }, e.prototype.createRadiationLayer = function (t) { var e = this, n = this.parserPointData(t), r = this.options.radiation || {}, i = r.enabled, o = void 0 === i || i, a = r.color, s = r.size, l = void 0 === s ? 20 : s, u = r.shape, c = void 0 === u ? "circle" : u, p = r.animate, h = new tU({ name: "radiationLayer", source: { data: n, parser: { type: "json", coordinates: "coordinates" } }, visible: o, color: a, size: l, shape: c, animate: void 0 === p || p }), f = function () { var t = e.parserPointData(e.source); h.layer.setData(t) }; return t.on("update", f), h.on("remove", (function () { t.off("update", f) })), h }, e.prototype.createLabelLayer = function (t, e) { var n = this, r = this.parserPointData(t), i = this.options, o = i.visible, a = i.minZoom, s = i.maxZoom, l = i.zIndex, u = new qj(k({ name: "labelLayer", source: { data: r, parser: { type: "json", coordinates: "coordinates" } }, visible: o, minZoom: a, maxZoom: s, zIndex: (void 0 === l ? 0 : l) + .1 }, e)), c = function () { var t = n.parserPointData(n.source); u.layer.setData(t) }; return t.on("update", c), u.on("remove", (function () { t.off("update", c) })), u }, e.prototype.updateLayers = function (t) { var e = E(t, OU.LayerOptionsKeys); if (this.flowLayer.update(e), t.radiation) if (this.radiationLayer) { var n = k(k({}, t.radiation), { visible: t.radiation.enabled }); this.radiationLayer.update(n) } else this.radiationLayer = this.createRadiationLayer(this.source), this.layerGroup.addLayer(this.radiationLayer); this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.prototype.getLegendOptions = function () { var t = this.flowLayer.getColorLegendItems(); return 0 !== t.length ? { type: "category", items: t } : {} }, e.DefaultOptions = MU, e }(Yj), IU = kj({}, Yj.DefaultOptions, { source: { data: { type: "FeatureCollection", features: [] }, parser: { type: "geojson" } } }), PU = "#2f54eb", LU = { active: { fill: !1, stroke: PU, lineWidth: 1.5, lineOpacity: .8 }, select: { fill: !1, stroke: PU, lineWidth: 1.5, lineOpacity: .8 } }, RU = function (t) { return g(t) || (!1 === t.active ? LU.active = Object.assign(LU.active, { fill: !1, stroke: !1 }) : "object" == typeof t.active && (!1 === t.active.fill ? LU.active.fill = !1 : "string" == typeof t.active.fill && (LU.active.fill = t.active.fill), !1 === t.active.stroke ? LU.active.stroke = !1 : "string" == typeof t.active.stroke && (LU.active.stroke = t.active.stroke), "number" == typeof t.active.lineWidth && (LU.active.lineWidth = t.active.lineWidth), "number" == typeof t.active.lineOpacity && (LU.active.lineOpacity = t.active.lineOpacity)), !1 === t.select ? LU.select = Object.assign(LU.select, { fill: !1, stroke: !1 }) : "object" == typeof t.select && (!1 === t.select.fill ? LU.select.fill = !1 : "string" == typeof t.select.fill && (LU.select.fill = t.select.fill), !1 === t.select.stroke ? LU.select.stroke = !1 : "string" == typeof t.select.stroke && (LU.select.stroke = t.select.stroke), "number" == typeof t.select.lineWidth && (LU.select.lineWidth = t.select.lineWidth), "number" == typeof t.select.lineOpacity && (LU.select.lineOpacity = t.select.lineOpacity))), LU }; var DU = { visible: !0, state: { active: !1, select: !1 }, enabledMultiSelect: !1 }, NU = ["color", "style", "state", "enabledMultiSelect"], zU = function (t) { function e(e) { var n = t.call(this, e) || this; n.selectData = [], n.type = Vj.LayerType.AreaLayer, n.interaction = !0, n.onHighlighHandle = function (t) { var e = t.feature, r = t.featureId; n.setHighlightLayerSource(e, r) }, n.onUnhighlighHandle = function () { n.setHighlightLayerSource() }, n.onSelectHandle = function (t) { var e = n.options.enabledMultiSelect, r = t.feature, i = t.featureId, o = _(n.selectData), a = o.findIndex((function (t) { return t.featureId === i })); if (-1 === a) e ? o.push({ feature: r, featureId: i }) : o = [{ feature: r, featureId: i }], n.emit("select", r, _(o)); else { var s = o[a]; e ? o.splice(a, 1) : o = [], n.emit("unselect", s, _(o)) } n.setSelectLayerSource(o) }; var r = n.options, i = r.name, o = r.source, a = r.visible, s = r.minZoom, l = r.maxZoom, u = r.zIndex, c = void 0 === u ? 0 : u, p = n.pickLayerConfig(n.options), h = RU(n.options.state); return n.name = i || T(n.type), n.layer = new _k(k(k({}, p), { name: n.name })), n.strokeLayer = new uO({ name: "strokeLayer", visible: a, zIndex: c, minZoom: s, maxZoom: l }), n.highlightLayer = new uO({ name: "highlightLayer", visible: a && Boolean(h.active.stroke), zIndex: c + .1, minZoom: s, maxZoom: l }), n.selectFillLayer = new _k({ name: "selectFillLayer", visible: a && Boolean(h.select.fill), zIndex: c + .1, minZoom: s, maxZoom: l }), n.selectStrokeLayer = new uO({ name: "selectStrokeLayer", visible: a && Boolean(h.select.stroke), zIndex: c + .1, minZoom: s, maxZoom: l }), n.mappingLayer(n.options), n.setSource(o), n.initEvent(), n } return M(e, t), e.prototype.getDefaultOptions = function () { return DU }, e.prototype.mappingLayer = function (t) { !function (t, e, n, r, i, o) { var a = o.color, s = o.style, l = o.state, u = RU(l), c = { active: !1 !== u.active.fill && { color: u.active.fill }, select: !1 }, p = { opacity: null == s ? void 0 : s.opacity }, h = null == s ? void 0 : s.fillBottomColor, f = null == s ? void 0 : s.lineWidth, d = null == s ? void 0 : s.stroke, m = { opacity: null == s ? void 0 : s.lineOpacity, dashArray: null == s ? void 0 : s.lineDash, lineType: null == s ? void 0 : s.lineType }; if (Hj.shape(t, "fill"), a && Hj.color(t, a), p && Hj.style(t, p), c && Hj.state(t, c), h && t.setBottomColor(h), Hj.shape(e, "line"), f && Hj.size(e, f), d && Hj.color(e, d), m && Hj.style(e, m), u.active.stroke) { var v = u.active.stroke, y = u.active.lineWidth || f, g = { opacity: u.active.lineOpacity }; Hj.shape(n, "line"), y && Hj.size(n, y), v && Hj.color(n, v), g && Hj.style(n, g) } if (u.select.fill) { var _ = u.select.fill; Hj.shape(r, "fill"), _ && Hj.color(r, _), p && Hj.style(r, p), Hj.state(r, { select: !1, active: !1 }) } if (u.select.stroke) { var x = u.select.stroke, b = (y = u.select.lineWidth || f, { opacity: u.select.lineOpacity }); Hj.shape(i, "line"), y && Hj.size(i, y), x && Hj.color(i, x), b && Hj.style(i, b) } }(this.layer, this.strokeLayer, this.highlightLayer, this.selectFillLayer, this.selectStrokeLayer, t) }, e.prototype.setSource = function (e) { t.prototype.setSource.call(this, e), this.setStrokeLayerSource(), this.setHighlightLayerSource(), this.selectFillLayer.source({ type: "FeatureCollection", features: [] }, { parser: { type: "geojson" } }), this.selectStrokeLayer.source({ type: "FeatureCollection", features: [] }, { parser: { type: "geojson" } }) }, e.prototype.setStrokeLayerSource = function () { var t = this.layer.getSource(); if (t) this.strokeLayer.setSource(t); else { var e = this.layer.sourceOption, n = e.data, r = e.options; this.strokeLayer.source(n, r) } }, e.prototype.setHighlightLayerSource = function (t, e) { if (void 0 === e && (e = -999), this.highlightLayerData !== e) { var n = t ? [t] : []; this.highlightLayer.setData({ type: "FeatureCollection", features: n }, { parser: { type: "geojson" } }), this.highlightLayerData = e } }, e.prototype.setSelectLayerSource = function (t) { if (void 0 === t && (t = []), this.selectData.length !== t.length || !w(this.selectData.map((function (t) { return t.featureId })), t.map((function (t) { return t.featureId })))) { var e = t.map((function (t) { return t.feature })); this.selectFillLayer.setData({ type: "FeatureCollection", features: e }, { parser: { type: "geojson" } }), this.selectStrokeLayer.setData({ type: "FeatureCollection", features: e }, { parser: { type: "geojson" } }), this.selectData = t } }, e.prototype.initEvent = function () { this.layer.off("mousemove", this.onHighlighHandle), this.layer.off("unmousemove", this.onHighlighHandle), this.layer.off("click", this.onSelectHandle), this.selectData = [], this.highlightLayerData = null, this.options.state && (this.options.state.active && (this.layer.on("mousemove", this.onHighlighHandle), this.layer.on("unmousemove", this.onUnhighlighHandle)), this.options.state.select && this.layer.on("click", this.onSelectHandle)) }, e.prototype.addTo = function (t) { t.addLayer(this.layer), t.addLayer(this.strokeLayer), t.addLayer(this.highlightLayer), t.addLayer(this.selectFillLayer), t.addLayer(this.selectStrokeLayer) }, e.prototype.remove = function (t) { t.removeLayer(this.layer), t.removeLayer(this.strokeLayer), t.removeLayer(this.highlightLayer), t.removeLayer(this.selectFillLayer), t.removeLayer(this.selectStrokeLayer) }, e.prototype.update = function (e) { if (t.prototype.update.call(this, e), this.mappingLayer(this.options), this.options.visible) { g(e.state) || w(this.lastOptions.state, this.options.state) || this.updateHighlightLayer(); var n = RU(this.options.state); n.active.stroke && this.setHighlightLayerSource(), (n.select.fill || n.select.stroke) && this.setSelectLayerSource() } this.initEvent() }, e.prototype.updateHighlightLayer = function () { var t = RU(this.options.state), e = RU(this.lastOptions.state); e.active.stroke !== t.active.stroke && (t.active.stroke ? this.highlightLayer.show() : this.highlightLayer.hide()), e.select.fill !== t.select.fill && (t.select.fill ? this.selectFillLayer.show() : this.selectFillLayer.hide()), e.select.stroke !== t.select.stroke && (t.select.stroke ? this.selectStrokeLayer.show() : this.selectStrokeLayer.hide()) }, e.prototype.setIndex = function (t) { this.layer.setIndex(t), this.strokeLayer.setIndex(t), this.highlightLayer.setIndex(t + .1), this.selectFillLayer.setIndex(t + .1), this.selectStrokeLayer.setIndex(t + .1) }, e.prototype.setMinZoom = function (t) { this.layer.setMinZoom(t), this.strokeLayer.setMinZoom(t), this.highlightLayer.setMinZoom(t), this.selectFillLayer.setMinZoom(t), this.selectStrokeLayer.setMinZoom(t) }, e.prototype.setMaxZoom = function (t) { this.layer.setMaxZoom(t), this.strokeLayer.setMaxZoom(t), this.highlightLayer.setMaxZoom(t), this.selectFillLayer.setMaxZoom(t), this.selectStrokeLayer.setMaxZoom(t) }, e.prototype.show = function () { this.layer.inited && (this.layer.show(), this.strokeLayer.show(), this.selectFillLayer.show(), this.selectStrokeLayer.show()) }, e.prototype.hide = function () { this.layer.inited && (this.layer.hide(), this.strokeLayer.hide(), this.selectFillLayer.hide(), this.selectStrokeLayer.hide()) }, e.prototype.getColorLegendItems = function () { var t = this.layer.getLegendItems("color"); return Array.isArray(t) && 0 !== t.length ? Qj(t) : [] }, e.prototype.setActive = function (t) { }, e.prototype.setSelect = function (t) { }, e.DefaultOptions = DU, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(NU), e }(Vj), FU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Area, e } return M(e, t), e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.createLayers = function (t) { this.areaLayer = new zU(k({ source: t }, E(this.options, zU.LayerOptionsKeys))); var e = new Rj([this.areaLayer]); return this.options.label && (this.labelLayer = this.createLabelLayer(t, this.options.label, this.options), e.addLayer(this.labelLayer)), e }, e.prototype.updateLayers = function (t) { var e = E(t, zU.LayerOptionsKeys); this.areaLayer.update(e), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.prototype.initLayersEvent = function () { }, e.prototype.getLegendOptions = function () { var t = this.areaLayer.getColorLegendItems(); return 0 !== t.length ? { type: "category", items: t } : {} }, e.DefaultOptions = IU, e }(Yj), BU = kj({}, Yj.DefaultOptions, { source: { data: [], joinBy: { geoField: "adcode" } }, viewLevel: { level: "country", adcode: "100000" }, chinaBorder: !0 }), jU = { world: "country", country: "province", province: "city", city: "district", district: "district" }, UU = baseUrl, VU = "".concat(UU, "/choropleth-data"), GU = { national: { color: "red", width: 1, opacity: 1 }, dispute: { color: "red", width: 1, opacity: .8, dashArray: [1, 6] }, coast: { color: "blue", width: .7, opacity: .8 }, hkm: { color: "gray", width: .7, opacity: .8 } }, HU = new Map; function WU(t) { return t } function XU(t, e) { var n = e.id, r = e.bbox, i = null == e.properties ? {} : e.properties, o = function (t, e) { var n = function (t) { if (null == t) return WU; var e, n, r = t.scale[0], i = t.scale[1], o = t.translate[0], a = t.translate[1]; return function (t, s) { s || (e = n = 0); var l = 2, u = t.length, c = new Array(u); for (c[0] = (e += t[0]) * r + o, c[1] = (n += t[1]) * i + a; l < u;)c[l] = t[l], ++l; return c } }(t.transform), r = t.arcs; function i(t, e) { e.length && e.pop(); for (var i = r[t < 0 ? ~t : t], o = 0, a = i.length; o < a; ++o)e.push(n(i[o], o)); t < 0 && function (t, e) { for (var n, r = t.length, i = r - e; i < --r;)n = t[i], t[i++] = t[r], t[r] = n }(e, a) } function o(t) { return n(t) } function a(t) { for (var e = [], n = 0, r = t.length; n < r; ++n)i(t[n], e); return e.length < 2 && e.push(e[0]), e } function s(t) { for (var e = a(t); e.length < 4;)e.push(e[0]); return e } function l(t) { return t.map(s) } function u(t) { var e, n = t.type; switch (n) { case "GeometryCollection": return { type: n, geometries: t.geometries.map(u) }; case "Point": e = o(t.coordinates); break; case "MultiPoint": e = t.coordinates.map(o); break; case "LineString": e = a(t.arcs); break; case "MultiLineString": e = t.arcs.map(a); break; case "Polygon": e = l(t.arcs); break; case "MultiPolygon": e = t.arcs.map(l); break; default: return null }return { type: n, coordinates: e } } return u(e) }(t, e); return null == n && null == r ? { type: "Feature", properties: i, geometry: o } : null == r ? { type: "Feature", id: n, properties: i, geometry: o } : { type: "Feature", id: n, bbox: r, properties: i, geometry: o } } var qU = function (t) { try { return e = t, "string" == typeof (n = "json") && (n = e.objects[n]), "GeometryCollection" === n.type ? { type: "FeatureCollection", features: n.geometries.map((function (t) { return XU(e, t) })) } : XU(e, n) } catch (t) { throw new Error('Failed convert to geojson from topojson, topojson default layer name "json"') } var e, n }, ZU = function (t) { return E(t, ["source", "color", "style", "state", "label", "tooltip"]) }, YU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = Yj.PlotType.Choropleth, e.chinaBoundaryData = { type: "FeatureCollection", features: [] }, e.currentDistrictData = { type: "FeatureCollection", features: [] }, e.drillSteps = [], e.drillStacks = [], e.onDrillDownHander = function (t) { var n, r = e.options.drill, i = r.steps, o = r.onDown, a = null === (n = t.feature) || void 0 === n ? void 0 : n.properties, s = a.adcode; if (e.drillStacks.length !== i.length + 1) { var l = e.drillStacks.slice(-1)[0], u = e.drillStacks.length - 1, c = e.drillSteps[u], p = c.level, h = c.granularity, f = void 0 === h ? jU[p] : h, d = I(c, ["level", "granularity"]), m = { from: { level: l.level, adcode: l.adcode, granularity: l.granularity }, to: { level: p, adcode: s, granularity: f, properties: a } }, v = function (t) { void 0 === t && (t = {}); var n = { level: p, adcode: s, granularity: f }, r = kj({}, d, t); e.changeView(n, r).then((function (t) { t && (e.drillStacks.push(t), e.emit("drilldown", m)) })) }; o ? o(m.from, m.to, v) : v() } }, e.onDrillUpHander = function () { var t = e.options.drill.onUp; if (!(0 === e.drillStacks.length || 1 === e.drillStacks.length)) { var n = e.drillStacks.length - 1, r = e.drillStacks[n], i = e.drillStacks[n - 1], o = { from: { level: r.level, adcode: r.adcode, granularity: r.granularity }, to: { level: i.level, adcode: i.adcode, granularity: i.granularity } }, a = function (t) { void 0 === t && (t = {}); var n = o.to, r = kj({}, i.config, t); e.changeView(n, r).then((function (t) { t && (e.drillStacks.pop(), e.emit("drillup", o)) })) }; t ? t(o.from, o.to, a) : a() } }, e } return M(e, t), e.prototype.initSource = function () { var t = this; this.getInitDistrictData().then((function () { t.source = t.createSource(), t.render(), t.inited = !0 })) }, e.prototype.render = function () { var t = this; if (console.time("l7plot choropleth render time"), this.inited) this.scene.setEnableRender(!0), this.scene.render(); else { var e = this.createLayers(this.source); this.layerGroup = e, this.scene.sceneService.loaded ? this.onSceneLoaded() : this.scene.once("loaded", (function () { t.onSceneLoaded() })), this.initLayersEvent() } console.timeEnd("l7plot choropleth render time") }, e.prototype.update = function (t) { var e, n, r, i = this; if (this.updateOption(t), t.map && !w(this.lastOptions.map, this.options.map) && this.updateMap(t.map), t.drill && !1 !== t.drill.enabled && !w(null === (e = this.lastOptions.drill) || void 0 === e ? void 0 : e.steps, null === (n = this.options.drill) || void 0 === n ? void 0 : n.steps) && (this.drillReset(), this.initDrillEvent()), this.scene.setEnableRender(!1), t.viewLevel && !w(this.lastOptions.viewLevel, this.options.viewLevel)) { var o = null === (r = t.source) || void 0 === r ? void 0 : r.joinBy.geoData; console.time("l7plot choropleth update viewLevel time"), this.getDistrictData(o).then((function () { var e = i.options.source, n = e.data, r = I(e, ["data"]); i.changeData(n, r), i.updateLayers(t), i.render(), i.updateComponents(), console.timeEnd("l7plot choropleth update viewLevel time"), i.emit("update") })) } else { if (t.source && !w(this.lastOptions.source, this.options.source)) { var a = this.options.source, s = a.data, l = I(a, ["data"]); this.changeData(s, l) } this.updateLayers(t), this.render(), this.updateComponents(), this.emit("update") } }, e.prototype.getDefaultOptions = function () { return e.DefaultOptions }, e.prototype.parserSourceConfig = function (t) { var e = t.data, n = t.joinBy, r = I(t, ["data", "joinBy"]), i = n.sourceField, o = n.geoField, a = n.geoData, s = { type: "join", sourceField: i, targetField: o, data: e }; return r.transforms ? r.transforms.push(s) : r.transforms = [s], r.parser && delete r.parser, { data: a, sourceCFG: r } }, e.prototype.createSource = function () { var t = this.parserSourceConfig(this.options.source), e = t.data, n = t.sourceCFG; return new yE(e, n) }, e.prototype.changeData = function (t, e) { var n = this; console.time("l7plot choropleth update data time"), this.options.source = kj({}, this.options.source, k({ data: t }, e)); var r = this.parserSourceConfig(this.options.source), i = r.data, o = r.sourceCFG; this.source.setData(i, o), console.timeEnd("l7plot choropleth update data time"); var a = this.options.legend; a && setTimeout((function () { n.updateLegendControl(a) })), this.emit("change-data") }, e.prototype.createLayers = function (t) { this.fillAreaLayer = new zU(k({ name: "fillAreaLayer", source: t }, E(this.options, zU.LayerOptionsKeys))); var e = new Rj([this.fillAreaLayer]); if (this.options.chinaBorder) { var n = this.createCountryBoundaryLayer(this.chinaBoundaryData, this.options), r = n.chinaBoundaryLayer, i = n.chinaDisputeBoundaryLayer; this.chinaBoundaryLayer = r, this.chinaDisputeBoundaryLayer = i, e.addLayer(this.chinaBoundaryLayer), e.addLayer(this.chinaDisputeBoundaryLayer) } return this.options.label && (this.labelLayer = this.createLabelLayer(t, this.options.label), e.addLayer(this.labelLayer)), e }, e.prototype.createCountryBoundaryLayer = function (t, e) { var n = function (t, e) { var n = e || {}, r = n.visible, i = n.minZoom, o = n.maxZoom, a = n.zIndex, s = void 0 === a ? 0 : a, l = n.chinaBorder, u = "object" == typeof l ? kj({}, GU, l) : GU, c = t.features.filter((function (t) { var e = t.properties; return ["coast", "hkm", "national"].includes(null == e ? void 0 : e.type) })), p = t.features.filter((function (t) { var e = t.properties; return "dispute" === (null == e ? void 0 : e.type) })), h = new TU({ name: "chinaBoundaryLayer", visible: r, minZoom: i, maxZoom: o, zIndex: s + .1, source: { data: { type: "FeatureCollection", features: c }, parser: { type: "geojson" } }, color: { field: "type", value: function (t) { var e = t.type; return u[e].color } }, size: { field: "type", value: function (t) { var e = t.type; return u[e].width } }, style: { opacity: ["type", function (t) { return u[t].opacity }] } }); return { chinaBoundaryLayer: h, chinaDisputeBoundaryLayer: new TU({ name: "chinaDisputeBoundaryLayer", visible: r, minZoom: i, maxZoom: o, zIndex: s + .1, source: { data: { type: "FeatureCollection", features: p }, parser: { type: "geojson" } }, color: u.dispute.color, size: u.dispute.width, style: { opacity: u.dispute.opacity, lineType: "dash", dashArray: u.dispute.dashArray } }) } }(t, e); return { chinaBoundaryLayer: n.chinaBoundaryLayer, chinaDisputeBoundaryLayer: n.chinaDisputeBoundaryLayer } }, e.prototype.createLabelLayer = function (t, e) { var n = this, r = t.originData.features.map((function (t) { var e = t.properties; return Object.assign({}, e, { centroid: e.centroid || e.center }) })).filter((function (t) { return t.centroid })), i = this.options, o = i.visible, a = i.minZoom, s = i.maxZoom, l = i.zIndex, u = void 0 === l ? 0 : l, c = new qj(k({ name: "labelLayer", source: { data: r, parser: { type: "json", coordinates: "centroid" }, transforms: t.transforms }, visible: o, minZoom: a, maxZoom: s, zIndex: u + .1 }, e)), p = function () { var t = n.source.originData.features.map((function (t) { return t.properties })).filter((function (t) { return t.centroid })); c.layer.setData(t) }; return t.on("update", p), c.on("remove", (function () { t.off("update", p) })), c }, e.prototype.updateLayers = function (t) { var e = this, n = E(t, zU.LayerOptionsKeys); this.fillAreaLayer.update(n); var r = function () { var t = e.createCountryBoundaryLayer(e.chinaBoundaryData, e.options), n = t.chinaBoundaryLayer, r = t.chinaDisputeBoundaryLayer; e.chinaBoundaryLayer = n, e.chinaDisputeBoundaryLayer = r, e.layerGroup.addLayer(e.chinaBoundaryLayer), e.layerGroup.addLayer(e.chinaDisputeBoundaryLayer) }, i = function () { e.chinaBoundaryLayer && e.layerGroup.removeLayer(e.chinaBoundaryLayer), e.chinaDisputeBoundaryLayer && e.layerGroup.removeLayer(e.chinaDisputeBoundaryLayer) }; t.chinaBorder ? this.chinaBoundaryLayer ? (i(), r()) : r() : !1 === t.chinaBorder && i(), this.updateLabelLayer(this.source, t.label, this.options, this.labelLayer) }, e.prototype.initLayersEvent = function () { this.initDrillEvent() }, e.prototype.initDrillEvent = function () { if (this.lastOptions.drill) { var t = this.lastOptions.drill, e = t.triggerUp, n = void 0 === e ? "unclick" : e, r = t.triggerDown, i = void 0 === r ? "click" : r; this.fillAreaLayer.off(n, this.onDrillUpHander), this.fillAreaLayer.off(i, this.onDrillDownHander) } if (this.options.drill && !1 !== this.options.drill.enabled) { var o = this.options.drill, a = o.steps, s = o.triggerUp, l = void 0 === s ? "unclick" : s, u = o.triggerDown, c = void 0 === u ? "click" : u, p = a.map((function (t) { return "string" == typeof t ? { level: t, granularity: jU[t] } : (t.granularity || (t.granularity = jU[t.level]), t) })); if (function (t, e) { if (t.length !== e.length) return !1; for (var n = 0; n < t.length; n++) { var r = t[n], i = r.level, o = r.granularity; if (e[n].level !== i || e[n].granularity !== o) return !1 } return !0 }(p, this.drillSteps) || (this.drillSteps = p, this.drillStacks = []), !this.drillStacks.length) { var h = this.options.viewLevel, f = h.level, d = h.adcode, m = h.granularity, v = void 0 === m ? jU[f] : m, y = ZU(this.options); this.drillStacks = [{ level: f, adcode: d, granularity: v, config: y }] } this.fillAreaLayer.on(l, this.onDrillUpHander), this.fillAreaLayer.on(c, this.onDrillDownHander) } }, e.prototype.drillReset = function () { this.drillStacks = [] }, e.prototype.getCurrentDrillSteps = function () { return this.drillStacks.map((function (t) { return E(t, ["level", "adcode", "granularity"]) })) }, e.prototype.getLegendOptions = function () { var t = this.fillAreaLayer.getColorLegendItems(); return 0 !== t.length ? { type: "category", items: t } : {} }, e.prototype.fetchData = function (t, e, n) { return P(this, void 0, void 0, (function () { var r, i, o, a, s, l, u; return L(this, (function (c) { switch (c.label) { case 0: return r = "".concat(e, "_").concat(t, "_").concat(n), f = r, (i = HU.get(f)) ? [2, i] : (p = this.options.geoArea, h = { url: VU, type: "topojson", extension: "topo.json" }, g(p) || ("string" == typeof p ? h.url = p : (h.url = (null == p ? void 0 : p.url) || VU, h.type = p.type, h.extension = "topojson" === p.type ? "topo.json" : "json")), a = (o = h).url, s = o.type, l = o.extension, [4, fetch("".concat(a, "/").concat(t, "/").concat(r, ".").concat(l))]); case 1: return [4, c.sent().json()]; case 2: return u = c.sent(), "topojson" === s && (u = qU(u)), function (t, e) { HU.set(t, e) }(r, u), [2, u] }var p, h, f })) })) }, e.prototype.getInitDistrictData = function () { var t; return P(this, void 0, void 0, (function () { var e, n, r, i; return L(this, (function (o) { switch (o.label) { case 0: e = this.fetchData("country", "100000", "boundary"), n = null === (t = this.options.source) || void 0 === t ? void 0 : t.joinBy.geoData, o.label = 1; case 1: return o.trys.push([1, 3, , 4]), [4, Promise.all([e, this.getDistrictData(n)])]; case 2: return i = R.apply(void 0, [o.sent(), 1]), this.chinaBoundaryData = i[0], [3, 4]; case 3: throw r = o.sent(), new Error("Failed to get china boundary data，".concat(r)); case 4: return [2] } })) })) }, e.prototype.getDistrictData = function (t) { return P(this, void 0, void 0, (function () { var e, n, r, i, o, a, s, l; return L(this, (function (u) { switch (u.label) { case 0: e = this.options.viewLevel, n = e.level, r = e.adcode, i = e.granularity, o = void 0 === i ? jU[n] : i, a = t ? Promise.resolve(t) : this.fetchData(n, r, o), u.label = 1; case 1: return u.trys.push([1, 3, , 4]), s = this, [4, a]; case 2: return s.currentDistrictData = u.sent(), this.options.source = kj({}, this.options.source, { joinBy: { geoData: this.currentDistrictData } }), [3, 4]; case 3: throw l = u.sent(), new Error("Failed to get district data，".concat(l)); case 4: return [2] } })) })) }, e.prototype.drillDown = function (t, e) { var n = this; void 0 === e && (e = {}), this.changeView(t, e).then((function (t) { t && n.drillStacks.push(t) })) }, e.prototype.drillUp = function (t, e) { void 0 === t && (t = {}); var n = this.drillStacks.length; if (![0, 1].includes(n)) { var r = e ? this.drillStacks.findIndex((function (t) { return t.level === e })) : -1, i = -1 !== r, o = i ? r : n - 2, a = this.drillStacks[o], s = a.config, l = I(a, ["config"]), u = kj({}, s, t); this.changeView(l, u), i ? this.drillStacks.splice(r + 1) : this.drillStacks.pop() } }, e.prototype.changeView = function (t, e) { return void 0 === e && (e = {}), P(this, void 0, void 0, (function () { var n, r, i, o, a, s; return L(this, (function (l) { switch (l.label) { case 0: return n = t.level, r = t.adcode, i = t.granularity, o = void 0 === i ? jU[n] : i, [4, this.fetchData(n, r, o)]; case 1: return (a = l.sent()).features.length ? (s = kj({}, ZU(this.options), e, { viewLevel: { level: n, adcode: r, granularity: o }, source: { joinBy: { geoData: a } } }), this.update(s), [2, { level: n, adcode: r, granularity: o, config: s }]) : [2] } })) })) }, e.DefaultOptions = BU, e.GeoDataUrl = UU, e.GeoAreaUrl = VU, e }(Yj), KU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = tU.LayerType.IconLayer, e } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, tU.DefaultOptions, { color: void 0 }) }, e }(tU), QU = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.type = tU.LayerType.ColumnLayer, e } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, tU.DefaultOptions, { shape: "cylinder" }) }, e }(tU); var JU, $U, tV = {}, eV = ["color", "size", "style", "state"], nV = function (t) { function e(e) { var n = t.call(this, e) || this; n.type = Vj.LayerType.PrismLayer, n.interaction = !0; var r = n.options, i = r.name, o = r.source, a = n.pickLayerConfig(n.options); return n.name = i || T(n.type), n.layer = new _k(k(k({}, a), { name: n.name })), n.mappingLayer(n.layer, n.options), n.setSource(o), n } return M(e, t), e.prototype.getDefaultOptions = function () { return tV }, e.prototype.mappingLayer = function (t, e) { !function (t, e) { var n = e.color, r = e.size, i = e.style, o = e.state; Hj.shape(t, "extrude"), r && Hj.size(t, r), n && Hj.color(t, n), i && Hj.style(t, i), o && Hj.state(t, o) }(t, e) }, e.prototype.update = function (e) { t.prototype.update.call(this, e), this.mappingLayer(this.layer, this.options) }, e.prototype.getColorLegendItems = function () { var t = this.layer.getLegendItems("color"); return Array.isArray(t) && 0 !== t.length ? Qj(t) : [] }, e.DefaultOptions = tV, e.LayerOptionsKeys = Vj.LayerConfigkeys.concat(eV), e }(Vj), rV = ((JU = {})[t.PlotType.Dot] = eU, JU[t.PlotType.DotDensity] = oU, JU[t.PlotType.Heatmap] = cU, JU[t.PlotType.Grid] = mU, JU[t.PlotType.Hexbin] = xU, JU[t.PlotType.Path] = AU, JU[t.PlotType.Flow] = kU, JU[t.PlotType.Area] = FU, JU[t.PlotType.Choropleth] = YU, JU), iV = (($U = {})[t.LayerType.TextLayer] = qj, $U[t.LayerType.DotLayer] = tU, $U[t.LayerType.IconLayer] = KU, $U[t.LayerType.DotDensity] = iU, $U[t.LayerType.ColumnLayer] = QU, $U[t.LayerType.HeatmapLayer] = uU, $U[t.LayerType.GridLayer] = dU, $U[t.LayerType.HexbinLayer] = _U, $U[t.LayerType.PathLayer] = TU, $U[t.LayerType.ArcLayer] = OU, $U[t.LayerType.AreaLayer] = zU, $U[t.LayerType.PrismLayer] = nV, $U), oV = {}, aV = function (t) { function e(e, n) { var r = t.call(this, n) || this; return r.plots = [], r.container = r.createContainer(e), r.theme = r.createTheme(), r.scene = r.createScene(), r.registerResources(), r.render(), r.inited = !0, r } return M(e, t), e.prototype.getDefaultOptions = function () { return kj({}, Bj.DefaultOptions, e.DefaultOptions) }, e.prototype.createLayers = function () { for (var t = new Rj([]), e = this.options.layers || [], n = 0; n < e.length; n++) { var r = this.createLayer(e[n]); t.addLayer(r) } return t }, e.prototype.createLayer = function (t) { var e = t.type, n = I(t, ["type"]), r = iV[e]; if (g(r)) throw new Error("Don't exist ".concat(e, " layer")); return new r(n) }, e.prototype.addLayer = function (e) { if (function (t) { return "function" == typeof t.render }(e)) t.prototype.addLayer.call(this, e); else { var n = this.createLayer(e); t.prototype.addLayer.call(this, n) } }, e.prototype.removeLayerByName = function (t) { var e = this.layerGroup.getLayerByName(t); return !!e && this.layerGroup.removeLayer(e) }, e.prototype.updateLayers = function (t) { }, e.prototype.updatePlots = function (t) { }, e.prototype.render = function () { var t = this, e = this.createLayers(); this.inited ? (this.layerGroup.removeAllLayer(), e.addTo(this.scene), this.layerGroup = e, this.updateControls()) : (this.layerGroup = e, this.scene.sceneService.loaded ? this.onSceneLoaded() : this.scene.once("loaded", (function () { t.onSceneLoaded() }))) }, e.prototype.onSceneLoaded = function () { var t = this; this.sceneLoaded = !0, this.layerGroup.isEmpty() ? this.onLayersLoaded() : this.layerGroup.once("inited-all", (function () { t.onLayersLoaded() })), this.layerGroup.addTo(this.scene) }, e.prototype.onLayersLoaded = function () { this.layersLoaded = !0, this.renderPlots(), this.initControls(), this.loaded = !0, this.emit("loaded") }, e.prototype.renderPlots = function () { for (var t = this.options.plots || [], e = 0; e < t.length; e++) { var n = t[e], r = this.createPlot(n); this.plots.push(r) } }, e.prototype.createPlot = function (t) { var e = t.type; t.legend, t.layerMenu; var n = I(t, ["type", "legend", "layerMenu"]), r = rV[e]; if (g(r)) throw new Error("Don't exist ".concat(e, " plot")); var i = new r(n); return i.attachToScene(this.scene, this.theme), i }, e.prototype.addPlot = function (t) { var e = this.createPlot(t); this.plots.push(e) }, e.prototype.getPlots = function () { return this.plots }, e.prototype.getPlotByName = function (t) { return this.plots.find((function (e) { var n; return (null === (n = e.options) || void 0 === n ? void 0 : n.name) === t })) }, e.prototype.removePlotByName = function (t) { var e = this.plots.findIndex((function (e) { var n; return (null === (n = e.options) || void 0 === n ? void 0 : n.name) === t })); return -1 !== e && (R(this.plots.splice(e, 1), 1)[0].unattachFromScene(), !0) }, e.prototype.removeAllPlot = function () { this.plots.forEach((function (t) { t.unattachFromScene() })), this.plots = [] }, e.DefaultOptions = oV, e }(Bj); t.ArcLayer = OU, t.Area = FU, t.AreaLayer = zU, t.Choropleth = YU, t.Dot = eU, t.DotDensity = oU, t.DotDensityLayer = iU, t.DotLayer = tU, t.Flow = kU, t.Grid = mU, t.GridLayer = dU, t.Heatmap = cU, t.HeatmapLayer = uU, t.Hexbin = xU, t.HexbinLayer = _U, t.IconLayer = KU, t.L7Plot = aV, t.Map = Bj, t.MapboxglMap = rM.exports.Map, t.Path = AU, t.PathLayer = TU, t.Plot = Yj, t.PrismLayer = nV, t.Source = yE, t.TextLayer = qj, t.getTheme = at, t.registerFontFace = function (t, e) { n.set(t, e) }, t.registerIconFont = function (t, e) { r.set(t, e) }, t.registerIconFonts = function (t) { t.forEach((function (t) { r.set(t.name, t.fontUnicode) })) }, t.registerImage = function (t, n) { e.set(t, n) }, t.registerImages = function (t) { t.forEach((function (t) { e.set(t.id, t.image) })) }, t.registerTheme = function (t, e, n) { void 0 === n && (n = "light"), ot[m(t)] = "light" === n ? et(e) : nt(e) }
/*! *****************************************************************************
    Copyright (C) Microsoft. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */, t.unregisterFontFace = function (t) { return n.delete(t) }, t.unregisterIconFont = function (t) { return r.delete(t) }, t.unregisterImage = function (t) { return e.delete(t) }, t.version = "0.0.11", Object.defineProperty(t, "__esModule", { value: !0 })
}));
//# sourceMappingURL=l7plot.min.js.map
